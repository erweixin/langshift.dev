---
title: "éŒ¯èª¤è™•ç†èˆ‡å‹åˆ¥å®‰å…¨"
description: "å­¸ç¿’ Rust çš„éŒ¯èª¤è™•ç†æ©Ÿåˆ¶ï¼ŒåŒ…æ‹¬ Resultã€Option å‹åˆ¥å’ŒéŒ¯èª¤å‚³æ’­ï¼Œå°æ¯” JavaScript çš„ç•°å¸¸è™•ç†"
---

# éŒ¯èª¤è™•ç†èˆ‡å‹åˆ¥å®‰å…¨

## ğŸ“– å­¸ç¿’ç›®æ¨™

ç†è§£ Rust çš„éŒ¯èª¤è™•ç†å“²å­¸ï¼Œå­¸æœƒä½¿ç”¨ `Result` å’Œ `Option` å‹åˆ¥ï¼ŒæŒæ¡éŒ¯èª¤å‚³æ’­æ¨¡å¼ï¼Œå°æ¯” JavaScript çš„ç•°å¸¸è™•ç†æ©Ÿåˆ¶ã€‚

---

## ğŸ¯ éŒ¯èª¤è™•ç†å“²å­¸å°æ¯”

### JavaScript çš„ç•°å¸¸è™•ç†

JavaScript ä½¿ç”¨ try-catch æ©Ÿåˆ¶è™•ç†ç•°å¸¸ï¼š

<UniversalEditor title="JavaScript ç•°å¸¸è™•ç†" compare={true}>
```javascript !! js
// JavaScript ç•°å¸¸è™•ç†
function divide(a, b) {
    if (b === 0) {
        throw new Error("é™¤æ•¸ä¸èƒ½ç‚ºé›¶");
    }
    return a / b;
}

function processData(data) {
    if (!data) {
        throw new Error("è³‡æ–™ä¸èƒ½ç‚ºç©º");
    }
    return data.toUpperCase();
}

// ä½¿ç”¨ try-catch è™•ç†ç•°å¸¸
try {
    const result1 = divide(10, 2);
    console.log("é™¤æ³•çµæœ:", result1);
    
    const result2 = divide(10, 0); // æ‹‹å‡ºç•°å¸¸
    console.log("é€™å€‹ä¸æœƒåŸ·è¡Œ");
} catch (error) {
    console.log("æ•ç²åˆ°ç•°å¸¸:", error.message);
}

// ç•°æ­¥ç•°å¸¸è™•ç†
async function fetchData(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP éŒ¯èª¤: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.log("ç¶²è·¯è«‹æ±‚å¤±æ•—:", error.message);
        return null;
    }
}

// Promise ç•°å¸¸è™•ç†
function asyncOperation() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const random = Math.random();
            if (random > 0.5) {
                resolve("æ“ä½œæˆåŠŸ");
            }
            else {
                reject(new Error("æ“ä½œå¤±æ•—"));
            }
        }, 1000);
    });
}

asyncOperation()
    .then(result => console.log("æˆåŠŸ:", result))
    .catch(error => console.log("å¤±æ•—:", error.message));

// å¯é¸éˆå’Œç©ºå€¼åˆä½µ
function getUserName(user) {
    // å‚³çµ±æ–¹å¼
    if (user && user.profile && user.profile.name) {
        return user.profile.name;
    }
    return "æœªçŸ¥ç”¨æˆ¶";
    
    // ç¾ä»£æ–¹å¼
    // return user?.profile?.name ?? "æœªçŸ¥ç”¨æˆ¶";
}

// å‡½æ•¸å¯èƒ½è¿”å› null æˆ– undefined
function findUser(id) {
    const users = [
        { id: 1, name: "Alice" },
        { id: 2, name: "Bob" }
    ];
    
    const user = users.find(u => u.id === id);
    return user || null; // å¯èƒ½è¿”å› null
}

const user = findUser(3);
if (user) {
    console.log("æ‰¾åˆ°ç”¨æˆ¶:", user.name);
} else {
    console.log("ç”¨æˆ¶ä¸å­˜åœ¨");
}
```
</UniversalEditor>

### Rust çš„éŒ¯èª¤è™•ç†

Rust ä½¿ç”¨å‹åˆ¥ç³»çµ±è™•ç†éŒ¯èª¤ï¼Œæ²’æœ‰ç•°å¸¸æ©Ÿåˆ¶ï¼š

<UniversalEditor title="Rust éŒ¯èª¤è™•ç†" compare={true}>
```rust !! rs
// Rust éŒ¯èª¤è™•ç† - ä½¿ç”¨ Result å‹åˆ¥
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("é™¤æ•¸ä¸èƒ½ç‚ºé›¶".to_string())
    } else {
        Ok(a / b)
    }
}

fn process_data(data: &str) -> Result<String, String> {
    if data.is_empty() {
        return Err("è³‡æ–™ä¸èƒ½ç‚ºç©º".to_string());
    }
    Ok(data.to_uppercase())
}

// ä½¿ç”¨ match è™•ç† Result
fn handle_division() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("é™¤æ³•çµæœ: {}", result),
        Err(error) => println!("éŒ¯èª¤: {}", error),
    }
    
    match divide(10.0, 0.0) {
        Ok(result) => println!("çµæœ: {}", result),
        Err(error) => println!("éŒ¯èª¤: {}", error),
    }
}

// ä½¿ç”¨ if let ç°¡åŒ–è™•ç†
fn handle_division_simple() {
    if let Ok(result) = divide(10.0, 2.0) {
        println!("é™¤æ³•çµæœ: {}", result);
    }
    
    if let Err(error) = divide(10.0, 0.0) {
        println!("éŒ¯èª¤: {}", error);
    }
}

// ä½¿ç”¨ unwrap å’Œ expectï¼ˆä¸æ¨è–¦åœ¨ç”Ÿç”¢ç¨‹å¼ç¢¼ä¸­ä½¿ç”¨ï¼‰
fn handle_division_unwrap() {
    let result = divide(10.0, 2.0).unwrap(); // æˆåŠŸæ™‚è¿”å›å€¼ï¼Œå¤±æ•—æ™‚ panic
    println!("çµæœ: {}", result);
    
    let result = divide(10.0, 0.0).expect("é™¤æ³•å¤±æ•—"); // å¤±æ•—æ™‚ panic ä¸¦é¡¯ç¤ºè¨Šæ¯
    println!("çµæœ: {}", result);
}

// ä½¿ç”¨ ? æ“ä½œç¬¦å‚³æ’­éŒ¯èª¤
fn process_operations() -> Result<(), String> {
    let result1 = divide(10.0, 2.0)?; // å¦‚æœå¤±æ•—ï¼Œç«‹å³è¿”å›éŒ¯èª¤
    println!("ç¬¬ä¸€å€‹çµæœ: {}", result1);
    
    let result2 = process_data("hello")?;
    println!("ç¬¬äºŒå€‹çµæœ: {}", result2);
    
    Ok(()) // æˆåŠŸæ™‚è¿”å› ()
}

fn main() {
    handle_division();
    handle_division_simple();
    
    // è™•ç†å¯èƒ½ panic çš„ç¨‹å¼ç¢¼
    match std::panic::catch_unwind(|| {
        handle_division_unwrap();
    }) {
        Ok(_) => println!("æ“ä½œæˆåŠŸ"),
        Err(_) => println!("æ“ä½œå¤±æ•—ï¼Œç™¼ç”Ÿ panic"),
    }
    
    // è™•ç†è¿”å› Result çš„å‡½æ•¸
    if let Err(error) = process_operations() {
        println!("è™•ç†æ“ä½œæ™‚å‡ºéŒ¯: {}", error);
    }
}
```
</UniversalEditor>

### éŒ¯èª¤è™•ç†å·®ç•°

1. **ç•°å¸¸ vs å‹åˆ¥**: JavaScript ä½¿ç”¨ç•°å¸¸ï¼ŒRust ä½¿ç”¨å‹åˆ¥ç³»çµ±
2. **åŸ·è¡Œæ™‚ vs ç·¨è­¯æ™‚**: JavaScript åŸ·è¡Œæ™‚æª¢æŸ¥ï¼ŒRust ç·¨è­¯æ™‚æª¢æŸ¥
3. **å¯æ¢å¾© vs ä¸å¯æ¢å¾©**: Rust å€åˆ†å¯æ¢å¾©éŒ¯èª¤ï¼ˆResultï¼‰å’Œä¸å¯æ¢å¾©éŒ¯èª¤ï¼ˆpanicï¼‰
4. **é¡¯å¼ vs éš±å¼**: Rust å¼·åˆ¶é¡¯å¼è™•ç†éŒ¯èª¤ï¼ŒJavaScript å¯ä»¥å¿½ç•¥ç•°å¸¸

---

## ğŸ“¦ Option å‹åˆ¥

### è™•ç†å¯èƒ½ç‚ºç©ºçš„å€¼

<UniversalEditor title="Option å‹åˆ¥" compare={true}>
```rust !! rs
// Option å‹åˆ¥ - è™•ç†å¯èƒ½ç‚ºç©ºçš„å€¼
fn find_user(id: u32) -> Option<User> {
    let users = vec![
        User { id: 1, name: String::from("Alice") },
        User { id: 2, name: String::from("Bob") },
    ];
    
    users.into_iter().find(|user| user.id == id)
}

fn get_user_name(user: &User) -> &str {
    &user.name
}

// ä½¿ç”¨ match è™•ç† Option
fn handle_user_match(id: u32) {
    match find_user(id) {
        Some(user) => println!("æ‰¾åˆ°ç”¨æˆ¶: {}", get_user_name(&user)),
        None => println!("ç”¨æˆ¶ä¸å­˜åœ¨"),
    }
}

// ä½¿ç”¨ if let ç°¡åŒ–è™•ç†
fn handle_user_if_let(id: u32) {
    if let Some(user) = find_user(id) {
        println!("æ‰¾åˆ°ç”¨æˆ¶: {}", get_user_name(&user));
    } else {
        println!("ç”¨æˆ¶ä¸å­˜åœ¨");
    }
}

// ä½¿ç”¨ map å’Œ and_then é€²è¡Œéˆå¼æ“ä½œ
fn handle_user_chain(id: u32) {
    let user_name = find_user(id)
        .map(|user| get_user_name(&user).to_string())
        .unwrap_or_else(|| "æœªçŸ¥ç”¨æˆ¶".to_string());
    
    println!("ç”¨æˆ¶å: {}", user_name);
}

// ä½¿ç”¨ unwrap å’Œ expectï¼ˆè¬¹æ…ä½¿ç”¨ï¼‰
fn handle_user_unwrap(id: u32) {
    let user = find_user(id).unwrap(); // å¦‚æœç‚º None å‰‡ panic
    println!("ç”¨æˆ¶: {}", get_user_name(&user));
    
    let user = find_user(id).expect("ç”¨æˆ¶æ‡‰è©²å­˜åœ¨"); // è‡ªå®šç¾© panic è¨Šæ¯
    println!("ç”¨æˆ¶: {}", get_user_name(&user));
}

// Option çš„å¯¦ç”¨æ–¹æ³•
fn option_methods() {
    let value: Option<i32> = Some(42);
    let none_value: Option<i32> = None;
    
    // unwrap_or - æä¾›é è¨­å€¼
    println!("å€¼: {}", value.unwrap_or(0)); // 42
    println!("å€¼: {}", none_value.unwrap_or(0)); // 0
    
    // unwrap_or_else - ä½¿ç”¨é–‰åŒ…æä¾›é è¨­å€¼
    println!("å€¼: {}", none_value.unwrap_or_else(|| {
        println!("è¨ˆç®—é è¨­å€¼");
        100
    }));
    
    // map - è½‰æ›å€¼
    let doubled = value.map(|x| x * 2);
    println!("åŠ å€: {:?}", doubled); // Some(84)
    
    // and_then - éˆå¼æ“ä½œ
    let result = value.and_then(|x| {
        if x > 40 {
            Some(x.to_string())
        } else {
            None
        }
    });
    println!("çµæœ: {:?}", result); // Some("42")
    
    // filter - éæ¿¾å€¼
    let filtered = value.filter(|&x| x > 50);
    println!("éæ¿¾å¾Œ: {:?}", filtered); // None
}

struct User {
    id: u32,
    name: String,
}

fn main() {
    handle_user_match(1);
    handle_user_match(3);
    
    handle_user_if_let(1);
    handle_user_if_let(3);
    
    handle_user_chain(1);
    handle_user_chain(3);
    
    option_methods();
}
```
</UniversalEditor>

---

## ğŸ”„ Result å‹åˆ¥

### è™•ç†å¯èƒ½å¤±æ•—çš„æ“ä½œ

<UniversalEditor title="Result å‹åˆ¥" compare={true}>
```rust !! rs
// è‡ªå®šç¾©éŒ¯èª¤å‹åˆ¥
#[derive(Debug)]
enum AppError {
    DivisionByZero,
    InvalidInput(String),
    NetworkError(String),
    DatabaseError(String),
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AppError::DivisionByZero => write!(f, "é™¤æ•¸ä¸èƒ½ç‚ºé›¶"),
            AppError::InvalidInput(msg) => write!(f, "ç„¡æ•ˆè¼¸å…¥: {}", msg),
            AppError::NetworkError(msg) => write!(f, "ç¶²è·¯éŒ¯èª¤: {}", msg),
            AppError::DatabaseError(msg) => write!(f, "è³‡æ–™åº«éŒ¯èª¤: {}", msg),
        }
    }
}

// å¯¦ç¾ std::error::Error trait
impl std::error::Error for AppError {}

// ä½¿ç”¨è‡ªå®šç¾©éŒ¯èª¤å‹åˆ¥
fn divide_with_custom_error(a: f64, b: f64) -> Result<f64, AppError> {
    if b == 0.0 {
        Err(AppError::DivisionByZero)
    } else {
        Ok(a / b)
    }
}

fn validate_input(input: &str) -> Result<String, AppError> {
    if input.is_empty() {
        return Err(AppError::InvalidInput("è³‡æ–™ä¸èƒ½ç‚ºç©º".to_string()));
    }
    
    if input.len() < 3 {
        return Err(AppError::InvalidInput("è¼¸å…¥é•·åº¦è‡³å°‘ç‚º3".to_string()));
    }
    
    Ok(input.to_string())
}

// æ¨¡æ“¬ç¶²è·¯è«‹æ±‚
fn fetch_data(url: &str) -> Result<String, AppError> {
    if url.is_empty() {
        return Err(AppError::NetworkError("URL ä¸èƒ½ç‚ºç©º".to_string()));
    }
    
    if url.contains("error") {
        return Err(AppError::NetworkError("æ¨¡æ“¬ç¶²è·¯éŒ¯èª¤".to_string()));
    }
    
    Ok(format!("å¾ {} ç²å–çš„è³‡æ–™", url))
}

// éŒ¯èª¤å‚³æ’­
fn process_data_chain(input: &str, url: &str) -> Result<String, AppError> {
    // ä½¿ç”¨ ? æ“ä½œç¬¦å‚³æ’­éŒ¯èª¤
    let validated_input = validate_input(input)?;
    let data = fetch_data(url)?;
    
    Ok(format!("è™•ç†å¾Œçš„è³‡æ–™: {} + {}", validated_input, data))
}

// ä½¿ç”¨ map å’Œ map_err è½‰æ›éŒ¯èª¤
fn process_with_map(input: &str) -> Result<String, AppError> {
    validate_input(input)
        .map(|s| s.to_uppercase())
        .map_err(|e| AppError::InvalidInput(format!("é©—è­‰å¤±æ•—: {}", e)))
}

// ä½¿ç”¨ and_then é€²è¡Œéˆå¼æ“ä½œ
fn process_with_and_then(input: &str) -> Result<String, AppError> {
    validate_input(input)
        .and_then(|s| {
            if s.len() > 10 {
                Ok(s)
            } else {
                Err(AppError::InvalidInput("è¼¸å…¥å¤ªçŸ­".to_string()))
            }
        })
        .map(|s| format!("è™•ç†çµæœ: {}", s))
}

// çµ„åˆå¤šå€‹ Result
fn combine_results() -> Result<(), AppError> {
    let result1 = divide_with_custom_error(10.0, 2.0)?;
    let result2 = validate_input("hello")?;
    let result3 = fetch_data("https://example.com")?;
    
    println!("æ‰€æœ‰æ“ä½œæˆåŠŸ: {}, {}, {}", result1, result2, result3);
    Ok(())
}

fn main() {
    // è™•ç†è‡ªå®šç¾©éŒ¯èª¤
    match divide_with_custom_error(10.0, 0.0) {
        Ok(result) => println!("çµæœ: {}", result),
        Err(error) => println!("éŒ¯èª¤: {}", error),
    }
    
    // ä½¿ç”¨ ? æ“ä½œç¬¦
    if let Err(error) = process_data_chain("hello", "https://example.com") {
        println!("è™•ç†å¤±æ•—: {}", error);
    }
    
    // ä½¿ç”¨ map å’Œ and_then
    match process_with_map("hi") {
        Ok(result) => println!("æˆåŠŸ: {}", result),
        Err(error) => println!("å¤±æ•—: {}", error),
    }
    
    match process_with_and_then("very long input string") {
        Ok(result) => println!("æˆåŠŸ: {}", result),
        Err(error) => println!("å¤±æ•—: {}", error),
    }
    
    // çµ„åˆå¤šå€‹æ“ä½œ
    if let Err(error) = combine_results() {
        println!("çµ„åˆæ“ä½œå¤±æ•—: {}", error);
    }
}
```
</UniversalEditor>

---

## ğŸ¯ éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸

### éŒ¯èª¤è™•ç†æ¨¡å¼å°æ¯”

<UniversalEditor title="éŒ¯èª¤è™•ç†æ¨¡å¼" compare={true}>
```javascript !! js
// JavaScript éŒ¯èª¤è™•ç†æ¨¡å¼
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
    }
}

class NetworkError extends Error {
    constructor(message) {
        super(message);
        this.name = 'NetworkError';
    }
}

// å‡½æ•¸å¯èƒ½æ‹‹å‡ºç•°å¸¸
function processUserData(userData) {
    if (!userData.name) {
        throw new ValidationError('ç”¨æˆ¶åä¸èƒ½ç‚ºç©º');
    }
    
    if (userData.age < 0) {
        throw new ValidationError('å¹´é½¡ä¸èƒ½ç‚ºè² æ•¸');
    }
    
    return {
        ...userData,
        processed: true
    };
}

// ç•°æ­¥å‡½æ•¸éŒ¯èª¤è™•ç†
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
            throw new NetworkError(`HTTP ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        if (error instanceof NetworkError) {
            console.log('ç¶²è·¯éŒ¯èª¤:', error.message);
        } else {
            console.log('æœªçŸ¥éŒ¯èª¤:', error.message);
        }
        throw error; // é‡æ–°æ‹‹å‡º
    }
}

// ä½¿ç”¨ try-catch è™•ç†
async function handleUser(userId, userData) {
    try {
        const processedData = processUserData(userData);
        const fetchedData = await fetchUserData(userId);
        
        return {
            ...processedData,
            ...fetchedData
        };
    } catch (error) {
        if (error instanceof ValidationError) {
            console.log('é©—è­‰éŒ¯èª¤:', error.message);
            return null;
        } else if (error instanceof NetworkError) {
            console.log('ç¶²è·¯éŒ¯èª¤:', error.message);
            return null;
        } else {
            console.log('æœªçŸ¥éŒ¯èª¤:', error.message);
            throw error;
        }
    }
}

// ä½¿ç”¨ Promise éˆ
function processWithPromise(userData) {
    return Promise.resolve(userData)
        .then(data => {
            if (!data.name) {
                throw new ValidationError('ç”¨æˆ¶åä¸èƒ½ç‚ºç©º');
            }
            return data;
        })
        .then(data => {
            return {
                ...data,
                processed: true
            };
        })
        .catch(error => {
            if (error instanceof ValidationError) {
                console.log('é©—è­‰å¤±æ•—:', error.message);
                return null;
            }
            throw error;
        });
}
```

```rust !! rs
// Rust éŒ¯èª¤è™•ç†æ¨¡å¼
use std::error::Error;
use std::fmt;

// è‡ªå®šç¾©éŒ¯èª¤å‹åˆ¥
#[derive(Debug)]
enum AppError {
    ValidationError(String),
    NetworkError(String),
    DatabaseError(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::ValidationError(msg) => write!(f, "é©—è­‰éŒ¯èª¤: {}", msg),
            AppError::NetworkError(msg) => write!(f, "ç¶²è·¯éŒ¯èª¤: {}", msg),
            AppError::DatabaseError(msg) => write!(f, "è³‡æ–™åº«éŒ¯èª¤: {}", msg),
        }
    }
}

impl Error for AppError {}

// å‡½æ•¸è¿”å› Result
fn process_user_data(user_data: UserData) -> Result<UserData, AppError> {
    if user_data.name.is_empty() {
        return Err(AppError::ValidationError("ç”¨æˆ¶åä¸èƒ½ç‚ºç©º".to_string()));
    }
    
    if user_data.age < 0 {
        return Err(AppError::ValidationError("å¹´é½¡ä¸èƒ½ç‚ºè² æ•¸".to_string()));
    }
    
    Ok(UserData {
        processed: true,
        ..user_data
    })
}

// ç•°æ­¥å‡½æ•¸éŒ¯èª¤è™•ç†
async fn fetch_user_data(user_id: u32) -> Result<UserData, AppError> {
    // æ¨¡æ“¬ç¶²è·¯è«‹æ±‚
    if user_id == 0 {
        return Err(AppError::NetworkError("ç„¡æ•ˆçš„ç”¨æˆ¶ID".to_string()));
    }
    
    // æ¨¡æ“¬æˆåŠŸéŸ¿æ‡‰
    Ok(UserData {
        id: user_id,
        name: format!("ç”¨æˆ¶{}", user_id),
        age: 25,
        processed: false,
    })
}

// ä½¿ç”¨ ? æ“ä½œç¬¦è™•ç†éŒ¯èª¤
async fn handle_user(user_id: u32, user_data: UserData) -> Result<UserData, AppError> {
    let processed_data = process_user_data(user_data)?;
    let fetched_data = fetch_user_data(user_id).await?;
    
    Ok(UserData {
        id: fetched_data.id,
        name: processed_data.name,
        age: processed_data.age,
        processed: true,
    })
}

// ä½¿ç”¨ map å’Œ map_err è½‰æ›éŒ¯èª¤
fn process_with_transformation(user_data: UserData) -> Result<UserData, AppError> {
    process_user_data(user_data)
        .map(|data| UserData {
            name: data.name.to_uppercase(),
            ..data
        })
        .map_err(|e| match e {
            AppError::ValidationError(msg) => AppError::ValidationError(format!("è™•ç†å¤±æ•—: {}", msg)),
            _ => e,
        })
}

// ä½¿ç”¨ and_then é€²è¡Œéˆå¼æ“ä½œ
fn process_with_chain(user_data: UserData) -> Result<UserData, AppError> {
    process_user_data(user_data)
        .and_then(|data| {
            if data.name.len() > 10 {
                Ok(data)
            } else {
                Err(AppError::ValidationError("ç”¨æˆ¶åå¤ªçŸ­".to_string()))
            }
        })
        .map(|data| UserData {
            name: format!("è™•ç†å¾Œçš„_{}", data.name),
            ..data
        })
}

#[derive(Debug, Clone)]
struct UserData {
    id: u32,
    name: String,
    age: i32,
    processed: bool,
}

#[tokio::main]
async fn main() {
    let user_data = UserData {
        id: 0,
        name: "Alice".to_string(),
        age: 25,
        processed: false,
    };
    
    // è™•ç†éŒ¯èª¤
    match handle_user(1, user_data.clone()).await {
        Ok(result) => println!("æˆåŠŸ: {:?}", result),
        Err(error) => println!("å¤±æ•—: {}", error),
    }
    
    // ä½¿ç”¨è½‰æ›
    match process_with_transformation(user_data.clone()) {
        Ok(result) => println!("è½‰æ›æˆåŠŸ: {:?}", result),
        Err(error) => println!("è½‰æ›å¤±æ•—: {}", error),
    }
    
    // ä½¿ç”¨éˆå¼æ“ä½œ
    match process_with_chain(user_data) {
        Ok(result) => println!("éˆå¼è™•ç†æˆåŠŸ: {:?}", result),
        Err(error) => println!("éˆå¼è™•ç†å¤±æ•—: {}", error),
    }
}
```
</UniversalEditor>

### é€²éšéŒ¯èª¤è™•ç†å‡½å¼åº«

åœ¨å¯¦éš›å°ˆæ¡ˆä¸­ï¼Œç‚ºäº†æ›´æ–¹ä¾¿åœ°å®šç¾©å’Œè™•ç†éŒ¯èª¤ï¼ŒRust ç¤¾ç¾¤æä¾›äº†è¨±å¤šå„ªç§€çš„éŒ¯èª¤è™•ç†å‡½å¼åº«ï¼Œä¾‹å¦‚ï¼š

*   **`thiserror`**: ç”¨æ–¼ç°¡åŒ–è‡ªå®šç¾©éŒ¯èª¤å‹åˆ¥çš„å®šç¾©ï¼Œç‰¹åˆ¥æ˜¯ç•¶éŒ¯èª¤éœ€è¦åŒ…å«é¡å¤–è³‡è¨Šæˆ–å¾å…¶ä»–éŒ¯èª¤å‹åˆ¥æ´¾ç”Ÿæ™‚ã€‚å®ƒé€éå·¨é›†è‡ªå‹•å¯¦ç¾ `Display` å’Œ `Error` traitã€‚
*   **`anyhow`**: ç”¨æ–¼ç°¡åŒ–éŒ¯èª¤å‚³æ’­ï¼Œç‰¹åˆ¥æ˜¯åœ¨æ‡‰ç”¨ç¨‹å¼å±¤ç¨‹å¼ç¢¼ä¸­ã€‚å®ƒæä¾›äº†ä¸€å€‹ç°¡å–®çš„ `Result` å‹åˆ¥åˆ¥å `anyhow::Result<T>`ï¼Œä¸¦å…è¨±ä½ è¼•é¬†åœ°å°‡å„ç¨®éŒ¯èª¤å‹åˆ¥è½‰æ›ç‚º `anyhow::Error`ã€‚

é€™äº›å‡½å¼åº«å¯ä»¥å¤§å¤§æ¸›å°‘éŒ¯èª¤è™•ç†çš„æ¨£æ¿ç¨‹å¼ç¢¼ï¼Œæé«˜ç¨‹å¼ç¢¼çš„å¯è®€æ€§å’Œå¯ç¶­è­·æ€§ã€‚

---

## ğŸ¯ ç·´ç¿’é¡Œ