---
title: "ä¸¦ç™¼èˆ‡ç•°æ­¥æ¨¡å‹"
description: "å­¸ç¿’ Rust çš„ä¸¦ç™¼ç¨‹å¼è¨­è¨ˆã€ç•°æ­¥æ¨¡å‹å’Œå¤šåŸ·è¡Œç·’å®‰å…¨ï¼Œå°æ¯” JavaScript çš„äº‹ä»¶å¾ªç’°æ©Ÿåˆ¶"
---

# ä¸¦ç™¼èˆ‡ç•°æ­¥æ¨¡å‹

## ğŸ“– å­¸ç¿’ç›®æ¨™

ç†è§£ Rust çš„ä¸¦ç™¼ç¨‹å¼è¨­è¨ˆæ¨¡å‹ï¼ŒåŒ…æ‹¬å¤šåŸ·è¡Œç·’ã€ç•°æ­¥ç¨‹å¼è¨­è¨ˆå’ŒåŸ·è¡Œç·’å®‰å…¨æ©Ÿåˆ¶ï¼Œå°æ¯” JavaScript çš„å–®åŸ·è¡Œç·’äº‹ä»¶å¾ªç’°æ¨¡å‹ã€‚

---

## ğŸ¯ åŸ·è¡Œæ¨¡å‹å°æ¯”

### JavaScript çš„äº‹ä»¶å¾ªç’°

JavaScript ä½¿ç”¨å–®åŸ·è¡Œç·’äº‹ä»¶å¾ªç’°æ¨¡å‹ï¼š

<UniversalEditor title="JavaScript äº‹ä»¶å¾ªç’°" compare={true}>
```javascript !! js
// JavaScript å–®åŸ·è¡Œç·’äº‹ä»¶å¾ªç’°
console.log("é–‹å§‹åŸ·è¡Œ");

// åŒæ­¥ç¨‹å¼ç¢¼
const result = 1 + 2;
console.log("åŒæ­¥è¨ˆç®—:", result);

// ç•°æ­¥ç¨‹å¼ç¢¼ - å¾®ä»»å‹™
Promise.resolve().then(() => {
    console.log("å¾®ä»»å‹™ 1");
});

// ç•°æ­¥ç¨‹å¼ç¢¼ - å®ä»»å‹™
setTimeout(() => {
    console.log("å®ä»»å‹™ 1");
}, 0);

// æ›´å¤šå¾®ä»»å‹™
Promise.resolve().then(() => {
    console.log("å¾®ä»»å‹™ 2");
});

console.log("çµæŸåŸ·è¡Œ");

// è¼¸å‡ºé †åºï¼š
// é–‹å§‹åŸ·è¡Œ
// åŒæ­¥è¨ˆç®—: 3
// çµæŸåŸ·è¡Œ
// å¾®ä»»å‹™ 1
// å¾®ä»»å‹™ 2
// å®ä»»å‹™ 1

// ç•°æ­¥å‡½æ•¸
async function fetchData() {
    console.log("é–‹å§‹ç²å–è³‡æ–™");
    
    // æ¨¡æ“¬ç¶²è·¯è«‹æ±‚
    const response = await new Promise(resolve => {
        setTimeout(() => {
            resolve({ data: "Hello from server" });
        }, 1000);
    });
    
    console.log("è³‡æ–™ç²å–å®Œæˆ:", response.data);
    return response.data;
}

// èª¿ç”¨ç•°æ­¥å‡½æ•¸
fetchData().then(data => {
    console.log("è™•ç†è³‡æ–™:", data);
});

console.log("ç¹¼çºŒåŸ·è¡Œå…¶ä»–ç¨‹å¼ç¢¼");

// ä¸¦ç™¼è™•ç†ï¼ˆå¯¦éš›ä¸Šæ˜¯ä¸¦ç™¼ï¼Œä¸æ˜¯ä¸¦è¡Œï¼‰
async function processItems(items) {
    const promises = items.map(async (item) => {
        // æ¨¡æ“¬ç•°æ­¥è™•ç†
        await new Promise(resolve => setTimeout(resolve, 100));
        return `processed_${item}`;
    });
    
    const results = await Promise.all(promises);
    console.log("æ‰€æœ‰é …ç›®è™•ç†å®Œæˆ:", results);
}

processItems([1, 2, 3, 4, 5]);
```
</UniversalEditor>

é›–ç„¶ JavaScript æœ¬èº«æ˜¯å–®åŸ·è¡Œç·’çš„ï¼Œä½†å¯ä»¥é€é **Web Workers** å¯¦ç¾å¤šåŸ·è¡Œç·’ä¸¦ç™¼ï¼Œå°‡è€—æ™‚çš„è¨ˆç®—ä»»å‹™æ”¾åˆ°å¾Œå°åŸ·è¡Œç·’åŸ·è¡Œï¼Œé¿å…é˜»å¡ä¸»åŸ·è¡Œç·’ã€‚é€™é¡ä¼¼æ–¼ Rust çš„å¤šåŸ·è¡Œç·’ï¼Œä½† Web Workers ä¹‹é–“ä¸èƒ½ç›´æ¥å…±äº«è¨˜æ†¶é«”ï¼Œéœ€è¦é€éè¨Šæ¯å‚³éé€²è¡Œé€šè¨Šã€‚

### Rust çš„å¤šåŸ·è¡Œç·’æ¨¡å‹

Rust æ”¯æ´çœŸæ­£çš„å¤šåŸ·è¡Œç·’ä¸¦è¡ŒåŸ·è¡Œï¼š

<UniversalEditor title="Rust å¤šåŸ·è¡Œç·’" compare={true}>
```rust !! rs
use std::thread;
use std::time::Duration;

fn main() {
    println!("é–‹å§‹åŸ·è¡Œ");
    
    // åŒæ­¥ç¨‹å¼ç¢¼
    let result = 1 + 2;
    println!("åŒæ­¥è¨ˆç®—: {}", result);
    
    // å»ºç«‹åŸ·è¡Œç·’
    let handle = thread::spawn(|| {
        println!("åŸ·è¡Œç·’ 1 é–‹å§‹åŸ·è¡Œ");
        thread::sleep(Duration::from_millis(100));
        println!("åŸ·è¡Œç·’ 1 åŸ·è¡Œå®Œæˆ");
    });
    
    // ä¸»åŸ·è¡Œç·’ç¹¼çºŒåŸ·è¡Œ
    println!("ä¸»åŸ·è¡Œç·’ç¹¼çºŒåŸ·è¡Œ");
    
    // ç­‰å¾…åŸ·è¡Œç·’å®Œæˆ
    handle.join().unwrap();
    println!("æ‰€æœ‰åŸ·è¡Œç·’åŸ·è¡Œå®Œæˆ");
}

// å¤šåŸ·è¡Œç·’è³‡æ–™è™•ç†
fn process_items_parallel(items: Vec<i32>) {
    let handles: Vec<_> = items.into_iter().map(|item| {
        thread::spawn(move || {
            // æ¨¡æ“¬è™•ç†æ™‚é–“
            thread::sleep(Duration::from_millis(100));
            format!("processed_{}", item)
        })
    }).collect();
    
    // æ”¶é›†æ‰€æœ‰åŸ·è¡Œç·’çš„çµæœ
    let results: Vec<String> = handles.into_iter()
        .map(|handle| handle.join().unwrap())
        .collect();
    
    println!("æ‰€æœ‰é …ç›®è™•ç†å®Œæˆ: {:?}", results);
}

// ä½¿ç”¨åŸ·è¡Œç·’æ± 
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
    
    // ç™¼é€åŸ·è¡Œç·’
    thread::spawn(move || {
        let messages = vec![
            String::from("è¨Šæ¯ 1"),
            String::from("è¨Šæ¯ 2"),
            String::from("è¨Šæ¯ 3"),
        ];
        
        for msg in messages {
            tx.send(msg).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    // æ¥æ”¶åŸ·è¡Œç·’
    for received in rx {
        println!("æ”¶åˆ°: {}", received);
    }
}
```
</UniversalEditor>

### åŸ·è¡Œæ¨¡å‹å·®ç•°

1. **å–®åŸ·è¡Œç·’ vs å¤šåŸ·è¡Œç·’**: JavaScript å–®åŸ·è¡Œç·’äº‹ä»¶å¾ªç’°ï¼ŒRust æ”¯æ´å¤šåŸ·è¡Œç·’ä¸¦è¡Œ
2. **ä¸¦ç™¼ vs ä¸¦è¡Œ**: JavaScript ä¸¦ç™¼éä¸¦è¡Œï¼ŒRust å¯ä»¥çœŸæ­£ä¸¦è¡Œ
3. **è¨˜æ†¶é«”å®‰å…¨**: JavaScript åŸ·è¡Œæ™‚æª¢æŸ¥ï¼ŒRust ç·¨è­¯æ™‚ä¿è­‰åŸ·è¡Œç·’å®‰å…¨
4. **æ•ˆèƒ½**: JavaScript å—å–®åŸ·è¡Œç·’é™åˆ¶ï¼ŒRust å¯ä»¥å……åˆ†åˆ©ç”¨å¤šæ ¸å¿ƒ

---

## ğŸ”’ åŸ·è¡Œç·’å®‰å…¨èˆ‡æ‰€æœ‰æ¬Š

### å…±äº«ç‹€æ…‹ç®¡ç†

<UniversalEditor title="åŸ·è¡Œç·’å®‰å…¨" compare={true}>
```rust !! rs
use std::sync::{Arc, Mutex};
use std::thread;

// åŸ·è¡Œç·’å®‰å…¨çš„è¨ˆæ•¸å™¨
struct SafeCounter {
    count: Mutex<i32>,
}

impl SafeCounter {
    fn new() -> Self {
        SafeCounter {
            count: Mutex::new(0),
        }
    }
    
    fn increment(&self) {
        let mut count = self.count.lock().unwrap();
        *count += 1;
    }
    
    fn get_count(&self) -> i32 {
        *self.count.lock().unwrap()
    }
}

fn main() {
    let counter = Arc::new(SafeCounter::new());
    let mut handles = vec![];
    
    // å»ºç«‹å¤šå€‹åŸ·è¡Œç·’åŒæ™‚å¢åŠ è¨ˆæ•¸å™¨
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                counter.increment();
            }
        });
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰åŸ·è¡Œç·’å®Œæˆ
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("æœ€çµ‚è¨ˆæ•¸: {}", counter.get_count()); // æ‡‰è©²æ˜¯ 1000
}

// ä½¿ç”¨ RwLock é€²è¡Œè®€å¯«åˆ†é›¢
use std::sync::RwLock;

struct DataStore {
    data: RwLock<Vec<String>>,
}

impl DataStore {
    fn new() -> Self {
        DataStore {
            data: RwLock::new(Vec::new()),
        }
    }
    
    fn write(&self, item: String) {
        let mut data = self.data.write().unwrap();
        data.push(item);
    }
    
    fn read(&self) -> Vec<String> {
        let data = self.data.read().unwrap();
        data.clone()
    }
}

fn main() {
    let store = Arc::new(DataStore::new());
    let mut handles = vec![];
    
    // å¯«å…¥åŸ·è¡Œç·’
    for i in 0..5 {
        let store = Arc::clone(&store);
        let handle = thread::spawn(move || {
            store.write(format!("è³‡æ–™ {}", i));
        });
        handles.push(handle);
    }
    
    // è®€å–åŸ·è¡Œç·’
    for _ in 0..3 {
        let store = Arc::clone(&store);
        let handle = thread::spawn(move || {
            let data = store.read();
            println!("è®€å–åˆ°è³‡æ–™: {:?}", data);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
}
```
</UniversalEditor>

---

## âš¡ ç•°æ­¥ç¨‹å¼è¨­è¨ˆ

### Rust çš„ç•°æ­¥ç¨‹å¼è¨­è¨ˆ

<UniversalEditor title="Rust ç•°æ­¥ç¨‹å¼è¨­è¨ˆ" compare={true}>
```rust !! rs
use tokio;
use std::time::Duration;

// ç•°æ­¥å‡½æ•¸
async fn fetch_data() -> String {
    println!("é–‹å§‹ç²å–è³‡æ–™");
    
    // æ¨¡æ“¬ç¶²è·¯è«‹æ±‚
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    println!("è³‡æ–™ç²å–å®Œæˆ");
    String::from("Hello from server")
}

// ç•°æ­¥ä¸»å‡½æ•¸
#[tokio::main]
async fn main() {
    println!("é–‹å§‹åŸ·è¡Œ");
    
    // èª¿ç”¨ç•°æ­¥å‡½æ•¸
    let data = fetch_data().await;
    println!("è™•ç†è³‡æ–™: {}", data);
    
    println!("ç¹¼çºŒåŸ·è¡Œå…¶ä»–ç¨‹å¼ç¢¼");
}

// ä¸¦ç™¼ç•°æ­¥ä»»å‹™
async fn process_items_async(items: Vec<i32>) -> Vec<String> {
    let mut handles = vec![];
    
    for item in items {
        let handle = tokio::spawn(async move {
            // æ¨¡æ“¬ç•°æ­¥è™•ç†
            tokio::time::sleep(Duration::from_millis(100)).await;
            format!("processed_{}", item)
        });
        handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰ä»»å‹™å®Œæˆ
    let mut results = vec![];
    for handle in handles {
        let result = handle.await.unwrap();
        results.push(result);
    }
    
    results
}

#[tokio::main]
async fn main() {
    let items = vec![1, 2, 3, 4, 5];
    let results = process_items_async(items).await;
    println!("æ‰€æœ‰é …ç›®è™•ç†å®Œæˆ: {:?}", results);
}

// ç•°æ­¥é€šé“
use tokio::sync::mpsc;

async fn async_channel_example() {
    let (tx, mut rx) = mpsc::channel(100);
    
    // ç™¼é€ä»»å‹™
    let producer = tokio::spawn(async move {
        for i in 0..10 {
            tx.send(format!("è¨Šæ¯ {}", i)).await.unwrap();
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
    });
    
    // æ¥æ”¶ä»»å‹™
    let consumer = tokio::spawn(async move {
        while let Some(message) = rx.recv().await {
            println!("æ”¶åˆ°: {}", message);
        }
    });
    
    // ç­‰å¾…å…©å€‹ä»»å‹™å®Œæˆ
    let _ = tokio::join!(producer, consumer);
}

#[tokio::main]
async fn main() {
    async_channel_example().await;
}
```
</UniversalEditor>

### ç•°æ­¥èˆ‡å¤šåŸ·è¡Œç·’å°æ¯”

<UniversalEditor title="ç•°æ­¥ vs å¤šåŸ·è¡Œç·’" compare={true}>
```rust !! rs
use std::time::Duration;
use tokio;

// å¤šåŸ·è¡Œç·’ç‰ˆæœ¬ - é©åˆ CPU å¯†é›†å‹ä»»å‹™
fn cpu_intensive_task() -> i32 {
    // æ¨¡æ“¬ CPU å¯†é›†å‹è¨ˆç®—
    let mut result = 0;
    for i in 0..1_000_000 {
        result += i;
    }
    result
}

fn multi_threaded_example() {
    let start = std::time::Instant::now();
    
    let handles: Vec<_> = (0..4).map(|_| {
        std::thread::spawn(|| {
            cpu_intensive_task()
        })
    }).collect();
    
    let results: Vec<i32> = handles.into_iter()
        .map(|handle| handle.join().unwrap())
        .collect();
    
    let duration = start.elapsed();
    println!("å¤šåŸ·è¡Œç·’è€—æ™‚: {:?}, çµæœ: {:?}", duration, results);
}

// ç•°æ­¥ç‰ˆæœ¬ - é©åˆ I/O å¯†é›†å‹ä»»å‹™
async fn io_intensive_task() -> String {
    // æ¨¡æ“¬ I/O æ“ä½œ
    tokio::time::sleep(Duration::from_millis(100)).await;
    String::from("I/O ä»»å‹™å®Œæˆ")
}

async fn async_example() {
    let start = std::time::Instant::now();
    
    let handles: Vec<_> = (0..100).map(|_| {
        tokio::spawn(async {
            io_intensive_task().await
        })
    }).collect();
    
    let results: Vec<String> = futures::future::join_all(handles).await
        .into_iter()
        .map(|r| r.unwrap())
        .collect();
    
    let duration = start.elapsed();
    println!("ç•°æ­¥è€—æ™‚: {:?}, è™•ç†äº† {} å€‹ä»»å‹™", duration, results.len());
}

#[tokio::main]
async fn main() {
    // æ¯”è¼ƒå…©ç¨®æ–¹æ³•
    multi_threaded_example();
    async_example().await;
}
```
</UniversalEditor>

---

## ğŸ¯ ä¸¦ç™¼æ¨¡å¼å°æ¯”

### JavaScript çš„ä¸¦ç™¼æ¨¡å¼

<UniversalEditor title="JavaScript ä¸¦ç™¼æ¨¡å¼" compare={true}>
```javascript !! js
// JavaScript çš„ä¸¦ç™¼æ¨¡å¼
class DataStore {
    constructor() {
        this.data = [];
        this.promise = Promise.resolve();
    }
    
    // ä½¿ç”¨ Promise éˆç¢ºä¿é †åºåŸ·è¡Œ
    async write(item) {
        this.promise = this.promise.then(async () => {
            await new Promise(resolve => setTimeout(resolve, 100));
            this.data.push(item);
            console.log(`å¯«å…¥: ${item}`);
        });
        return this.promise;
    }
    
    async read() {
        await this.promise;
        return [...this.data];
    }
}

// ä½¿ç”¨ç¯„ä¾‹
async function javascript_concurrency() {
    const store = new DataStore();
    
    // ä¸¦ç™¼å¯«å…¥
    const writePromises = [];
    for (let i = 0; i < 5; i++) {
        writePromises.push(store.write(`è³‡æ–™ ${i}`));
    }
    
    // ç­‰å¾…æ‰€æœ‰å¯«å…¥å®Œæˆ
    await Promise.all(writePromises);
    
    // è®€å–è³‡æ–™
    const data = await store.read();
    console.log("è®€å–åˆ°è³‡æ–™:", data);
}

// Worker åŸ·è¡Œç·’ï¼ˆé¡ä¼¼ Rust çš„å¤šåŸ·è¡Œç·’ï¼‰
if (typeof Worker !== 'undefined') {
    const worker = new Worker(`
        self.onmessage = function(e) {
            const result = e.data * 2;
            self.postMessage(result);
        };
    `);
    
    worker.onmessage = function(e) {
        console.log("Worker è¨ˆç®—çµæœ:", e.data);
    };
    
    worker.postMessage(42);
}

javascript_concurrency();
```
</UniversalEditor>

### Rust çš„ä¸¦ç™¼æ¨¡å¼

<UniversalEditor title="Rust ä¸¦ç™¼æ¨¡å¼" compare={true}>
```rust !! rs
use std::sync::{Arc, Mutex};
use tokio::sync::RwLock;

// åŸ·è¡Œç·’å®‰å…¨çš„ç•°æ­¥è³‡æ–™å„²å­˜
struct AsyncDataStore {
    data: Arc<RwLock<Vec<String>>>,
}

impl AsyncDataStore {
    fn new() -> Self {
        AsyncDataStore {
            data: Arc::new(RwLock::new(Vec::new())),
        }
    }
    
    async fn write(&self, item: String) {
        let mut data = self.data.write().await;
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        data.push(item);
        println!("å¯«å…¥: {}", item);
    }
    
    async fn read(&self) -> Vec<String> {
        let data = self.data.read().await;
        data.clone()
    }
}

#[tokio::main]
async fn rust_concurrency() {
    let store = Arc::new(AsyncDataStore::new());
    
    // ä¸¦ç™¼å¯«å…¥
    let mut write_handles = vec![];
    for i in 0..5 {
        let store = Arc::clone(&store);
        let handle = tokio::spawn(async move {
            store.write(format!("è³‡æ–™ {}", i)).await;
        });
        write_handles.push(handle);
    }
    
    // ç­‰å¾…æ‰€æœ‰å¯«å…¥å®Œæˆ
    for handle in write_handles {
        handle.await.unwrap();
    }
    
    // è®€å–è³‡æ–™
    let data = store.read().await;
    println!("è®€å–åˆ°è³‡æ–™: {:?}", data);
}

// ä½¿ç”¨ rayon é€²è¡Œä¸¦è¡Œè¨ˆç®—
use rayon::prelude::*;

fn parallel_computation() {
    let numbers: Vec<i32> = (0..1_000_000).collect();
    
    let start = std::time::Instant::now();
    
    // ä¸¦è¡Œè¨ˆç®—
    let sum: i64 = numbers.par_iter()
        .map(|&x| x as i64)
        .sum();
    
    let duration = start.elapsed();
    println!("ä¸¦è¡Œè¨ˆç®—è€—æ™‚: {:?}, çµæœ: {}", duration, sum);
}

fn main() {
    // åŸ·è¡Œç•°æ­¥ä¸¦ç™¼ç¯„ä¾‹
    rust_concurrency();
    
    // åŸ·è¡Œä¸¦è¡Œè¨ˆç®—ç¯„ä¾‹
    parallel_computation();
}
```
</UniversalEditor>

---

## ğŸ¯ ç·´ç¿’é¡Œ

### ç·´ç¿’ 1: åŸ·è¡Œç·’å®‰å…¨è¨ˆæ•¸å™¨

å»ºç«‹ä¸€å€‹åŸ·è¡Œç·’å®‰å…¨çš„è¨ˆæ•¸å™¨ï¼Œæ”¯æ´å¤šå€‹åŸ·è¡Œç·’åŒæ™‚å¢åŠ è¨ˆæ•¸ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use std::sync::{Arc, Mutex};
use std::thread;

struct Counter {
    count: Mutex<i32>,
}

impl Counter {
    fn new() -> Self {
        Counter {
            count: Mutex::new(0),
        }
    }
    
    fn increment(&self) {
        let mut count = self.count.lock().unwrap();
        *count += 1;
    }
    
    fn get_count(&self) -> i32 {
        *self.count.lock().unwrap()
    }
}

fn main() {
    let counter = Arc::new(Counter::new());
    let mut handles = vec![];
    
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..100 {
                counter.increment();
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.join().unwrap();
    }
    
    println!("æœ€çµ‚è¨ˆæ•¸: {}", counter.get_count()); // æ‡‰è©²æ˜¯ 1000
}
```

</details>

### ç·´ç¿’ 2: ç•°æ­¥ä»»å‹™è™•ç†

å»ºç«‹ä¸€å€‹ç•°æ­¥å‡½æ•¸ï¼Œä¸¦ç™¼è™•ç†å¤šå€‹ä»»å‹™ä¸¦æ”¶é›†çµæœï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use tokio;
use std::time::Duration;

async fn process_task(id: i32) -> String {
    tokio::time::sleep(Duration::from_millis(100)).await;
    format!("ä»»å‹™ {} å®Œæˆ", id)
}

async fn process_all_tasks() -> Vec<String> {
    let mut handles = vec![];
    
    for i in 0..10 {
        let handle = tokio::spawn(async move {
            process_task(i).await
        });
        handles.push(handle);
    }
    
    let mut results = vec![];
    for handle in handles {
        let result = handle.await.unwrap();
        results.push(result);
    }
    
    results
}

#[tokio::main]
async fn main() {
    let results = process_all_tasks().await;
    println!("æ‰€æœ‰ä»»å‹™å®Œæˆ: {:?}", results);
}
```

</details>

### ç·´ç¿’ 3: ç”Ÿç”¢è€…æ¶ˆè²»è€…æ¨¡å¼

å¯¦ç¾ä¸€å€‹ç”Ÿç”¢è€…æ¶ˆè²»è€…æ¨¡å¼ï¼Œä½¿ç”¨é€šé“é€²è¡ŒåŸ·è¡Œç·’é–“é€šè¨Šï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn producer_consumer() {
    let (tx, rx) = mpsc::channel();
    
    // ç”Ÿç”¢è€…
    let producer = thread::spawn(move || {
        for i in 0..10 {
            tx.send(format!("ç”¢å“ {}", i)).unwrap();
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    // æ¶ˆè²»è€…
    let consumer = thread::spawn(move || {
        for received in rx {
            println!("æ¶ˆè²»: {}", received);
        }
    });
    
    producer.join().unwrap();
    consumer.join().unwrap();
}

fn main() {
    producer_consumer();
}
```

</details>

---

## ğŸ“ ç¸½çµ

åœ¨é€™ä¸€ç« ä¸­ï¼Œæˆ‘å€‘å­¸ç¿’äº† Rust çš„ä¸¦ç™¼å’Œç•°æ­¥ç¨‹å¼è¨­è¨ˆï¼š

1. **åŸ·è¡Œæ¨¡å‹**: Rust æ”¯æ´çœŸæ­£çš„å¤šåŸ·è¡Œç·’ä¸¦è¡Œï¼ŒJavaScript æ˜¯å–®åŸ·è¡Œç·’äº‹ä»¶å¾ªç’°
2. **åŸ·è¡Œç·’å®‰å…¨**: Rust é€éæ‰€æœ‰æ¬Šç³»çµ±åœ¨ç·¨è­¯æ™‚ä¿è­‰åŸ·è¡Œç·’å®‰å…¨
3. **ç•°æ­¥ç¨‹å¼è¨­è¨ˆ**: Rust çš„ async/await èªæ³•èˆ‡ JavaScript é¡ä¼¼
4. **ä¸¦ç™¼æ¨¡å¼**: ä½¿ç”¨ Arcã€Mutexã€RwLock ç­‰å‹åˆ¥å®‰å…¨åœ°å…±äº«ç‹€æ…‹
5. **æ•ˆèƒ½é¸æ“‡**: å¤šåŸ·è¡Œç·’é©åˆ CPU å¯†é›†å‹ï¼Œç•°æ­¥é©åˆ I/O å¯†é›†å‹

### é—œéµè¦é»

- Rust çš„æ‰€æœ‰æ¬Šç³»çµ±ç¢ºä¿åŸ·è¡Œç·’å®‰å…¨
- ç•°æ­¥ç¨‹å¼è¨­è¨ˆæä¾›é«˜æ€§èƒ½çš„ I/O è™•ç†
- é¸æ“‡åˆé©çš„ä¸¦ç™¼æ¨¡å‹å¾ˆé‡è¦
- ç·¨è­¯æ™‚æª¢æŸ¥é¿å…åŸ·è¡Œæ™‚éŒ¯èª¤

### ä¸‹ä¸€æ­¥å­¸ç¿’

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘å€‘å°‡å­¸ç¿’ Rust çš„å‹åˆ¥ç³»çµ±å’Œç‰¹å¾µï¼ˆTraitsï¼‰ï¼Œäº†è§£å¦‚ä½•å»ºæ§‹å¯è¤‡ç”¨çš„æŠ½è±¡ã€‚

---

**ç¹¼çºŒå­¸ç¿’**: [å‹åˆ¥ç³»çµ±èˆ‡ç‰¹å¾µ](./module-05-type-system-traits)