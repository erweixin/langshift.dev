---
title: "Web é–‹ç™¼å¯¦æˆ°"
description: "å­¸ç¿’ä½¿ç”¨ Rust é€²è¡Œ Web é–‹ç™¼ï¼ŒåŒ…æ‹¬ Axum æ¡†æ¶ã€è³‡æ–™åº«æ“ä½œå’Œ API è¨­è¨ˆï¼Œå°æ¯” JavaScript çš„ Web é–‹ç™¼"
---

# Web é–‹ç™¼å¯¦æˆ°

## ğŸ“– å­¸ç¿’ç›®æ¨™

å­¸æœƒä½¿ç”¨ Rust å»ºæ§‹ Web æ‡‰ç”¨ç¨‹å¼ï¼ŒæŒæ¡ Axum æ¡†æ¶ã€è³‡æ–™åº«æ“ä½œã€API è¨­è¨ˆå’Œéƒ¨ç½²ï¼Œå°æ¯” JavaScript çš„ Web é–‹ç™¼ç”Ÿæ…‹ã€‚

---

## ğŸ¯ Web æ¡†æ¶å°æ¯”

### JavaScript çš„ Web é–‹ç™¼

JavaScript ä½¿ç”¨ Express.js ç­‰æ¡†æ¶ï¼š

<UniversalEditor title="JavaScript Web é–‹ç™¼" compare={true}>
```javascript !! js
// Express.js Web æ‡‰ç”¨ç¨‹å¼
const express = require('express');
const app = express();
const port = 3000;

// ä¸­é–“ä»¶
app.use(express.json());
app.use(express.static('public'));

// è¨˜æ†¶é«”è³‡æ–™å„²å­˜
let users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' }
];

// è·¯ç”±å®šç¾©
app.get('/', (req, res) => {
    res.json({ message: 'Hello from Express!' });
});

// GET ç²å–æ‰€æœ‰ç”¨æˆ¶
app.get('/api/users', (req, res) => {
    res.json(users);
});

// GET ç²å–å–®å€‹ç”¨æˆ¶
app.get('/api/users/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const user = users.find(u => u.id === id);
    
    if (!user) {
        return res.status(404).json({ error: 'ç”¨æˆ¶æœªæ‰¾åˆ°' });
    }
    
    res.json(user);
});

// POST å»ºç«‹ç”¨æˆ¶
app.post('/api/users', (req, res) => {
    const { name, email } = req.body;
    
    if (!name || !email) {
        return res.status(400).json({ error: 'å§“åå’Œé›»å­éƒµä»¶æ˜¯å¿…éœ€çš„' });
    }
    
    const newUser = {
        id: users.length + 1,
        name,
        email
    };
    
    users.push(newUser);
    res.status(201).json(newUser);
});

// PUT æ›´æ–°ç”¨æˆ¶
app.put('/api/users/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const { name, email } = req.body;
    
    const userIndex = users.findIndex(u => u.id === id);
    if (userIndex === -1) {
        return res.status(404).json({ error: 'ç”¨æˆ¶æœªæ‰¾åˆ°' });
    }
    
    users[userIndex] = { ...users[userIndex], name, email };
    res.json(users[userIndex]);
});

// DELETE åˆªé™¤ç”¨æˆ¶
app.delete('/api/users/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const userIndex = users.findIndex(u => u.id === id);
    
    if (userIndex === -1) {
        return res.status(404).json({ error: 'ç”¨æˆ¶æœªæ‰¾åˆ°' });
    }
    
    users.splice(userIndex, 1);
    res.status(204).send();
});

// éŒ¯èª¤è™•ç†ä¸­é–“ä»¶
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'ä¼ºæœå™¨å…§éƒ¨éŒ¯èª¤' });
});

// 404 è™•ç†
app.use((req, res) => {
    res.status(404).json({ error: 'è·¯ç”±æœªæ‰¾åˆ°' });
});

app.listen(port, () => {
    console.log(`ä¼ºæœå™¨é‹è¡Œåœ¨ http://localhost:${port}`);
});

// ç•°æ­¥è·¯ç”±ç¯„ä¾‹
app.get('/api/async-data', async (req, res) => {
    try {
        // æ¨¡æ“¬ç•°æ­¥æ“ä½œ
        const data = await new Promise(resolve => {
            setTimeout(() => {
                resolve({ message: 'ç•°æ­¥è³‡æ–™', timestamp: Date.now() });
            }, 1000);
        });
        
        res.json(data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ä¸­é–“ä»¶ç¯„ä¾‹
const authMiddleware = (req, res, next) => {
    const token = req.headers.authorization;
    
    if (!token) {
        return res.status(401).json({ error: 'ç¼ºå°‘èªè­‰ä»¤ç‰Œ' });
    }
    
    // ä»¤ç‰Œé©—è­‰é‚è¼¯
    req.user = { id: 1, name: 'Authenticated User' };
    next();
};

app.get('/api/protected', authMiddleware, (req, res) => {
    res.json({ message: 'å—ä¿è­·çš„è·¯ç”±', user: req.user });
});
```
</UniversalEditor>

### Rust çš„ Web é–‹ç™¼

Rust ä½¿ç”¨ Axum æ¡†æ¶ï¼š

<UniversalEditor title="Rust Web é–‹ç™¼" compare={true}>
```rust !! rs
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::RwLock;

// è³‡æ–™æ¨¡å‹
#[derive(Debug, Serialize, Deserialize, Clone)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹
#[derive(Clone)]
struct AppState {
    users: Arc<RwLock<HashMap<u32, User>>>,
}

impl AppState {
    fn new() -> Self {
        let mut users = HashMap::new();
        users.insert(1, User {
            id: 1,
            name: String::from("Alice"),
            email: String::from("alice@example.com"),
        });
        users.insert(2, User {
            id: 2,
            name: String::from("Bob"),
            email: String::from("bob@example.com"),
        });
        
        AppState {
            users: Arc::new(RwLock::new(users)),
        }
    }
}

// è«‹æ±‚å’ŒéŸ¿æ‡‰å‹åˆ¥
#[derive(Debug, Deserialize)]
struct CreateUserRequest {
    name: String,
    email: String,
}

#[derive(Debug, Deserialize)]
struct UpdateUserRequest {
    name: Option<String>,
    email: Option<String>,
}

// è·¯ç”±è™•ç†å‡½æ•¸
async fn root() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "message": "Hello from Axum!"
    }))
}

async fn get_users(State(state): State<AppState>) -> Json<Vec<User>> {
    let users = state.users.read().await;
    let user_list: Vec<User> = users.values().cloned().collect();
    Json(user_list)
}

async fn get_user(
    State(state): State<AppState>,
    Path(id): Path<u32>,
) -> Result<Json<User>, StatusCode> {
    let users = state.users.read().await;
    
    if let Some(user) = users.get(&id) {
        Ok(Json(user.clone()))
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, StatusCode> {
    if payload.name.is_empty() || payload.email.is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let mut users = state.users.write().await;
    let new_id = users.keys().max().unwrap_or(&0) + 1;
    
    let new_user = User {
        id: new_id,
        name: payload.name,
        email: payload.email,
    };
    
    users.insert(new_id, new_user.clone());
    Ok(Json(new_user))
}

async fn update_user(
    State(state): State<AppState>,
    Path(id): Path<u32>,
    Json(payload): Json<UpdateUserRequest>,
) -> Result<Json<User>, StatusCode> {
    let mut users = state.users.write().await;
    
    if let Some(user) = users.get_mut(&id) {
        if let Some(name) = payload.name {
            user.name = name;
        }
        if let Some(email) = payload.email {
            user.email = email;
        }
        Ok(Json(user.clone()))
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

async fn delete_user(
    State(state): State<AppState>,
    Path(id): Path<u32>,
) -> StatusCode {
    let mut users = state.users.write().await;
    
    if users.remove(&id).is_some() {
        StatusCode::NO_CONTENT
    } else {
        StatusCode::NOT_FOUND)
    }
}

// ç•°æ­¥è³‡æ–™è·¯ç”±
async fn async_data() -> Json<serde_json::Value> {
    // æ¨¡æ“¬ç•°æ­¥æ“ä½œ
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    
    Json(serde_json::json!({
        "message": "ç•°æ­¥è³‡æ–™",
        "timestamp": chrono::Utc::now().timestamp()
    }))
}

// èªè­‰ä¸­é–“ä»¶
async fn auth_middleware(
    headers: axum::http::HeaderMap,
) -> Result<(), StatusCode> {
    if let Some(auth_header) = headers.get("authorization") {
        if auth_header.to_str().unwrap_or("").starts_with("Bearer ") {
            return Ok(());
        }
    }
    Err(StatusCode::UNAUTHORIZED)
}

async fn protected_route() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "message": "å—ä¿è­·çš„è·¯ç”±",
        "user": {
            "id": 1,
            "name": "Authenticated User"
        }
    }))
}

// å»ºç«‹è·¯ç”±
fn create_router() -> Router {
    let state = AppState::new();
    
    Router::new()
        .route("/", get(root))
        .route("/api/users", get(get_users))
        .route("/api/users", post(create_user))
        .route("/api/users/:id", get(get_user))
        .route("/api/users/:id", put(update_user))
        .route("/api/users/:id", delete(delete_user))
        .route("/api/async-data", get(async_data))
        .route("/api/protected", get(protected_route))
        .with_state(state)
}

#[tokio::main]
async fn main() {
    let app = create_router();
    
    println!("ä¼ºæœå™¨é‹è¡Œåœ¨ http://localhost:3000");
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();
    
    axum::serve(listener, app).await.unwrap();
}
```
</UniversalEditor>

### Web æ¡†æ¶å·®ç•°

1. **æ•ˆèƒ½**: Rust ç·¨è­¯åˆ°æ©Ÿå™¨ç¢¼ï¼Œæ•ˆèƒ½æ›´é«˜
2. **å‹åˆ¥å®‰å…¨**: Rust ç·¨è­¯æ™‚æª¢æŸ¥ï¼ŒJavaScript åŸ·è¡Œæ™‚æª¢æŸ¥
3. **è¨˜æ†¶é«”å®‰å…¨**: Rust ç„¡è³‡æ–™ç«¶çˆ­ï¼ŒJavaScript å–®åŸ·è¡Œç·’äº‹ä»¶å¾ªç’°
4. **ç”Ÿæ…‹ç³»çµ±**: JavaScript ç”Ÿæ…‹æ›´æˆç†Ÿï¼ŒRust ç”Ÿæ…‹æ­£åœ¨å¿«é€Ÿç™¼å±•

---

## ğŸ—„ï¸ è³‡æ–™åº«æ“ä½œ

### ä½¿ç”¨ SQLx é€²è¡Œè³‡æ–™åº«æ“ä½œ

<UniversalEditor title="è³‡æ–™åº«æ“ä½œ" compare={true}>
```rust !! rs
use sqlx::{postgres::PgPoolOptions, PgPool, Row};
use serde::{Deserialize, Serialize};

// è³‡æ–™æ¨¡å‹
#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: Option<i32>,
    name: String,
    email: String,
    created_at: Option<chrono::DateTime<chrono::Utc>>,
}

// è³‡æ–™åº«æ“ä½œ
struct UserRepository {
    pool: PgPool,
}

impl UserRepository {
    fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    async fn create_user(&self, user: &User) -> Result<User, sqlx::Error> {
        let row = sqlx::query_as!(
            User,
            r#"
            INSERT INTO users (name, email)
            VALUES ($1, $2)
            RETURNING id, name, email, created_at
            "#,
            user.name,
            user.email
        )
        .fetch_one(&self.pool)
        .await?;
        
        Ok(row)
    }
    
    async fn get_user(&self, id: i32) -> Result<Option<User>, sqlx::Error> {
        let user = sqlx::query_as!(
            User,
            r#"
            SELECT id, name, email, created_at
            FROM users
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(user)
    }
    
    async fn get_all_users(&self) -> Result<Vec<User>, sqlx::Error> {
        let users = sqlx::query_as!(
            User,
            r#"
            SELECT id, name, email, created_at
            FROM users
            ORDER BY created_at DESC
            "#
        )
        .fetch_all(&self.pool)
        .await?;
        
        Ok(users)
    }
    
    async fn update_user(&self, id: i32, user: &User) -> Result<Option<User>, sqlx::Error> {
        let updated_user = sqlx::query_as!(
            User,
            r#"
            UPDATE users
            SET name = $1, email = $2
            WHERE id = $3
            RETURNING id, name, email, created_at
            "#,
            user.name,
            user.email,
            id
        )
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(updated_user)
    }
    
    async fn delete_user(&self, id: i32) -> Result<bool, sqlx::Error> {
        let result = sqlx::query!(
            r#"
            DELETE FROM users
            WHERE id = $1
            "#,
            id
        )
        .execute(&self.pool)
        .await?;
        
        Ok(result.rows_affected() > 0)
    }
}

// æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹
#[derive(Clone)]
struct AppState {
    user_repo: UserRepository,
}

// è·¯ç”±è™•ç†å‡½æ•¸
async fn create_user_handler(
    State(state): State<AppState>,
    Json(user): Json<User>,
) -> Result<Json<User>, StatusCode> {
    let created_user = state.user_repo
        .create_user(&user)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(created_user))
}

async fn get_user_handler(
    State(state): State<AppState>,
    Path(id): Path<i32>,
) -> Result<Json<User>, StatusCode> {
    let user = state.user_repo
        .get_user(id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;
    
    Ok(Json(user))
}

async fn get_users_handler(
    State(state): State<AppState>,
) -> Result<Json<Vec<User>>, StatusCode> {
    let users = state.user_repo
        .get_all_users()
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(users))
}

async fn update_user_handler(
    State(state): State<AppState>,
    Path(id): Path<i32>,
    Json(user): Json<User>,
) -> Result<Json<User>, StatusCode> {
    let updated_user = state.user_repo
        .update_user(id, &user)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;
    
    Ok(Json(updated_user))
}

async fn delete_user_handler(
    State(state): State<AppState>,
    Path(id): Path<i32>,
) -> StatusCode {
    let deleted = state.user_repo
        .delete_user(id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    if deleted {
        StatusCode::NO_CONTENT
    } else {
        StatusCode::NOT_FOUND
    }
}

// è³‡æ–™åº«åˆå§‹åŒ–
async fn init_database(pool: &PgPool) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        )
        "#
    )
    .execute(pool)
    .await?;
    
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // è³‡æ–™åº«é€£æ¥
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://user:password@localhost/rust_web".to_string());
    
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;
    
    // åˆå§‹åŒ–è³‡æ–™åº«
    init_database(&pool).await?;
    
    // å»ºç«‹æ‡‰ç”¨ç¨‹å¼ç‹€æ…‹
    let user_repo = UserRepository::new(pool);
    let state = AppState { user_repo };
    
    // å»ºç«‹è·¯ç”±
    let app = Router::new()
        .route("/api/users", post(create_user_handler))
        .route("/api/users", get(get_users_handler))
        .route("/api/users/:id", get(get_user_handler))
        .route("/api/users/:id", put(update_user_handler))
        .route("/api/users/:id", delete(delete_user_handler))
        .with_state(state);
    
    println!("ä¼ºæœå™¨é‹è¡Œåœ¨ http://localhost:3000");
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();
    
    axum::serve(listener, app).await.unwrap();
    
    Ok(())
}
```
</UniversalEditor>

### ç”Ÿç”¢ç’°å¢ƒéŒ¯èª¤è™•ç†æç¤º

åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ï¼Œè³‡æ–™åº«é€£æ¥å’Œåˆå§‹åŒ–ç­‰æ“ä½œæ‡‰è©²é€²è¡Œæ›´å¥å£¯çš„éŒ¯èª¤è™•ç†ï¼Œä¾‹å¦‚ä½¿ç”¨ `Result` å’Œ `Box<dyn std::error.Error>` ä¾†æ•ç²å’Œå‚³æ’­æ‰€æœ‰å¯èƒ½çš„éŒ¯èª¤ï¼Œè€Œä¸æ˜¯ç°¡å–®åœ°ä½¿ç”¨ `unwrap()` æˆ– `expect()`ã€‚é€™æ¨£å¯ä»¥ç¢ºä¿æ‡‰ç”¨ç¨‹å¼åœ¨é‡åˆ°è³‡æ–™åº«å•é¡Œæ™‚èƒ½å¤ å„ªé›…åœ°å¤±æ•—æˆ–æä¾›æœ‰æ„ç¾©çš„éŒ¯èª¤è¨Šæ¯ã€‚

---

## ğŸ” èªè­‰èˆ‡æˆæ¬Š