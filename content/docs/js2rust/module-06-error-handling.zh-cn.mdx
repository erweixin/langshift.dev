---
title: "é”™è¯¯å¤„ç†ä¸ç±»å‹å®‰å…¨"
description: "å­¦ä¹  Rust çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼ŒåŒ…æ‹¬ Resultã€Option ç±»å‹å’Œé”™è¯¯ä¼ æ’­ï¼Œå¯¹æ¯” JavaScript çš„å¼‚å¸¸å¤„ç†"
---

# é”™è¯¯å¤„ç†ä¸ç±»å‹å®‰å…¨

## ğŸ“– å­¦ä¹ ç›®æ ‡

ç†è§£ Rust çš„é”™è¯¯å¤„ç†å“²å­¦ï¼Œå­¦ä¼šä½¿ç”¨ `Result` å’Œ `Option` ç±»å‹ï¼ŒæŒæ¡é”™è¯¯ä¼ æ’­æ¨¡å¼ï¼Œå¯¹æ¯” JavaScript çš„å¼‚å¸¸å¤„ç†æœºåˆ¶ã€‚

---

## ğŸ¯ é”™è¯¯å¤„ç†å“²å­¦å¯¹æ¯”

### JavaScript çš„å¼‚å¸¸å¤„ç†

JavaScript ä½¿ç”¨ try-catch æœºåˆ¶å¤„ç†å¼‚å¸¸ï¼š

<UniversalEditor title="JavaScript å¼‚å¸¸å¤„ç†" compare={true}>
```javascript !! js
// JavaScript å¼‚å¸¸å¤„ç†
function divide(a, b) {
    if (b === 0) {
        throw new Error("é™¤æ•°ä¸èƒ½ä¸ºé›¶");
    }
    return a / b;
}

function processData(data) {
    if (!data) {
        throw new Error("æ•°æ®ä¸èƒ½ä¸ºç©º");
    }
    return data.toUpperCase();
}

// ä½¿ç”¨ try-catch å¤„ç†å¼‚å¸¸
try {
    const result1 = divide(10, 2);
    console.log("é™¤æ³•ç»“æœ:", result1);
    
    const result2 = divide(10, 0); // æŠ›å‡ºå¼‚å¸¸
    console.log("è¿™ä¸ªä¸ä¼šæ‰§è¡Œ");
} catch (error) {
    console.log("æ•è·åˆ°å¼‚å¸¸:", error.message);
}

// å¼‚æ­¥å¼‚å¸¸å¤„ç†
async function fetchData(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP é”™è¯¯: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.log("ç½‘ç»œè¯·æ±‚å¤±è´¥:", error.message);
        return null;
    }
}

// Promise å¼‚å¸¸å¤„ç†
function asyncOperation() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const random = Math.random();
            if (random > 0.5) {
                resolve("æ“ä½œæˆåŠŸ");
            } else {
                reject(new Error("æ“ä½œå¤±è´¥"));
            }
        }, 1000);
    });
}

asyncOperation()
    .then(result => console.log("æˆåŠŸ:", result))
    .catch(error => console.log("å¤±è´¥:", error.message));

// å¯é€‰é“¾å’Œç©ºå€¼åˆå¹¶
function getUserName(user) {
    // ä¼ ç»Ÿæ–¹å¼
    if (user && user.profile && user.profile.name) {
        return user.profile.name;
    }
    return "æœªçŸ¥ç”¨æˆ·";
    
    // ç°ä»£æ–¹å¼
    // return user?.profile?.name ?? "æœªçŸ¥ç”¨æˆ·";
}

// å‡½æ•°å¯èƒ½è¿”å› null æˆ– undefined
function findUser(id) {
    const users = [
        { id: 1, name: "Alice" },
        { id: 2, name: "Bob" }
    ];
    
    const user = users.find(u => u.id === id);
    return user || null; // å¯èƒ½è¿”å› null
}

const user = findUser(3);
if (user) {
    console.log("æ‰¾åˆ°ç”¨æˆ·:", user.name);
} else {
    console.log("ç”¨æˆ·ä¸å­˜åœ¨");
}
```
</UniversalEditor>

### Rust çš„é”™è¯¯å¤„ç†

Rust ä½¿ç”¨ç±»å‹ç³»ç»Ÿå¤„ç†é”™è¯¯ï¼Œæ²¡æœ‰å¼‚å¸¸æœºåˆ¶ï¼š

<UniversalEditor title="Rust é”™è¯¯å¤„ç†" compare={true}>
```rust !! rs
// Rust é”™è¯¯å¤„ç† - ä½¿ç”¨ Result ç±»å‹
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err("é™¤æ•°ä¸èƒ½ä¸ºé›¶".to_string())
    } else {
        Ok(a / b)
    }
}

fn process_data(data: &str) -> Result<String, String> {
    if data.is_empty() {
        return Err("æ•°æ®ä¸èƒ½ä¸ºç©º".to_string());
    }
    Ok(data.to_uppercase())
}

// ä½¿ç”¨ match å¤„ç† Result
fn handle_division() {
    match divide(10.0, 2.0) {
        Ok(result) => println!("é™¤æ³•ç»“æœ: {}", result),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
    
    match divide(10.0, 0.0) {
        Ok(result) => println!("ç»“æœ: {}", result),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
}

// ä½¿ç”¨ if let ç®€åŒ–å¤„ç†
fn handle_division_simple() {
    if let Ok(result) = divide(10.0, 2.0) {
        println!("é™¤æ³•ç»“æœ: {}", result);
    }
    
    if let Err(error) = divide(10.0, 0.0) {
        println!("é”™è¯¯: {}", error);
    }
}

// ä½¿ç”¨ unwrap å’Œ expectï¼ˆä¸æ¨èåœ¨ç”Ÿäº§ä»£ç ä¸­ä½¿ç”¨ï¼‰
fn handle_division_unwrap() {
    let result = divide(10.0, 2.0).unwrap(); // æˆåŠŸæ—¶è¿”å›å€¼ï¼Œå¤±è´¥æ—¶ panic
    println!("ç»“æœ: {}", result);
    
    let result = divide(10.0, 0.0).expect("é™¤æ³•å¤±è´¥"); // å¤±è´¥æ—¶ panic å¹¶æ˜¾ç¤ºæ¶ˆæ¯
    println!("ç»“æœ: {}", result);
}

// ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
fn process_operations() -> Result<(), String> {
    let result1 = divide(10.0, 2.0)?; // å¦‚æœå¤±è´¥ï¼Œç«‹å³è¿”å›é”™è¯¯
    println!("ç¬¬ä¸€ä¸ªç»“æœ: {}", result1);
    
    let result2 = process_data("hello")?;
    println!("ç¬¬äºŒä¸ªç»“æœ: {}", result2);
    
    Ok(()) // æˆåŠŸæ—¶è¿”å› ()
}

fn main() {
    handle_division();
    handle_division_simple();
    
    // å¤„ç†å¯èƒ½ panic çš„ä»£ç 
    match std::panic::catch_unwind(|| {
        handle_division_unwrap();
    }) {
        Ok(_) => println!("æ“ä½œæˆåŠŸ"),
        Err(_) => println!("æ“ä½œå¤±è´¥ï¼Œå‘ç”Ÿ panic"),
    }
    
    // å¤„ç†è¿”å› Result çš„å‡½æ•°
    if let Err(error) = process_operations() {
        println!("å¤„ç†æ“ä½œæ—¶å‡ºé”™: {}", error);
    }
}
```
</UniversalEditor>

### é”™è¯¯å¤„ç†å·®å¼‚

1. **å¼‚å¸¸ vs ç±»å‹**: JavaScript ä½¿ç”¨å¼‚å¸¸ï¼ŒRust ä½¿ç”¨ç±»å‹ç³»ç»Ÿ
2. **è¿è¡Œæ—¶ vs ç¼–è¯‘æ—¶**: JavaScript è¿è¡Œæ—¶æ£€æŸ¥ï¼ŒRust ç¼–è¯‘æ—¶æ£€æŸ¥
3. **å¯æ¢å¤ vs ä¸å¯æ¢å¤**: Rust åŒºåˆ†å¯æ¢å¤é”™è¯¯ï¼ˆResultï¼‰å’Œä¸å¯æ¢å¤é”™è¯¯ï¼ˆpanicï¼‰
4. **æ˜¾å¼ vs éšå¼**: Rust å¼ºåˆ¶æ˜¾å¼å¤„ç†é”™è¯¯ï¼ŒJavaScript å¯ä»¥å¿½ç•¥å¼‚å¸¸

---

## ğŸ“¦ Option ç±»å‹

### å¤„ç†å¯èƒ½ä¸ºç©ºçš„å€¼

<UniversalEditor title="Option ç±»å‹" compare={true}>
```rust !! rs
// Option ç±»å‹ - å¤„ç†å¯èƒ½ä¸ºç©ºçš„å€¼
fn find_user(id: u32) -> Option<User> {
    let users = vec![
        User { id: 1, name: String::from("Alice") },
        User { id: 2, name: String::from("Bob") },
    ];
    
    users.into_iter().find(|user| user.id == id)
}

fn get_user_name(user: &User) -> &str {
    &user.name
}

// ä½¿ç”¨ match å¤„ç† Option
fn handle_user_match(id: u32) {
    match find_user(id) {
        Some(user) => println!("æ‰¾åˆ°ç”¨æˆ·: {}", get_user_name(&user)),
        None => println!("ç”¨æˆ·ä¸å­˜åœ¨"),
    }
}

// ä½¿ç”¨ if let ç®€åŒ–å¤„ç†
fn handle_user_if_let(id: u32) {
    if let Some(user) = find_user(id) {
        println!("æ‰¾åˆ°ç”¨æˆ·: {}", get_user_name(&user));
    } else {
        println!("ç”¨æˆ·ä¸å­˜åœ¨");
    }
}

// ä½¿ç”¨ map å’Œ and_then è¿›è¡Œé“¾å¼æ“ä½œ
fn handle_user_chain(id: u32) {
    let user_name = find_user(id)
        .map(|user| get_user_name(&user).to_string())
        .unwrap_or_else(|| "æœªçŸ¥ç”¨æˆ·".to_string());
    
    println!("ç”¨æˆ·å: {}", user_name);
}

// ä½¿ç”¨ unwrap å’Œ expectï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
fn handle_user_unwrap(id: u32) {
    let user = find_user(id).unwrap(); // å¦‚æœä¸º None åˆ™ panic
    println!("ç”¨æˆ·: {}", get_user_name(&user));
    
    let user = find_user(id).expect("ç”¨æˆ·åº”è¯¥å­˜åœ¨"); // è‡ªå®šä¹‰ panic æ¶ˆæ¯
    println!("ç”¨æˆ·: {}", get_user_name(&user));
}

// Option çš„å®ç”¨æ–¹æ³•
fn option_methods() {
    let value: Option<i32> = Some(42);
    let none_value: Option<i32> = None;
    
    // unwrap_or - æä¾›é»˜è®¤å€¼
    println!("å€¼: {}", value.unwrap_or(0)); // 42
    println!("å€¼: {}", none_value.unwrap_or(0)); // 0
    
    // unwrap_or_else - ä½¿ç”¨é—­åŒ…æä¾›é»˜è®¤å€¼
    println!("å€¼: {}", none_value.unwrap_or_else(|| {
        println!("è®¡ç®—é»˜è®¤å€¼");
        100
    }));
    
    // map - è½¬æ¢å€¼
    let doubled = value.map(|x| x * 2);
    println!("åŠ å€: {:?}", doubled); // Some(84)
    
    // and_then - é“¾å¼æ“ä½œ
    let result = value.and_then(|x| {
        if x > 40 {
            Some(x.to_string())
        } else {
            None
        }
    });
    println!("ç»“æœ: {:?}", result); // Some("42")
    
    // filter - è¿‡æ»¤å€¼
    let filtered = value.filter(|&x| x > 50);
    println!("è¿‡æ»¤å: {:?}", filtered); // None
}

struct User {
    id: u32,
    name: String,
}

fn main() {
    handle_user_match(1);
    handle_user_match(3);
    
    handle_user_if_let(1);
    handle_user_if_let(3);
    
    handle_user_chain(1);
    handle_user_chain(3);
    
    option_methods();
}
```
</UniversalEditor>

---

## ğŸ”„ Result ç±»å‹

### å¤„ç†å¯èƒ½å¤±è´¥çš„æ“ä½œ

<UniversalEditor title="Result ç±»å‹" compare={true}>
```rust !! rs
// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
enum AppError {
    DivisionByZero,
    InvalidInput(String),
    NetworkError(String),
    DatabaseError(String),
}

impl std::fmt::Display for AppError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            AppError::DivisionByZero => write!(f, "é™¤æ•°ä¸èƒ½ä¸ºé›¶"),
            AppError::InvalidInput(msg) => write!(f, "æ— æ•ˆè¾“å…¥: {}", msg),
            AppError::NetworkError(msg) => write!(f, "ç½‘ç»œé”™è¯¯: {}", msg),
            AppError::DatabaseError(msg) => write!(f, "æ•°æ®åº“é”™è¯¯: {}", msg),
        }
    }
}

// å®ç° std::error::Error trait
impl std::error::Error for AppError {}

// ä½¿ç”¨è‡ªå®šä¹‰é”™è¯¯ç±»å‹
fn divide_with_custom_error(a: f64, b: f64) -> Result<f64, AppError> {
    if b == 0.0 {
        Err(AppError::DivisionByZero)
    } else {
        Ok(a / b)
    }
}

fn validate_input(input: &str) -> Result<String, AppError> {
    if input.is_empty() {
        return Err(AppError::InvalidInput("è¾“å…¥ä¸èƒ½ä¸ºç©º".to_string()));
    }
    
    if input.len() < 3 {
        return Err(AppError::InvalidInput("è¾“å…¥é•¿åº¦è‡³å°‘ä¸º3".to_string()));
    }
    
    Ok(input.to_string())
}

// æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
fn fetch_data(url: &str) -> Result<String, AppError> {
    if url.is_empty() {
        return Err(AppError::NetworkError("URL ä¸èƒ½ä¸ºç©º".to_string()));
    }
    
    if url.contains("error") {
        return Err(AppError::NetworkError("æ¨¡æ‹Ÿç½‘ç»œé”™è¯¯".to_string()));
    }
    
    Ok(format!("ä» {} è·å–çš„æ•°æ®", url))
}

// é”™è¯¯ä¼ æ’­
fn process_data_chain(input: &str, url: &str) -> Result<String, AppError> {
    // ä½¿ç”¨ ? æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
    let validated_input = validate_input(input)?;
    let data = fetch_data(url)?;
    
    Ok(format!("å¤„ç†åçš„æ•°æ®: {} + {}", validated_input, data))
}

// ä½¿ç”¨ map å’Œ map_err è½¬æ¢é”™è¯¯
fn process_with_map(input: &str) -> Result<String, AppError> {
    validate_input(input)
        .map(|s| s.to_uppercase())
        .map_err(|e| AppError::InvalidInput(format!("éªŒè¯å¤±è´¥: {}", e)))
}

// ä½¿ç”¨ and_then è¿›è¡Œé“¾å¼æ“ä½œ
fn process_with_and_then(input: &str) -> Result<String, AppError> {
    validate_input(input)
        .and_then(|s| {
            if s.len() > 10 {
                Ok(s)
            } else {
                Err(AppError::InvalidInput("è¾“å…¥å¤ªçŸ­".to_string()))
            }
        })
        .map(|s| format!("å¤„ç†ç»“æœ: {}", s))
}

// ç»„åˆå¤šä¸ª Result
fn combine_results() -> Result<(), AppError> {
    let result1 = divide_with_custom_error(10.0, 2.0)?;
    let result2 = validate_input("hello")?;
    let result3 = fetch_data("https://example.com")?;
    
    println!("æ‰€æœ‰æ“ä½œæˆåŠŸ: {}, {}, {}", result1, result2, result3);
    Ok(())
}

fn main() {
    // å¤„ç†è‡ªå®šä¹‰é”™è¯¯
    match divide_with_custom_error(10.0, 0.0) {
        Ok(result) => println!("ç»“æœ: {}", result),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
    
    // ä½¿ç”¨ ? æ“ä½œç¬¦
    if let Err(error) = process_data_chain("hello", "https://example.com") {
        println!("å¤„ç†å¤±è´¥: {}", error);
    }
    
    // ä½¿ç”¨ map å’Œ and_then
    match process_with_map("hi") {
        Ok(result) => println!("æˆåŠŸ: {}", result),
        Err(error) => println!("å¤±è´¥: {}", error),
    }
    
    match process_with_and_then("very long input string") {
        Ok(result) => println!("æˆåŠŸ: {}", result),
        Err(error) => println!("å¤±è´¥: {}", error),
    }
    
    // ç»„åˆå¤šä¸ªæ“ä½œ
    if let Err(error) = combine_results() {
        println!("ç»„åˆæ“ä½œå¤±è´¥: {}", error);
    }
}
```
</UniversalEditor>

---

## ğŸ¯ é”™è¯¯å¤„ç†æœ€ä½³å®è·µ

### é”™è¯¯å¤„ç†æ¨¡å¼å¯¹æ¯”

<UniversalEditor title="é”™è¯¯å¤„ç†æ¨¡å¼" compare={true}>
```javascript !! js
// JavaScript é”™è¯¯å¤„ç†æ¨¡å¼
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
    }
}

class NetworkError extends Error {
    constructor(message) {
        super(message);
        this.name = 'NetworkError';
    }
}

// å‡½æ•°å¯èƒ½æŠ›å‡ºå¼‚å¸¸
function processUserData(userData) {
    if (!userData.name) {
        throw new ValidationError('ç”¨æˆ·åä¸èƒ½ä¸ºç©º');
    }
    
    if (userData.age < 0) {
        throw new ValidationError('å¹´é¾„ä¸èƒ½ä¸ºè´Ÿæ•°');
    }
    
    return {
        ...userData,
        processed: true
    };
}

// å¼‚æ­¥å‡½æ•°é”™è¯¯å¤„ç†
async function fetchUserData(userId) {
    try {
        const response = await fetch(`/api/users/${userId}`);
        if (!response.ok) {
            throw new NetworkError(`HTTP ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        if (error instanceof NetworkError) {
            console.log('ç½‘ç»œé”™è¯¯:', error.message);
        } else {
            console.log('æœªçŸ¥é”™è¯¯:', error.message);
        }
        throw error; // é‡æ–°æŠ›å‡º
    }
}

// ä½¿ç”¨ try-catch å¤„ç†
async function handleUser(userId, userData) {
    try {
        const processedData = processUserData(userData);
        const fetchedData = await fetchUserData(userId);
        
        return {
            ...processedData,
            ...fetchedData
        };
    } catch (error) {
        if (error instanceof ValidationError) {
            console.log('éªŒè¯é”™è¯¯:', error.message);
            return null;
        } else if (error instanceof NetworkError) {
            console.log('ç½‘ç»œé”™è¯¯:', error.message);
            return null;
        } else {
            console.log('æœªçŸ¥é”™è¯¯:', error.message);
            throw error;
        }
    }
}

// ä½¿ç”¨ Promise é“¾
function processWithPromise(userData) {
    return Promise.resolve(userData)
        .then(data => {
            if (!data.name) {
                throw new ValidationError('ç”¨æˆ·åä¸èƒ½ä¸ºç©º');
            }
            return data;
        })
        .then(data => {
            return {
                ...data,
                processed: true
            };
        })
        .catch(error => {
            if (error instanceof ValidationError) {
                console.log('éªŒè¯å¤±è´¥:', error.message);
                return null;
            }
            throw error;
        });
}
```

```rust !! rs
// Rust é”™è¯¯å¤„ç†æ¨¡å¼
use std::error::Error;
use std::fmt;

// è‡ªå®šä¹‰é”™è¯¯ç±»å‹
#[derive(Debug)]
enum AppError {
    ValidationError(String),
    NetworkError(String),
    DatabaseError(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            AppError::ValidationError(msg) => write!(f, "éªŒè¯é”™è¯¯: {}", msg),
            AppError::NetworkError(msg) => write!(f, "ç½‘ç»œé”™è¯¯: {}", msg),
            AppError::DatabaseError(msg) => write!(f, "æ•°æ®åº“é”™è¯¯: {}", msg),
        }
    }
}

impl Error for AppError {}

// å‡½æ•°è¿”å› Result
fn process_user_data(user_data: UserData) -> Result<UserData, AppError> {
    if user_data.name.is_empty() {
        return Err(AppError::ValidationError("ç”¨æˆ·åä¸èƒ½ä¸ºç©º".to_string()));
    }
    
    if user_data.age < 0 {
        return Err(AppError::ValidationError("å¹´é¾„ä¸èƒ½ä¸ºè´Ÿæ•°".to_string()));
    }
    
    Ok(UserData {
        processed: true,
        ..user_data
    })
}

// å¼‚æ­¥å‡½æ•°é”™è¯¯å¤„ç†
async fn fetch_user_data(user_id: u32) -> Result<UserData, AppError> {
    // æ¨¡æ‹Ÿç½‘ç»œè¯·æ±‚
    if user_id == 0 {
        return Err(AppError::NetworkError("æ— æ•ˆçš„ç”¨æˆ·ID".to_string()));
    }
    
    // æ¨¡æ‹ŸæˆåŠŸå“åº”
    Ok(UserData {
        id: user_id,
        name: format!("ç”¨æˆ·{}", user_id),
        age: 25,
        processed: false,
    })
}

// ä½¿ç”¨ ? æ“ä½œç¬¦å¤„ç†é”™è¯¯
async fn handle_user(user_id: u32, user_data: UserData) -> Result<UserData, AppError> {
    let processed_data = process_user_data(user_data)?;
    let fetched_data = fetch_user_data(user_id).await?;
    
    Ok(UserData {
        id: fetched_data.id,
        name: processed_data.name,
        age: processed_data.age,
        processed: true,
    })
}

// ä½¿ç”¨ map å’Œ map_err è½¬æ¢é”™è¯¯
fn process_with_transformation(user_data: UserData) -> Result<UserData, AppError> {
    process_user_data(user_data)
        .map(|data| UserData {
            name: data.name.to_uppercase(),
            ..data
        })
        .map_err(|e| match e {
            AppError::ValidationError(msg) => AppError::ValidationError(format!("å¤„ç†å¤±è´¥: {}", msg)),
            _ => e,
        })
}

// ä½¿ç”¨ and_then è¿›è¡Œé“¾å¼æ“ä½œ
fn process_with_chain(user_data: UserData) -> Result<UserData, AppError> {
    process_user_data(user_data)
        .and_then(|data| {
            if data.name.len() > 10 {
                Ok(data)
            } else {
                Err(AppError::ValidationError("ç”¨æˆ·åå¤ªçŸ­".to_string()))
            }
        })
        .map(|data| UserData {
            name: format!("å¤„ç†åçš„_{}", data.name),
            ..data
        })
}

#[derive(Debug, Clone)]
struct UserData {
    id: u32,
    name: String,
    age: i32,
    processed: bool,
}

#[tokio::main]
async fn main() {
    let user_data = UserData {
        id: 0,
        name: "Alice".to_string(),
        age: 25,
        processed: false,
    };
    
    // å¤„ç†é”™è¯¯
    match handle_user(1, user_data.clone()).await {
        Ok(result) => println!("æˆåŠŸ: {:?}", result),
        Err(error) => println!("å¤±è´¥: {}", error),
    }
    
    // ä½¿ç”¨è½¬æ¢
    match process_with_transformation(user_data.clone()) {
        Ok(result) => println!("è½¬æ¢æˆåŠŸ: {:?}", result),
        Err(error) => println!("è½¬æ¢å¤±è´¥: {}", error),
    }
    
    // ä½¿ç”¨é“¾å¼æ“ä½œ
    match process_with_chain(user_data) {
        Ok(result) => println!("é“¾å¼å¤„ç†æˆåŠŸ: {:?}", result),
        Err(error) => println!("é“¾å¼å¤„ç†å¤±è´¥: {}", error),
    }
}
```
</UniversalEditor>

---

## ğŸ¯ ç»ƒä¹ é¢˜

### ç»ƒä¹  1: å®ç° Option æ–¹æ³•

å®ç°ä¸€ä¸ªå‡½æ•°ï¼Œä»å­—ç¬¦ä¸²ä¸­æå–æ•°å­—ï¼Œè¿”å› `Option<i32>`ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
fn extract_number(s: &str) -> Option<i32> {
    s.chars()
        .filter(|c| c.is_digit(10))
        .collect::<String>()
        .parse::<i32>()
        .ok()
}

fn main() {
    println!("{:?}", extract_number("abc123def")); // Some(123)
    println!("{:?}", extract_number("no numbers")); // None
    println!("{:?}", extract_number("456")); // Some(456)
}
```

</details>

### ç»ƒä¹  2: è‡ªå®šä¹‰é”™è¯¯ç±»å‹

åˆ›å»ºä¸€ä¸ªè‡ªå®šä¹‰é”™è¯¯ç±»å‹ï¼Œç”¨äºå¤„ç†æ–‡ä»¶æ“ä½œï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
enum FileError {
    NotFound(String),
    PermissionDenied(String),
    InvalidFormat(String),
}

impl fmt::Display for FileError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            FileError::NotFound(path) => write!(f, "æ–‡ä»¶æœªæ‰¾åˆ°: {}", path),
            FileError::PermissionDenied(path) => write!(f, "æƒé™è¢«æ‹’ç»: {}", path),
            FileError::InvalidFormat(msg) => write!(f, "æ ¼å¼æ— æ•ˆ: {}", msg),
        }
    }
}

impl Error for FileError {}

fn read_file(path: &str) -> Result<String, FileError> {
    if path.is_empty() {
        return Err(FileError::NotFound("è·¯å¾„ä¸ºç©º".to_string()));
    }
    
    if path.contains("private") {
        return Err(FileError::PermissionDenied(path.to_string()));
    }
    
    if path.contains("invalid") {
        return Err(FileError::InvalidFormat("æ–‡ä»¶æ ¼å¼æ— æ•ˆ".to_string()));
    }
    
    Ok(format!("æ–‡ä»¶å†…å®¹: {}", path))
}

fn main() {
    match read_file("test.txt") {
        Ok(content) => println!("æˆåŠŸ: {}", content),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
    
    match read_file("") {
        Ok(content) => println!("æˆåŠŸ: {}", content),
        Err(error) => println!("é”™è¯¯: {}", error),
    }
}
```

</details>

### ç»ƒä¹  3: é”™è¯¯ä¼ æ’­

åˆ›å»ºä¸€ä¸ªå‡½æ•°é“¾ï¼Œæ¯ä¸ªå‡½æ•°éƒ½å¯èƒ½å¤±è´¥ï¼Œä½¿ç”¨ `?` æ“ä½œç¬¦ä¼ æ’­é”™è¯¯ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
fn validate_input(input: &str) -> Result<String, String> {
    if input.is_empty() {
        return Err("è¾“å…¥ä¸èƒ½ä¸ºç©º".to_string());
    }
    Ok(input.to_string())
}

fn process_data(data: &str) -> Result<String, String> {
    if data.len() < 3 {
        return Err("æ•°æ®å¤ªçŸ­".to_string());
    }
    Ok(data.to_uppercase())
}

fn save_data(data: &str) -> Result<(), String> {
    if data.contains("error") {
        return Err("ä¿å­˜å¤±è´¥".to_string());
    }
    println!("ä¿å­˜æ•°æ®: {}", data);
    Ok(())
}

fn process_pipeline(input: &str) -> Result<(), String> {
    let validated = validate_input(input)?;
    let processed = process_data(&validated)?;
    save_data(&processed)?;
    Ok(())
}

fn main() {
    match process_pipeline("hello") {
        Ok(_) => println!("å¤„ç†æˆåŠŸ"),
        Err(error) => println!("å¤„ç†å¤±è´¥: {}", error),
    }
    
    match process_pipeline("") {
        Ok(_) => println!("å¤„ç†æˆåŠŸ"),
        Err(error) => println!("å¤„ç†å¤±è´¥: {}", error),
    }
}
```

</details>

---

## ğŸ“ æ€»ç»“

åœ¨è¿™ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº† Rust çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼š

1. **Option ç±»å‹**: å¤„ç†å¯èƒ½ä¸ºç©ºçš„å€¼
2. **Result ç±»å‹**: å¤„ç†å¯èƒ½å¤±è´¥çš„æ“ä½œ
3. **é”™è¯¯ä¼ æ’­**: ä½¿ç”¨ `?` æ“ä½œç¬¦ä¼ æ’­é”™è¯¯
4. **è‡ªå®šä¹‰é”™è¯¯**: åˆ›å»ºè‡ªå·±çš„é”™è¯¯ç±»å‹
5. **ä¸ JavaScript å¯¹æ¯”**: ç±»å‹å®‰å…¨ vs å¼‚å¸¸å¤„ç†

### å…³é”®è¦ç‚¹

- Rust ä½¿ç”¨ç±»å‹ç³»ç»Ÿè€Œä¸æ˜¯å¼‚å¸¸å¤„ç†é”™è¯¯
- `Option` å’Œ `Result` å¼ºåˆ¶æ˜¾å¼å¤„ç†é”™è¯¯æƒ…å†µ
- `?` æ“ä½œç¬¦ç®€åŒ–é”™è¯¯ä¼ æ’­
- è‡ªå®šä¹‰é”™è¯¯ç±»å‹æä¾›æ›´å¥½çš„é”™è¯¯ä¿¡æ¯

### ä¸‹ä¸€æ­¥å­¦ä¹ 

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹  Rust çš„ Web å¼€å‘ï¼Œäº†è§£å¦‚ä½•ä½¿ç”¨ Rust æ„å»º Web åº”ç”¨ç¨‹åºã€‚

---

**ç»§ç»­å­¦ä¹ **: [Web å¼€å‘å®æˆ˜](./module-07-web-development.zh-cn.mdx) 