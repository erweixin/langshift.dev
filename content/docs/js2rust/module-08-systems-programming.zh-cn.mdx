---
title: "ç³»ç»Ÿçº§ç¼–ç¨‹ä¸é«˜çº§ä¸»é¢˜"
description: "å­¦ä¹  Rust çš„ç³»ç»Ÿçº§ç¼–ç¨‹ç‰¹æ€§ï¼ŒåŒ…æ‹¬ unsafe ä»£ç ã€å®ç³»ç»Ÿã€æ€§èƒ½ä¼˜åŒ–å’Œåº•å±‚ç¼–ç¨‹"
---

# ç³»ç»Ÿçº§ç¼–ç¨‹ä¸é«˜çº§ä¸»é¢˜

## ğŸ“– å­¦ä¹ ç›®æ ‡

ç†è§£ Rust çš„ç³»ç»Ÿçº§ç¼–ç¨‹ç‰¹æ€§ï¼Œå­¦ä¼šä½¿ç”¨ unsafe ä»£ç ã€å®ç³»ç»Ÿã€æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ï¼ŒæŒæ¡åº•å±‚ç¼–ç¨‹æ¦‚å¿µã€‚

---

## ğŸ¯ ç³»ç»Ÿçº§ç¼–ç¨‹å¯¹æ¯”

### JavaScript çš„é«˜çº§æŠ½è±¡

JavaScript è¿è¡Œåœ¨è™šæ‹Ÿæœºä¸­ï¼Œæä¾›é«˜çº§æŠ½è±¡ï¼š

<UniversalEditor title="JavaScript é«˜çº§æŠ½è±¡" compare={true}>
```javascript !! js
// JavaScript é«˜çº§æŠ½è±¡ç¤ºä¾‹
class MemoryManager {
    constructor() {
        this.memory = new Map();
        this.gcStats = {
            collections: 0,
            freedMemory: 0
        };
    }
    
    // åˆ†é…å†…å­˜ï¼ˆJavaScript è‡ªåŠ¨ç®¡ç†ï¼‰
    allocate(key, data) {
        this.memory.set(key, data);
        console.log(`åˆ†é…å†…å­˜: ${key}`);
    }
    
    // é‡Šæ”¾å†…å­˜ï¼ˆJavaScript è‡ªåŠ¨åƒåœ¾å›æ”¶ï¼‰
    deallocate(key) {
        this.memory.delete(key);
        console.log(`é‡Šæ”¾å†…å­˜: ${key}`);
    }
    
    // æ‰‹åŠ¨è§¦å‘åƒåœ¾å›æ”¶ï¼ˆä»…åœ¨æŸäº›ç¯å¢ƒä¸­å¯ç”¨ï¼‰
    forceGarbageCollection() {
        if (global.gc) {
            global.gc();
            this.gcStats.collections++;
            console.log('å¼ºåˆ¶åƒåœ¾å›æ”¶');
        }
    }
    
    // å†…å­˜ä½¿ç”¨ç»Ÿè®¡
    getMemoryUsage() {
        if (process.memoryUsage) {
            const usage = process.memoryUsage();
            return {
                rss: usage.rss,
                heapUsed: usage.heapUsed,
                heapTotal: usage.heapTotal,
                external: usage.external
            };
        }
        return null;
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const memoryManager = new MemoryManager();

// åˆ†é…å¤§é‡æ•°æ®
for (let i = 0; i < 1000; i++) {
    memoryManager.allocate(`key${i}`, {
        id: i,
        data: 'x'.repeat(1000), // 1KB æ•°æ®
        timestamp: Date.now()
    });
}

console.log('å†…å­˜ä½¿ç”¨æƒ…å†µ:', memoryManager.getMemoryUsage());

// é‡Šæ”¾éƒ¨åˆ†æ•°æ®
for (let i = 0; i < 500; i++) {
    memoryManager.deallocate(`key${i}`);
}

// å¼ºåˆ¶åƒåœ¾å›æ”¶
memoryManager.forceGarbageCollection();

console.log('åƒåœ¾å›æ”¶åå†…å­˜ä½¿ç”¨:', memoryManager.getMemoryUsage());

// åº•å±‚æ“ä½œæ¨¡æ‹Ÿï¼ˆJavaScript é™åˆ¶ï¼‰
class LowLevelOperations {
    // æ¨¡æ‹ŸæŒ‡é’ˆæ“ä½œï¼ˆJavaScript æ²¡æœ‰çœŸæ­£çš„æŒ‡é’ˆï¼‰
    createPointer() {
        return {
            address: Math.random().toString(16),
            value: null,
            dereference() {
                return this.value;
            },
            assign(value) {
                this.value = value;
            }
        };
    }
    
    // æ¨¡æ‹Ÿå†…å­˜å¸ƒå±€
    createMemoryLayout() {
        return {
            stack: [],
            heap: new Map(),
            allocateOnStack(value) {
                this.stack.push(value);
                return this.stack.length - 1;
            },
            allocateOnHeap(key, value) {
                this.heap.set(key, value);
                return key;
            }
        };
    }
    
    // æ¨¡æ‹Ÿç³»ç»Ÿè°ƒç”¨
    systemCall(operation, data) {
        console.log(`ç³»ç»Ÿè°ƒç”¨: ${operation}`, data);
        // åœ¨å®é™…ç¯å¢ƒä¸­ï¼Œè¿™äº›æ“ä½œä¼šè¢« JavaScript å¼•æ“å¤„ç†
        return {
            success: true,
            result: `æ¨¡æ‹Ÿ ${operation} ç»“æœ`,
            timestamp: Date.now()
        };
    }
}

// ä½¿ç”¨åº•å±‚æ“ä½œ
const lowLevel = new LowLevelOperations();

const pointer = lowLevel.createPointer();
pointer.assign("Hello, World!");
console.log("æŒ‡é’ˆå€¼:", pointer.dereference());

const memory = lowLevel.createMemoryLayout();
const stackAddr = memory.allocateOnStack(42);
const heapAddr = memory.allocateOnHeap("dynamic", "data");

console.log("æ ˆåœ°å€:", stackAddr, "å€¼:", memory.stack[stackAddr]);
console.log("å †åœ°å€:", heapAddr, "å€¼:", memory.heap.get(heapAddr));

// æ¨¡æ‹Ÿç³»ç»Ÿè°ƒç”¨
const syscall = lowLevel.systemCall("read", { file: "test.txt", size: 1024 });
console.log("ç³»ç»Ÿè°ƒç”¨ç»“æœ:", syscall);
```
</UniversalEditor>

### Rust çš„ç³»ç»Ÿçº§ç¼–ç¨‹

Rust æä¾›ç›´æ¥çš„å†…å­˜æ§åˆ¶å’Œç³»ç»Ÿçº§è®¿é—®ï¼š

<UniversalEditor title="Rust ç³»ç»Ÿçº§ç¼–ç¨‹" compare={true}>
```rust !! rs
use std::alloc::{alloc, dealloc, Layout};
use std::ptr;
use std::mem;

// è‡ªå®šä¹‰å†…å­˜ç®¡ç†å™¨
struct MemoryManager {
    allocations: std::collections::HashMap<usize, Layout>,
    total_allocated: usize,
}

impl MemoryManager {
    fn new() -> Self {
        Self {
            allocations: HashMap::new(),
            total_allocated: 0,
        }
    }
    
    // æ‰‹åŠ¨åˆ†é…å†…å­˜
    unsafe fn allocate(&mut self, size: usize) -> *mut u8 {
        let layout = Layout::from_size_align(size, 8).unwrap();
        let ptr = alloc(layout);
        
        if !ptr.is_null() {
            self.allocations.insert(ptr as usize, layout);
            self.total_allocated += size;
            println!("åˆ†é…å†…å­˜: {} å­—èŠ‚ï¼Œåœ°å€: {:p}", size, ptr);
        }
        
        ptr
    }
    
    // æ‰‹åŠ¨é‡Šæ”¾å†…å­˜
    unsafe fn deallocate(&mut self, ptr: *mut u8) {
        if let Some(layout) = self.allocations.remove(&(ptr as usize)) {
            dealloc(ptr, layout);
            self.total_allocated -= layout.size();
            println!("é‡Šæ”¾å†…å­˜: {} å­—èŠ‚ï¼Œåœ°å€: {:p}", layout.size(), ptr);
        }
    }
    
    // è·å–å†…å­˜ä½¿ç”¨ç»Ÿè®¡
    fn get_stats(&self) -> (usize, usize) {
        (self.total_allocated, self.allocations.len())
    }
}

// æ™ºèƒ½æŒ‡é’ˆå®ç°
struct SmartPtr<T> {
    ptr: *mut T,
    manager: *mut MemoryManager,
}

impl<T> SmartPtr<T> {
    unsafe fn new(value: T, manager: &mut MemoryManager) -> Self {
        let size = mem::size_of::<T>();
        let ptr = manager.allocate(size) as *mut T;
        
        if !ptr.is_null() {
            ptr::write(ptr, value);
        }
        
        Self {
            ptr,
            manager: manager as *mut MemoryManager,
        }
    }
    
    fn get(&self) -> Option<&T> {
        if self.ptr.is_null() {
            None
        } else {
            unsafe { Some(&*self.ptr) }
        }
    }
    
    fn get_mut(&mut self) -> Option<&mut T> {
        if self.ptr.is_null() {
            None
        } else {
            unsafe { Some(&mut *self.ptr) }
        }
    }
}

impl<T> Drop for SmartPtr<T> {
    fn drop(&mut self) {
        if !self.ptr.is_null() {
            unsafe {
                ptr::drop_in_place(self.ptr);
                (*self.manager).deallocate(self.ptr as *mut u8);
            }
        }
    }
}

// å†…å­˜å¸ƒå±€æ§åˆ¶
#[repr(C)]
struct MemoryLayout {
    data: [u8; 64],
    metadata: u32,
}

impl MemoryLayout {
    fn new() -> Self {
        Self {
            data: [0; 64],
            metadata: 0,
        }
    }
    
    fn size(&self) -> usize {
        mem::size_of::<Self>()
    }
    
    fn align(&self) -> usize {
        mem::align_of::<Self>()
    }
}

// ç³»ç»Ÿè°ƒç”¨æ¨¡æ‹Ÿ
#[cfg(unix)]
mod system_calls {
    use std::ffi::CString;
    
    extern "C" {
        fn write(fd: i32, buf: *const u8, count: usize) -> isize;
        fn read(fd: i32, buf: *mut u8, count: usize) -> isize;
    }
    
    pub fn sys_write(fd: i32, data: &[u8]) -> isize {
        unsafe {
            write(fd, data.as_ptr(), data.len())
        }
    }
    
    pub fn sys_read(fd: i32, buffer: &mut [u8]) -> isize {
        unsafe {
            read(fd, buffer.as_mut_ptr(), buffer.len())
        }
    }
}

fn main() {
    // ä½¿ç”¨è‡ªå®šä¹‰å†…å­˜ç®¡ç†å™¨
    let mut manager = MemoryManager::new();
    
    // åˆ†é…å†…å­˜
    let ptr1 = unsafe { manager.allocate(1024) };
    let ptr2 = unsafe { manager.allocate(512) };
    
    // å†™å…¥æ•°æ®
    unsafe {
        ptr::write_bytes(ptr1, 0x42, 1024);
        ptr::write_bytes(ptr2, 0xAA, 512);
    }
    
    // ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆ
    let mut smart_ptr = unsafe { SmartPtr::new(42, &mut manager) };
    println!("æ™ºèƒ½æŒ‡é’ˆå€¼: {:?}", smart_ptr.get());
    
    if let Some(value) = smart_ptr.get_mut() {
        *value = 100;
        println!("ä¿®æ”¹åå€¼: {:?}", smart_ptr.get());
    }
    
    // å†…å­˜å¸ƒå±€
    let layout = MemoryLayout::new();
    println!("å†…å­˜å¸ƒå±€å¤§å°: {} å­—èŠ‚", layout.size());
    println!("å†…å­˜å¯¹é½: {} å­—èŠ‚", layout.align());
    
    // é‡Šæ”¾å†…å­˜
    unsafe {
        manager.deallocate(ptr1);
        manager.deallocate(ptr2);
    }
    
    let (total, count) = manager.get_stats();
    println!("å†…å­˜ç»Ÿè®¡: æ€»åˆ†é… {} å­—èŠ‚ï¼Œ{} ä¸ªåˆ†é…", total, count);
    
    // ç³»ç»Ÿè°ƒç”¨ï¼ˆä»…åœ¨ Unix ç³»ç»Ÿä¸Šï¼‰
    #[cfg(unix)]
    {
        let message = b"Hello from Rust system call!\n";
        let result = system_calls::sys_write(1, message);
        println!("ç³»ç»Ÿè°ƒç”¨ç»“æœ: {}", result);
    }
}
```
</UniversalEditor>

### ç³»ç»Ÿçº§ç¼–ç¨‹å·®å¼‚

1. **å†…å­˜æ§åˆ¶**: Rust æä¾›ç›´æ¥å†…å­˜æ§åˆ¶ï¼ŒJavaScript è‡ªåŠ¨ç®¡ç†
2. **æ€§èƒ½**: Rust é›¶æˆæœ¬æŠ½è±¡ï¼ŒJavaScript æœ‰è¿è¡Œæ—¶å¼€é”€
3. **å®‰å…¨æ€§**: Rust ç¼–è¯‘æ—¶ä¿è¯å†…å­˜å®‰å…¨ï¼ŒJavaScript è¿è¡Œæ—¶æ£€æŸ¥
4. **ç³»ç»Ÿè®¿é—®**: Rust å¯ä»¥ç›´æ¥è°ƒç”¨ç³»ç»Ÿ APIï¼ŒJavaScript å—æ²™ç®±é™åˆ¶

---

## âš ï¸ Unsafe ä»£ç 

### ä½•æ—¶ä½¿ç”¨ Unsafe

<UniversalEditor title="Unsafe ä»£ç ä½¿ç”¨" compare={true}>
```rust !! rs
// å®‰å…¨çš„ Rust ä»£ç 
fn safe_function() -> i32 {
    let x = 42;
    x * 2
}

// éœ€è¦ unsafe çš„åœºæ™¯
fn unsafe_examples() {
    // 1. è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆ
    let x = 42;
    let raw_ptr = &x as *const i32;
    
    unsafe {
        let value = *raw_ptr; // è§£å¼•ç”¨åŸå§‹æŒ‡é’ˆéœ€è¦ unsafe
        println!("è§£å¼•ç”¨å€¼: {}", value);
    }
    
    // 2. è°ƒç”¨ unsafe å‡½æ•°
    unsafe {
        let ptr = std::ptr::null_mut::<i32>();
        // è°ƒç”¨ C å‡½æ•°æˆ–å…¶ä»– unsafe å‡½æ•°
    }
    
    // 3. è®¿é—®æˆ–ä¿®æ”¹é™æ€å¯å˜å˜é‡
    static mut COUNTER: i32 = 0;
    
    unsafe {
        COUNTER += 1;
        println!("è®¡æ•°å™¨: {}", COUNTER);
    }
    
    // 4. å®ç° unsafe trait
    unsafe trait UnsafeTrait {
        fn unsafe_method(&self);
    }
    
    struct UnsafeStruct;
    
    unsafe impl UnsafeTrait for UnsafeStruct {
        fn unsafe_method(&self) {
            println!("è¿™æ˜¯ unsafe æ–¹æ³•");
        }
    }
}

// å®‰å…¨çš„æŠ½è±¡åŒ…è£… unsafe ä»£ç 
struct SafeWrapper {
    data: Vec<i32>,
}

impl SafeWrapper {
    fn new() -> Self {
        Self { data: Vec::new() }
    }
    
    fn push(&mut self, value: i32) {
        self.data.push(value);
    }
    
    fn get(&self, index: usize) -> Option<&i32> {
        self.data.get(index)
    }
    
    // å†…éƒ¨ä½¿ç”¨ unsafe ä½†å¯¹å¤–æä¾›å®‰å…¨æ¥å£
    fn get_unchecked(&self, index: usize) -> &i32 {
        unsafe {
            // è°ƒç”¨è€…å¿…é¡»ç¡®ä¿ index åœ¨æœ‰æ•ˆèŒƒå›´å†…
            self.data.get_unchecked(index)
        }
    }
    
    fn as_ptr(&self) -> *const i32 {
        self.data.as_ptr()
    }
    
    fn len(&self) -> usize {
        self.data.len()
    }
}

// è‡ªå®šä¹‰å†…å­˜åˆ†é…å™¨
struct CustomAllocator {
    memory: Vec<u8>,
    allocated: std::collections::HashMap<usize, usize>, // åœ°å€ -> å¤§å°
}

impl CustomAllocator {
    fn new(size: usize) -> Self {
        Self {
            memory: vec![0; size],
            allocated: HashMap::new(),
        }
    }
    
    // åˆ†é…å†…å­˜
    fn allocate(&mut self, size: usize) -> Option<*mut u8> {
        // ç®€å•çš„é¦–æ¬¡é€‚é…ç®—æ³•
        let mut current_pos = 0;
        
        while current_pos + size <= self.memory.len() {
            let mut can_allocate = true;
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å†²çªçš„åˆ†é…
            for (&addr, &alloc_size) in &self.allocated {
                if current_pos < addr + alloc_size && current_pos + size > addr {
                    current_pos = addr + alloc_size;
                    can_allocate = false;
                    break;
                }
            }
            
            if can_allocate {
                self.allocated.insert(current_pos, size);
                return Some(self.memory.as_mut_ptr().add(current_pos));
            }
        }
        
        None
    }
    
    // é‡Šæ”¾å†…å­˜
    fn deallocate(&mut self, ptr: *mut u8) {
        let addr = unsafe { ptr.offset_from(self.memory.as_ptr()) } as usize;
        self.allocated.remove(&addr);
    }
    
    // è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
    fn get_usage(&self) -> (usize, usize) {
        let total_allocated: usize = self.allocated.values().sum();
        (total_allocated, self.allocated.len())
    }
}

// ä½¿ç”¨è‡ªå®šä¹‰åˆ†é…å™¨
fn custom_allocator_example() {
    let mut allocator = CustomAllocator::new(1024);
    
    // åˆ†é…å†…å­˜
    if let Some(ptr1) = allocator.allocate(64) {
        println!("åˆ†é… 64 å­—èŠ‚ï¼Œåœ°å€: {:p}", ptr1);
        
        // å†™å…¥æ•°æ®
        unsafe {
            ptr::write_bytes(ptr1, 0x42, 64);
        }
        
        // åˆ†é…æ›´å¤šå†…å­˜
        if let Some(ptr2) = allocator.allocate(128) {
            println!("åˆ†é… 128 å­—èŠ‚ï¼Œåœ°å€: {:p}", ptr2);
            
            unsafe {
                ptr::write_bytes(ptr2, 0xAA, 128);
            }
            
            // é‡Šæ”¾å†…å­˜
            allocator.deallocate(ptr2);
            println!("é‡Šæ”¾ç¬¬äºŒä¸ªåˆ†é…");
        }
        
        allocator.deallocate(ptr1);
        println!("é‡Šæ”¾ç¬¬ä¸€ä¸ªåˆ†é…");
    }
    
    let (total, count) = allocator.get_usage();
    println!("æœ€ç»ˆä½¿ç”¨æƒ…å†µ: {} å­—èŠ‚ï¼Œ{} ä¸ªåˆ†é…", total, count);
}

fn main() {
    unsafe_examples();
    
    let mut wrapper = SafeWrapper::new();
    wrapper.push(1);
    wrapper.push(2);
    wrapper.push(3);
    
    // å®‰å…¨è®¿é—®
    if let Some(value) = wrapper.get(1) {
        println!("å®‰å…¨è®¿é—®: {}", value);
    }
    
    // ä¸å®‰å…¨ä½†å¿«é€Ÿçš„è®¿é—®ï¼ˆè°ƒç”¨è€…è´Ÿè´£è¾¹ç•Œæ£€æŸ¥ï¼‰
    if wrapper.len() > 1 {
        let value = wrapper.get_unchecked(1);
        println!("ä¸å®‰å…¨è®¿é—®: {}", value);
    }
    
    custom_allocator_example();
}
```
</UniversalEditor>

---

## ğŸ”§ å®ç³»ç»Ÿ

### å£°æ˜å®å’Œè¿‡ç¨‹å®

<UniversalEditor title="å®ç³»ç»Ÿ" compare={true}>
```rust !! rs
// å£°æ˜å® (macro_rules!)
macro_rules! vec_init {
    // ç©ºå‘é‡
    () => {
        Vec::new()
    };
    
    // å•ä¸ªå…ƒç´ é‡å¤ n æ¬¡
    ($elem:expr; $n:expr) => {
        {
            let mut vec = Vec::new();
            vec.resize($n, $elem);
            vec
        }
    };
    
    // å¤šä¸ªå…ƒç´ 
    ($($x:expr),*) => {
        {
            let mut vec = Vec::new();
            $(vec.push($x);)*
            vec
        }
    };
    
    // å¸¦å°¾éšé€—å·
    ($($x:expr,)*) => {
        vec_init!($($x),*)
    };
}

// æ¡ä»¶ç¼–è¯‘å®
macro_rules! debug_print {
    ($($arg:tt)*) => {
        #[cfg(debug_assertions)]
        println!($($arg)*);
    };
}

// é€’å½’å®
macro_rules! count_exprs {
    () => (0);
    ($head:expr) => (1);
    ($head:expr, $($tail:expr),*) => (1 + count_exprs!($($tail),*));
}

// é‡å¤å®
macro_rules! create_struct {
    ($name:ident { $($field:ident: $type:ty),* }) => {
        struct $name {
            $($field: $type),*
        }
        
        impl $name {
            fn new($($field: $type),*) -> Self {
                Self {
                    $($field),*
                }
            }
        }
    };
}

// è¿‡ç¨‹å®ï¼ˆéœ€è¦å•ç‹¬çš„ crateï¼‰
// è¿™é‡Œå±•ç¤ºå¦‚ä½•ä½¿ç”¨è¿‡ç¨‹å®
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// è‡ªå®šä¹‰æ´¾ç”Ÿå®ï¼ˆç®€åŒ–ç‰ˆï¼‰
macro_rules! derive_debug {
    ($name:ident) => {
        impl std::fmt::Debug for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                write!(f, "{} {{ ... }}", stringify!($name))
            }
        }
    };
}

// å‡½æ•°å¼å®
macro_rules! hash_map {
    ($($key:expr => $value:expr),*) => {
        {
            let mut map = std::collections::HashMap::new();
            $(map.insert($key, $value);)*
            map
        }
    };
}

// å±æ€§å®ï¼ˆç®€åŒ–ç‰ˆï¼‰
macro_rules! route {
    ($method:expr, $path:expr) => {
        // è¿™é‡Œä¼šç”Ÿæˆè·¯ç”±å¤„ç†ä»£ç 
        println!("æ³¨å†Œè·¯ç”±: {} {}", $method, $path);
    };
}

fn main() {
    // ä½¿ç”¨å£°æ˜å®
    let empty_vec = vec_init!();
    let repeated_vec = vec_init![42; 5];
    let normal_vec = vec_init![1, 2, 3, 4, 5];
    let trailing_comma_vec = vec_init![1, 2, 3,];
    
    println!("ç©ºå‘é‡: {:?}", empty_vec);
    println!("é‡å¤å‘é‡: {:?}", repeated_vec);
    println!("æ™®é€šå‘é‡: {:?}", normal_vec);
    println!("å°¾éšé€—å·å‘é‡: {:?}", trailing_comma_vec);
    
    // ä½¿ç”¨æ¡ä»¶ç¼–è¯‘å®
    debug_print!("è¿™æ˜¯è°ƒè¯•ä¿¡æ¯");
    
    // ä½¿ç”¨é€’å½’å®
    let count = count_exprs!(1, 2, 3, 4, 5);
    println!("è¡¨è¾¾å¼æ•°é‡: {}", count);
    
    // ä½¿ç”¨ç»“æ„ä½“åˆ›å»ºå®
    create_struct!(Point {
        x: f64,
        y: f64
    });
    
    let point = Point::new(3.0, 4.0);
    println!("ç‚¹: ({}, {})", point.x, point.y);
    
    // ä½¿ç”¨æ´¾ç”Ÿå®
    struct SimpleStruct {
        value: i32,
    }
    
    derive_debug!(SimpleStruct);
    
    let simple = SimpleStruct { value: 42 };
    println!("ç®€å•ç»“æ„ä½“: {:?}", simple);
    
    // ä½¿ç”¨å‡½æ•°å¼å®
    let map = hash_map! {
        "a" => 1,
        "b" => 2,
        "c" => 3
    };
    println!("å“ˆå¸Œæ˜ å°„: {:?}", map);
    
    // ä½¿ç”¨å±æ€§å®
    route!("GET", "/users");
    route!("POST", "/users");
    
    // åºåˆ—åŒ–ç¤ºä¾‹
    let user = User {
        id: 1,
        name: "Alice".to_string(),
        email: "alice@example.com".to_string(),
    };
    
    let json = serde_json::to_string(&user).unwrap();
    println!("åºåˆ—åŒ–ç»“æœ: {}", json);
    
    let deserialized: User = serde_json::from_str(&json).unwrap();
    println!("ååºåˆ—åŒ–ç»“æœ: {:?}", deserialized);
}

// é«˜çº§å®ï¼šå®ç° DSLï¼ˆé¢†åŸŸç‰¹å®šè¯­è¨€ï¼‰
macro_rules! html {
    () => { String::new() };
    
    ($tag:ident { $($content:tt)* }) => {
        {
            let mut html = String::new();
            html.push_str(&format!("<{}>", stringify!($tag)));
            html.push_str(&html!($($content)*));
            html.push_str(&format!("</{}>", stringify!($tag)));
            html
        }
    };
    
    ($text:expr) => {
        $text.to_string()
    };
    
    ($($content:tt)*) => {
        {
            let mut html = String::new();
            $(html.push_str(&html!($content));)*
            html
        }
    };
}

fn html_example() {
    let page = html! {
        html {
            head {
                title { "æˆ‘çš„ç½‘é¡µ" }
            }
            body {
                h1 { "æ¬¢è¿" }
                p { "è¿™æ˜¯ä¸€ä¸ªä½¿ç”¨å®ç”Ÿæˆçš„ HTML" }
            }
        }
    };
    
    println!("ç”Ÿæˆçš„ HTML:\n{}", page);
}
```
</UniversalEditor>

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

<UniversalEditor title="æ€§èƒ½ä¼˜åŒ–" compare={true}>
```rust !! rs
use std::time::Instant;
use std::collections::HashMap;

// 1. å†…å­˜å¸ƒå±€ä¼˜åŒ–
#[repr(C)]
struct OptimizedStruct {
    a: u64,    // 8 å­—èŠ‚
    b: u32,    // 4 å­—èŠ‚
    c: u8,     // 1 å­—èŠ‚
    // ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ·»åŠ  3 å­—èŠ‚å¡«å……
}

#[repr(C)]
struct UnoptimizedStruct {
    a: u8,     // 1 å­—èŠ‚
    b: u64,    // 8 å­—èŠ‚
    c: u32,    // 4 å­—èŠ‚
    // ç¼–è¯‘å™¨ä¼šæ·»åŠ  7 å­—èŠ‚å¡«å……
}

// 2. é›¶æ‹·è´ä¼˜åŒ–
fn zero_copy_example() {
    let data = vec![1, 2, 3, 4, 5];
    
    // é¿å…ä¸å¿…è¦çš„å…‹éš†
    let reference = &data; // é›¶æ‹·è´
    let slice = &data[1..4]; // é›¶æ‹·è´
    
    // ä½¿ç”¨è¿­ä»£å™¨é¿å…åˆ†é…
    let sum: i32 = data.iter().sum(); // é›¶æ‹·è´è¿­ä»£
    let doubled: Vec<i32> = data.iter().map(|x| x * 2).collect(); // éœ€è¦åˆ†é…
}

// 3. ç¼“å­˜å‹å¥½çš„æ•°æ®ç»“æ„
struct CacheFriendlyArray {
    data: Vec<f64>,
    size: usize,
}

impl CacheFriendlyArray {
    fn new(size: usize) -> Self {
        Self {
            data: vec![0.0; size],
            size,
        }
    }
    
    // é¡ºåºè®¿é—®ï¼ˆç¼“å­˜å‹å¥½ï¼‰
    fn sum_sequential(&self) -> f64 {
        self.data.iter().sum()
    }
    
    // éšæœºè®¿é—®ï¼ˆç¼“å­˜ä¸å‹å¥½ï¼‰
    fn sum_random(&self) -> f64 {
        let mut indices: Vec<usize> = (0..self.size).collect();
        // æ‰“ä¹±ç´¢å¼•
        for i in 0..self.size {
            indices.swap(i, (i * 7) % self.size);
        }
        
        indices.iter().map(|&i| self.data[i]).sum()
    }
}

// 4. å†…è”ä¼˜åŒ–
#[inline(always)]
fn fast_add(a: i32, b: i32) -> i32 {
    a + b
}

#[inline(never)]
fn slow_function(a: i32, b: i32) -> i32 {
    // å¤æ‚çš„è®¡ç®—
    let mut result = 0;
    for i in 0..1000 {
        result += a * b + i;
    }
    result
}

// 5. SIMD ä¼˜åŒ–
#[cfg(target_arch = "x86_64")]
use std::arch::x86_64::*;

#[cfg(target_arch = "x86_64")]
unsafe fn simd_add(a: &[f32], b: &[f32], result: &mut [f32]) {
    let len = a.len().min(b.len()).min(result.len());
    
    for i in (0..len).step_by(4) {
        let a_vec = _mm_loadu_ps(a.as_ptr().add(i));
        let b_vec = _mm_loadu_ps(b.as_ptr().add(i));
        let sum_vec = _mm_add_ps(a_vec, b_vec);
        _mm_storeu_ps(result.as_mut_ptr().add(i), sum_vec);
    }
}

// 6. å†…å­˜æ± 
struct MemoryPool {
    blocks: Vec<Vec<u8>>,
    block_size: usize,
    free_blocks: Vec<usize>,
}

impl MemoryPool {
    fn new(block_size: usize, initial_blocks: usize) -> Self {
        let mut blocks = Vec::with_capacity(initial_blocks);
        let mut free_blocks = Vec::with_capacity(initial_blocks);
        
        for i in 0..initial_blocks {
            blocks.push(vec![0; block_size]);
            free_blocks.push(i);
        }
        
        Self {
            blocks,
            block_size,
            free_blocks,
        }
    }
    
    fn allocate(&mut self) -> Option<&mut [u8]> {
        if let Some(block_index) = self.free_blocks.pop() {
            Some(&mut self.blocks[block_index])
        } else {
            // åˆ›å»ºæ–°å—
            let new_index = self.blocks.len();
            self.blocks.push(vec![0; self.block_size]);
            Some(&mut self.blocks[new_index])
        }
    }
    
    fn deallocate(&mut self, block: &mut [u8]) {
        // åœ¨å®é™…å®ç°ä¸­ï¼Œéœ€è¦æ‰¾åˆ°å¯¹åº”çš„å—ç´¢å¼•
        // è¿™é‡Œç®€åŒ–å¤„ç†
        if let Some(index) = self.blocks.iter().position(|b| b.as_ptr() == block.as_ptr()) {
            self.free_blocks.push(index);
        }
    }
}

// 7. æ€§èƒ½åŸºå‡†æµ‹è¯•
fn benchmark_examples() {
    let size = 1_000_000;
    
    // æµ‹è¯•å†…å­˜å¸ƒå±€
    let start = Instant::now();
    let optimized: Vec<OptimizedStruct> = (0..size)
        .map(|i| OptimizedStruct { a: i as u64, b: i as u32, c: i as u8 })
        .collect();
    let optimized_time = start.elapsed();
    
    let start = Instant::now();
    let unoptimized: Vec<UnoptimizedStruct> = (0..size)
        .map(|i| UnoptimizedStruct { a: i as u8, b: i as u64, c: i as u32 })
        .collect();
    let unoptimized_time = start.elapsed();
    
    println!("ä¼˜åŒ–ç»“æ„ä½“æ—¶é—´: {:?}", optimized_time);
    println!("æœªä¼˜åŒ–ç»“æ„ä½“æ—¶é—´: {:?}", unoptimized_time);
    
    // æµ‹è¯•ç¼“å­˜å‹å¥½æ€§
    let array = CacheFriendlyArray::new(1_000_000);
    
    let start = Instant::now();
    let sequential_sum = array.sum_sequential();
    let sequential_time = start.elapsed();
    
    let start = Instant::now();
    let random_sum = array.sum_random();
    let random_time = start.elapsed();
    
    println!("é¡ºåºè®¿é—®æ—¶é—´: {:?}, ç»“æœ: {}", sequential_time, sequential_sum);
    println!("éšæœºè®¿é—®æ—¶é—´: {:?}, ç»“æœ: {}", random_time, random_sum);
    
    // æµ‹è¯•å†…è”ä¼˜åŒ–
    let start = Instant::now();
    let mut fast_result = 0;
    for i in 0..1_000_000 {
        fast_result += fast_add(i, i);
    }
    let fast_time = start.elapsed();
    
    let start = Instant::now();
    let mut slow_result = 0;
    for i in 0..1000 {
        slow_result += slow_function(i, i);
    }
    let slow_time = start.elapsed();
    
    println!("å¿«é€Ÿå‡½æ•°æ—¶é—´: {:?}, ç»“æœ: {}", fast_time, fast_result);
    println!("æ…¢é€Ÿå‡½æ•°æ—¶é—´: {:?}, ç»“æœ: {}", slow_time, slow_result);
}

fn main() {
    zero_copy_example();
    benchmark_examples();
    
    // ä½¿ç”¨å†…å­˜æ± 
    let mut pool = MemoryPool::new(1024, 10);
    
    if let Some(block1) = pool.allocate() {
        println!("åˆ†é…å— 1ï¼Œå¤§å°: {}", block1.len());
        
        if let Some(block2) = pool.allocate() {
            println!("åˆ†é…å— 2ï¼Œå¤§å°: {}", block2.len());
            pool.deallocate(block2);
            println!("é‡Šæ”¾å— 2");
        }
        
        pool.deallocate(block1);
        println!("é‡Šæ”¾å— 1");
    }
    
    // SIMD ç¤ºä¾‹
    #[cfg(target_arch = "x86_64")]
    {
        let a = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];
        let b = vec![2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
        let mut result = vec![0.0; 8];
        
        unsafe {
            simd_add(&a, &b, &mut result);
        }
        
        println!("SIMD ç»“æœ: {:?}", result);
    }
}
```
</UniversalEditor>

---

## ğŸ¯ ç»ƒä¹ é¢˜

### ç»ƒä¹  1: å®ç°è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ

åˆ›å»ºä¸€ä¸ªå¼•ç”¨è®¡æ•°çš„æ™ºèƒ½æŒ‡é’ˆï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use std::sync::{Arc, Mutex};

struct RefCounted<T> {
    data: Arc<Mutex<T>>,
}

impl<T> RefCounted<T> {
    fn new(data: T) -> Self {
        Self {
            data: Arc::new(Mutex::new(data)),
        }
    }
    
    fn get(&self) -> Option<T>
    where
        T: Clone,
    {
        self.data.lock().ok().map(|guard| (*guard).clone())
    }
    
    fn set(&self, value: T) -> Result<(), String> {
        self.data
            .lock()
            .map(|mut guard| *guard = value)
            .map_err(|_| "æ— æ³•è·å–é”".to_string())
    }
    
    fn strong_count(&self) -> usize {
        Arc::strong_count(&self.data)
    }
}

impl<T> Clone for RefCounted<T> {
    fn clone(&self) -> Self {
        Self {
            data: Arc::clone(&self.data),
        }
    }
}

fn main() {
    let ptr1 = RefCounted::new(42);
    println!("å¼•ç”¨è®¡æ•°: {}", ptr1.strong_count());
    
    let ptr2 = ptr1.clone();
    println!("å¼•ç”¨è®¡æ•°: {}", ptr1.strong_count());
    
    ptr1.set(100).unwrap();
    println!("ptr1 å€¼: {:?}", ptr1.get());
    println!("ptr2 å€¼: {:?}", ptr2.get());
}
```

</details>

### ç»ƒä¹  2: åˆ›å»ºæ€§èƒ½ä¼˜åŒ–çš„æ•°æ®ç»“æ„

å®ç°ä¸€ä¸ªç¼“å­˜å‹å¥½çš„çŸ©é˜µä¹˜æ³•ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
struct Matrix {
    data: Vec<f64>,
    rows: usize,
    cols: usize,
}

impl Matrix {
    fn new(rows: usize, cols: usize) -> Self {
        Self {
            data: vec![0.0; rows * cols],
            rows,
            cols,
        }
    }
    
    fn get(&self, row: usize, col: usize) -> f64 {
        self.data[row * self.cols + col]
    }
    
    fn set(&mut self, row: usize, col: usize, value: f64) {
        self.data[row * self.cols + col] = value;
    }
    
    // ç¼“å­˜å‹å¥½çš„çŸ©é˜µä¹˜æ³•
    fn multiply(&self, other: &Matrix) -> Option<Matrix> {
        if self.cols != other.rows {
            return None;
        }
        
        let mut result = Matrix::new(self.rows, other.cols);
        
        // ä½¿ç”¨åˆ†å—ä¹˜æ³•ä¼˜åŒ–ç¼“å­˜æ€§èƒ½
        let block_size = 32;
        
        for i in (0..self.rows).step_by(block_size) {
            for j in (0..other.cols).step_by(block_size) {
                for k in (0..self.cols).step_by(block_size) {
                    // å¤„ç†å½“å‰å—
                    let i_end = (i + block_size).min(self.rows);
                    let j_end = (j + block_size).min(other.cols);
                    let k_end = (k + block_size).min(self.cols);
                    
                    for ii in i..i_end {
                        for jj in j..j_end {
                            let mut sum = 0.0;
                            for kk in k..k_end {
                                sum += self.get(ii, kk) * other.get(kk, jj);
                            }
                            result.set(ii, jj, result.get(ii, jj) + sum);
                        }
                    }
                }
            }
        }
        
        Some(result)
    }
}

fn main() {
    let mut a = Matrix::new(100, 100);
    let mut b = Matrix::new(100, 100);
    
    // åˆå§‹åŒ–çŸ©é˜µ
    for i in 0..100 {
        for j in 0..100 {
            a.set(i, j, (i + j) as f64);
            b.set(i, j, (i * j) as f64);
        }
    }
    
    if let Some(result) = a.multiply(&b) {
        println!("çŸ©é˜µä¹˜æ³•å®Œæˆï¼Œç»“æœçŸ©é˜µå¤§å°: {}x{}", result.rows, result.cols);
    }
}
```

</details>

### ç»ƒä¹  3: å®ç°è‡ªå®šä¹‰å®

åˆ›å»ºä¸€ä¸ªç”¨äºç”Ÿæˆæµ‹è¯•ä»£ç çš„å®ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
macro_rules! generate_tests {
    ($test_name:ident, $input:expr, $expected:expr) => {
        #[test]
        fn $test_name() {
            let result = $input;
            assert_eq!(result, $expected);
        }
    };
    
    ($test_name:ident, $input:expr, $expected:expr, $($extra_assert:expr);*) => {
        #[test]
        fn $test_name() {
            let result = $input;
            assert_eq!(result, $expected);
            $($extra_assert;)*
        }
    };
}

fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn multiply(a: i32, b: i32) -> i32 {
    a * b
}

// ä½¿ç”¨å®ç”Ÿæˆæµ‹è¯•
generate_tests!(test_add, add(2, 3), 5);
generate_tests!(test_multiply, multiply(4, 5), 20);
generate_tests!(
    test_add_with_extra,
    add(10, 20),
    30,
    assert!(add(10, 20) > 0);
    assert!(add(10, 20) < 100)
);

fn main() {
    println!("è¿è¡Œæµ‹è¯•...");
    test_add();
    test_multiply();
    test_add_with_extra();
    println!("æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼");
}
```

</details>

---

## ğŸ“ æ€»ç»“

åœ¨è¿™ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº† Rust çš„ç³»ç»Ÿçº§ç¼–ç¨‹ç‰¹æ€§ï¼š

1. **ç³»ç»Ÿçº§ç¼–ç¨‹**: ç›´æ¥å†…å­˜æ§åˆ¶å’Œç³»ç»Ÿè®¿é—®
2. **Unsafe ä»£ç **: ä½•æ—¶ä½¿ç”¨å’Œå¦‚ä½•å®‰å…¨åœ°ä½¿ç”¨
3. **å®ç³»ç»Ÿ**: å£°æ˜å®å’Œè¿‡ç¨‹å®çš„ä½¿ç”¨
4. **æ€§èƒ½ä¼˜åŒ–**: å†…å­˜å¸ƒå±€ã€ç¼“å­˜å‹å¥½æ€§å’Œ SIMD
5. **ä¸ JavaScript å¯¹æ¯”**: åº•å±‚æ§åˆ¶ vs é«˜çº§æŠ½è±¡

### å…³é”®è¦ç‚¹

- Rust æä¾›é›¶æˆæœ¬æŠ½è±¡å’Œç³»ç»Ÿçº§æ§åˆ¶
- Unsafe ä»£ç éœ€è¦è°¨æ…ä½¿ç”¨ï¼Œç¡®ä¿å®‰å…¨æ€§
- å®ç³»ç»Ÿæä¾›å¼ºå¤§çš„ä»£ç ç”Ÿæˆèƒ½åŠ›
- æ€§èƒ½ä¼˜åŒ–éœ€è¦ç†è§£åº•å±‚ç¡¬ä»¶ç‰¹æ€§

### ä¸‹ä¸€æ­¥å­¦ä¹ 

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹  Rust çš„å®æˆ˜é¡¹ç›®ï¼Œé€šè¿‡å®Œæ•´çš„é¡¹ç›®æ¥å·©å›ºæ‰€å­¦çŸ¥è¯†ã€‚

---

**ç»§ç»­å­¦ä¹ **: [å®æˆ˜é¡¹ç›®é©±åŠ¨](./module-09-projects) 