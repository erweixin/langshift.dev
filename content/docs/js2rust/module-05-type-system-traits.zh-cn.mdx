---
title: "ç±»å‹ç³»ç»Ÿä¸ç‰¹å¾"
description: "å­¦ä¹  Rust çš„é™æ€ç±»å‹ç³»ç»Ÿã€ç‰¹å¾ï¼ˆTraitsï¼‰å’Œæ³›å‹ï¼Œå¯¹æ¯” JavaScript çš„åŠ¨æ€ç±»å‹ç³»ç»Ÿ"
---

# ç±»å‹ç³»ç»Ÿä¸ç‰¹å¾

## ğŸ“– å­¦ä¹ ç›®æ ‡

ç†è§£ Rust çš„é™æ€ç±»å‹ç³»ç»Ÿå’Œç‰¹å¾ç³»ç»Ÿï¼Œå­¦ä¼šä½¿ç”¨æ³›å‹å’Œç‰¹å¾çº¦æŸï¼Œå¯¹æ¯” JavaScript çš„åŠ¨æ€ç±»å‹ç³»ç»Ÿã€‚

---

## ğŸ¯ ç±»å‹ç³»ç»Ÿå¯¹æ¯”

### JavaScript çš„åŠ¨æ€ç±»å‹

JavaScript æ˜¯åŠ¨æ€ç±»å‹è¯­è¨€ï¼Œç±»å‹åœ¨è¿è¡Œæ—¶ç¡®å®šï¼š

<UniversalEditor title="JavaScript åŠ¨æ€ç±»å‹" compare={true}>
```javascript !! js
// JavaScript åŠ¨æ€ç±»å‹ç¤ºä¾‹
function add(a, b) {
    return a + b;
}

// å¯ä»¥ä¼ é€’ä»»ä½•ç±»å‹çš„å‚æ•°
console.log(add(5, 3));        // 8 (æ•°å­—)
console.log(add("Hello", " World")); // "Hello World" (å­—ç¬¦ä¸²)
console.log(add(5, "3"));      // "53" (å­—ç¬¦ä¸²æ‹¼æ¥)
console.log(add([1, 2], [3, 4])); // "1,23,4" (æ•°ç»„è½¬å­—ç¬¦ä¸²)

// è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥
function processData(data) {
    if (typeof data === 'number') {
        return data * 2;
    } else if (typeof data === 'string') {
        return data.toUpperCase();
    } else if (Array.isArray(data)) {
        return data.length;
    } else {
        return "æœªçŸ¥ç±»å‹";
    }
}

console.log(processData(10));      // 20
console.log(processData("hello")); // "HELLO"
console.log(processData([1, 2, 3])); // 3

// ç±»å‹è½¬æ¢
let value = "42";
let number = parseInt(value); // æ˜¾å¼è½¬æ¢
let result = value * 1;       // éšå¼è½¬æ¢
console.log(typeof number, number); // "number" 42
console.log(typeof result, result); // "number" 42

// åŠ¨æ€å±æ€§
let obj = {};
obj.name = "Rust";           // åŠ¨æ€æ·»åŠ å±æ€§
obj.age = 25;
obj.sayHello = function() {  // åŠ¨æ€æ·»åŠ æ–¹æ³•
    return `Hello, I'm ${this.name}`;
};

console.log(obj.sayHello()); // "Hello, I'm Rust"
```
</UniversalEditor>

### Rust çš„é™æ€ç±»å‹

Rust æ˜¯é™æ€ç±»å‹è¯­è¨€ï¼Œç±»å‹åœ¨ç¼–è¯‘æ—¶ç¡®å®šï¼š

<UniversalEditor title="Rust é™æ€ç±»å‹" compare={true}>
```rust !! rs
// Rust é™æ€ç±»å‹ç¤ºä¾‹
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// åªèƒ½ä¼ é€’æŒ‡å®šç±»å‹çš„å‚æ•°
println!("{}", add(5, 3)); // 8

// è¿™äº›ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼š
// println!("{}", add("Hello", "World")); // é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…
// println!("{}", add(5, "3")); // é”™è¯¯ï¼šç±»å‹ä¸åŒ¹é…

// ä½¿ç”¨æ³›å‹å¤„ç†ä¸åŒç±»å‹
fn process_data<T>(data: T) -> String 
where
    T: std::fmt::Display,
{
    format!("å¤„ç†åçš„æ•°æ®: {}", data)
}

// æˆ–è€…ä½¿ç”¨ç‰¹å¾å¯¹è±¡
trait Processable {
    fn process(&self) -> String;
}

impl Processable for i32 {
    fn process(&self) -> String {
        format!("æ•°å­—: {}", self * 2)
    }
}

impl Processable for String {
    fn process(&self) -> String {
        format!("å­—ç¬¦ä¸²: {}", self.to_uppercase())
    }
}

impl Processable for Vec<i32> {
    fn process(&self) -> String {
        format!("æ•°ç»„é•¿åº¦: {}", self.len())
    }
}

fn process_with_trait(data: &dyn Processable) -> String {
    data.process()
}

// ç±»å‹è½¬æ¢
fn type_conversion() {
    let value = "42";
    let number: i32 = value.parse().unwrap(); // æ˜¾å¼è½¬æ¢
    println!("è½¬æ¢åçš„æ•°å­—: {}", number);
    
    // ä½¿ç”¨ as è¿›è¡Œç±»å‹è½¬æ¢
    let float: f64 = 42.0;
    let integer: i32 = float as i32;
    println!("æµ®ç‚¹æ•°è½¬æ•´æ•°: {}", integer);
}

// ç»“æ„ä½“å®šä¹‰
struct User {
    name: String,
    age: u32,
}

impl User {
    fn new(name: String, age: u32) -> Self {
        User { name, age }
    }
    
    fn say_hello(&self) -> String {
        format!("Hello, I'm {}", self.name)
    }
}

fn main() {
    // ä½¿ç”¨æ³›å‹å‡½æ•°
    println!("{}", process_data(10));
    println!("{}", process_data("hello".to_string()));
    
    // ä½¿ç”¨ç‰¹å¾å¯¹è±¡
    println!("{}", process_with_trait(&42));
    println!("{}", process_with_trait(&"hello".to_string()));
    println!("{}", process_with_trait(&vec![1, 2, 3]));
    
    type_conversion();
    
    // ä½¿ç”¨ç»“æ„ä½“
    let user = User::new("Rust".to_string(), 25);
    println!("{}", user.say_hello());
}
```
</UniversalEditor>

### ç±»å‹ç³»ç»Ÿå·®å¼‚

1. **é™æ€ vs åŠ¨æ€**: Rust ç¼–è¯‘æ—¶æ£€æŸ¥ç±»å‹ï¼ŒJavaScript è¿è¡Œæ—¶æ£€æŸ¥
2. **ç±»å‹å®‰å…¨**: Rust é˜²æ­¢ç±»å‹é”™è¯¯ï¼ŒJavaScript å…è®¸ç±»å‹è½¬æ¢
3. **æ€§èƒ½**: Rust é›¶æˆæœ¬æŠ½è±¡ï¼ŒJavaScript æœ‰è¿è¡Œæ—¶å¼€é”€
4. **å¼€å‘ä½“éªŒ**: Rust ç¼–è¯‘æ—¶é”™è¯¯æç¤ºï¼ŒJavaScript è¿è¡Œæ—¶é”™è¯¯

---

## ğŸ”§ ç‰¹å¾ï¼ˆTraitsï¼‰ç³»ç»Ÿ

### ç‰¹å¾å®šä¹‰ä¸å®ç°

<UniversalEditor title="ç‰¹å¾ç³»ç»Ÿ" compare={true}>
```rust !! rs
// å®šä¹‰ç‰¹å¾ï¼ˆç±»ä¼¼ JavaScript çš„æ¥å£æ¦‚å¿µï¼‰
trait Printable {
    fn print(&self);
    fn get_description(&self) -> String {
        String::from("é»˜è®¤æè¿°") // é»˜è®¤å®ç°
    }
}

// ä¸ºä¸åŒç±»å‹å®ç°ç‰¹å¾
struct Book {
    title: String,
    author: String,
    pages: u32,
}

impl Printable for Book {
    fn print(&self) {
        println!("ä¹¦å: {}, ä½œè€…: {}, é¡µæ•°: {}", 
                 self.title, self.author, self.pages);
    }
    
    fn get_description(&self) -> String {
        format!("ã€Š{}ã€‹ç”±{}ç¼–å†™ï¼Œå…±{}é¡µ", 
                self.title, self.author, self.pages)
    }
}

struct Movie {
    title: String,
    director: String,
    duration: u32,
}

impl Printable for Movie {
    fn print(&self) {
        println!("ç”µå½±: {}, å¯¼æ¼”: {}, æ—¶é•¿: {}åˆ†é’Ÿ", 
                 self.title, self.director, self.duration);
    }
}

// ä½¿ç”¨ç‰¹å¾çº¦æŸ
fn print_item<T: Printable>(item: &T) {
    item.print();
    println!("æè¿°: {}", item.get_description());
}

// ç‰¹å¾ä½œä¸ºå‚æ•°
fn print_multiple_items(items: &[&dyn Printable]) {
    for item in items {
        item.print();
    }
}

// ç‰¹å¾ä½œä¸ºè¿”å›å€¼
fn create_printable(is_book: bool) -> Box<dyn Printable> {
    if is_book {
        Box::new(Book {
            title: String::from("Rust ç¼–ç¨‹"),
            author: String::from("Steve Klabnik"),
            pages: 500,
        })
    } else {
        Box::new(Movie {
            title: String::from("Rust çºªå½•ç‰‡"),
            director: String::from("Graydon Hoare"),
            duration: 120,
        })
    }
}

fn main() {
    let book = Book {
        title: String::from("Rust æƒå¨æŒ‡å—"),
        author: String::from("Steve Klabnik"),
        pages: 400,
    };
    
    let movie = Movie {
        title: String::from("Rust ç¼–ç¨‹è¯­è¨€"),
        director: String::from("Graydon Hoare"),
        duration: 90,
    };
    
    // ä½¿ç”¨ç‰¹å¾çº¦æŸå‡½æ•°
    print_item(&book);
    print_item(&movie);
    
    // ä½¿ç”¨ç‰¹å¾å¯¹è±¡
    let items: Vec<&dyn Printable> = vec![&book, &movie];
    print_multiple_items(&items);
    
    // ä½¿ç”¨ç‰¹å¾ä½œä¸ºè¿”å›å€¼
    let printable = create_printable(true);
    printable.print();
}
```
</UniversalEditor>

### ç‰¹å¾ä¸ JavaScript æ¥å£å¯¹æ¯”

<UniversalEditor title="ç‰¹å¾ vs æ¥å£" compare={true}>
```javascript !! js
// JavaScript æ¥å£æ¦‚å¿µï¼ˆé€šè¿‡æ–‡æ¡£çº¦å®šï¼‰
/**
 * @interface Printable
 * @property {function} print - æ‰“å°æ–¹æ³•
 * @property {function} getDescription - è·å–æè¿°æ–¹æ³•
 */

// å®ç°"æ¥å£"
class Book {
    constructor(title, author, pages) {
        this.title = title;
        this.author = author;
        this.pages = pages;
    }
    
    print() {
        console.log(`ä¹¦å: ${this.title}, ä½œè€…: ${this.author}, é¡µæ•°: ${this.pages}`);
    }
    
    getDescription() {
        return `ã€Š${this.title}ã€‹ç”±${this.author}ç¼–å†™ï¼Œå…±${this.pages}é¡µ`;
    }
}

class Movie {
    constructor(title, director, duration) {
        this.title = title;
        this.director = director;
        this.duration = duration;
    }
    
    print() {
        console.log(`ç”µå½±: ${this.title}, å¯¼æ¼”: ${this.director}, æ—¶é•¿: ${this.duration}åˆ†é’Ÿ`);
    }
    
    getDescription() {
        return `${this.title} ç”± ${this.director} å¯¼æ¼”ï¼Œæ—¶é•¿ ${this.duration} åˆ†é’Ÿ`;
    }
}

// ä½¿ç”¨"æ¥å£"
function printItem(item) {
    if (typeof item.print === 'function') {
        item.print();
        if (typeof item.getDescription === 'function') {
            console.log("æè¿°:", item.getDescription());
        }
    }
}

// é¸­å­ç±»å‹ï¼šåªè¦å¯¹è±¡æœ‰ç›¸åº”æ–¹æ³•å°±å¯ä»¥ä½¿ç”¨
const book = new Book("JavaScript æƒå¨æŒ‡å—", "David Flanagan", 1000);
const movie = new Movie("JavaScript çºªå½•ç‰‡", "Brendan Eich", 60);

printItem(book);
printItem(movie);

// ç”šè‡³å¯ä»¥ä½¿ç”¨æ™®é€šå¯¹è±¡
const simpleObject = {
    print() {
        console.log("ç®€å•å¯¹è±¡");
    },
    getDescription() {
        return "è¿™æ˜¯ä¸€ä¸ªç®€å•å¯¹è±¡";
    }
};

printItem(simpleObject);
```

```rust !! rs
// Rust ç‰¹å¾ç³»ç»Ÿï¼ˆç¼–è¯‘æ—¶æ£€æŸ¥ï¼‰
trait Printable {
    fn print(&self);
    fn get_description(&self) -> String {
        String::from("é»˜è®¤æè¿°")
    }
}

struct Book {
    title: String,
    author: String,
    pages: u32,
}

impl Printable for Book {
    fn print(&self) {
        println!("ä¹¦å: {}, ä½œè€…: {}, é¡µæ•°: {}", 
                 self.title, self.author, self.pages);
    }
    
    fn get_description(&self) -> String {
        format!("ã€Š{}ã€‹ç”±{}ç¼–å†™ï¼Œå…±{}é¡µ", 
                self.title, self.author, self.pages)
    }
}

struct Movie {
    title: String,
    director: String,
    duration: u32,
}

impl Printable for Movie {
    fn print(&self) {
        println!("ç”µå½±: {}, å¯¼æ¼”: {}, æ—¶é•¿: {}åˆ†é’Ÿ", 
                 self.title, self.director, self.duration);
    }
}

// ç¼–è¯‘æ—¶æ£€æŸ¥ï¼šåªæœ‰å®ç°äº† Printable ç‰¹å¾çš„ç±»å‹æ‰èƒ½ä½¿ç”¨
fn print_item<T: Printable>(item: &T) {
    item.print();
    println!("æè¿°: {}", item.get_description());
}

fn main() {
    let book = Book {
        title: String::from("Rust æƒå¨æŒ‡å—"),
        author: String::from("Steve Klabnik"),
        pages: 400,
    };
    
    let movie = Movie {
        title: String::from("Rust ç¼–ç¨‹è¯­è¨€"),
        director: String::from("Graydon Hoare"),
        duration: 90,
    };
    
    print_item(&book);  // ç¼–è¯‘æ—¶æ£€æŸ¥é€šè¿‡
    print_item(&movie); // ç¼–è¯‘æ—¶æ£€æŸ¥é€šè¿‡
    
    // è¿™ä¼šå¯¼è‡´ç¼–è¯‘é”™è¯¯ï¼š
    // let simple_object = "hello";
    // print_item(&simple_object); // é”™è¯¯ï¼šString æ²¡æœ‰å®ç° Printable
}
```
</UniversalEditor>

---

## ğŸ”„ æ³›å‹ç¼–ç¨‹

### æ³›å‹å‡½æ•°å’Œç»“æ„ä½“

<UniversalEditor title="æ³›å‹ç¼–ç¨‹" compare={true}>
```rust !! rs
// æ³›å‹å‡½æ•°
fn find_max<T: PartialOrd>(list: &[T]) -> Option<&T> {
    if list.is_empty() {
        return None;
    }
    
    let mut max = &list[0];
    for item in list {
        if item > max {
            max = item;
        }
    }
    Some(max)
}

// æ³›å‹ç»“æ„ä½“
struct Pair<T, U> {
    first: T,
    second: U,
}

impl<T, U> Pair<T, U> {
    fn new(first: T, second: U) -> Self {
        Pair { first, second }
    }
    
    fn get_first(&self) -> &T {
        &self.first
    }
    
    fn get_second(&self) -> &U {
        &self.second
    }
}

// ä¸ºç‰¹å®šç±»å‹å®ç°ç‰¹å®šæ–¹æ³•
impl Pair<String, i32> {
    fn describe(&self) -> String {
        format!("å­—ç¬¦ä¸²: {}, æ•°å­—: {}", self.first, self.second)
    }
}

// æ³›å‹æšä¸¾
enum Result<T, E> {
    Ok(T),
    Err(E),
}

// ä½¿ç”¨æ³›å‹å®ç°é€šç”¨å®¹å™¨
struct Container<T> {
    items: Vec<T>,
}

impl<T> Container<T> {
    fn new() -> Self {
        Container { items: Vec::new() }
    }
    
    fn add(&mut self, item: T) {
        self.items.push(item);
    }
    
    fn get(&self, index: usize) -> Option<&T> {
        self.items.get(index)
    }
    
    fn len(&self) -> usize {
        self.items.len()
    }
}

// ä¸ºå®ç°äº†ç‰¹å®šç‰¹å¾çš„ç±»å‹æ·»åŠ æ–¹æ³•
impl<T: std::fmt::Display> Container<T> {
    fn print_all(&self) {
        for (i, item) in self.items.iter().enumerate() {
            println!("é¡¹ç›® {}: {}", i, item);
        }
    }
}

fn main() {
    // ä½¿ç”¨æ³›å‹å‡½æ•°
    let numbers = vec![1, 5, 3, 9, 2];
    if let Some(max) = find_max(&numbers) {
        println!("æœ€å¤§å€¼: {}", max);
    }
    
    let words = vec!["apple", "banana", "cherry"];
    if let Some(max) = find_max(&words) {
        println!("æœ€å¤§å•è¯: {}", max);
    }
    
    // ä½¿ç”¨æ³›å‹ç»“æ„ä½“
    let pair1 = Pair::new(42, "hello");
    let pair2 = Pair::new(String::from("Rust"), 100);
    
    println!("ç¬¬ä¸€ä¸ª: {}, ç¬¬äºŒä¸ª: {}", 
             pair1.get_first(), pair1.get_second());
    println!("{}", pair2.describe());
    
    // ä½¿ç”¨æ³›å‹å®¹å™¨
    let mut container = Container::new();
    container.add(1);
    container.add(2);
    container.add(3);
    
    container.print_all();
    println!("å®¹å™¨é•¿åº¦: {}", container.len());
}
```
</UniversalEditor>

### ç‰¹å¾çº¦æŸå’Œå…³è”ç±»å‹

<UniversalEditor title="ç‰¹å¾çº¦æŸ" compare={true}>
```rust !! rs
// ç‰¹å¾çº¦æŸ
trait Summary {
    fn summarize(&self) -> String;
}

trait Display {
    fn display(&self) -> String;
}

// å¤šä¸ªç‰¹å¾çº¦æŸ
fn print_summary<T: Summary + Display>(item: &T) {
    println!("æ‘˜è¦: {}", item.summarize());
    println!("æ˜¾ç¤º: {}", item.display());
}

// where å­å¥
fn complex_function<T, U>(t: &T, u: &U) -> String
where
    T: Summary + Display,
    U: Summary,
{
    format!("Tæ‘˜è¦: {}, Tæ˜¾ç¤º: {}, Uæ‘˜è¦: {}", 
            t.summarize(), t.display(), u.summarize())
}

// å…³è”ç±»å‹
trait Iterator {
    type Item;
    
    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {
    count: u32,
    max: u32,
}

impl Iterator for Counter {
    type Item = u32;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.count < self.max {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}

// é»˜è®¤ç±»å‹å‚æ•°
trait Add<Rhs = Self> {
    type Output;
    
    fn add(self, rhs: Rhs) -> Self::Output;
}

impl Add for i32 {
    type Output = i32;
    
    fn add(self, rhs: i32) -> i32 {
        self + rhs
    }
}

// ä½¿ç”¨ç‰¹å¾çº¦æŸå®ç°æ¡ä»¶æ–¹æ³•
struct Wrapper<T> {
    value: T,
}

impl<T> Wrapper<T> {
    fn new(value: T) -> Self {
        Wrapper { value }
    }
}

// åªæœ‰å®ç°äº† Display çš„ç±»å‹æ‰æœ‰è¿™ä¸ªæ–¹æ³•
impl<T: std::fmt::Display> Wrapper<T> {
    fn print(&self) {
        println!("å€¼: {}", self.value);
    }
}

// åªæœ‰å®ç°äº† Clone çš„ç±»å‹æ‰æœ‰è¿™ä¸ªæ–¹æ³•
impl<T: Clone> Wrapper<T> {
    fn duplicate(&self) -> Self {
        Wrapper {
            value: self.value.clone(),
        }
    }
}

fn main() {
    let counter = Counter { count: 0, max: 5 };
    let mut counter = counter;
    
    while let Some(value) = counter.next() {
        println!("è®¡æ•°: {}", value);
    }
    
    let wrapper1 = Wrapper::new(42);
    wrapper1.print(); // å¯ä»¥è°ƒç”¨ï¼Œå› ä¸º i32 å®ç°äº† Display
    let wrapper2 = wrapper1.duplicate(); // å¯ä»¥è°ƒç”¨ï¼Œå› ä¸º i32 å®ç°äº† Clone
    
    let wrapper3 = Wrapper::new("hello".to_string());
    wrapper3.print(); // å¯ä»¥è°ƒç”¨ï¼Œå› ä¸º String å®ç°äº† Display
    let wrapper4 = wrapper3.duplicate(); // å¯ä»¥è°ƒç”¨ï¼Œå› ä¸º String å®ç°äº† Clone
}
```
</UniversalEditor>

---

## ğŸ¯ ç»ƒä¹ é¢˜

### ç»ƒä¹  1: å®ç°ç‰¹å¾

ä¸ºä»¥ä¸‹ç»“æ„ä½“å®ç° `Display` å’Œ `Debug` ç‰¹å¾ï¼š

```rust
struct Point {
    x: f64,
    y: f64,
}
```

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use std::fmt;

struct Point {
    x: f64,
    y: f64,
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

impl fmt::Debug for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Point {{ x: {}, y: {} }}", self.x, self.y)
    }
}

fn main() {
    let point = Point { x: 3.0, y: 4.0 };
    println!("æ˜¾ç¤º: {}", point);
    println!("è°ƒè¯•: {:?}", point);
}
```

</details>

### ç»ƒä¹  2: æ³›å‹å‡½æ•°

åˆ›å»ºä¸€ä¸ªæ³›å‹å‡½æ•°ï¼Œå¯ä»¥æ¯”è¾ƒä¸¤ä¸ªå€¼çš„å¤§å°ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
fn compare<T: PartialOrd>(a: &T, b: &T) -> std::cmp::Ordering {
    a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)
}

fn main() {
    let result1 = compare(&5, &3);
    println!("5 ä¸ 3 æ¯”è¾ƒ: {:?}", result1); // Greater
    
    let result2 = compare(&"apple", &"banana");
    println!("apple ä¸ banana æ¯”è¾ƒ: {:?}", result2); // Less
    
    let result3 = compare(&3.14, &3.14);
    println!("3.14 ä¸ 3.14 æ¯”è¾ƒ: {:?}", result3); // Equal
}
```

</details>

### ç»ƒä¹  3: ç‰¹å¾å¯¹è±¡

åˆ›å»ºä¸€ä¸ªç‰¹å¾å¯¹è±¡ï¼Œå¯ä»¥å­˜å‚¨ä¸åŒç±»å‹çš„å¯æ‰“å°å¯¹è±¡ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
trait Printable {
    fn print(&self);
}

struct Book {
    title: String,
}

impl Printable for Book {
    fn print(&self) {
        println!("ä¹¦: {}", self.title);
    }
}

struct Movie {
    title: String,
}

impl Printable for Movie {
    fn print(&self) {
        println!("ç”µå½±: {}", self.title);
    }
}

fn main() {
    let items: Vec<Box<dyn Printable>> = vec![
        Box::new(Book { title: "Rust ç¼–ç¨‹".to_string() }),
        Box::new(Movie { title: "Rust çºªå½•ç‰‡".to_string() }),
    ];
    
    for item in items {
        item.print();
    }
}
```

</details>

---

## ğŸ“ æ€»ç»“

åœ¨è¿™ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº† Rust çš„ç±»å‹ç³»ç»Ÿå’Œç‰¹å¾ï¼š

1. **é™æ€ç±»å‹**: Rust åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥ç±»å‹ï¼Œé˜²æ­¢è¿è¡Œæ—¶é”™è¯¯
2. **ç‰¹å¾ç³»ç»Ÿ**: æä¾›æ¥å£æŠ½è±¡ï¼Œæ”¯æŒå¤šæ€ç¼–ç¨‹
3. **æ³›å‹ç¼–ç¨‹**: ç¼–å†™å¯é‡ç”¨çš„ç±»å‹æ— å…³ä»£ç 
4. **ç‰¹å¾çº¦æŸ**: é™åˆ¶æ³›å‹ç±»å‹å¿…é¡»å®ç°çš„ç‰¹å¾
5. **ä¸ JavaScript å¯¹æ¯”**: ç¼–è¯‘æ—¶å®‰å…¨ vs è¿è¡Œæ—¶çµæ´»æ€§

### å…³é”®è¦ç‚¹

- Rust çš„ç±»å‹ç³»ç»Ÿæä¾›ç¼–è¯‘æ—¶å®‰å…¨ä¿éšœ
- ç‰¹å¾ç³»ç»Ÿæ˜¯ Rust å¤šæ€çš„æ ¸å¿ƒæœºåˆ¶
- æ³›å‹å…è®¸ç¼–å†™ç±»å‹æ— å…³çš„é€šç”¨ä»£ç 
- ç‰¹å¾çº¦æŸç¡®ä¿ç±»å‹å…·æœ‰æ‰€éœ€çš„è¡Œä¸º

### ä¸‹ä¸€æ­¥å­¦ä¹ 

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹  Rust çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œäº†è§£å¦‚ä½•ä½¿ç”¨ `Result` å’Œ `Option` ç±»å‹ã€‚

---

**ç»§ç»­å­¦ä¹ **: [é”™è¯¯å¤„ç†ä¸ç±»å‹å®‰å…¨](./module-06-error-handling) 