---
title: "Web å¼€å‘å®æˆ˜"
description: "å­¦ä¹ ä½¿ç”¨ Rust è¿›è¡Œ Web å¼€å‘ï¼ŒåŒ…æ‹¬ Axum æ¡†æ¶ã€æ•°æ®åº“æ“ä½œå’Œ API è®¾è®¡ï¼Œå¯¹æ¯” JavaScript çš„ Web å¼€å‘"
---

# Web å¼€å‘å®æˆ˜

## ğŸ“– å­¦ä¹ ç›®æ ‡

å­¦ä¼šä½¿ç”¨ Rust æ„å»º Web åº”ç”¨ç¨‹åºï¼ŒæŒæ¡ Axum æ¡†æ¶ã€æ•°æ®åº“æ“ä½œã€API è®¾è®¡å’Œéƒ¨ç½²ï¼Œå¯¹æ¯” JavaScript çš„ Web å¼€å‘ç”Ÿæ€ã€‚

---

## ğŸ¯ Web æ¡†æ¶å¯¹æ¯”

### JavaScript çš„ Web å¼€å‘

JavaScript ä½¿ç”¨ Express.js ç­‰æ¡†æ¶ï¼š

<UniversalEditor title="JavaScript Web å¼€å‘" compare={true}>
```javascript !! js
// Express.js Web åº”ç”¨
const express = require('express');
const app = express();
const port = 3000;

// ä¸­é—´ä»¶
app.use(express.json());
app.use(express.static('public'));

// å†…å­˜æ•°æ®å­˜å‚¨
let users = [
    { id: 1, name: 'Alice', email: 'alice@example.com' },
    { id: 2, name: 'Bob', email: 'bob@example.com' }
];

// è·¯ç”±å®šä¹‰
app.get('/', (req, res) => {
    res.json({ message: 'Hello from Express!' });
});

// GET è·å–æ‰€æœ‰ç”¨æˆ·
app.get('/api/users', (req, res) => {
    res.json(users);
});

// GET è·å–å•ä¸ªç”¨æˆ·
app.get('/api/users/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const user = users.find(u => u.id === id);
    
    if (!user) {
        return res.status(404).json({ error: 'ç”¨æˆ·æœªæ‰¾åˆ°' });
    }
    
    res.json(user);
});

// POST åˆ›å»ºç”¨æˆ·
app.post('/api/users', (req, res) => {
    const { name, email } = req.body;
    
    if (!name || !email) {
        return res.status(400).json({ error: 'å§“åå’Œé‚®ç®±æ˜¯å¿…éœ€çš„' });
    }
    
    const newUser = {
        id: users.length + 1,
        name,
        email
    };
    
    users.push(newUser);
    res.status(201).json(newUser);
});

// PUT æ›´æ–°ç”¨æˆ·
app.put('/api/users/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const { name, email } = req.body;
    
    const userIndex = users.findIndex(u => u.id === id);
    if (userIndex === -1) {
        return res.status(404).json({ error: 'ç”¨æˆ·æœªæ‰¾åˆ°' });
    }
    
    users[userIndex] = { ...users[userIndex], name, email };
    res.json(users[userIndex]);
});

// DELETE åˆ é™¤ç”¨æˆ·
app.delete('/api/users/:id', (req, res) => {
    const id = parseInt(req.params.id);
    const userIndex = users.findIndex(u => u.id === id);
    
    if (userIndex === -1) {
        return res.status(404).json({ error: 'ç”¨æˆ·æœªæ‰¾åˆ°' });
    }
    
    users.splice(userIndex, 1);
    res.status(204).send();
});

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).json({ error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯' });
});

// 404 å¤„ç†
app.use((req, res) => {
    res.status(404).json({ error: 'è·¯ç”±æœªæ‰¾åˆ°' });
});

app.listen(port, () => {
    console.log(`æœåŠ¡å™¨è¿è¡Œåœ¨ http://localhost:${port}`);
});

// å¼‚æ­¥è·¯ç”±ç¤ºä¾‹
app.get('/api/async-data', async (req, res) => {
    try {
        // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
        const data = await new Promise(resolve => {
            setTimeout(() => {
                resolve({ message: 'å¼‚æ­¥æ•°æ®', timestamp: Date.now() });
            }, 1000);
        });
        
        res.json(data);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ä¸­é—´ä»¶ç¤ºä¾‹
const authMiddleware = (req, res, next) => {
    const token = req.headers.authorization;
    
    if (!token) {
        return res.status(401).json({ error: 'ç¼ºå°‘è®¤è¯ä»¤ç‰Œ' });
    }
    
    // éªŒè¯ä»¤ç‰Œé€»è¾‘
    req.user = { id: 1, name: 'Authenticated User' };
    next();
};

app.get('/api/protected', authMiddleware, (req, res) => {
    res.json({ message: 'å—ä¿æŠ¤çš„è·¯ç”±', user: req.user });
});
```
</UniversalEditor>

### Rust çš„ Web å¼€å‘

Rust ä½¿ç”¨ Axum æ¡†æ¶ï¼š

<UniversalEditor title="Rust Web å¼€å‘" compare={true}>
```rust !! rs
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tokio::sync::RwLock;

// æ•°æ®æ¨¡å‹
#[derive(Debug, Serialize, Deserialize, Clone)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// åº”ç”¨çŠ¶æ€
#[derive(Clone)]
struct AppState {
    users: Arc<RwLock<HashMap<u32, User>>>,
}

impl AppState {
    fn new() -> Self {
        let mut users = HashMap::new();
        users.insert(1, User {
            id: 1,
            name: String::from("Alice"),
            email: String::from("alice@example.com"),
        });
        users.insert(2, User {
            id: 2,
            name: String::from("Bob"),
            email: String::from("bob@example.com"),
        });
        
        AppState {
            users: Arc::new(RwLock::new(users)),
        }
    }
}

// è¯·æ±‚å’Œå“åº”ç±»å‹
#[derive(Debug, Deserialize)]
struct CreateUserRequest {
    name: String,
    email: String,
}

#[derive(Debug, Deserialize)]
struct UpdateUserRequest {
    name: Option<String>,
    email: Option<String>,
}

// è·¯ç”±å¤„ç†å‡½æ•°
async fn root() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "message": "Hello from Axum!"
    }))
}

async fn get_users(State(state): State<AppState>) -> Json<Vec<User>> {
    let users = state.users.read().await;
    let user_list: Vec<User> = users.values().cloned().collect();
    Json(user_list)
}

async fn get_user(
    State(state): State<AppState>,
    Path(id): Path<u32>,
) -> Result<Json<User>, StatusCode> {
    let users = state.users.read().await;
    
    if let Some(user) = users.get(&id) {
        Ok(Json(user.clone()))
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

async fn create_user(
    State(state): State<AppState>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<User>, StatusCode> {
    if payload.name.is_empty() || payload.email.is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }
    
    let mut users = state.users.write().await;
    let new_id = users.keys().max().unwrap_or(&0) + 1;
    
    let new_user = User {
        id: new_id,
        name: payload.name,
        email: payload.email,
    };
    
    users.insert(new_id, new_user.clone());
    Ok(Json(new_user))
}

async fn update_user(
    State(state): State<AppState>,
    Path(id): Path<u32>,
    Json(payload): Json<UpdateUserRequest>,
) -> Result<Json<User>, StatusCode> {
    let mut users = state.users.write().await;
    
    if let Some(user) = users.get_mut(&id) {
        if let Some(name) = payload.name {
            user.name = name;
        }
        if let Some(email) = payload.email {
            user.email = email;
        }
        Ok(Json(user.clone()))
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

async fn delete_user(
    State(state): State<AppState>,
    Path(id): Path<u32>,
) -> StatusCode {
    let mut users = state.users.write().await;
    
    if users.remove(&id).is_some() {
        StatusCode::NO_CONTENT
    } else {
        StatusCode::NOT_FOUND
    }
}

// å¼‚æ­¥æ•°æ®è·¯ç”±
async fn async_data() -> Json<serde_json::Value> {
    // æ¨¡æ‹Ÿå¼‚æ­¥æ“ä½œ
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    
    Json(serde_json::json!({
        "message": "å¼‚æ­¥æ•°æ®",
        "timestamp": chrono::Utc::now().timestamp()
    }))
}

// è®¤è¯ä¸­é—´ä»¶
async fn auth_middleware(
    headers: axum::http::HeaderMap,
) -> Result<(), StatusCode> {
    if let Some(auth_header) = headers.get("authorization") {
        if auth_header.to_str().unwrap_or("").starts_with("Bearer ") {
            return Ok(());
        }
    }
    Err(StatusCode::UNAUTHORIZED)
}

async fn protected_route() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "message": "å—ä¿æŠ¤çš„è·¯ç”±",
        "user": {
            "id": 1,
            "name": "Authenticated User"
        }
    }))
}

// åˆ›å»ºè·¯ç”±
fn create_router() -> Router {
    let state = AppState::new();
    
    Router::new()
        .route("/", get(root))
        .route("/api/users", get(get_users))
        .route("/api/users", post(create_user))
        .route("/api/users/:id", get(get_user))
        .route("/api/users/:id", put(update_user))
        .route("/api/users/:id", delete(delete_user))
        .route("/api/async-data", get(async_data))
        .route("/api/protected", get(protected_route))
        .with_state(state)
}

#[tokio::main]
async fn main() {
    let app = create_router();
    
    println!("æœåŠ¡å™¨è¿è¡Œåœ¨ http://localhost:3000");
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();
    
    axum::serve(listener, app).await.unwrap();
}
```
</UniversalEditor>

### Web æ¡†æ¶å·®å¼‚

1. **æ€§èƒ½**: Rust ç¼–è¯‘åˆ°æœºå™¨ç ï¼Œæ€§èƒ½æ›´é«˜
2. **ç±»å‹å®‰å…¨**: Rust ç¼–è¯‘æ—¶æ£€æŸ¥ï¼ŒJavaScript è¿è¡Œæ—¶æ£€æŸ¥
3. **å†…å­˜å®‰å…¨**: Rust æ— æ•°æ®ç«äº‰ï¼ŒJavaScript å•çº¿ç¨‹äº‹ä»¶å¾ªç¯
4. **ç”Ÿæ€ç³»ç»Ÿ**: JavaScript ç”Ÿæ€æ›´æˆç†Ÿï¼ŒRust ç”Ÿæ€æ­£åœ¨å¿«é€Ÿå‘å±•

---

## ğŸ—„ï¸ æ•°æ®åº“æ“ä½œ

### ä½¿ç”¨ SQLx è¿›è¡Œæ•°æ®åº“æ“ä½œ

<UniversalEditor title="æ•°æ®åº“æ“ä½œ" compare={true}>
```rust !! rs
use sqlx::{postgres::PgPoolOptions, PgPool, Row};
use serde::{Deserialize, Serialize};

// æ•°æ®æ¨¡å‹
#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: Option<i32>,
    name: String,
    email: String,
    created_at: Option<chrono::DateTime<chrono::Utc>>,
}

// æ•°æ®åº“æ“ä½œ
struct UserRepository {
    pool: PgPool,
}

impl UserRepository {
    fn new(pool: PgPool) -> Self {
        Self { pool }
    }
    
    async fn create_user(&self, user: &User) -> Result<User, sqlx::Error> {
        let row = sqlx::query_as!(
            User,
            r#"
            INSERT INTO users (name, email)
            VALUES ($1, $2)
            RETURNING id, name, email, created_at
            "#,
            user.name,
            user.email
        )
        .fetch_one(&self.pool)
        .await?;
        
        Ok(row)
    }
    
    async fn get_user(&self, id: i32) -> Result<Option<User>, sqlx::Error> {
        let user = sqlx::query_as!(
            User,
            r#"
            SELECT id, name, email, created_at
            FROM users
            WHERE id = $1
            "#,
            id
        )
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(user)
    }
    
    async fn get_all_users(&self) -> Result<Vec<User>, sqlx::Error> {
        let users = sqlx::query_as!(
            User,
            r#"
            SELECT id, name, email, created_at
            FROM users
            ORDER BY created_at DESC
            "#
        )
        .fetch_all(&self.pool)
        .await?;
        
        Ok(users)
    }
    
    async fn update_user(&self, id: i32, user: &User) -> Result<Option<User>, sqlx::Error> {
        let updated_user = sqlx::query_as!(
            User,
            r#"
            UPDATE users
            SET name = $1, email = $2
            WHERE id = $3
            RETURNING id, name, email, created_at
            "#,
            user.name,
            user.email,
            id
        )
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(updated_user)
    }
    
    async fn delete_user(&self, id: i32) -> Result<bool, sqlx::Error> {
        let result = sqlx::query!(
            r#"
            DELETE FROM users
            WHERE id = $1
            "#,
            id
        )
        .execute(&self.pool)
        .await?;
        
        Ok(result.rows_affected() > 0)
    }
}

// åº”ç”¨çŠ¶æ€
#[derive(Clone)]
struct AppState {
    user_repo: UserRepository,
}

// è·¯ç”±å¤„ç†å‡½æ•°
async fn create_user_handler(
    State(state): State<AppState>,
    Json(user): Json<User>,
) -> Result<Json<User>, StatusCode> {
    let created_user = state.user_repo
        .create_user(&user)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(created_user))
}

async fn get_user_handler(
    State(state): State<AppState>,
    Path(id): Path<i32>,
) -> Result<Json<User>, StatusCode> {
    let user = state.user_repo
        .get_user(id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;
    
    Ok(Json(user))
}

async fn get_users_handler(
    State(state): State<AppState>,
) -> Result<Json<Vec<User>>, StatusCode> {
    let users = state.user_repo
        .get_all_users()
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(users))
}

async fn update_user_handler(
    State(state): State<AppState>,
    Path(id): Path<i32>,
    Json(user): Json<User>,
) -> Result<Json<User>, StatusCode> {
    let updated_user = state.user_repo
        .update_user(id, &user)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;
    
    Ok(Json(updated_user))
}

async fn delete_user_handler(
    State(state): State<AppState>,
    Path(id): Path<i32>,
) -> StatusCode {
    let deleted = state.user_repo
        .delete_user(id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    if deleted {
        StatusCode::NO_CONTENT
    } else {
        StatusCode::NOT_FOUND
    }
}

// æ•°æ®åº“åˆå§‹åŒ–
async fn init_database(pool: &PgPool) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        )
        "#
    )
    .execute(pool)
    .await?;
    
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // æ•°æ®åº“è¿æ¥
    let database_url = std::env::var("DATABASE_URL")
        .unwrap_or_else(|_| "postgres://user:password@localhost/rust_web".to_string());
    
    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;
    
    // åˆå§‹åŒ–æ•°æ®åº“
    init_database(&pool).await?;
    
    // åˆ›å»ºåº”ç”¨çŠ¶æ€
    let user_repo = UserRepository::new(pool);
    let state = AppState { user_repo };
    
    // åˆ›å»ºè·¯ç”±
    let app = Router::new()
        .route("/api/users", post(create_user_handler))
        .route("/api/users", get(get_users_handler))
        .route("/api/users/:id", get(get_user_handler))
        .route("/api/users/:id", put(update_user_handler))
        .route("/api/users/:id", delete(delete_user_handler))
        .with_state(state);
    
    println!("æœåŠ¡å™¨è¿è¡Œåœ¨ http://localhost:3000");
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}
```
</UniversalEditor>

---

## ğŸ” è®¤è¯ä¸æˆæƒ

### JWT è®¤è¯å®ç°

<UniversalEditor title="JWT è®¤è¯" compare={true}>
```rust !! rs
use axum::{
    extract::{Request, State},
    http::StatusCode,
    middleware::Next,
    response::Response,
};
use jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

// JWT å£°æ˜
#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String, // ç”¨æˆ·ID
    exp: usize,  // è¿‡æœŸæ—¶é—´
    iat: usize,  // ç­¾å‘æ—¶é—´
}

// ç”¨æˆ·æ¨¡å‹
#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: String,
    username: String,
    password_hash: String,
}

// è®¤è¯è¯·æ±‚
#[derive(Debug, Deserialize)]
struct LoginRequest {
    username: String,
    password: String,
}

// è®¤è¯å“åº”
#[derive(Debug, Serialize)]
struct AuthResponse {
    token: String,
    user: User,
}

// è®¤è¯ä¸­é—´ä»¶
async fn auth_middleware(
    State(state): State<AppState>,
    mut request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    let auth_header = request
        .headers()
        .get("authorization")
        .and_then(|header| header.to_str().ok())
        .and_then(|header| header.strip_prefix("Bearer "));
    
    if let Some(token) = auth_header {
        if let Ok(claims) = decode_token(token, &state.jwt_secret) {
            // å°†ç”¨æˆ·ä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚ä¸­
            request.extensions_mut().insert(claims);
            return Ok(next.run(request).await);
        }
    }
    
    Err(StatusCode::UNAUTHORIZED)
}

// JWT å·¥å…·å‡½æ•°
fn create_token(user_id: &str, secret: &str) -> Result<String, jsonwebtoken::errors::Error> {
    let now = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_secs() as usize;
    
    let claims = Claims {
        sub: user_id.to_string(),
        exp: now + (24 * 60 * 60), // 24å°æ—¶è¿‡æœŸ
        iat: now,
    };
    
    encode(
        &Header::default(),
        &claims,
        &EncodingKey::from_secret(secret.as_ref()),
    )
}

fn decode_token(token: &str, secret: &str) -> Result<Claims, jsonwebtoken::errors::Error> {
    decode::<Claims>(
        token,
        &DecodingKey::from_secret(secret.as_ref()),
        &Validation::default(),
    )
    .map(|data| data.claims)
}

// åº”ç”¨çŠ¶æ€
#[derive(Clone)]
struct AppState {
    jwt_secret: String,
    users: Arc<RwLock<HashMap<String, User>>>,
}

impl AppState {
    fn new() -> Self {
        let mut users = HashMap::new();
        users.insert(
            "1".to_string(),
            User {
                id: "1".to_string(),
                username: "alice".to_string(),
                password_hash: "hashed_password".to_string(),
            },
        );
        
        Self {
            jwt_secret: "your-secret-key".to_string(),
            users: Arc::new(RwLock::new(users)),
        }
    }
}

// è®¤è¯è·¯ç”±
async fn login(
    State(state): State<AppState>,
    Json(login_req): Json<LoginRequest>,
) -> Result<Json<AuthResponse>, StatusCode> {
    let users = state.users.read().await;
    
    // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œåº”è¯¥éªŒè¯å¯†ç å“ˆå¸Œ
    if let Some(user) = users.values().find(|u| u.username == login_req.username) {
        let token = create_token(&user.id, &state.jwt_secret)
            .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        
        Ok(Json(AuthResponse {
            token,
            user: User {
                id: user.id.clone(),
                username: user.username.clone(),
                password_hash: String::new(), // ä¸è¿”å›å¯†ç å“ˆå¸Œ
            },
        }))
    } else {
        Err(StatusCode::UNAUTHORIZED)
    }
}

async fn protected_route(
    Extension(claims): Extension<Claims>,
) -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "message": "å—ä¿æŠ¤çš„è·¯ç”±",
        "user_id": claims.sub
    }))
}

// åˆ›å»ºå¸¦è®¤è¯çš„è·¯ç”±
fn create_auth_router() -> Router {
    let state = AppState::new();
    
    Router::new()
        .route("/auth/login", post(login))
        .route("/protected", get(protected_route))
        .route_layer(axum::middleware::from_fn_with_state(
            state.clone(),
            auth_middleware,
        ))
        .with_state(state)
}

#[tokio::main]
async fn main() {
    let app = create_auth_router();
    
    println!("è®¤è¯æœåŠ¡å™¨è¿è¡Œåœ¨ http://localhost:3000");
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();
    
    axum::serve(listener, app).await.unwrap();
}
```
</UniversalEditor>

---

## ğŸ¯ ç»ƒä¹ é¢˜

### ç»ƒä¹  1: åˆ›å»ºç®€å•çš„ API

åˆ›å»ºä¸€ä¸ªç®€å•çš„å¾…åŠäº‹é¡¹ APIï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Debug, Serialize, Deserialize, Clone)]
struct Todo {
    id: u32,
    title: String,
    completed: bool,
}

#[derive(Debug, Deserialize)]
struct CreateTodoRequest {
    title: String,
}

#[derive(Clone)]
struct AppState {
    todos: Arc<RwLock<HashMap<u32, Todo>>>,
}

impl AppState {
    fn new() -> Self {
        Self {
            todos: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}

async fn get_todos(State(state): State<AppState>) -> Json<Vec<Todo>> {
    let todos = state.todos.read().await;
    let todo_list: Vec<Todo> = todos.values().cloned().collect();
    Json(todo_list)
}

async fn create_todo(
    State(state): State<AppState>,
    Json(payload): Json<CreateTodoRequest>,
) -> Json<Todo> {
    let mut todos = state.todos.write().await;
    let new_id = todos.keys().max().unwrap_or(&0) + 1;
    
    let new_todo = Todo {
        id: new_id,
        title: payload.title,
        completed: false,
    };
    
    todos.insert(new_id, new_todo.clone());
    Json(new_todo)
}

async fn toggle_todo(
    State(state): State<AppState>,
    Path(id): Path<u32>,
) -> Result<Json<Todo>, StatusCode> {
    let mut todos = state.todos.write().await;
    
    if let Some(todo) = todos.get_mut(&id) {
        todo.completed = !todo.completed;
        Ok(Json(todo.clone()))
    } else {
        Err(StatusCode::NOT_FOUND)
    }
}

async fn delete_todo(
    State(state): State<AppState>,
    Path(id): Path<u32>,
) -> StatusCode {
    let mut todos = state.todos.write().await;
    
    if todos.remove(&id).is_some() {
        StatusCode::NO_CONTENT
    } else {
        StatusCode::NOT_FOUND
    }
}

#[tokio::main]
async fn main() {
    let state = AppState::new();
    
    let app = Router::new()
        .route("/api/todos", get(get_todos))
        .route("/api/todos", post(create_todo))
        .route("/api/todos/:id/toggle", put(toggle_todo))
        .route("/api/todos/:id", delete(delete_todo))
        .with_state(state);
    
    println!("å¾…åŠäº‹é¡¹ API è¿è¡Œåœ¨ http://localhost:3000");
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();
    
    axum::serve(listener, app).await.unwrap();
}
```

</details>

### ç»ƒä¹  2: æ·»åŠ ä¸­é—´ä»¶

ä¸º API æ·»åŠ æ—¥å¿—ä¸­é—´ä»¶å’Œé”™è¯¯å¤„ç†ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use axum::{
    extract::{Request, State},
    http::StatusCode,
    middleware::Next,
    response::Response,
    routing::{get, post},
    Router,
};
use std::time::Instant;
use tower_http::trace::TraceLayer;

async fn logging_middleware(
    request: Request,
    next: Next,
) -> Response {
    let start = Instant::now();
    let method = request.method().clone();
    let uri = request.uri().clone();
    
    let response = next.run(request).await;
    
    let duration = start.elapsed();
    println!(
        "{} {} - {} - {:?}",
        method,
        uri,
        response.status(),
        duration
    );
    
    response
}

async fn error_handler(
    State(state): State<AppState>,
    request: Request,
    next: Next,
) -> Result<Response, StatusCode> {
    match next.run(request).await {
        response if response.status().is_success() => Ok(response),
        response => {
            println!("é”™è¯¯å“åº”: {}", response.status());
            Ok(response)
        }
    }
}

fn create_router_with_middleware() -> Router {
    let state = AppState::new();
    
    Router::new()
        .route("/", get(|| async { "Hello World" }))
        .route("/api/test", post(|| async { "Test endpoint" }))
        .layer(TraceLayer::new_for_http())
        .route_layer(axum::middleware::from_fn(logging_middleware))
        .with_state(state)
}
```

</details>

### ç»ƒä¹  3: æ•°æ®åº“é›†æˆ

åˆ›å»ºä¸€ä¸ªç®€å•çš„ç”¨æˆ·ç®¡ç† APIï¼Œé›†æˆ SQLite æ•°æ®åº“ï¼š

<details>
<summary>æŸ¥çœ‹ç­”æ¡ˆ</summary>

```rust
use axum::{
    extract::{Path, State},
    http::StatusCode,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use sqlx::sqlite::SqlitePool;

#[derive(Debug, Serialize, Deserialize)]
struct User {
    id: Option<i32>,
    name: String,
    email: String,
}

#[derive(Clone)]
struct AppState {
    pool: SqlitePool,
}

async fn create_user(
    State(state): State<AppState>,
    Json(user): Json<User>,
) -> Result<Json<User>, StatusCode> {
    let user = sqlx::query_as!(
        User,
        r#"
        INSERT INTO users (name, email)
        VALUES (?, ?)
        RETURNING id, name, email
        "#,
        user.name,
        user.email
    )
    .fetch_one(&state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(user))
}

async fn get_users(State(state): State<AppState>) -> Result<Json<Vec<User>>, StatusCode> {
    let users = sqlx::query_as!(
        User,
        r#"
        SELECT id, name, email
        FROM users
        "#
    )
    .fetch_all(&state.pool)
    .await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(users))
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let pool = SqlitePool::connect("sqlite:users.db").await?;
    
    // åˆ›å»ºè¡¨
    sqlx::query(
        r#"
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            email TEXT UNIQUE NOT NULL
        )
        "#
    )
    .execute(&pool)
    .await?;
    
    let state = AppState { pool };
    
    let app = Router::new()
        .route("/api/users", post(create_user))
        .route("/api/users", get(get_users))
        .with_state(state);
    
    println!("ç”¨æˆ· API è¿è¡Œåœ¨ http://localhost:3000");
    
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await?;
    axum::serve(listener, app).await?;
    
    Ok(())
}
```

</details>

---

## ğŸ“ æ€»ç»“

åœ¨è¿™ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å­¦ä¹ äº† Rust çš„ Web å¼€å‘ï¼š

1. **Axum æ¡†æ¶**: é«˜æ€§èƒ½çš„ Rust Web æ¡†æ¶
2. **æ•°æ®åº“æ“ä½œ**: ä½¿ç”¨ SQLx è¿›è¡Œç±»å‹å®‰å…¨çš„æ•°æ®åº“æ“ä½œ
3. **è®¤è¯æˆæƒ**: JWT è®¤è¯å’Œä¸­é—´ä»¶å®ç°
4. **API è®¾è®¡**: RESTful API è®¾è®¡å’Œé”™è¯¯å¤„ç†
5. **ä¸ JavaScript å¯¹æ¯”**: æ€§èƒ½ã€ç±»å‹å®‰å…¨å’Œç”Ÿæ€ç³»ç»Ÿå·®å¼‚

### å…³é”®è¦ç‚¹

- Rust Web å¼€å‘æä¾›æ›´å¥½çš„æ€§èƒ½å’Œç±»å‹å®‰å…¨
- Axum æ¡†æ¶ç®€æ´é«˜æ•ˆï¼Œé€‚åˆæ„å»º API
- SQLx æä¾›ç¼–è¯‘æ—¶ SQL æŸ¥è¯¢éªŒè¯
- JWT è®¤è¯ç¡®ä¿ API å®‰å…¨æ€§

### ä¸‹ä¸€æ­¥å­¦ä¹ 

åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†å­¦ä¹  Rust çš„ç³»ç»Ÿçº§ç¼–ç¨‹å’Œé«˜çº§ä¸»é¢˜ï¼ŒåŒ…æ‹¬ unsafe ä»£ç ã€å®ç³»ç»Ÿå’Œæ€§èƒ½ä¼˜åŒ–ã€‚

---

**ç»§ç»­å­¦ä¹ **: [ç³»ç»Ÿçº§ç¼–ç¨‹ä¸é«˜çº§ä¸»é¢˜](./module-08-systems-programming.zh-cn.mdx) 