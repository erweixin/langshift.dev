---
title: "ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆèˆ‡é€²éšä¸»é¡Œ"
description: "å­¸ç¿’ Rust çš„ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆç‰¹æ€§ï¼ŒåŒ…æ‹¬ unsafe ç¨‹å¼ç¢¼ã€å·¨é›†ç³»çµ±ã€æ•ˆèƒ½æœ€ä½³åŒ–å’Œåº•å±¤ç¨‹å¼è¨­è¨ˆ"
---

# ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆèˆ‡é€²éšä¸»é¡Œ

## ğŸ“– å­¸ç¿’ç›®æ¨™

ç†è§£ Rust çš„ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆç‰¹æ€§ï¼Œå­¸æœƒä½¿ç”¨ unsafe ç¨‹å¼ç¢¼ã€å·¨é›†ç³»çµ±ã€æ•ˆèƒ½æœ€ä½³åŒ–æŠ€è¡“ï¼ŒæŒæ¡åº•å±¤ç¨‹å¼è¨­è¨ˆæ¦‚å¿µã€‚

---

## ğŸ¯ ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆå°æ¯”

### JavaScript çš„é«˜éšæŠ½è±¡

JavaScript åŸ·è¡Œåœ¨è™›æ“¬æ©Ÿå™¨ä¸­ï¼Œæä¾›é«˜éšæŠ½è±¡ï¼š

<UniversalEditor title="JavaScript é«˜éšæŠ½è±¡" compare={true}>
```javascript !! js
// JavaScript é«˜éšæŠ½è±¡ç¯„ä¾‹
class MemoryManager {
    constructor() {
        this.memory = new Map();
        this.gcStats = {
            collections: 0,
            freedMemory: 0
        };
    }
    
    // åˆ†é…è¨˜æ†¶é«”ï¼ˆJavaScript è‡ªå‹•ç®¡ç†ï¼‰
    allocate(key, data) {
        this.memory.set(key, data);
        console.log(`åˆ†é…è¨˜æ†¶é«”: ${key}`);
    }
    
    // é‡‹æ”¾è¨˜æ†¶é«”ï¼ˆJavaScript è‡ªå‹•åƒåœ¾å›æ”¶ï¼‰
    deallocate(key) {
        this.memory.delete(key);
        console.log(`é‡‹æ”¾è¨˜æ†¶é«”: ${key}`);
    }
    
    // æ‰‹å‹•è§¸ç™¼åƒåœ¾å›æ”¶ï¼ˆåƒ…åœ¨æŸäº›ç’°å¢ƒä¸­å¯ç”¨ï¼‰
    forceGarbageCollection() {
        if (global.gc) {
            global.gc();
            this.gcStats.collections++;
            console.log('å¼·åˆ¶åƒåœ¾å›æ”¶');
        }
    }
    
    // è¨˜æ†¶é«”ä½¿ç”¨çµ±è¨ˆ
    getMemoryUsage() {
        if (process.memoryUsage) {
            const usage = process.memoryUsage();
            return {
                rss: usage.rss,
                heapUsed: usage.heapUsed,
                heapTotal: usage.heapTotal,
                external: usage.external
            };
        }
        return null;
    }
}

// ä½¿ç”¨ç¯„ä¾‹
const memoryManager = new MemoryManager();

// åˆ†é…å¤§é‡è³‡æ–™
for (let i = 0; i < 1000; i++) {
    memoryManager.allocate(`key${i}`, {
        id: i,
        data: 'x'.repeat(1000), // 1KB è³‡æ–™
        timestamp: Date.now()
    });
}

console.log('è¨˜æ†¶é«”ä½¿ç”¨æƒ…æ³:', memoryManager.getMemoryUsage());

// é‡‹æ”¾éƒ¨åˆ†è³‡æ–™
for (let i = 0; i < 500; i++) {
    memoryManager.deallocate(`key${i}`);
}

// å¼·åˆ¶åƒåœ¾å›æ”¶
memoryManager.forceGarbageCollection();

console.log('åƒåœ¾å›æ”¶å¾Œè¨˜æ†¶é«”ä½¿ç”¨:', memoryManager.getMemoryUsage());

// åº•å±¤æ“ä½œæ¨¡æ“¬ï¼ˆJavaScript é™åˆ¶ï¼‰
class LowLevelOperations {
    // æ¨¡æ“¬æŒ‡æ¨™æ“ä½œï¼ˆJavaScript æ²’æœ‰çœŸæ­£çš„æŒ‡æ¨™ï¼‰
    createPointer() {
        return {
            address: Math.random().toString(16),
            value: null,
            dereference() {
                return this.value;
            },
            assign(value) {
                this.value = value;
            }
        };
    }
    
    // æ¨¡æ“¬è¨˜æ†¶é«”ä½ˆå±€
    createMemoryLayout() {
        return {
            stack: [],
            heap: new Map(),
            allocateOnStack(value) {
                this.stack.push(value);
                return this.stack.length - 1;
            },
            allocateOnHeap(key, value) {
                this.heap.set(key, value);
                return key;
            }
        };
    }
    
    // æ¨¡æ“¬ç³»çµ±å‘¼å«
    systemCall(operation, data) {
        console.log(`ç³»çµ±å‘¼å«: ${operation}`, data);
        // åœ¨å¯¦éš›ç’°å¢ƒä¸­ï¼Œé€™äº›æ“ä½œæœƒè¢« JavaScript å¼•æ“è™•ç†
        return {
            success: true,
            result: `æ¨¡æ“¬ ${operation} çµæœ`,
            timestamp: Date.now()
        };
    }
}

// ä½¿ç”¨åº•å±¤æ“ä½œ
const lowLevel = new LowLevelOperations();

const pointer = lowLevel.createPointer();
pointer.assign("Hello, World!");
console.log("æŒ‡æ¨™å€¼:", pointer.dereference());

const memory = lowLevel.createMemoryLayout();
const stackAddr = memory.allocateOnStack(42);
const heapAddr = memory.allocateOnHeap("dynamic", "data");

console.log("å †ç–Šä½å€:", stackAddr, "å€¼:", memory.stack[stackAddr]);
console.log("å †ç©ä½å€:", heapAddr, "å€¼:", memory.heap.get(heapAddr));

// æ¨¡æ“¬ç³»çµ±å‘¼å«
const syscall = lowLevel.systemCall("read", { file: "test.txt", size: 1024 });
console.log("ç³»çµ±å‘¼å«çµæœ:", syscall);
```
</UniversalEditor>

### Rust çš„ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆ

Rust æä¾›ç›´æ¥çš„è¨˜æ†¶é«”æ§åˆ¶å’Œç³»çµ±ç´šå­˜å–ï¼š

<UniversalEditor title="Rust ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆ" compare={true}>
```rust !! rs
use std::alloc::{alloc, dealloc, Layout};
use std::collections::HashMap;
use std::ptr;
use std::mem;

// è‡ªè¨‚è¨˜æ†¶é«”ç®¡ç†å™¨
struct MemoryManager {
    allocations: HashMap<usize, Layout>,
    total_allocated: usize,
}

impl MemoryManager {
    fn new() -> Self {
        Self {
            allocations: HashMap::new(),
            total_allocated: 0,
        }
    }
    
    // æ‰‹å‹•åˆ†é…è¨˜æ†¶é«”
    unsafe fn allocate(&mut self, size: usize, align: usize) -> *mut u8 {
        let layout = Layout::from_size_align(size, align).unwrap();
        let ptr = alloc(layout);
        
        if !ptr.is_null() {
            self.allocations.insert(ptr as usize, layout);
            self.total_allocated += size;
            println!("åˆ†é…è¨˜æ†¶é«”: {} ä½å…ƒçµ„ï¼Œä½å€: {:p}", size, ptr);
        }
        
        ptr
    }
    
    // æ‰‹å‹•é‡‹æ”¾è¨˜æ†¶é«”
    unsafe fn deallocate(&mut self, ptr: *mut u8) {
        if let Some(layout) = self.allocations.remove(&(ptr as usize)) {
            dealloc(ptr, layout);
            self.total_allocated -= layout.size();
            println!("é‡‹æ”¾è¨˜æ†¶é«”: {} ä½å…ƒçµ„ï¼Œä½å€: {:p}", layout.size(), ptr);
        }
    }
    
    // å–å¾—è¨˜æ†¶é«”ä½¿ç”¨çµ±è¨ˆ
    fn get_stats(&self) -> (usize, usize) {
        (self.total_allocated, self.allocations.len())
    }
}

// æ™ºæ…§æŒ‡æ¨™å¯¦ä½œ
struct SmartPtr<T> {
    ptr: *mut T,
    manager: *mut MemoryManager,
}

impl<T> SmartPtr<T> {
    unsafe fn new(value: T, manager: &mut MemoryManager) -> Self {
        let size = mem::size_of::<T>();
        let align = mem::align_of::<T>();
        let ptr = manager.allocate(size, align) as *mut T;
        
        if !ptr.is_null() {
            ptr::write(ptr, value);
        }
        
        Self {
            ptr,
            manager: manager as *mut MemoryManager,
        }
    }
    
    fn get(&self) -> Option<&T> {
        if self.ptr.is_null() { None } else { unsafe { Some(&*self.ptr) } }
    }
    
    fn get_mut(&mut self) -> Option<&mut T> {
        if self.ptr.is_null() { None } else { unsafe { Some(&mut *self.ptr) } }
    }
}

impl<T> Drop for SmartPtr<T> {
    fn drop(&mut self) {
        if !self.ptr.is_null() {
            unsafe {
                ptr::drop_in_place(self.ptr);
                (*self.manager).deallocate(self.ptr as *mut u8);
            }
        }
    }
}

fn main() {
    let mut manager = MemoryManager::new();

    // åˆ†é…è¨˜æ†¶é«”ä¸¦ä½¿ç”¨æ™ºæ…§æŒ‡æ¨™
    unsafe {
        let mut data1 = SmartPtr::new(100i32, &mut manager);
        let mut data2 = SmartPtr::new([0u8; 1024], &mut manager);
        
        if let Some(val) = data1.get_mut() {
            *val = 200;
        }
        
        println!("data1 çš„å€¼: {:?}", data1.get());
        println!("çµ±è¨ˆ: {} ä½å…ƒçµ„, {} å€‹åˆ†é…", manager.get_stats().0, manager.get_stats().1);
    } // data1 å’Œ data2 åœ¨æ­¤è¢«ä¸Ÿæ£„ï¼Œé‡‹æ”¾è¨˜æ†¶é«”
    
    println!("ä¸Ÿæ£„å¾Œçµ±è¨ˆ: {} ä½å…ƒçµ„, {} å€‹åˆ†é…", manager.get_stats().0, manager.get_stats().1);
}
```
</UniversalEditor>

### ç³»çµ±ç¨‹å¼è¨­è¨ˆå·®ç•°

1.  **è¨˜æ†¶é«”ç®¡ç†**: Rust å…è¨±ä½¿ç”¨ `unsafe` é€²è¡Œæ‰‹å‹•è¨˜æ†¶é«”ç®¡ç†ï¼Œè€Œ JavaScript æœ‰è‡ªå‹•åƒåœ¾å›æ”¶ã€‚
2.  **æŒ‡æ¨™**: Rust æœ‰çœŸæ­£çš„æŒ‡æ¨™ï¼Œè€Œ JavaScript æ²’æœ‰ã€‚
3.  **æ•ˆèƒ½**: Rust æä¾›å°æ•ˆèƒ½çš„ç²¾ç´°æ§åˆ¶ï¼Œè€Œ JavaScript çš„æ•ˆèƒ½ç”±å…¶å¼•æ“ç®¡ç†ã€‚
4.  **å®‰å…¨æ€§**: Rust çš„ `unsafe` å€å¡Šå…è¨±ç¹éå®‰å…¨æª¢æŸ¥ï¼Œéœ€è¦è¬¹æ…è™•ç†ã€‚

---

## ğŸ”§ å·¨é›†ç³»çµ±

### ç¨‹åºæ€§ vs. å®£å‘Šå¼å·¨é›†

<UniversalEditor title="Rust å·¨é›†ç³»çµ±" compare={true}>
```rust !! rs
// å®£å‘Šå¼å·¨é›† (macro_rules!)
macro_rules! my_vec {
    ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}

// ç¨‹åºæ€§å·¨é›† (è‡ªè¨‚ derive)
// é€™éœ€è¦åœ¨ Cargo.toml ä¸­æ–°å¢ä¸€å€‹ crate ä¸¦è¨­å®š `proc-macro = true`
/*
extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(MyTrait)]
pub fn my_trait_derive(input: TokenStream) -> TokenStream {
    let ast = syn::parse(input).unwrap();
    impl_my_trait(&ast)
}

fn impl_my_trait(ast: &syn::DeriveInput) -> TokenStream {
    let name = &ast.ident;
    let gen = quote! {
        impl MyTrait for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    gen.into()
}
*/

trait MyTrait {
    fn hello_macro();
}

// ä½¿ç”¨å®£å‘Šå¼å·¨é›†
fn use_declarative_macro() {
    let v = my_vec![1, 2, 3];
    println!("{:?}", v);
}

// ä½¿ç”¨ç¨‹åºæ€§å·¨é›† (æ¦‚å¿µæ€§)
// #[derive(MyTrait)]
// struct MyStruct;

fn main() {
    use_declarative_macro();
    // MyStruct::hello_macro();
}
```
</UniversalEditor>

### å·¨é›†çš„é—œéµæ¦‚å¿µ

1.  **ç¨‹å¼ç¢¼ç”¢ç”Ÿ**: å·¨é›†åœ¨ç·¨è­¯æ™‚å¯«å…¥ç¨‹å¼ç¢¼ï¼Œæ¸›å°‘æ¨£æ¿ç¨‹å¼ç¢¼ã€‚
2.  **å®£å‘Šå¼å·¨é›†**: ä½¿ç”¨ `macro_rules!` é€²è¡Œç°¡å–®çš„æ¨¡å¼åŒ¹é…å·¨é›†ã€‚
3.  **ç¨‹åºæ€§å·¨é›†**: åŠŸèƒ½æ›´å¼·å¤§çš„å·¨é›†ï¼Œç”¨æ–¼è‡ªè¨‚ deriveã€å±¬æ€§å’Œå‡½å¼å‹å·¨é›†ã€‚
4.  **é ˜åŸŸç‰¹å®šèªè¨€ (DSLs)**: å·¨é›†å¯ç”¨æ–¼å»ºç«‹åµŒå…¥å¼ DSLã€‚

---

## âš¡ æ•ˆèƒ½æœ€ä½³åŒ–

### åŸºæº–æ¸¬è©¦èˆ‡åˆ†æ

<UniversalEditor title="Rust æ•ˆèƒ½æœ€ä½³åŒ–" compare={true}>
```rust !! rs
// ä½¿ç”¨ Criterion é€²è¡ŒåŸºæº–æ¸¬è©¦
// é€™éœ€è¦åœ¨ [dev-dependencies] ä¸­åŠ å…¥ `criterion`
/*
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 1,
        1 => 1,
        n => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

fn criterion_benchmark(c: &mut Criterion) {
    c.bench_function("fib 20", |b| b.iter(|| fibonacci(black_box(20))));
}

criterion_group!(benches, criterion_benchmark);
criterion_main!(benches);
*/

// ä½¿ç”¨ `perf` é€²è¡Œåˆ†æ (Linux)
// 1. cargo build --release
// 2. perf record ./target/release/my_app
// 3. perf report

// é›¶æˆæœ¬æŠ½è±¡ç¯„ä¾‹
fn use_iterator() {
    let numbers = vec![1, 2, 3, 4, 5];
    // é€™å€‹è¿­ä»£å™¨éˆæœƒç·¨è­¯æˆé«˜æ•ˆçš„æ©Ÿå™¨ç¢¼
    let sum: i32 = numbers.iter().map(|&x| x * 2).filter(|&x| x > 5).sum();
    println!("ç¸½å’Œ: {}", sum);
}

fn main() {
    use_iterator();
}
```
</UniversalEditor>

### æœ€ä½³åŒ–æŠ€è¡“

1.  **åŸºæº–æ¸¬è©¦**: ä½¿ç”¨ Criterion ç­‰å·¥å…·æ¸¬é‡æ•ˆèƒ½ã€‚
2.  **åˆ†æ**: ä½¿ç”¨ `perf` ç­‰å·¥å…·æ‰¾å‡ºæ•ˆèƒ½ç“¶é ¸ã€‚
3.  **ç™¼è¡Œæ¨¡å¼**: ç¸½æ˜¯ä½¿ç”¨ `--release` ç·¨è­¯ç”Ÿç”¢ç‰ˆæœ¬ã€‚
4.  **é›¶æˆæœ¬æŠ½è±¡**: ä½¿ç”¨é«˜éšç‰¹æ€§ï¼Œå¦‚è¿­ä»£å™¨ï¼Œå®ƒå€‘æœƒè¢«ç·¨è­¯æˆé«˜æ•ˆçš„ç¨‹å¼ç¢¼ã€‚
5.  **è³‡æ–™çµæ§‹**: ç‚ºå·¥ä½œé¸æ“‡æ­£ç¢ºçš„è³‡æ–™çµæ§‹ã€‚ 