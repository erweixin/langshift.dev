---
title: "å¯¦æˆ°å°ˆæ¡ˆé©…å‹•"
description: "é€éåˆ†æé«˜å“è³ªçš„é–‹æº Rust å°ˆæ¡ˆä¾†éå›ºå­¸ç¿’ï¼Œæ¨è–¦é©åˆå­¸ç¿’çš„ GitHub å°ˆæ¡ˆ"
---

# å¯¦æˆ°å°ˆæ¡ˆé©…å‹•

## ğŸ“– å­¸ç¿’ç›®æ¨™

é€éåˆ†æçœŸå¯¦çš„é«˜å“è³ª Rust é–‹æºå°ˆæ¡ˆï¼Œéå›ºæ‰€å­¸çŸ¥è­˜ï¼Œäº†è§£ Rust åœ¨å¯¦éš›å°ˆæ¡ˆä¸­çš„æ‡‰ç”¨æ¨¡å¼å’Œæœ€ä½³å¯¦è¸ã€‚

---

## ğŸ¯ å°ˆæ¡ˆå­¸ç¿’ç­–ç•¥

### å¦‚ä½•å­¸ç¿’é–‹æºå°ˆæ¡ˆ

<UniversalEditor title="å°ˆæ¡ˆå­¸ç¿’ç­–ç•¥" compare={true}>
```rust !! rs
// å­¸ç¿’é–‹æºå°ˆæ¡ˆçš„æ­¥é©Ÿ
struct ProjectLearningStrategy {
    steps: Vec<String>,
    focus_areas: Vec<String>,
}

impl ProjectLearningStrategy {
    fn new() -> Self {
        Self {
            steps: vec![
                "1. é–±è®€ README å’Œæ–‡ä»¶".to_string(),
                "2. æŸ¥çœ‹å°ˆæ¡ˆçµæ§‹å’Œæ¶æ§‹".to_string(),
                "3. åˆ†ææ ¸å¿ƒæ¨¡çµ„å’Œé—œéµç¨‹å¼ç¢¼".to_string(),
                "4. åŸ·è¡Œå°ˆæ¡ˆä¸¦ç†è§£åŠŸèƒ½".to_string(),
                "5. å˜—è©¦ä¿®æ”¹å’Œæ“´å±•åŠŸèƒ½".to_string(),
                "6. è²¢ç»ç¨‹å¼ç¢¼æˆ–æäº¤ Issue".to_string(),
            ],
            focus_areas: vec![
                "ç¨‹å¼ç¢¼çµ„ç¹”æ–¹å¼".to_string(),
                "éŒ¯èª¤è™•ç†æ¨¡å¼".to_string(),
                "æ•ˆèƒ½æœ€ä½³åŒ–æŠ€å·§".to_string(),
                "æ¸¬è©¦ç­–ç•¥".to_string(),
                "æ–‡ä»¶å’Œè¨»é‡‹".to_string(),
                "ç¤¾ç¾¤å”ä½œæ–¹å¼".to_string(),
            ],
        }
    }
    
    fn print_strategy(&self) {
        println!("å­¸ç¿’æ­¥é©Ÿ:");
        for step in &self.steps {
            println!("  {}", step);
        }
        
        println!("\né‡é»é—œæ³¨:");
        for area in &self.focus_areas {
            println!("  â€¢ {}", area);
        }
    }
}

// å°ˆæ¡ˆåˆ†æå·¥å…·
struct ProjectAnalyzer {
    project_name: String,
    github_url: String,
    difficulty: ProjectDifficulty,
    learning_value: u8, // 1-10
    key_features: Vec<String>,
}

#[derive(Debug)]
enum ProjectDifficulty {
    Beginner,
    Intermediate,
    Advanced,
}

impl ProjectAnalyzer {
    fn analyze(&self) {
        println!("å°ˆæ¡ˆåˆ†æ: {}", self.project_name);
        println!("GitHub: {}", self.github_url);
        println!("é›£åº¦: {:?}", self.difficulty);
        println!("å­¸ç¿’åƒ¹å€¼: {}/10", self.learning_value);
        println!("æ ¸å¿ƒç‰¹æ€§:");
        for feature in &self.key_features {
            println!("  â€¢ {}", feature);
        }
    }
}

fn main() {
    let strategy = ProjectLearningStrategy::new();
    strategy.print_strategy();
}
```
</UniversalEditor>

---

## ğŸš€ æ¨è–¦å°ˆæ¡ˆ

### 1. ripgrep - é«˜æ•ˆèƒ½æ–‡å­—æœå°‹å·¥å…·

**å°ˆæ¡ˆåœ°å€**: https://github.com/BurntSushi/ripgrep

**å°ˆæ¡ˆç°¡ä»‹**: ripgrep æ˜¯ä¸€å€‹ç”¨ Rust ç·¨å¯«çš„é«˜æ•ˆèƒ½æ–‡å­—æœå°‹å·¥å…·ï¼Œæ¯”å‚³çµ±çš„ grep æ›´å¿«ã€æ›´å®‰å…¨ã€‚

<UniversalEditor title="ripgrep å°ˆæ¡ˆåˆ†æ" compare={true}>
```rust !! rs
// ripgrep æ ¸å¿ƒç‰¹æ€§åˆ†æ
struct RipgrepAnalysis {
    // æ ¸å¿ƒç‰¹æ€§
    features: Vec<String>,
    // æŠ€è¡“äº®é»
    technical_highlights: Vec<String>,
    // å­¸ç¿’è¦é»
    learning_points: Vec<String>,
}

impl RipgrepAnalysis {
    fn new() -> Self {
        Self {
            features: vec![
                "éè¿´æœå°‹ç›®éŒ„".to_string(),
                "æ”¯æ´æ­£è¦è¡¨ç¤ºå¼".to_string(),
                "å¿½ç•¥ .gitignore æª”æ¡ˆ".to_string(),
                "ä¸¦è¡Œæœå°‹".to_string(),
                "Unicode æ”¯æ´".to_string(),
            ],
            technical_highlights: vec![
                "ä½¿ç”¨ regex å‡½å¼åº«é€²è¡Œé«˜æ•ˆèƒ½æ­£è¦è¡¨ç¤ºå¼æ¯”å°".to_string(),
                "ä¸¦è¡Œæª”æ¡ˆç³»çµ±éæ­·".to_string(),
                "è¨˜æ†¶é«”æ˜ å°„æª”æ¡ˆè®€å–".to_string(),
                "æ™ºæ…§æª”æ¡ˆé¡å‹åµæ¸¬".to_string(),
                "é›¶æ‹·è²å­—ä¸²è™•ç†".to_string(),
            ],
            learning_points: vec![
                "å‘½ä»¤åˆ—åƒæ•¸è§£æ".to_string(),
                "éåŒæ­¥ I/O æ“ä½œ".to_string(),
                "éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸".to_string(),
                "æ•ˆèƒ½æœ€ä½³åŒ–æŠ€å·§".to_string(),
                "è·¨å¹³å°ç›¸å®¹æ€§".to_string(),
            ],
        }
    }
    
    fn print_analysis(&self) {
        println!("=== ripgrep å°ˆæ¡ˆåˆ†æ ===");
        println!("æ ¸å¿ƒç‰¹æ€§:");
        for feature in &self.features {
            println!("  â€¢ {}", feature);
        }
        
        println!("\næŠ€è¡“äº®é»:");
        for highlight in &self.technical_highlights {
            println!("  â€¢ {}", highlight);
        }
        
        println!("\nå­¸ç¿’è¦é»:");
        for point in &self.learning_points {
            println!("  â€¢ {}", point);
        }
    }
}

// ripgrep æ ¸å¿ƒæ¦‚å¿µç¯„ä¾‹
struct SearchEngine {
    pattern: String,
    case_sensitive: bool,
    recursive: bool,
}

impl SearchEngine {
    fn new(pattern: String) -> Self {
        Self {
            pattern,
            case_sensitive: true,
            recursive: true,
        }
    }
    
    fn search_file(&self, file_path: &str) -> Result<Vec<String>, std::io::Error> {
        // æ¨¡æ“¬æª”æ¡ˆæœå°‹é‚è¼¯
        let content = std::fs::read_to_string(file_path)?;
        let mut matches = Vec::new();
        
        for (line_num, line) in content.lines().enumerate() {
            if self.matches_pattern(line) {
                matches.push(format!("{}:{}: {}", file_path, line_num + 1, line));
            }
        }
        
        Ok(matches)
    }
    
    fn matches_pattern(&self, line: &str) -> bool {
        if self.case_sensitive {
            line.contains(&self.pattern)
        } else {
            line.to_lowercase().contains(&self.pattern.to_lowercase())
        }
    }
}

fn ripgrep_example() {
    let engine = SearchEngine::new("rust".to_string());
    
    // å»ºç«‹ä¸€å€‹ç”¨æ–¼ç¯„ä¾‹çš„è™›æ“¬æª”æ¡ˆ
    std::fs::write("example.txt", "Learning rust is fun.\nRust is fast.").unwrap();
    
    // æ¨¡æ“¬æœå°‹
    match engine.search_file("example.txt") {
        Ok(matches) => {
            println!("æ‰¾åˆ° {} å€‹æ¯”å°:", matches.len());
            for m in matches {
                println!("  {}", m);
            }
        }
        Err(e) => println!("æœå°‹éŒ¯èª¤: {}", e),
    }

    std::fs::remove_file("example.txt").unwrap();
}
```
</UniversalEditor>

**å­¸ç¿’åƒ¹å€¼**: â­â­â­â­â­ (5/5)
- å­¸ç¿’å‘½ä»¤åˆ—å·¥å…·é–‹ç™¼
- ç†è§£é«˜æ•ˆèƒ½æ–‡å­—è™•ç†
- æŒæ¡ä¸¦è¡Œç¨‹å¼è¨­è¨ˆæŠ€å·§
- äº†è§£è·¨å¹³å°é–‹ç™¼

---

### 2. actix-web - Web æ¡†æ¶

**å°ˆæ¡ˆåœ°å€**: https://github.com/actix/actix-web

**å°ˆæ¡ˆç°¡ä»‹**: actix-web æ˜¯ä¸€å€‹åŠŸèƒ½å¼·å¤§ã€æ•ˆèƒ½å“è¶Šçš„ Rust Web æ¡†æ¶ã€‚

<UniversalEditor title="actix-web å°ˆæ¡ˆåˆ†æ" compare={true}>
```rust !! rs
// actix-web æ ¸å¿ƒæ¦‚å¿µç¯„ä¾‹
use actix_web::{web, App, HttpServer, HttpResponse, Result};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone)]
struct User {
    id: u32,
    name: String,
    email: String,
}

// è·¯ç”±è™•ç†å‡½å¼
async fn get_users() -> Result<HttpResponse> {
    let users = vec![
        User { id: 1, name: "Alice".to_string(), email: "alice@example.com".to_string() },
        User { id: 2, name: "Bob".to_string(), email: "bob@example.com".to_string() },
    ];
    Ok(HttpResponse::Ok().json(users))
}

async fn create_user(user: web::Json<User>) -> Result<HttpResponse> {
    // åœ¨çœŸå¯¦æ‡‰ç”¨ä¸­ï¼Œä½ æœƒå°‡ä½¿ç”¨è€…å„²å­˜åˆ°è³‡æ–™åº«
    println!("æ­£åœ¨å»ºç«‹ä½¿ç”¨è€…: {:?}", user);
    Ok(HttpResponse::Created().json(user.into_inner()))
}

// æ¦‚å¿µæ€§çš„ä¼ºæœå™¨è¨­å®š
#[actix_web::main]
async fn actix_example() -> std::io::Result<()> {
    println!("ä¼ºæœå™¨å•Ÿå‹•æ–¼ http://127.0.0.1:8080");

    HttpServer::new(|| {
        App::new()
            .route("/users", web::get().to(get_users))
            .route("/users", web.post().to(create_user))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```
</UniversalEditor>

**å­¸ç¿’åƒ¹å€¼**: â­â­â­â­ (4/5)
- å­¸ç¿’ Web å¾Œç«¯é–‹ç™¼
- ç†è§£ Rust ä¸­çš„éåŒæ­¥ç¨‹å¼è¨­è¨ˆ
- æŒæ¡ Actor æ¨¡å‹
- å­¸ç¿’ Web å®‰å…¨å’Œä¸­ä»‹è»Ÿé«” 