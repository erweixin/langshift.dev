---
title: "å¸¸è§é™·é˜±å’Œè°ƒè¯•"
description: "ä» JavaScript è§†è§’å­¦ä¹  C è¯­è¨€å¸¸è§é™·é˜±å’Œè°ƒè¯•ï¼Œç†è§£æŒ‡é’ˆé”™è¯¯ã€å†…å­˜æ³„æ¼ã€ç¼“å†²åŒºæº¢å‡ºå’Œè°ƒè¯•å·¥å…·ã€‚"
---

# å¸¸è§é™·é˜±å’Œè°ƒè¯•

## 1. æ¦‚å¿µä»‹ç»

### ä» JavaScript é”™è¯¯å¤„ç†åˆ° C è°ƒè¯•

åœ¨ JavaScript ä¸­ï¼Œä½ æœ‰è‡ªåŠ¨å†…å­˜ç®¡ç†å’Œè¿è¡Œæ—¶é”™è¯¯æ£€æŸ¥ã€‚è€Œåœ¨ C è¯­è¨€ä¸­ï¼Œä½ å¿…é¡»æ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œå¹¶æ³¨æ„å¯èƒ½å¯¼è‡´å´©æºƒã€å†…å­˜æ³„æ¼å’Œæœªå®šä¹‰è¡Œä¸ºçš„æ½œåœ¨é™·é˜±ã€‚

> ğŸ’¡ **æ ¸å¿ƒæ¦‚å¿µ**ï¼šC è°ƒè¯•éœ€è¦ç†è§£åº•å±‚å†…å­˜ç®¡ç†ã€æŒ‡é’ˆæ“ä½œï¼Œå¹¶ä½¿ç”¨é€‚å½“çš„å·¥å…·æ¥è¯†åˆ«å’Œä¿®å¤é—®é¢˜ã€‚

## 2. æŒ‡é’ˆé”™è¯¯å’Œæ®µé”™è¯¯

<UniversalEditor title="æŒ‡é’ˆé”™è¯¯" compare={true}>
```javascript !! js
// JavaScript - è‡ªåŠ¨å†…å­˜ç®¡ç†
let obj = { name: "John", age: 30 };

// å®‰å…¨çš„å±æ€§è®¿é—®
console.log(obj.name); // "John"
console.log(obj.nonExistent); // undefined

// å¸¦è¾¹ç•Œæ£€æŸ¥çš„æ•°ç»„è®¿é—®
let arr = [1, 2, 3, 4, 5];
console.log(arr[2]); // 3
console.log(arr[10]); // undefined (ä¸ä¼šå´©æºƒ)

// å¯¹è±¡æ“ä½œ
obj = null;
// console.log(obj.name); // TypeError: Cannot read property 'name' of null

// å®‰å…¨çš„æ•°ç»„æ“ä½œ
arr = null;
// console.log(arr[0]); // TypeError: Cannot read property '0' of null

// è‡ªåŠ¨æ¸…ç†
function createObjects() {
    let temp = { data: "temporary" };
    // JavaScript åœ¨ temp è¶…å‡ºä½œç”¨åŸŸæ—¶è‡ªåŠ¨æ¸…ç†
}

createObjects();
// temp è¢«è‡ªåŠ¨åƒåœ¾å›æ”¶
```

```c !! c
#include <stdio.h>
#include <stdlib.h>

// å¸¸è§æŒ‡é’ˆé”™è¯¯
void demonstratePointerErrors() {
    // 1. è§£å¼•ç”¨ç©ºæŒ‡é’ˆ
    int* ptr = NULL;
    // *ptr = 10; // æ®µé”™è¯¯ï¼
    
    // å®‰å…¨æ–¹å¼ï¼šè§£å¼•ç”¨å‰æ£€æŸ¥
    if (ptr != NULL) {
        *ptr = 10;
    } else {
        printf("æŒ‡é’ˆä¸ºç©ºï¼Œæ— æ³•è§£å¼•ç”¨\n");
    }
    
    // 2. è§£å¼•ç”¨æœªåˆå§‹åŒ–çš„æŒ‡é’ˆ
    int* uninitPtr;
    // *uninitPtr = 20; // æœªå®šä¹‰è¡Œä¸ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šåˆå§‹åŒ–æŒ‡é’ˆ
    int value = 20;
    uninitPtr = &value;
    *uninitPtr = 30; // å®‰å…¨
    
    // 3. é‡Šæ”¾å†…å­˜åä½¿ç”¨æŒ‡é’ˆ
    int* dynamicPtr = (int*)malloc(sizeof(int));
    *dynamicPtr = 40;
    free(dynamicPtr);
    // *dynamicPtr = 50; // é‡Šæ”¾åä½¿ç”¨ - æœªå®šä¹‰è¡Œä¸ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šé‡Šæ”¾åè®¾ç½®ä¸º NULL
    dynamicPtr = NULL;
    if (dynamicPtr != NULL) {
        *dynamicPtr = 50;
    }
    
    // 4. ç¼“å†²åŒºæº¢å‡º
    char buffer[5];
    // strcpy(buffer, "This is too long"); // ç¼“å†²åŒºæº¢å‡ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šä½¿ç”¨ strncpy è¿›è¡Œè¾¹ç•Œæ£€æŸ¥
    strncpy(buffer, "Hi", sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0'; // ç¡®ä¿ null ç»ˆæ­¢
}

// å®‰å…¨æŒ‡é’ˆæ“ä½œ
int* createSafePointer() {
    int* ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL) {
        printf("å†…å­˜åˆ†é…å¤±è´¥\n");
        return NULL;
    }
    *ptr = 100;
    return ptr;
}

void useSafePointer(int* ptr) {
    if (ptr == NULL) {
        printf("æ— æ³•ä½¿ç”¨ç©ºæŒ‡é’ˆ\n");
        return;
    }
    printf("å€¼: %d\n", *ptr);
}

int main() {
    demonstratePointerErrors();
    
    // å®‰å…¨æŒ‡é’ˆä½¿ç”¨
    int* safePtr = createSafePointer();
    useSafePointer(safePtr);
    
    if (safePtr != NULL) {
        free(safePtr);
        safePtr = NULL; // è‰¯å¥½å®è·µ
    }
    
    return 0;
}
```
</UniversalEditor>

## 3. å†…å­˜æ³„æ¼

<UniversalEditor title="å†…å­˜æ³„æ¼" compare={true}>
```javascript !! js
// JavaScript - è‡ªåŠ¨åƒåœ¾å›æ”¶
class MemoryIntensive {
    constructor() {
        this.data = new Array(1000000).fill('data');
    }
}

// JavaScript åœ¨å¯¹è±¡è¶…å‡ºä½œç”¨åŸŸæ—¶è‡ªåŠ¨æ¸…ç†
function createAndDestroy() {
    let obj = new MemoryIntensive();
    // obj åœ¨å‡½æ•°ç»“æŸæ—¶è¢«è‡ªåŠ¨åƒåœ¾å›æ”¶
}

createAndDestroy();

// äº‹ä»¶ç›‘å¬å™¨çš„æ‰‹åŠ¨æ¸…ç†
class EventHandler {
    constructor() {
        this.handlers = [];
    }
    
    addHandler(handler) {
        this.handlers.push(handler);
    }
    
    cleanup() {
        this.handlers = []; // æ¸…é™¤å¼•ç”¨
    }
}

// å†…å­˜æ³„æ¼ç¤ºä¾‹ï¼ˆå¾ªç¯å¼•ç”¨ï¼‰
let obj1 = { name: 'Object 1' };
let obj2 = { name: 'Object 2' };

obj1.ref = obj2;
obj2.ref = obj1;

// è¿™äº›å¯¹è±¡ç”±äºå¾ªç¯å¼•ç”¨ä¸ä¼šè¢«åƒåœ¾å›æ”¶
// è§£å†³æ–¹æ¡ˆï¼šæ‰“ç ´å¾ªç¯å¼•ç”¨
obj1.ref = null;
obj2.ref = null;
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// å†…å­˜æ³„æ¼ç¤ºä¾‹
void memoryLeakExample() {
    // 1. åˆ†é…å†…å­˜ä½†ä¸é‡Šæ”¾
    int* leakyPtr = (int*)malloc(sizeof(int));
    *leakyPtr = 42;
    // ç¼ºå°‘: free(leakyPtr);
    
    // 2. ä¸¢å¤±æŒ‡å‘å·²åˆ†é…å†…å­˜çš„æŒ‡é’ˆ
    int* lostPtr = (int*)malloc(sizeof(int));
    lostPtr = NULL; // ä¸¢å¤±æŒ‡é’ˆï¼Œæ— æ³•å†é‡Šæ”¾
    
    // 3. åœ¨é”™è¯¯æ¡ä»¶ä¸‹ä¸é‡Šæ”¾å†…å­˜
    int* errorPtr = (int*)malloc(sizeof(int));
    if (errorPtr == NULL) {
        return; // å¦‚æœåˆ†é…å¤±è´¥åˆ™å†…å­˜æ³„æ¼
    }
    
    // åšä¸€äº›å·¥ä½œ...
    if (someErrorCondition()) {
        return; // å†…å­˜æ³„æ¼ - å¿˜è®°é‡Šæ”¾
    }
    
    free(errorPtr); // åªåœ¨æˆåŠŸæƒ…å†µä¸‹é‡Šæ”¾
}

// æ­£ç¡®çš„å†…å­˜ç®¡ç†
typedef struct {
    int* data;
    int size;
} SafeArray;

SafeArray* createSafeArray(int size) {
    SafeArray* arr = (SafeArray*)malloc(sizeof(SafeArray));
    if (arr == NULL) {
        return NULL;
    }
    
    arr->data = (int*)malloc(size * sizeof(int));
    if (arr->data == NULL) {
        free(arr); // æ¸…ç†éƒ¨åˆ†åˆ†é…
        return NULL;
    }
    
    arr->size = size;
    return arr;
}

void destroySafeArray(SafeArray* arr) {
    if (arr != NULL) {
        if (arr->data != NULL) {
            free(arr->data);
        }
        free(arr);
    }
}

// å†…å­˜æ³„æ¼æ£€æµ‹è¾…åŠ©å‡½æ•°
void* safeMalloc(size_t size) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        printf("å†…å­˜åˆ†é…å¤±è´¥\n");
    } else {
        printf("åˆ†é…äº† %zu å­—èŠ‚åœ¨ %p\n", size, ptr);
    }
    return ptr;
}

void safeFree(void* ptr) {
    if (ptr != NULL) {
        printf("é‡Šæ”¾å†…å­˜ %p\n", ptr);
        free(ptr);
    }
}

int main() {
    // æ¼”ç¤ºå†…å­˜æ³„æ¼
    memoryLeakExample();
    
    // æ­£ç¡®çš„å†…å­˜ç®¡ç†
    SafeArray* arr = createSafeArray(10);
    if (arr != NULL) {
        // ä½¿ç”¨æ•°ç»„
        for (int i = 0; i < arr->size; i++) {
            arr->data[i] = i;
        }
        
        // æ¸…ç†
        destroySafeArray(arr);
    }
    
    // ä½¿ç”¨å®‰å…¨å†…å­˜å‡½æ•°
    int* ptr1 = (int*)safeMalloc(sizeof(int));
    int* ptr2 = (int*)safeMalloc(sizeof(int));
    
    if (ptr1 && ptr2) {
        *ptr1 = 100;
        *ptr2 = 200;
        
        safeFree(ptr1);
        safeFree(ptr2);
    }
    
    return 0;
}
```
</UniversalEditor>

## 4. ç¼“å†²åŒºæº¢å‡º

<UniversalEditor title="ç¼“å†²åŒºæº¢å‡º" compare={true}>
```javascript !! js
// JavaScript - è‡ªåŠ¨è¾¹ç•Œæ£€æŸ¥
let arr = new Array(5);

// å®‰å…¨çš„æ•°ç»„è®¿é—®
arr[0] = 1;
arr[4] = 5;
// arr[5] = 6; // æ²¡æœ‰ç¼“å†²åŒºæº¢å‡ºï¼Œä½†å¯èƒ½åˆ›å»ºç¨€ç–æ•°ç»„

// å­—ç¬¦ä¸²æ“ä½œæ˜¯å®‰å…¨çš„
let str = "Hello";
let substring = str.substring(0, 3); // "Hel"
let char = str.charAt(2); // "l"

// å¸¦è¾¹ç•Œæ£€æŸ¥çš„æ•°ç»„æ–¹æ³•
let numbers = [1, 2, 3, 4, 5];
numbers.push(6); // å®‰å…¨ - æ•°ç»„è‡ªåŠ¨å¢é•¿
numbers.splice(2, 1); // å®‰å…¨ - åˆ é™¤ç´¢å¼• 2 å¤„çš„å…ƒç´ 

// å®‰å…¨çš„å­—ç¬¦ä¸²è¿æ¥
let result = "";
for (let i = 0; i < 1000; i++) {
    result += "a"; // å®‰å…¨ - å­—ç¬¦ä¸²è‡ªåŠ¨å¢é•¿
}

// Node.js ä¸­çš„ Bufferï¼ˆå¦‚æœéœ€è¦ï¼‰
const { Buffer } = require('buffer');
let buffer = Buffer.alloc(10);
buffer.write("Hello", 0, 5); // å®‰å…¨ - å†™å…¥ 5 å­—èŠ‚
// buffer.write("This is too long", 0, 20); // æŠ›å‡ºé”™è¯¯
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ç¼“å†²åŒºæº¢å‡ºç¤ºä¾‹
void bufferOverflowExamples() {
    // 1. æ ˆç¼“å†²åŒºæº¢å‡º
    char buffer[10];
    // strcpy(buffer, "This string is too long for the buffer"); // æº¢å‡ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šä½¿ç”¨ strncpy
    strncpy(buffer, "Hello", sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0'; // ç¡®ä¿ null ç»ˆæ­¢
    
    // 2. æ•°ç»„è¾¹ç•Œè¿å
    int arr[5];
    // arr[10] = 100; // ç¼“å†²åŒºæº¢å‡ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæ£€æŸ¥è¾¹ç•Œ
    int index = 10;
    if (index >= 0 && index < 5) {
        arr[index] = 100;
    } else {
        printf("ç´¢å¼• %d è¶…å‡ºè¾¹ç•Œ\n", index);
    }
    
    // 3. æ•´æ•°æº¢å‡º
    int small = 2147483647; // MAX_INT
    // small++; // æ•´æ•°æº¢å‡ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæ£€æŸ¥æº¢å‡º
    if (small < 2147483647) {
        small++;
    } else {
        printf("ä¼šå‘ç”Ÿæ•´æ•°æº¢å‡º\n");
    }
}

// å®‰å…¨å­—ç¬¦ä¸²å‡½æ•°
char* safeStringCopy(const char* source, size_t maxLen) {
    char* dest = (char*)malloc(maxLen + 1);
    if (dest == NULL) {
        return NULL;
    }
    
    strncpy(dest, source, maxLen);
    dest[maxLen] = '\0'; // ç¡®ä¿ null ç»ˆæ­¢
    return dest;
}

// å®‰å…¨æ•°ç»„è®¿é—®
int safeArrayAccess(int* arr, int size, int index) {
    if (index >= 0 && index < size) {
        return arr[index];
    } else {
        printf("ç´¢å¼• %d è¶…å‡ºè¾¹ç•Œ (å¤§å°: %d)\n", index, size);
        return -1; // é”™è¯¯å€¼
    }
}

// å®‰å…¨æ•´æ•°æ“ä½œ
int safeAdd(int a, int b) {
    if (a > 0 && b > 0 && a > INT_MAX - b) {
        printf("ä¼šå‘ç”Ÿæ•´æ•°æº¢å‡º\n");
        return -1; // é”™è¯¯å€¼
    }
    if (a < 0 && b < 0 && a < INT_MIN - b) {
        printf("ä¼šå‘ç”Ÿæ•´æ•°ä¸‹æº¢\n");
        return -1; // é”™è¯¯å€¼
    }
    return a + b;
}

int main() {
    bufferOverflowExamples();
    
    // å®‰å…¨å­—ç¬¦ä¸²æ“ä½œ
    char* safeStr = safeStringCopy("Hello, World!", 10);
    if (safeStr != NULL) {
        printf("å®‰å…¨å­—ç¬¦ä¸²: %s\n", safeStr);
        free(safeStr);
    }
    
    // å®‰å…¨æ•°ç»„æ“ä½œ
    int arr[5] = {1, 2, 3, 4, 5};
    printf("å®‰å…¨è®¿é—®: %d\n", safeArrayAccess(arr, 5, 2));
    printf("ä¸å®‰å…¨è®¿é—®: %d\n", safeArrayAccess(arr, 5, 10));
    
    // å®‰å…¨æ•´æ•°æ“ä½œ
    printf("å®‰å…¨åŠ æ³•: %d\n", safeAdd(100, 200));
    printf("æº¢å‡ºæ£€æŸ¥: %d\n", safeAdd(2147483647, 1));
    
    return 0;
}
```
</UniversalEditor>

## 5. æœªå®šä¹‰è¡Œä¸º

<UniversalEditor title="æœªå®šä¹‰è¡Œä¸º" compare={true}>
```javascript !! js
// JavaScript - æ˜ç¡®å®šä¹‰çš„è¡Œä¸º
let x = 5;
let y = x / 0; // Infinity (æ˜ç¡®å®šä¹‰)
let z = x % 0; // NaN (æ˜ç¡®å®šä¹‰)

// æ•°ç»„è®¿é—®
let arr = [1, 2, 3];
console.log(arr[5]); // undefined (æ˜ç¡®å®šä¹‰)

// ç±»å‹è½¬æ¢
console.log("5" + 3); // "53" (æ˜ç¡®å®šä¹‰)
console.log("5" - 3); // 2 (æ˜ç¡®å®šä¹‰)

// null å’Œ undefined
let obj = null;
console.log(obj?.property); // undefined (æ˜ç¡®å®šä¹‰)

// å‡½æ•°è°ƒç”¨
function test(a, b) {
    return a + b;
}
console.log(test(1)); // NaN (æ˜ç¡®å®šä¹‰)
console.log(test(1, 2, 3)); // 3 (å¿½ç•¥é¢å¤–å‚æ•°)

// è‡ªåŠ¨ç±»å‹è½¬æ¢
console.log(1 == "1"); // true (æ˜ç¡®å®šä¹‰è½¬æ¢)
console.log(1 === "1"); // false (ä¸¥æ ¼ç›¸ç­‰)
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// æœªå®šä¹‰è¡Œä¸ºç¤ºä¾‹
void undefinedBehaviorExamples() {
    // 1. é™¤é›¶
    int a = 10;
    // int result = a / 0; // æœªå®šä¹‰è¡Œä¸ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæ£€æŸ¥é›¶
    int divisor = 0;
    if (divisor != 0) {
        int result = a / divisor;
        printf("ç»“æœ: %d\n", result);
    } else {
        printf("é¿å…é™¤é›¶\n");
    }
    
    // 2. è®¿é—®æœªåˆå§‹åŒ–çš„å˜é‡
    int uninit;
    // printf("æœªåˆå§‹åŒ–: %d\n", uninit); // æœªå®šä¹‰è¡Œä¸ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šåˆå§‹åŒ–
    int init = 0;
    printf("å·²åˆå§‹åŒ–: %d\n", init);
    
    // 3. è§£å¼•ç”¨ç©ºæŒ‡é’ˆ
    int* ptr = NULL;
    // printf("å€¼: %d\n", *ptr); // æœªå®šä¹‰è¡Œä¸ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæ£€æŸ¥æŒ‡é’ˆ
    if (ptr != NULL) {
        printf("å€¼: %d\n", *ptr);
    }
    
    // 4. æ•´æ•°æº¢å‡º
    int max = INT_MAX;
    // max++; // æœªå®šä¹‰è¡Œä¸ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šé€’å¢å‰æ£€æŸ¥
    if (max < INT_MAX) {
        max++;
    }
    
    // 5. ä½¿ç”¨å·²é‡Šæ”¾çš„å†…å­˜
    int* dynamic = (int*)malloc(sizeof(int));
    free(dynamic);
    // *dynamic = 100; // æœªå®šä¹‰è¡Œä¸ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šé‡Šæ”¾åè®¾ç½®ä¸º NULL
    dynamic = NULL;
}

// å®‰å…¨ç®—æœ¯å‡½æ•°
int safeDivide(int a, int b) {
    if (b == 0) {
        printf("é™¤é›¶\n");
        return 0; // é”™è¯¯å€¼
    }
    return a / b;
}

int safeModulo(int a, int b) {
    if (b == 0) {
        printf("æ¨¡é›¶\n");
        return 0; // é”™è¯¯å€¼
    }
    return a % b;
}

// å®‰å…¨æŒ‡é’ˆæ“ä½œ
void* safeDereference(void* ptr) {
    if (ptr == NULL) {
        printf("æ— æ³•è§£å¼•ç”¨ç©ºæŒ‡é’ˆ\n");
        return NULL;
    }
    return ptr;
}

// å¸¦è¾¹ç•Œæ£€æŸ¥çš„å®‰å…¨æ•°ç»„è®¿é—®
int safeArrayGet(int* arr, int size, int index) {
    if (arr == NULL) {
        printf("æ•°ç»„ä¸ºç©º\n");
        return -1;
    }
    if (index < 0 || index >= size) {
        printf("ç´¢å¼• %d è¶…å‡ºè¾¹ç•Œ\n", index);
        return -1;
    }
    return arr[index];
}

int main() {
    undefinedBehaviorExamples();
    
    // å®‰å…¨ç®—æœ¯
    printf("å®‰å…¨é™¤æ³•: %d\n", safeDivide(10, 2));
    printf("å®‰å…¨é™¤é›¶: %d\n", safeDivide(10, 0));
    
    printf("å®‰å…¨æ¨¡è¿ç®—: %d\n", safeModulo(10, 3));
    printf("å®‰å…¨æ¨¡é›¶: %d\n", safeModulo(10, 0));
    
    // å®‰å…¨æŒ‡é’ˆæ“ä½œ
    int value = 42;
    int* ptr = &value;
    safeDereference(ptr);
    safeDereference(NULL);
    
    // å®‰å…¨æ•°ç»„è®¿é—®
    int arr[5] = {1, 2, 3, 4, 5};
    printf("å®‰å…¨è·å–: %d\n", safeArrayGet(arr, 5, 2));
    printf("ä¸å®‰å…¨è·å–: %d\n", safeArrayGet(arr, 5, 10));
    printf("ç©ºæ•°ç»„: %d\n", safeArrayGet(NULL, 5, 0));
    
    return 0;
}
```
</UniversalEditor>

## 6. è°ƒè¯•å·¥å…·

<UniversalEditor title="è°ƒè¯•å·¥å…·" compare={true}>
```javascript !! js
// JavaScript - å†…ç½®è°ƒè¯•å·¥å…·
console.log("è°ƒè¯•æ¶ˆæ¯");
console.error("é”™è¯¯æ¶ˆæ¯");
console.warn("è­¦å‘Šæ¶ˆæ¯");

// å †æ ˆè·Ÿè¸ª
function debugFunction() {
    console.trace("å‡½æ•°è°ƒç”¨å †æ ˆ");
}

debugFunction();

// æ€§èƒ½æµ‹é‡
console.time("æ“ä½œ");
// ... ä¸€äº›æ“ä½œ
console.timeEnd("æ“ä½œ");

// å†…å­˜ä½¿ç”¨ (Node.js)
const used = process.memoryUsage();
console.log('å†…å­˜ä½¿ç”¨:', {
    rss: `${Math.round(used.rss / 1024 / 1024 * 100) / 100} MB`,
    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024 * 100) / 100} MB`,
    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`,
    external: `${Math.round(used.external / 1024 / 1024 * 100) / 100} MB`
});

// é”™è¯¯å¤„ç†
try {
    throw new Error("æµ‹è¯•é”™è¯¯");
} catch (error) {
    console.error("æ•è·é”™è¯¯:", error.message);
    console.error("å †æ ˆè·Ÿè¸ª:", error.stack);
}

// è°ƒè¯•å™¨è¯­å¥
function debugMe() {
    let x = 1;
    debugger; // å¦‚æœå¼€å‘å·¥å…·æ‰“å¼€ï¼Œæµè§ˆå™¨ä¼šåœ¨è¿™é‡Œæš‚åœ
    x = 2;
}
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>

// è°ƒè¯•å®
#define DEBUG 1

#if DEBUG
    #define DEBUG_PRINT(fmt, ...) \
        fprintf(stderr, "è°ƒè¯•: %s:%d: " fmt "\n", \
                __FILE__, __LINE__, ##__VA_ARGS__)
#else
    #define DEBUG_PRINT(fmt, ...) do {} while(0)
#endif

#define ASSERT(condition) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "æ–­è¨€å¤±è´¥: %s, æ–‡ä»¶ %s, è¡Œ %d\n", \
                    #condition, __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)

// å†…å­˜è°ƒè¯•
void* debugMalloc(size_t size) {
    void* ptr = malloc(size);
    DEBUG_PRINT("malloc(%zu) = %p", size, ptr);
    return ptr;
}

void debugFree(void* ptr) {
    DEBUG_PRINT("free(%p)", ptr);
    free(ptr);
}

// æ€§èƒ½æµ‹é‡
clock_t startTimer() {
    return clock();
}

double endTimer(clock_t start) {
    clock_t end = clock();
    return ((double)(end - start)) / CLOCKS_PER_SEC;
}

// é”™è¯¯å¤„ç†
typedef enum {
    SUCCESS = 0,
    ERROR_NULL_POINTER,
    ERROR_INVALID_SIZE,
    ERROR_MEMORY_ALLOCATION
} ErrorCode;

const char* getErrorMessage(ErrorCode code) {
    switch (code) {
        case SUCCESS: return "æˆåŠŸ";
        case ERROR_NULL_POINTER: return "ç©ºæŒ‡é’ˆ";
        case ERROR_INVALID_SIZE: return "æ— æ•ˆå¤§å°";
        case ERROR_MEMORY_ALLOCATION: return "å†…å­˜åˆ†é…å¤±è´¥";
        default: return "æœªçŸ¥é”™è¯¯";
    }
}

// å¸¦é”™è¯¯å¤„ç†çš„å®‰å…¨å‡½æ•°
ErrorCode safeFunction(int* arr, int size) {
    DEBUG_PRINT("safeFunction è¢«è°ƒç”¨ï¼Œå¤§å° %d", size);
    
    if (arr == NULL) {
        DEBUG_PRINT("é”™è¯¯: ç©ºæŒ‡é’ˆ");
        return ERROR_NULL_POINTER;
    }
    
    if (size <= 0) {
        DEBUG_PRINT("é”™è¯¯: æ— æ•ˆå¤§å° %d", size);
        return ERROR_INVALID_SIZE;
    }
    
    // åšå·¥ä½œ
    for (int i = 0; i < size; i++) {
        arr[i] = i * 2;
    }
    
    DEBUG_PRINT("å‡½æ•°æˆåŠŸå®Œæˆ");
    return SUCCESS;
}

// å†…å­˜æ³„æ¼æ£€æµ‹
typedef struct {
    void* ptr;
    size_t size;
    const char* file;
    int line;
} MemoryInfo;

#define MAX_ALLOCATIONS 1000
MemoryInfo allocations[MAX_ALLOCATIONS];
int allocationCount = 0;

void* trackMalloc(size_t size, const char* file, int line) {
    void* ptr = malloc(size);
    if (ptr != NULL && allocationCount < MAX_ALLOCATIONS) {
        allocations[allocationCount].ptr = ptr;
        allocations[allocationCount].size = size;
        allocations[allocationCount].file = file;
        allocations[allocationCount].line = line;
        allocationCount++;
    }
    return ptr;
}

void trackFree(void* ptr) {
    for (int i = 0; i < allocationCount; i++) {
        if (allocations[i].ptr == ptr) {
            // ä»è·Ÿè¸ªä¸­ç§»é™¤
            for (int j = i; j < allocationCount - 1; j++) {
                allocations[j] = allocations[j + 1];
            }
            allocationCount--;
            break;
        }
    }
    free(ptr);
}

void reportMemoryLeaks() {
    if (allocationCount > 0) {
        printf("æ£€æµ‹åˆ°å†…å­˜æ³„æ¼:\n");
        for (int i = 0; i < allocationCount; i++) {
            printf("  %p: %zu å­—èŠ‚åˆ†é…åœ¨ %s:%d\n",
                   allocations[i].ptr, allocations[i].size,
                   allocations[i].file, allocations[i].line);
        }
    } else {
        printf("æœªæ£€æµ‹åˆ°å†…å­˜æ³„æ¼\n");
    }
}

int main() {
    clock_t start = startTimer();
    
    // ä½¿ç”¨è°ƒè¯•å®
    DEBUG_PRINT("ç¨‹åºå¼€å§‹");
    
    // æµ‹è¯•æ–­è¨€
    int x = 5;
    ASSERT(x > 0);
    // ASSERT(x < 0); // è¿™ä¼šä¸­æ­¢ç¨‹åº
    
    // æµ‹è¯•é”™è¯¯å¤„ç†
    int arr[5];
    ErrorCode result = safeFunction(arr, 5);
    if (result != SUCCESS) {
        printf("é”™è¯¯: %s\n", getErrorMessage(result));
    }
    
    // æµ‹è¯•å†…å­˜è·Ÿè¸ª
    void* ptr1 = trackMalloc(100, __FILE__, __LINE__);
    void* ptr2 = trackMalloc(200, __FILE__, __LINE__);
    
    trackFree(ptr1);
    // ptr2 æ•…æ„ä¸é‡Šæ”¾ä»¥æ¼”ç¤ºæ³„æ¼æ£€æµ‹
    
    // æŠ¥å‘Šå†…å­˜æ³„æ¼
    reportMemoryLeaks();
    
    double elapsed = endTimer(start);
    printf("ç¨‹åºåœ¨ %.3f ç§’å†…å®Œæˆ\n", elapsed);
    
    return 0;
}
```
</UniversalEditor>

## 7. å¸¸è§é™·é˜±
- **è§£å¼•ç”¨ç©ºæŒ‡é’ˆ**ï¼šä½¿ç”¨å‰å§‹ç»ˆæ£€æŸ¥æŒ‡é’ˆ
- **å†…å­˜æ³„æ¼**ï¼šå§‹ç»ˆé‡Šæ”¾åˆ†é…çš„å†…å­˜
- **ç¼“å†²åŒºæº¢å‡º**ï¼šæ•°ç»„è®¿é—®å‰æ£€æŸ¥è¾¹ç•Œ
- **æ•´æ•°æº¢å‡º**ï¼šç®—æœ¯æ“ä½œå‰æ£€æŸ¥é™åˆ¶
- **é‡Šæ”¾åä½¿ç”¨**ï¼šé‡Šæ”¾åå°†æŒ‡é’ˆè®¾ç½®ä¸º NULL
- **æœªåˆå§‹åŒ–å˜é‡**ï¼šä½¿ç”¨å‰å§‹ç»ˆåˆå§‹åŒ–å˜é‡

## 8. ç»ƒä¹ é¢˜
1. ç¼–å†™ä¸€ä¸ªæ¼”ç¤ºå¹¶ä¿®å¤å¸¸è§æŒ‡é’ˆé”™è¯¯çš„ç¨‹åºã€‚
2. ä¸ºä½ çš„ç¨‹åºåˆ›å»ºä¸€ä¸ªå†…å­˜æ³„æ¼æ£€æµ‹å™¨ã€‚
3. å®ç°å­—ç¬¦ä¸²å’Œæ•°ç»„å‡½æ•°çš„å®‰å…¨ç‰ˆæœ¬ã€‚
4. ä½¿ç”¨è°ƒè¯•å·¥å…·æŸ¥æ‰¾å’Œä¿®å¤ç°æœ‰ä»£ç ä¸­çš„é”™è¯¯ã€‚

## 9. æ€§èƒ½åˆ†æ
- **è°ƒè¯•æ„å»º**ï¼šåŒ…å«è°ƒè¯•ä¿¡æ¯å’Œæ£€æŸ¥
- **å‘å¸ƒæ„å»º**ï¼šä¼˜åŒ–æ€§èƒ½ï¼Œç§»é™¤è°ƒè¯•ä»£ç 
- **å†…å­˜åˆ†æ**ï¼šç›‘æ§å†…å­˜ä½¿ç”¨å’Œæ³„æ¼
- **æ€§èƒ½åˆ†æ**ï¼šè¯†åˆ«ç“¶é¢ˆå¹¶ä¼˜åŒ–

---

> **å°ç»“**ï¼šç†è§£ C å¸¸è§é™·é˜±å’Œè°ƒè¯•æŠ€æœ¯å¯¹äºç¼–å†™å¯é ç¨‹åºè‡³å…³é‡è¦ã€‚ä½¿ç”¨é€‚å½“çš„å·¥å…·å¹¶éµå¾ªæœ€ä½³å®è·µæ¥é¿å…å’Œä¿®å¤é—®é¢˜ã€‚ 