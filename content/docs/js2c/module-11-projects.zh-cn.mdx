---
title: "å®æˆ˜é¡¹ç›®å¼€å‘"
description: "ä» JavaScript è§†è§’å­¦ä¹  C è¯­è¨€å®æˆ˜é¡¹ç›®ï¼Œæ„å»ºæ–‡æœ¬ç¼–è¾‘å™¨ã€å†…å­˜åˆ†é…å™¨ã€æ•°æ®ç»“æ„åº“å’Œç³»ç»Ÿå·¥å…·ã€‚"
---

# å®æˆ˜é¡¹ç›®å¼€å‘

## 1. æ¦‚å¿µä»‹ç»

### ä» JavaScript é¡¹ç›®åˆ° C ç³»ç»Ÿåº”ç”¨ç¨‹åº

åœ¨ JavaScript ä¸­ï¼Œä½ é€šå¸¸æ„å»º Web åº”ç”¨ç¨‹åºã€API å’Œç”¨æˆ·ç•Œé¢ã€‚è€Œåœ¨ C è¯­è¨€ä¸­ï¼Œä½ å¯ä»¥åˆ›å»ºç³»ç»Ÿå·¥å…·ã€åµŒå…¥å¼åº”ç”¨ç¨‹åºå’Œç›´æ¥ä¸ç¡¬ä»¶å’Œæ“ä½œç³»ç»Ÿäº¤äº’çš„æ€§èƒ½å…³é”®å‹è½¯ä»¶ã€‚

> ğŸ’¡ **æ ¸å¿ƒæ¦‚å¿µ**ï¼šC é¡¹ç›®ä¸“æ³¨äºç³»ç»Ÿçº§ç¼–ç¨‹ã€æ€§èƒ½ä¼˜åŒ–å’Œç›´æ¥ç¡¬ä»¶äº¤äº’ï¼Œä½¿ä½ èƒ½å¤Ÿæ„å»ºé«˜æ•ˆã€ä½çº§çš„åº”ç”¨ç¨‹åºã€‚

## 2. ç®€å•æ–‡æœ¬ç¼–è¾‘å™¨

<UniversalEditor title="æ–‡æœ¬ç¼–è¾‘å™¨å®ç°" compare={true}>
```javascript !! js
// JavaScript - ç®€å•æ–‡æœ¬ç¼–è¾‘å™¨ (Node.js)
const readline = require('readline');
const fs = require('fs');

class TextEditor {
    constructor() {
        this.content = '';
        this.filename = '';
        this.isModified = false;
    }
    
    open(filename) {
        try {
            this.content = fs.readFileSync(filename, 'utf8');
            this.filename = filename;
            this.isModified = false;
            console.log(`å·²æ‰“å¼€: ${filename}`);
        } catch (error) {
            console.error(`æ‰“å¼€æ–‡ä»¶é”™è¯¯: ${error.message}`);
        }
    }
    
    save() {
        if (!this.filename) {
            console.error('æ²¡æœ‰æ–‡ä»¶å¯ä¿å­˜');
            return;
        }
        
        try {
            fs.writeFileSync(this.filename, this.content);
            this.isModified = false;
            console.log(`å·²ä¿å­˜: ${this.filename}`);
        } catch (error) {
            console.error(`ä¿å­˜æ–‡ä»¶é”™è¯¯: ${error.message}`);
        }
    }
    
    insert(text, position) {
        this.content = this.content.slice(0, position) + text + this.content.slice(position);
        this.isModified = true;
    }
    
    delete(start, end) {
        this.content = this.content.slice(0, start) + this.content.slice(end);
        this.isModified = true;
    }
    
    display() {
        console.log('\n--- æ–‡ä»¶å†…å®¹ ---');
        console.log(this.content);
        console.log('--- å†…å®¹ç»“æŸ ---\n');
    }
    
    getStats() {
        return {
            lines: this.content.split('\n').length,
            characters: this.content.length,
            words: this.content.split(/\s+/).filter(word => word.length > 0).length
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const editor = new TextEditor();
editor.open('test.txt');
editor.insert('ä½ å¥½ï¼Œä¸–ç•Œï¼\n', 0);
editor.display();
console.log('ç»Ÿè®¡:', editor.getStats());
editor.save();
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>

#define MAX_CONTENT 10000
#define MAX_FILENAME 256

typedef struct {
    char content[MAX_CONTENT];
    char filename[MAX_FILENAME];
    int length;
    int isModified;
} TextEditor;

// åˆå§‹åŒ–ç¼–è¾‘å™¨
void initEditor(TextEditor* editor) {
    editor->content[0] = '\0';
    editor->filename[0] = '\0';
    editor->length = 0;
    editor->isModified = 0;
}

// æ‰“å¼€æ–‡ä»¶
int openFile(TextEditor* editor, const char* filename) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        printf("æ‰“å¼€æ–‡ä»¶é”™è¯¯: %s\n", filename);
        return 0;
    }
    
    editor->length = fread(editor->content, 1, MAX_CONTENT - 1, file);
    editor->content[editor->length] = '\0';
    strcpy(editor->filename, filename);
    editor->isModified = 0;
    
    fclose(file);
    printf("å·²æ‰“å¼€: %s\n", filename);
    return 1;
}

// ä¿å­˜æ–‡ä»¶
int saveFile(TextEditor* editor) {
    if (strlen(editor->filename) == 0) {
        printf("æ²¡æœ‰æ–‡ä»¶å¯ä¿å­˜\n");
        return 0;
    }
    
    FILE* file = fopen(editor->filename, "w");
    if (file == NULL) {
        printf("ä¿å­˜æ–‡ä»¶é”™è¯¯: %s\n", editor->filename);
        return 0;
    }
    
    fwrite(editor->content, 1, editor->length, file);
    fclose(file);
    editor->isModified = 0;
    printf("å·²ä¿å­˜: %s\n", editor->filename);
    return 1;
}

// æ’å…¥æ–‡æœ¬
void insertText(TextEditor* editor, const char* text, int position) {
    int textLen = strlen(text);
    if (position + textLen >= MAX_CONTENT) {
        printf("å†…å®¹è¿‡å¤§\n");
        return;
    }
    
    // ç§»åŠ¨å†…å®¹ä»¥è…¾å‡ºç©ºé—´
    memmove(editor->content + position + textLen, 
            editor->content + position, 
            editor->length - position + 1);
    
    // æ’å…¥æ–‡æœ¬
    memcpy(editor->content + position, text, textLen);
    editor->length += textLen;
    editor->isModified = 1;
}

// åˆ é™¤æ–‡æœ¬
void deleteText(TextEditor* editor, int start, int end) {
    if (start >= end || end > editor->length) {
        return;
    }
    
    memmove(editor->content + start, 
            editor->content + end, 
            editor->length - end + 1);
    editor->length -= (end - start);
    editor->isModified = 1;
}

// æ˜¾ç¤ºå†…å®¹
void displayContent(TextEditor* editor) {
    printf("\n--- æ–‡ä»¶å†…å®¹ ---\n");
    printf("%s", editor->content);
    printf("--- å†…å®¹ç»“æŸ ---\n\n");
}

// è·å–æ–‡ä»¶ç»Ÿè®¡
void getStats(TextEditor* editor) {
    int lines = 1;
    int words = 0;
    int inWord = 0;
    
    for (int i = 0; i < editor->length; i++) {
        if (editor->content[i] == '\n') {
            lines++;
        }
        
        if (editor->content[i] == ' ' || editor->content[i] == '\n' || editor->content[i] == '\t') {
            inWord = 0;
        } else if (!inWord) {
            words++;
            inWord = 1;
        }
    }
    
    printf("è¡Œæ•°: %d, å­—ç¬¦æ•°: %d, å•è¯æ•°: %d\n", 
           lines, editor->length, words);
}

int main() {
    TextEditor editor;
    initEditor(&editor);
    
    // ä½¿ç”¨ç¤ºä¾‹
    if (openFile(&editor, "test.txt")) {
        insertText(&editor, "ä½ å¥½ï¼Œä¸–ç•Œï¼\n", 0);
        displayContent(&editor);
        getStats(&editor);
        saveFile(&editor);
    }
    
    return 0;
}
```
</UniversalEditor>

## 3. å†…å­˜åˆ†é…å™¨

<UniversalEditor title="å†…å­˜åˆ†é…å™¨" compare={true}>
```javascript !! js
// JavaScript - å†…å­˜ç®¡ç†æ¨¡æ‹Ÿ
class MemoryPool {
    constructor(size) {
        this.buffer = new ArrayBuffer(size);
        this.used = new Set();
        this.freeBlocks = [{ start: 0, size: size }];
    }
    
    allocate(size) {
        // æŸ¥æ‰¾æœ€ä½³åŒ¹é…å—
        let bestBlock = null;
        let bestIndex = -1;
        
        for (let i = 0; i < this.freeBlocks.length; i++) {
            const block = this.freeBlocks[i];
            if (block.size >= size) {
                if (!bestBlock || block.size < bestBlock.size) {
                    bestBlock = block;
                    bestIndex = i;
                }
            }
        }
        
        if (!bestBlock) {
            throw new Error('æœªæ‰¾åˆ°åˆé€‚çš„å—');
        }
        
        // ä»å—ä¸­åˆ†é…
        const allocated = {
            start: bestBlock.start,
            size: size
        };
        
        this.used.add(allocated);
        
        // æ›´æ–°ç©ºé—²å—
        if (bestBlock.size > size) {
            this.freeBlocks[bestIndex] = {
                start: bestBlock.start + size,
                size: bestBlock.size - size
            };
        } else {
            this.freeBlocks.splice(bestIndex, 1);
        }
        
        return allocated;
    }
    
    free(block) {
        if (!this.used.has(block)) {
            throw new Error('å—æœªåˆ†é…');
        }
        
        this.used.delete(block);
        
        // ä¸ç›¸é‚»ç©ºé—²å—åˆå¹¶
        let merged = false;
        for (let i = 0; i < this.freeBlocks.length; i++) {
            const freeBlock = this.freeBlocks[i];
            
            // ä¸åé¢çš„å—åˆå¹¶
            if (block.start + block.size === freeBlock.start) {
                freeBlock.start = block.start;
                freeBlock.size += block.size;
                merged = true;
                break;
            }
            
            // ä¸å‰é¢çš„å—åˆå¹¶
            if (freeBlock.start + freeBlock.size === block.start) {
                freeBlock.size += block.size;
                merged = true;
                break;
            }
        }
        
        if (!merged) {
            this.freeBlocks.push(block);
        }
    }
    
    getStats() {
        const totalUsed = Array.from(this.used).reduce((sum, block) => sum + block.size, 0);
        const totalFree = this.freeBlocks.reduce((sum, block) => sum + block.size, 0);
        
        return {
            totalUsed,
            totalFree,
            fragmentation: this.freeBlocks.length
        };
    }
}

// ä½¿ç”¨
const pool = new MemoryPool(1024);
const block1 = pool.allocate(100);
const block2 = pool.allocate(200);
console.log('ç»Ÿè®¡:', pool.getStats());
pool.free(block1);
console.log('é‡Šæ”¾å:', pool.getStats());
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define POOL_SIZE 1024
#define MAX_BLOCKS 50

typedef struct {
    int start;
    int size;
    int isUsed;
} MemoryBlock;

typedef struct {
    char buffer[POOL_SIZE];
    MemoryBlock blocks[MAX_BLOCKS];
    int blockCount;
} MemoryPool;

// åˆå§‹åŒ–å†…å­˜æ± 
void initPool(MemoryPool* pool) {
    pool->blockCount = 1;
    pool->blocks[0].start = 0;
    pool->blocks[0].size = POOL_SIZE;
    pool->blocks[0].isUsed = 0;
}

// æŸ¥æ‰¾æœ€ä½³åŒ¹é…å—
int findBestFit(MemoryPool* pool, int size) {
    int bestIndex = -1;
    int bestSize = POOL_SIZE + 1;
    
    for (int i = 0; i < pool->blockCount; i++) {
        if (!pool->blocks[i].isUsed && pool->blocks[i].size >= size) {
            if (pool->blocks[i].size < bestSize) {
                bestSize = pool->blocks[i].size;
                bestIndex = i;
            }
        }
    }
    
    return bestIndex;
}

// åˆ†é…å†…å­˜
void* allocate(MemoryPool* pool, int size) {
    int blockIndex = findBestFit(pool, size);
    if (blockIndex == -1) {
        printf("æœªæ‰¾åˆ°åˆé€‚çš„å—\n");
        return NULL;
    }
    
    MemoryBlock* block = &pool->blocks[blockIndex];
    
    // å¦‚æœå—æ¯”éœ€è¦çš„å¤§ï¼Œåˆ†å‰²å®ƒ
    if (block->size > size) {
        // åˆ›å»ºæ–°çš„ç©ºé—²å—
        if (pool->blockCount < MAX_BLOCKS) {
            pool->blocks[pool->blockCount].start = block->start + size;
            pool->blocks[pool->blockCount].size = block->size - size;
            pool->blocks[pool->blockCount].isUsed = 0;
            pool->blockCount++;
        }
        
        block->size = size;
    }
    
    block->isUsed = 1;
    return &pool->buffer[block->start];
}

// é‡Šæ”¾å†…å­˜
void freeMemory(MemoryPool* pool, void* ptr) {
    int offset = (char*)ptr - pool->buffer;
    
    // æŸ¥æ‰¾å—
    for (int i = 0; i < pool->blockCount; i++) {
        if (pool->blocks[i].start == offset && pool->blocks[i].isUsed) {
            pool->blocks[i].isUsed = 0;
            
            // ä¸ç›¸é‚»ç©ºé—²å—åˆå¹¶
            for (int j = 0; j < pool->blockCount; j++) {
                if (i != j && !pool->blocks[j].isUsed) {
                    // ä¸åé¢çš„å—åˆå¹¶
                    if (pool->blocks[i].start + pool->blocks[i].size == pool->blocks[j].start) {
                        pool->blocks[i].size += pool->blocks[j].size;
                        // ç§»é™¤å— j
                        for (int k = j; k < pool->blockCount - 1; k++) {
                            pool->blocks[k] = pool->blocks[k + 1];
                        }
                        pool->blockCount--;
                        break;
                    }
                    
                    // ä¸å‰é¢çš„å—åˆå¹¶
                    if (pool->blocks[j].start + pool->blocks[j].size == pool->blocks[i].start) {
                        pool->blocks[j].size += pool->blocks[i].size;
                        // ç§»é™¤å— i
                        for (int k = i; k < pool->blockCount - 1; k++) {
                            pool->blocks[k] = pool->blocks[k + 1];
                        }
                        pool->blockCount--;
                        break;
                    }
                }
            }
            break;
        }
    }
}

// è·å–æ± ç»Ÿè®¡
void getPoolStats(MemoryPool* pool) {
    int totalUsed = 0;
    int totalFree = 0;
    int fragmentation = 0;
    
    for (int i = 0; i < pool->blockCount; i++) {
        if (pool->blocks[i].isUsed) {
            totalUsed += pool->blocks[i].size;
        } else {
            totalFree += pool->blocks[i].size;
            fragmentation++;
        }
    }
    
    printf("æ€»ä½¿ç”¨: %d, æ€»ç©ºé—²: %d, ç¢ç‰‡åŒ–: %d\n", 
           totalUsed, totalFree, fragmentation);
}

int main() {
    MemoryPool pool;
    initPool(&pool);
    
    // ä½¿ç”¨ç¤ºä¾‹
    void* block1 = allocate(&pool, 100);
    void* block2 = allocate(&pool, 200);
    
    if (block1 && block2) {
        strcpy(block1, "ä½ å¥½");
        strcpy(block2, "ä¸–ç•Œ");
        
        printf("å—1: %s\n", (char*)block1);
        printf("å—2: %s\n", (char*)block2);
        
        getPoolStats(&pool);
        
        freeMemory(&pool, block1);
        getPoolStats(&pool);
    }
    
    return 0;
}
```
</UniversalEditor>

## 4. æ•°æ®ç»“æ„åº“

<UniversalEditor title="æ•°æ®ç»“æ„åº“" compare={true}>
```javascript !! js
// JavaScript - æ•°æ®ç»“æ„åº“
class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }
    
    append(data) {
        const newNode = { data, next: null };
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }
    
    remove(data) {
        if (!this.head) return false;
        
        if (this.head.data === data) {
            this.head = this.head.next;
            this.size--;
            return true;
        }
        
        let current = this.head;
        while (current.next && current.next.data !== data) {
            current = current.next;
        }
        
        if (current.next) {
            current.next = current.next.next;
            this.size--;
            return true;
        }
        
        return false;
    }
    
    find(data) {
        let current = this.head;
        while (current) {
            if (current.data === data) {
                return current;
            }
            current = current.next;
        }
        return null;
    }
    
    toArray() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        return result;
    }
}

class Stack {
    constructor() {
        this.items = [];
    }
    
    push(item) {
        this.items.push(item);
    }
    
    pop() {
        return this.items.pop();
    }
    
    peek() {
        return this.items[this.items.length - 1];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}

class Queue {
    constructor() {
        this.items = [];
    }
    
    enqueue(item) {
        this.items.push(item);
    }
    
    dequeue() {
        return this.items.shift();
    }
    
    front() {
        return this.items[0];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}

// ä½¿ç”¨
const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);
console.log('é“¾è¡¨:', list.toArray());

const stack = new Stack();
stack.push(1);
stack.push(2);
console.log('æ ˆå¼¹å‡º:', stack.pop());

const queue = new Queue();
queue.enqueue('a');
queue.enqueue('b');
console.log('é˜Ÿåˆ—å‡ºé˜Ÿ:', queue.dequeue());
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// é“¾è¡¨
typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
    int size;
} LinkedList;

// æ ˆ
typedef struct {
    int* items;
    int top;
    int capacity;
} Stack;

// é˜Ÿåˆ—
typedef struct {
    int* items;
    int front;
    int rear;
    int size;
    int capacity;
} Queue;

// é“¾è¡¨å‡½æ•°
LinkedList* createLinkedList() {
    LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));
    list->head = NULL;
    list->size = 0;
    return list;
}

void append(LinkedList* list, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    
    if (!list->head) {
        list->head = newNode;
    } else {
        Node* current = list->head;
        while (current->next) {
            current = current->next;
        }
        current->next = newNode;
    }
    list->size++;
}

int removeNode(LinkedList* list, int data) {
    if (!list->head) return 0;
    
    if (list->head->data == data) {
        Node* temp = list->head;
        list->head = list->head->next;
        free(temp);
        list->size--;
        return 1;
    }
    
    Node* current = list->head;
    while (current->next && current->next->data != data) {
        current = current->next;
    }
    
    if (current->next) {
        Node* temp = current->next;
        current->next = current->next->next;
        free(temp);
        list->size--;
        return 1;
    }
    
    return 0;
}

Node* find(LinkedList* list, int data) {
    Node* current = list->head;
    while (current) {
        if (current->data == data) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}

// æ ˆå‡½æ•°
Stack* createStack(int capacity) {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    stack->items = (int*)malloc(capacity * sizeof(int));
    stack->top = -1;
    stack->capacity = capacity;
    return stack;
}

void push(Stack* stack, int item) {
    if (stack->top < stack->capacity - 1) {
        stack->items[++stack->top] = item;
    }
}

int pop(Stack* stack) {
    if (stack->top >= 0) {
        return stack->items[stack->top--];
    }
    return -1;
}

int peek(Stack* stack) {
    if (stack->top >= 0) {
        return stack->items[stack->top];
    }
    return -1;
}

int isEmpty(Stack* stack) {
    return stack->top == -1;
}

// é˜Ÿåˆ—å‡½æ•°
Queue* createQueue(int capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->items = (int*)malloc(capacity * sizeof(int));
    queue->front = 0;
    queue->rear = -1;
    queue->size = 0;
    queue->capacity = capacity;
    return queue;
}

void enqueue(Queue* queue, int item) {
    if (queue->size < queue->capacity) {
        queue->rear = (queue->rear + 1) % queue->capacity;
        queue->items[queue->rear] = item;
        queue->size++;
    }
}

int dequeue(Queue* queue) {
    if (queue->size > 0) {
        int item = queue->items[queue->front];
        queue->front = (queue->front + 1) % queue->capacity;
        queue->size--;
        return item;
    }
    return -1;
}

int front(Queue* queue) {
    if (queue->size > 0) {
        return queue->items[queue->front];
    }
    return -1;
}

int main() {
    // é“¾è¡¨ç¤ºä¾‹
    LinkedList* list = createLinkedList();
    append(list, 1);
    append(list, 2);
    append(list, 3);
    
    Node* found = find(list, 2);
    if (found) {
        printf("æ‰¾åˆ°: %d\n", found->data);
    }
    
    // æ ˆç¤ºä¾‹
    Stack* stack = createStack(10);
    push(stack, 1);
    push(stack, 2);
    printf("æ ˆå¼¹å‡º: %d\n", pop(stack));
    
    // é˜Ÿåˆ—ç¤ºä¾‹
    Queue* queue = createQueue(10);
    enqueue(queue, 'a');
    enqueue(queue, 'b');
    printf("é˜Ÿåˆ—å‡ºé˜Ÿ: %c\n", dequeue(queue));
    
    return 0;
}
```
</UniversalEditor>

## 5. å¸¸è§é™·é˜±
- **å†…å­˜æ³„æ¼**ï¼šå§‹ç»ˆé‡Šæ”¾æ•°æ®ç»“æ„ä¸­åˆ†é…çš„å†…å­˜
- **ç¼“å†²åŒºæº¢å‡º**ï¼šåœ¨è®¿é—®æ•°ç»„å‰æ£€æŸ¥è¾¹ç•Œ
- **èµ„æºç®¡ç†**ï¼šæ­£ç¡®å…³é—­æ–‡ä»¶å’Œé‡Šæ”¾ç³»ç»Ÿèµ„æº
- **é”™è¯¯å¤„ç†**ï¼šæ£€æŸ¥è¿”å›å€¼å¹¶ä¼˜é›…åœ°å¤„ç†é”™è¯¯
- **çº¿ç¨‹å®‰å…¨**ï¼šåœ¨å…±äº«æ•°æ®æ—¶ä½¿ç”¨åŒæ­¥

## 6. ç»ƒä¹ é¢˜
1. æ‰©å±•æ–‡æœ¬ç¼–è¾‘å™¨ä»¥æ”¯æŒæœç´¢å’Œæ›¿æ¢åŠŸèƒ½ã€‚
2. å®ç°å…·æœ‰ä¸åŒåˆ†é…ç­–ç•¥çš„æ›´å¤æ‚çš„å†…å­˜åˆ†é…å™¨ã€‚
3. å‘æ•°æ®ç»“æ„åº“æ·»åŠ æ’åºå’Œæœç´¢ç®—æ³•ã€‚
4. åˆ›å»ºä¸€ä¸ªæ˜¾ç¤ºè¿›ç¨‹ä¿¡æ¯çš„ç®€å•ç³»ç»Ÿç›‘æ§å·¥å…·ã€‚

## 7. æ€§èƒ½åˆ†æ
- **æ–‡æœ¬ç¼–è¾‘å™¨**ï¼šé«˜æ•ˆçš„å­—ç¬¦ä¸²æ“ä½œå’Œæ–‡ä»¶ I/O
- **å†…å­˜åˆ†é…å™¨**ï¼šæœ€å°åŒ–ç¢ç‰‡åŒ–å’Œåˆ†é…å¼€é”€
- **æ•°æ®ç»“æ„**ï¼šä¼˜åŒ–å¸¸è§æ“ä½œï¼ˆæ’å…¥ã€åˆ é™¤ã€æœç´¢ï¼‰
- **ç³»ç»Ÿå·¥å…·**ï¼šé«˜æ•ˆçš„ç³»ç»Ÿè°ƒç”¨å’Œæœ€å°èµ„æºä½¿ç”¨

---

> **å°ç»“**ï¼šC é¡¹ç›®å±•ç¤ºäº†ç³»ç»Ÿç¼–ç¨‹æ¦‚å¿µçš„å®é™…åº”ç”¨ã€‚æ„å»ºè¿™äº›é¡¹ç›®æœ‰åŠ©äºå·©å›ºå¯¹å†…å­˜ç®¡ç†ã€æ•°æ®ç»“æ„å’Œç³»ç»Ÿçº§ç¼–ç¨‹çš„ç†è§£ã€‚ 