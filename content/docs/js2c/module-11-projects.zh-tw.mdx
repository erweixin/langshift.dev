---
title: "å¯¦æˆ°å°ˆæ¡ˆé–‹ç™¼"
description: "å¾ JavaScript è¦–è§’å­¸ç¿’ C èªè¨€å¯¦æˆ°å°ˆæ¡ˆï¼Œå»ºæ§‹æ–‡å­—ç·¨è¼¯å™¨ã€è¨˜æ†¶é«”åˆ†é…å™¨ã€è³‡æ–™çµæ§‹åº«å’Œç³»çµ±å·¥å…·ã€‚"
---

# å¯¦æˆ°å°ˆæ¡ˆé–‹ç™¼

## 1. æ¦‚å¿µä»‹ç´¹

### å¾ JavaScript å°ˆæ¡ˆåˆ° C ç³»çµ±æ‡‰ç”¨ç¨‹å¼

åœ¨ JavaScript ä¸­ï¼Œä½ é€šå¸¸å»ºæ§‹ Web æ‡‰ç”¨ç¨‹å¼ã€API å’Œä½¿ç”¨è€…ä»‹é¢ã€‚è€Œåœ¨ C èªè¨€ä¸­ï¼Œä½ å¯ä»¥å»ºç«‹ç³»çµ±å·¥å…·ã€åµŒå…¥å¼æ‡‰ç”¨ç¨‹å¼å’Œç›´æ¥èˆ‡ç¡¬é«”å’Œä½œæ¥­ç³»çµ±äº’å‹•çš„æ•ˆèƒ½é—œéµå‹è»Ÿé«”ã€‚

> ğŸ’¡ **æ ¸å¿ƒæ¦‚å¿µ**ï¼šC å°ˆæ¡ˆå°ˆæ³¨æ–¼ç³»çµ±ç´šç¨‹å¼è¨­è¨ˆã€æ•ˆèƒ½æœ€ä½³åŒ–å’Œç›´æ¥ç¡¬é«”äº’å‹•ï¼Œä½¿ä½ èƒ½å¤ å»ºæ§‹é«˜æ•ˆã€ä½ç´šçš„æ‡‰ç”¨ç¨‹å¼ã€‚

## 2. ç°¡å–®æ–‡å­—ç·¨è¼¯å™¨

<UniversalEditor title="æ–‡å­—ç·¨è¼¯å™¨å¯¦ç¾" compare={true}>
```javascript !! js
// JavaScript - ç°¡å–®æ–‡å­—ç·¨è¼¯å™¨ (Node.js)
const readline = require('readline');
const fs = require('fs');

class TextEditor {
    constructor() {
        this.content = '';
        this.filename = '';
        this.isModified = false;
    }
    
    open(filename) {
        try {
            this.content = fs.readFileSync(filename, 'utf8');
            this.filename = filename;
            this.isModified = false;
            console.log(`å·²é–‹å•Ÿ: ${filename}`);
        } catch (error) {
            console.error(`é–‹å•Ÿæª”æ¡ˆéŒ¯èª¤: ${error.message}`);
        }
    }
    
    save() {
        if (!this.filename) {
            console.error('æ²’æœ‰æª”æ¡ˆå¯å„²å­˜');
            return;
        }
        
        try {
            fs.writeFileSync(this.filename, this.content);
            this.isModified = false;
            console.log(`å·²å„²å­˜: ${this.filename}`);
        } catch (error) {
            console.error(`å„²å­˜æª”æ¡ˆéŒ¯èª¤: ${error.message}`);
        }
    }
    
    insert(text, position) {
        this.content = this.content.slice(0, position) + text + this.content.slice(position);
        this.isModified = true;
    }
    
    delete(start, end) {
        this.content = this.content.slice(0, start) + this.content.slice(end);
        this.isModified = true;
    }
    
    display() {
        console.log('\n--- æª”æ¡ˆå…§å®¹ ---');
        console.log(this.content);
        console.log('--- å…§å®¹çµæŸ ---\n');
    }
    
    getStats() {
        return {
            lines: this.content.split('\n').length,
            characters: this.content.length,
            words: this.content.split(/\s+/).filter(word => word.length > 0).length
        };
    }
}

// ä½¿ç”¨ç¯„ä¾‹
const editor = new TextEditor();
editor.open('test.txt');
editor.insert('ä½ å¥½ï¼Œä¸–ç•Œï¼\n', 0);
editor.display();
console.log('çµ±è¨ˆ:', editor.getStats());
editor.save();
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <termios.h>

#define MAX_CONTENT 10000
#define MAX_FILENAME 256

typedef struct {
    char content[MAX_CONTENT];
    char filename[MAX_FILENAME];
    int length;
    int isModified;
} TextEditor;

// åˆå§‹åŒ–ç·¨è¼¯å™¨
void initEditor(TextEditor* editor) {
    editor->content[0] = '\0';
    editor->filename[0] = '\0';
    editor->length = 0;
    editor->isModified = 0;
}

// é–‹å•Ÿæª”æ¡ˆ
int openFile(TextEditor* editor, const char* filename) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        printf("é–‹å•Ÿæª”æ¡ˆéŒ¯èª¤: %s\n", filename);
        return 0;
    }
    
    editor->length = fread(editor->content, 1, MAX_CONTENT - 1, file);
    editor->content[editor->length] = '\0';
    strcpy(editor->filename, filename);
    editor->isModified = 0;
    
    fclose(file);
    printf("å·²é–‹å•Ÿ: %s\n", filename);
    return 1;
}

// å„²å­˜æª”æ¡ˆ
int saveFile(TextEditor* editor) {
    if (strlen(editor->filename) == 0) {
        printf("æ²’æœ‰æª”æ¡ˆå¯å„²å­˜\n");
        return 0;
    }
    
    FILE* file = fopen(editor->filename, "w");
    if (file == NULL) {
        printf("å„²å­˜æª”æ¡ˆéŒ¯èª¤: %s\n", editor->filename);
        return 0;
    }
    
    fwrite(editor->content, 1, editor->length, file);
    fclose(file);
    editor->isModified = 0;
    printf("å·²å„²å­˜: %s\n", editor->filename);
    return 1;
}

// æ’å…¥æ–‡å­—
void insertText(TextEditor* editor, const char* text, int position) {
    int textLen = strlen(text);
    if (position + textLen >= MAX_CONTENT) {
        printf("å…§å®¹éå¤§\n");
        return;
    }
    
    // ç§»å‹•å…§å®¹ä»¥é¨°å‡ºç©ºé–“
    memmove(editor->content + position + textLen, 
            editor->content + position, 
            editor->length - position + 1);
    
    // æ’å…¥æ–‡å­—
    memcpy(editor->content + position, text, textLen);
    editor->length += textLen;
    editor->isModified = 1;
}

// åˆªé™¤æ–‡å­—
void deleteText(TextEditor* editor, int start, int end) {
    if (start >= end || end > editor->length) {
        return;
    }
    
    memmove(editor->content + start, 
            editor->content + end, 
            editor->length - end + 1);
    editor->length -= (end - start);
    editor->isModified = 1;
}

// é¡¯ç¤ºå…§å®¹
void displayContent(TextEditor* editor) {
    printf("\n--- æª”æ¡ˆå…§å®¹ ---\n");
    printf("%s", editor->content);
    printf("--- å…§å®¹çµæŸ ---\n\n");
}

// å–å¾—æª”æ¡ˆçµ±è¨ˆ
void getStats(TextEditor* editor) {
    int lines = 1;
    int words = 0;
    int inWord = 0;
    
    for (int i = 0; i < editor->length; i++) {
        if (editor->content[i] == '\n') {
            lines++;
        }
        
        if (editor->content[i] == ' ' || editor->content[i] == '\n' || editor->content[i] == '\t') {
            inWord = 0;
        } else if (!inWord) {
            words++;
            inWord = 1;
        }
    }
    
    printf("è¡Œæ•¸: %d, å­—å…ƒæ•¸: %d, å–®è©æ•¸: %d\n", 
           lines, editor->length, words);
}

int main() {
    TextEditor editor;
    initEditor(&editor);
    
    // ä½¿ç”¨ç¯„ä¾‹
    if (openFile(&editor, "test.txt")) {
        insertText(&editor, "ä½ å¥½ï¼Œä¸–ç•Œï¼\n", 0);
        displayContent(&editor);
        getStats(&editor);
        saveFile(&editor);
    }
    
    return 0;
}
```
</UniversalEditor>

## 3. è¨˜æ†¶é«”åˆ†é…å™¨

<UniversalEditor title="è¨˜æ†¶é«”åˆ†é…å™¨" compare={true}>
```javascript !! js
// JavaScript - è¨˜æ†¶é«”ç®¡ç†æ¨¡æ“¬
class MemoryPool {
    constructor(size) {
        this.buffer = new ArrayBuffer(size);
        this.used = new Set();
        this.freeBlocks = [{ start: 0, size: size }];
    }
    
    allocate(size) {
        // å°‹æ‰¾æœ€ä½³åŒ¹é…å¡Š
        let bestBlock = null;
        let bestIndex = -1;
        
        for (let i = 0; i < this.freeBlocks.length; i++) {
            const block = this.freeBlocks[i];
            if (block.size >= size) {
                if (!bestBlock || block.size < bestBlock.size) {
                    bestBlock = block;
                    bestIndex = i;
                }
            }
        }
        
        if (!bestBlock) {
            throw new Error('æœªæ‰¾åˆ°åˆé©çš„å¡Š');
        }
        
        // å¾å¡Šä¸­åˆ†é…
        const allocated = {
            start: bestBlock.start,
            size: size
        };
        
        this.used.add(allocated);
        
        // æ›´æ–°ç©ºé–’å¡Š
        if (bestBlock.size > size) {
            this.freeBlocks[bestIndex] = {
                start: bestBlock.start + size,
                size: bestBlock.size - size
            };
        } else {
            this.freeBlocks.splice(bestIndex, 1);
        }
        
        return allocated;
    }
    
    free(block) {
        if (!this.used.has(block)) {
            throw new Error('å¡Šæœªåˆ†é…');
        }
        
        this.used.delete(block);
        
        // èˆ‡ç›¸é„°ç©ºé–’å¡Šåˆä½µ
        let merged = false;
        for (let i = 0; i < this.freeBlocks.length; i++) {
            const freeBlock = this.freeBlocks[i];
            
            // èˆ‡å¾Œé¢çš„å¡Šåˆä½µ
            if (block.start + block.size === freeBlock.start) {
                freeBlock.start = block.start;
                freeBlock.size += block.size;
                merged = true;
                break;
            }
            
            // èˆ‡å‰é¢çš„å¡Šåˆä½µ
            if (freeBlock.start + freeBlock.size === block.start) {
                freeBlock.size += block.size;
                merged = true;
                break;
            }
        }
        
        if (!merged) {
            this.freeBlocks.push(block);
        }
    }
    
    getStats() {
        const totalUsed = Array.from(this.used).reduce((sum, block) => sum + block.size, 0);
        const totalFree = this.freeBlocks.reduce((sum, block) => sum + block.size, 0);
        
        return {
            totalUsed,
            totalFree,
            fragmentation: this.freeBlocks.length
        };
    }
}

// ä½¿ç”¨
const pool = new MemoryPool(1024);
const block1 = pool.allocate(100);
const block2 = pool.allocate(200);
console.log('çµ±è¨ˆ:', pool.getStats());
pool.free(block1);
console.log('é‡‹æ”¾å¾Œ:', pool.getStats());
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define POOL_SIZE 1024
#define MAX_BLOCKS 50

typedef struct {
    int start;
    int size;
    int isUsed;
} MemoryBlock;

typedef struct {
    char buffer[POOL_SIZE];
    MemoryBlock blocks[MAX_BLOCKS];
    int blockCount;
} MemoryPool;

// åˆå§‹åŒ–è¨˜æ†¶é«”æ± 
void initPool(MemoryPool* pool) {
    pool->blockCount = 1;
    pool->blocks[0].start = 0;
    pool->blocks[0].size = POOL_SIZE;
    pool->blocks[0].isUsed = 0;
}

// å°‹æ‰¾æœ€ä½³åŒ¹é…å¡Š
int findBestFit(MemoryPool* pool, int size) {
    int bestIndex = -1;
    int bestSize = POOL_SIZE + 1;
    
    for (int i = 0; i < pool->blockCount; i++) {
        if (!pool->blocks[i].isUsed && pool->blocks[i].size >= size) {
            if (pool->blocks[i].size < bestSize) {
                bestSize = pool->blocks[i].size;
                bestIndex = i;
            }
        }
    }
    
    return bestIndex;
}

// åˆ†é…è¨˜æ†¶é«”
void* allocate(MemoryPool* pool, int size) {
    int blockIndex = findBestFit(pool, size);
    if (blockIndex == -1) {
        printf("æœªæ‰¾åˆ°åˆé©çš„å¡Š\n");
        return NULL;
    }
    
    MemoryBlock* block = &pool->blocks[blockIndex];
    
    // å¦‚æœå¡Šæ¯”éœ€è¦çš„å¤§ï¼Œåˆ†å‰²å®ƒ
    if (block->size > size) {
        // å»ºç«‹æ–°çš„ç©ºé–’å¡Š
        if (pool->blockCount < MAX_BLOCKS) {
            pool->blocks[pool->blockCount].start = block->start + size;
            pool->blocks[pool->blockCount].size = block->size - size;
            pool->blocks[pool->blockCount].isUsed = 0;
            pool->blockCount++;
        }
        
        block->size = size;
    }
    
    block->isUsed = 1;
    return &pool->buffer[block->start];
}

// é‡‹æ”¾è¨˜æ†¶é«”
void freeMemory(MemoryPool* pool, void* ptr) {
    int offset = (char*)ptr - pool->buffer;
    
    // å°‹æ‰¾å¡Š
    for (int i = 0; i < pool->blockCount; i++) {
        if (pool->blocks[i].start == offset && pool->blocks[i].isUsed) {
            pool->blocks[i].isUsed = 0;
            
            // èˆ‡ç›¸é„°ç©ºé–’å¡Šåˆä½µ
            for (int j = 0; j < pool->blockCount; j++) {
                if (i != j && !pool->blocks[j].isUsed) {
                    // èˆ‡å¾Œé¢çš„å¡Šåˆä½µ
                    if (pool->blocks[i].start + pool->blocks[i].size == pool->blocks[j].start) {
                        pool->blocks[i].size += pool->blocks[j].size;
                        // ç§»é™¤å¡Š j
                        for (int k = j; k < pool->blockCount - 1; k++) {
                            pool->blocks[k] = pool->blocks[k + 1];
                        }
                        pool->blockCount--;
                        break;
                    }
                    
                    // èˆ‡å‰é¢çš„å¡Šåˆä½µ
                    if (pool->blocks[j].start + pool->blocks[j].size == pool->blocks[i].start) {
                        pool->blocks[j].size += pool->blocks[i].size;
                        // ç§»é™¤å¡Š i
                        for (int k = i; k < pool->blockCount - 1; k++) {
                            pool->blocks[k] = pool->blocks[k + 1];
                        }
                        pool->blockCount--;
                        break;
                    }
                }
            }
            break;
        }
    }
}

// å–å¾—æ± çµ±è¨ˆ
void getPoolStats(MemoryPool* pool) {
    int totalUsed = 0;
    int totalFree = 0;
    int fragmentation = 0;
    
    for (int i = 0; i < pool->blockCount; i++) {
        if (pool->blocks[i].isUsed) {
            totalUsed += pool->blocks[i].size;
        } else {
            totalFree += pool->blocks[i].size;
            fragmentation++;
        }
    }
    
    printf("ç¸½ä½¿ç”¨: %d, ç¸½ç©ºé–’: %d, ç¢ç‰‡åŒ–: %d\n", 
           totalUsed, totalFree, fragmentation);
}

int main() {
    MemoryPool pool;
    initPool(&pool);
    
    // ä½¿ç”¨ç¯„ä¾‹
    void* block1 = allocate(&pool, 100);
    void* block2 = allocate(&pool, 200);
    
    if (block1 && block2) {
        strcpy(block1, "ä½ å¥½");
        strcpy(block2, "ä¸–ç•Œ");
        
        printf("å¡Š1: %s\n", (char*)block1);
        printf("å¡Š2: %s\n", (char*)block2);
        
        getPoolStats(&pool);
        
        freeMemory(&pool, block1);
        getPoolStats(&pool);
    }
    
    return 0;
}
```
</UniversalEditor>

## 4. è³‡æ–™çµæ§‹åº«

<UniversalEditor title="è³‡æ–™çµæ§‹åº«" compare={true}>
```javascript !! js
// JavaScript - è³‡æ–™çµæ§‹åº«
class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }
    
    append(data) {
        const newNode = { data, next: null };
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }
    
    remove(data) {
        if (!this.head) return false;
        
        if (this.head.data === data) {
            this.head = this.head.next;
            this.size--;
            return true;
        }
        
        let current = this.head;
        while (current.next && current.next.data !== data) {
            current = current.next;
        }
        
        if (current.next) {
            current.next = current.next.next;
            this.size--;
            return true;
        }
        
        return false;
    }
    
    find(data) {
        let current = this.head;
        while (current) {
            if (current.data === data) {
                return current;
            }
            current = current.next;
        }
        return null;
    }
    
    toArray() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        return result;
    }
}

class Stack {
    constructor() {
        this.items = [];
    }
    
    push(item) {
        this.items.push(item);
    }
    
    pop() {
        return this.items.pop();
    }
    
    peek() {
        return this.items[this.items.length - 1];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}

class Queue {
    constructor() {
        this.items = [];
    }
    
    enqueue(item) {
        this.items.push(item);
    }
    
    dequeue() {
        return this.items.shift();
    }
    
    front() {
        return this.items[0];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
}

// ä½¿ç”¨
const list = new LinkedList();
list.append(1);
list.append(2);
list.append(3);
console.log('éˆè¡¨:', list.toArray());

const stack = new Stack();
stack.push(1);
stack.push(2);
console.log('å †ç–Šå½ˆå‡º:', stack.pop());

const queue = new Queue();
queue.enqueue('a');
queue.enqueue('b');
console.log('ä½‡åˆ—å‡ºéšŠ:', queue.dequeue());
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// éˆè¡¨
typedef struct Node {
    int data;
    struct Node* next;
} Node;

typedef struct {
    Node* head;
    int size;
} LinkedList;

// å †ç–Š
typedef struct {
    int* items;
    int top;
    int capacity;
} Stack;

// ä½‡åˆ—
typedef struct {
    int* items;
    int front;
    int rear;
    int size;
    int capacity;
} Queue;

// éˆè¡¨å‡½æ•¸
LinkedList* createLinkedList() {
    LinkedList* list = (LinkedList*)malloc(sizeof(LinkedList));
    list->head = NULL;
    list->size = 0;
    return list;
}

void append(LinkedList* list, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    
    if (!list->head) {
        list->head = newNode;
    } else {
        Node* current = list->head;
        while (current->next) {
            current = current->next;
        }
        current->next = newNode;
    }
    list->size++;
}

int removeNode(LinkedList* list, int data) {
    if (!list->head) return 0;
    
    if (list->head->data == data) {
        Node* temp = list->head;
        list->head = list->head->next;
        free(temp);
        list->size--;
        return 1;
    }
    
    Node* current = list->head;
    while (current->next && current->next->data != data) {
        current = current->next;
    }
    
    if (current->next) {
        Node* temp = current->next;
        current->next = current->next->next;
        free(temp);
        list->size--;
        return 1;
    }
    
    return 0;
}

Node* find(LinkedList* list, int data) {
    Node* current = list->head;
    while (current) {
        if (current->data == data) {
            return current;
        }
        current = current->next;
    }
    return NULL;
}

// å †ç–Šå‡½æ•¸
Stack* createStack(int capacity) {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    stack->items = (int*)malloc(capacity * sizeof(int));
    stack->top = -1;
    stack->capacity = capacity;
    return stack;
}

void push(Stack* stack, int item) {
    if (stack->top < stack->capacity - 1) {
        stack->items[++stack->top] = item;
    }
}

int pop(Stack* stack) {
    if (stack->top >= 0) {
        return stack->items[stack->top--];
    }
    return -1;
}

int peek(Stack* stack) {
    if (stack->top >= 0) {
        return stack->items[stack->top];
    }
    return -1;
}

int isEmpty(Stack* stack) {
    return stack->top == -1;
}

// ä½‡åˆ—å‡½æ•¸
Queue* createQueue(int capacity) {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->items = (int*)malloc(capacity * sizeof(int));
    queue->front = 0;
    queue->rear = -1;
    queue->size = 0;
    queue->capacity = capacity;
    return queue;
}

void enqueue(Queue* queue, int item) {
    if (queue->size < queue->capacity) {
        queue->rear = (queue->rear + 1) % queue->capacity;
        queue->items[queue->rear] = item;
        queue->size++;
    }
}

int dequeue(Queue* queue) {
    if (queue->size > 0) {
        int item = queue->items[queue->front];
        queue->front = (queue->front + 1) % queue->capacity;
        queue->size--;
        return item;
    }
    return -1;
}

int front(Queue* queue) {
    if (queue->size > 0) {
        return queue->items[queue->front];
    }
    return -1;
}

int main() {
    // éˆè¡¨ç¤ºä¾‹
    LinkedList* list = createLinkedList();
    append(list, 1);
    append(list, 2);
    append(list, 3);
    
    Node* found = find(list, 2);
    if (found) {
        printf("æ‰¾åˆ°: %d\n", found->data);
    }
    
    // å †ç–Šç¤ºä¾‹
    Stack* stack = createStack(10);
    push(stack, 1);
    push(stack, 2);
    printf("å †ç–Šå½ˆå‡º: %d\n", pop(stack));
    
    // ä½‡åˆ—ç¤ºä¾‹
    Queue* queue = createQueue(10);
    enqueue(queue, 'a');
    enqueue(queue, 'b');
    printf("ä½‡åˆ—å‡ºéšŠ: %c\n", dequeue(queue));
    
    return 0;
}
```
</UniversalEditor>

## 5. å¸¸è¦‹é™·é˜±
- **è¨˜æ†¶é«”æ´©æ¼**ï¼šå§‹çµ‚é‡‹æ”¾è³‡æ–™çµæ§‹ä¸­åˆ†é…çš„è¨˜æ†¶é«”
- **ç·©è¡å€æº¢ä½**ï¼šåœ¨å­˜å–é™£åˆ—å‰æª¢æŸ¥é‚Šç•Œ
- **è³‡æºç®¡ç†**ï¼šæ­£ç¢ºé—œé–‰æª”æ¡ˆå’Œé‡‹æ”¾ç³»çµ±è³‡æº
- **éŒ¯èª¤è™•ç†**ï¼šæª¢æŸ¥è¿”å›å€¼ä¸¦å„ªé›…åœ°è™•ç†éŒ¯èª¤
- **åŸ·è¡Œç·’å®‰å…¨**ï¼šåœ¨å…±äº«è³‡æ–™æ™‚ä½¿ç”¨åŒæ­¥

## 6. ç·´ç¿’é¡Œ
1. æ“´å±•æ–‡å­—ç·¨è¼¯å™¨ä»¥æ”¯æ´æœå°‹å’Œæ›¿æ›åŠŸèƒ½ã€‚
2. å¯¦ç¾å…·æœ‰ä¸åŒåˆ†é…ç­–ç•¥çš„æ›´è¤‡é›œçš„è¨˜æ†¶é«”åˆ†é…å™¨ã€‚
3. å‘è³‡æ–™çµæ§‹åº«æ–°å¢æ’åºå’Œæœå°‹æ¼”ç®—æ³•ã€‚
4. å»ºç«‹ä¸€å€‹é¡¯ç¤ºè¡Œç¨‹è³‡è¨Šçš„ç°¡å–®ç³»çµ±ç›£æ§å·¥å…·ã€‚

## 7. æ•ˆèƒ½åˆ†æ
- **æ–‡å­—ç·¨è¼¯å™¨**ï¼šé«˜æ•ˆçš„å­—ä¸²æ“ä½œå’Œæª”æ¡ˆ I/O
- **è¨˜æ†¶é«”åˆ†é…å™¨**ï¼šæœ€å°åŒ–ç¢ç‰‡åŒ–å’Œåˆ†é…é–‹éŠ·
- **è³‡æ–™çµæ§‹**ï¼šæœ€ä½³åŒ–å¸¸è¦‹æ“ä½œï¼ˆæ’å…¥ã€åˆªé™¤ã€æœå°‹ï¼‰
- **ç³»çµ±å·¥å…·**ï¼šé«˜æ•ˆçš„ç³»çµ±å‘¼å«å’Œæœ€å°è³‡æºä½¿ç”¨

---

> **å°çµ**ï¼šC å°ˆæ¡ˆå±•ç¤ºäº†ç³»çµ±ç¨‹å¼è¨­è¨ˆæ¦‚å¿µçš„å¯¦éš›æ‡‰ç”¨ã€‚å»ºæ§‹é€™äº›å°ˆæ¡ˆæœ‰åŠ©æ–¼éå›ºå°è¨˜æ†¶é«”ç®¡ç†ã€è³‡æ–™çµæ§‹å’Œç³»çµ±ç´šç¨‹å¼è¨­è¨ˆçš„ç†è§£ã€‚ 