---
title: "å¸¸è¦‹é™·é˜±å’Œé™¤éŒ¯"
description: "å¾ JavaScript è¦–è§’å­¸ç¿’ C èªè¨€å¸¸è¦‹é™·é˜±å’Œé™¤éŒ¯ï¼Œç†è§£æŒ‡æ¨™éŒ¯èª¤ã€è¨˜æ†¶é«”æ´©æ¼ã€ç·©è¡å€æº¢ä½å’Œé™¤éŒ¯å·¥å…·ã€‚"
---

# å¸¸è¦‹é™·é˜±å’Œé™¤éŒ¯

## 1. æ¦‚å¿µä»‹ç´¹

### å¾ JavaScript éŒ¯èª¤è™•ç†åˆ° C é™¤éŒ¯

åœ¨ JavaScript ä¸­ï¼Œä½ æœ‰è‡ªå‹•è¨˜æ†¶é«”ç®¡ç†å’ŒåŸ·è¡Œæ™‚éŒ¯èª¤æª¢æŸ¥ã€‚è€Œåœ¨ C èªè¨€ä¸­ï¼Œä½ å¿…é ˆæ‰‹å‹•ç®¡ç†è¨˜æ†¶é«”ï¼Œä¸¦æ³¨æ„å¯èƒ½å°è‡´å´©æ½°ã€è¨˜æ†¶é«”æ´©æ¼å’Œæœªå®šç¾©è¡Œç‚ºçš„æ½›åœ¨é™·é˜±ã€‚

> ğŸ’¡ **æ ¸å¿ƒæ¦‚å¿µ**ï¼šC é™¤éŒ¯éœ€è¦ç†è§£åº•å±¤è¨˜æ†¶é«”ç®¡ç†ã€æŒ‡æ¨™æ“ä½œï¼Œä¸¦ä½¿ç”¨é©ç•¶çš„å·¥å…·ä¾†è­˜åˆ¥å’Œä¿®å¾©å•é¡Œã€‚

## 2. æŒ‡æ¨™éŒ¯èª¤å’Œæ®µéŒ¯èª¤

<UniversalEditor title="æŒ‡æ¨™éŒ¯èª¤" compare={true}>
```javascript !! js
// JavaScript - è‡ªå‹•è¨˜æ†¶é«”ç®¡ç†
let obj = { name: "John", age: 30 };

// å®‰å…¨çš„å±¬æ€§å­˜å–
console.log(obj.name); // "John"
console.log(obj.nonExistent); // undefined

// å¸¶é‚Šç•Œæª¢æŸ¥çš„é™£åˆ—å­˜å–
let arr = [1, 2, 3, 4, 5];
console.log(arr[2]); // 3
console.log(arr[10]); // undefined (ä¸æœƒå´©æ½°)

// ç‰©ä»¶æ“ä½œ
obj = null;
// console.log(obj.name); // TypeError: Cannot read property 'name' of null

// å®‰å…¨çš„é™£åˆ—æ“ä½œ
arr = null;
// console.log(arr[0]); // TypeError: Cannot read property '0' of null

// è‡ªå‹•æ¸…ç†
function createObjects() {
    let temp = { data: "temporary" };
    // JavaScript åœ¨ temp è¶…å‡ºä½œç”¨åŸŸæ™‚è‡ªå‹•æ¸…ç†
}

createObjects();
// temp è¢«è‡ªå‹•åƒåœ¾å›æ”¶
```

```c !! c
#include <stdio.h>
#include <stdlib.h>

// å¸¸è¦‹æŒ‡æ¨™éŒ¯èª¤
void demonstratePointerErrors() {
    // 1. è§£åƒè€ƒç©ºæŒ‡æ¨™
    int* ptr = NULL;
    // *ptr = 10; // æ®µéŒ¯èª¤ï¼
    
    // å®‰å…¨æ–¹å¼ï¼šè§£åƒè€ƒå‰æª¢æŸ¥
    if (ptr != NULL) {
        *ptr = 10;
    } else {
        printf("æŒ‡æ¨™ç‚ºç©ºï¼Œç„¡æ³•è§£åƒè€ƒ\n");
    }
    
    // 2. è§£åƒè€ƒæœªåˆå§‹åŒ–çš„æŒ‡æ¨™
    int* uninitPtr;
    // *uninitPtr = 20; // æœªå®šç¾©è¡Œç‚ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šåˆå§‹åŒ–æŒ‡æ¨™
    int value = 20;
    uninitPtr = &value;
    *uninitPtr = 30; // å®‰å…¨
    
    // 3. é‡‹æ”¾è¨˜æ†¶é«”å¾Œä½¿ç”¨æŒ‡æ¨™
    int* dynamicPtr = (int*)malloc(sizeof(int));
    *dynamicPtr = 40;
    free(dynamicPtr);
    // *dynamicPtr = 50; // é‡‹æ”¾å¾Œä½¿ç”¨ - æœªå®šç¾©è¡Œç‚ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šé‡‹æ”¾å¾Œè¨­å®šç‚º NULL
    dynamicPtr = NULL;
    if (dynamicPtr != NULL) {
        *dynamicPtr = 50;
    }
    
    // 4. ç·©è¡å€æº¢ä½
    char buffer[5];
    // strcpy(buffer, "This is too long"); // ç·©è¡å€æº¢ä½ï¼
    
    // å®‰å…¨æ–¹å¼ï¼šä½¿ç”¨ strncpy é€²è¡Œé‚Šç•Œæª¢æŸ¥
    strncpy(buffer, "Hi", sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0'; // ç¢ºä¿ null çµ‚æ­¢
}

// å®‰å…¨æŒ‡æ¨™æ“ä½œ
int* createSafePointer() {
    int* ptr = (int*)malloc(sizeof(int));
    if (ptr == NULL) {
        printf("è¨˜æ†¶é«”åˆ†é…å¤±æ•—\n");
        return NULL;
    }
    *ptr = 100;
    return ptr;
}

void useSafePointer(int* ptr) {
    if (ptr == NULL) {
        printf("ç„¡æ³•ä½¿ç”¨ç©ºæŒ‡æ¨™\n");
        return;
    }
    printf("å€¼: %d\n", *ptr);
}

int main() {
    demonstratePointerErrors();
    
    // å®‰å…¨æŒ‡æ¨™ä½¿ç”¨
    int* safePtr = createSafePointer();
    useSafePointer(safePtr);
    
    if (safePtr != NULL) {
        free(safePtr);
        safePtr = NULL; // è‰¯å¥½å¯¦è¸
    }
    
    return 0;
}
```
</UniversalEditor>

## 3. è¨˜æ†¶é«”æ´©æ¼

<UniversalEditor title="è¨˜æ†¶é«”æ´©æ¼" compare={true}>
```javascript !! js
// JavaScript - è‡ªå‹•åƒåœ¾å›æ”¶
class MemoryIntensive {
    constructor() {
        this.data = new Array(1000000).fill('data');
    }
}

// JavaScript åœ¨ç‰©ä»¶è¶…å‡ºä½œç”¨åŸŸæ™‚è‡ªå‹•æ¸…ç†
function createAndDestroy() {
    let obj = new MemoryIntensive();
    // obj åœ¨å‡½æ•¸çµæŸæ™‚è¢«è‡ªå‹•åƒåœ¾å›æ”¶
}

createAndDestroy();

// äº‹ä»¶ç›£è½å™¨çš„æ‰‹å‹•æ¸…ç†
class EventHandler {
    constructor() {
        this.handlers = [];
    }
    
    addHandler(handler) {
        this.handlers.push(handler);
    }
    
    cleanup() {
        this.handlers = []; // æ¸…é™¤åƒè€ƒ
    }
}

// è¨˜æ†¶é«”æ´©æ¼ç¯„ä¾‹ï¼ˆå¾ªç’°åƒè€ƒï¼‰
let obj1 = { name: 'Object 1' };
let obj2 = { name: 'Object 2' };

obj1.ref = obj2;
obj2.ref = obj1;

// é€™äº›ç‰©ä»¶ç”±æ–¼å¾ªç’°åƒè€ƒä¸æœƒè¢«åƒåœ¾å›æ”¶
// è§£æ±ºæ–¹æ¡ˆï¼šæ‰“ç ´å¾ªç’°åƒè€ƒ
obj1.ref = null;
obj2.ref = null;
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// è¨˜æ†¶é«”æ´©æ¼ç¯„ä¾‹
void memoryLeakExample() {
    // 1. åˆ†é…è¨˜æ†¶é«”ä½†ä¸é‡‹æ”¾
    int* leakyPtr = (int*)malloc(sizeof(int));
    *leakyPtr = 42;
    // ç¼ºå°‘: free(leakyPtr);
    
    // 2. éºå¤±æŒ‡å‘å·²åˆ†é…è¨˜æ†¶é«”çš„æŒ‡æ¨™
    int* lostPtr = (int*)malloc(sizeof(int));
    lostPtr = NULL; // éºå¤±æŒ‡æ¨™ï¼Œç„¡æ³•å†é‡‹æ”¾
    
    // 3. åœ¨éŒ¯èª¤æ¢ä»¶ä¸‹ä¸é‡‹æ”¾è¨˜æ†¶é«”
    int* errorPtr = (int*)malloc(sizeof(int));
    if (errorPtr == NULL) {
        return; // å¦‚æœåˆ†é…å¤±æ•—å‰‡è¨˜æ†¶é«”æ´©æ¼
    }
    
    // åšä¸€äº›å·¥ä½œ...
    if (someErrorCondition()) {
        return; // è¨˜æ†¶é«”æ´©æ¼ - å¿˜è¨˜é‡‹æ”¾
    }
    
    free(errorPtr); // åªåœ¨æˆåŠŸæƒ…æ³ä¸‹é‡‹æ”¾
}

// æ­£ç¢ºçš„è¨˜æ†¶é«”ç®¡ç†
typedef struct {
    int* data;
    int size;
} SafeArray;

SafeArray* createSafeArray(int size) {
    SafeArray* arr = (SafeArray*)malloc(sizeof(SafeArray));
    if (arr == NULL) {
        return NULL;
    }
    
    arr->data = (int*)malloc(size * sizeof(int));
    if (arr->data == NULL) {
        free(arr); // æ¸…ç†éƒ¨åˆ†åˆ†é…
        return NULL;
    }
    
    arr->size = size;
    return arr;
}

void destroySafeArray(SafeArray* arr) {
    if (arr != NULL) {
        if (arr->data != NULL) {
            free(arr->data);
        }
        free(arr);
    }
}

// è¨˜æ†¶é«”æ´©æ¼æª¢æ¸¬è¼”åŠ©å‡½æ•¸
void* safeMalloc(size_t size) {
    void* ptr = malloc(size);
    if (ptr == NULL) {
        printf("è¨˜æ†¶é«”åˆ†é…å¤±æ•—\n");
    } else {
        printf("åˆ†é…äº† %zu ä½å…ƒçµ„åœ¨ %p\n", size, ptr);
    }
    return ptr;
}

void safeFree(void* ptr) {
    if (ptr != NULL) {
        printf("é‡‹æ”¾è¨˜æ†¶é«” %p\n", ptr);
        free(ptr);
    }
}

int main() {
    // æ¼”ç¤ºè¨˜æ†¶é«”æ´©æ¼
    memoryLeakExample();
    
    // æ­£ç¢ºçš„è¨˜æ†¶é«”ç®¡ç†
    SafeArray* arr = createSafeArray(10);
    if (arr != NULL) {
        // ä½¿ç”¨é™£åˆ—
        for (int i = 0; i < arr->size; i++) {
            arr->data[i] = i;
        }
        
        // æ¸…ç†
        destroySafeArray(arr);
    }
    
    // ä½¿ç”¨å®‰å…¨è¨˜æ†¶é«”å‡½æ•¸
    int* ptr1 = (int*)safeMalloc(sizeof(int));
    int* ptr2 = (int*)safeMalloc(sizeof(int));
    
    if (ptr1 && ptr2) {
        *ptr1 = 100;
        *ptr2 = 200;
        
        safeFree(ptr1);
        safeFree(ptr2);
    }
    
    return 0;
}
```
</UniversalEditor>

## 4. ç·©è¡å€æº¢ä½

<UniversalEditor title="ç·©è¡å€æº¢ä½" compare={true}>
```javascript !! js
// JavaScript - è‡ªå‹•é‚Šç•Œæª¢æŸ¥
let arr = new Array(5);

// å®‰å…¨çš„é™£åˆ—å­˜å–
arr[0] = 1;
arr[4] = 5;
// arr[5] = 6; // æ²’æœ‰ç·©è¡å€æº¢ä½ï¼Œä½†å¯èƒ½å»ºç«‹ç¨€ç–é™£åˆ—

// å­—ä¸²æ“ä½œæ˜¯å®‰å…¨çš„
let str = "Hello";
let substring = str.substring(0, 3); // "Hel"
let char = str.charAt(2); // "l"

// å¸¶é‚Šç•Œæª¢æŸ¥çš„é™£åˆ—æ–¹æ³•
let numbers = [1, 2, 3, 4, 5];
numbers.push(6); // å®‰å…¨ - é™£åˆ—è‡ªå‹•æˆé•·
numbers.splice(2, 1); // å®‰å…¨ - åˆªé™¤ç´¢å¼• 2 è™•çš„å…ƒç´ 

// å®‰å…¨çš„å­—ä¸²é€£æ¥
let result = "";
for (let i = 0; i < 1000; i++) {
    result += "a"; // å®‰å…¨ - å­—ä¸²è‡ªå‹•æˆé•·
}

// Node.js ä¸­çš„ Bufferï¼ˆå¦‚æœéœ€è¦ï¼‰
const { Buffer } = require('buffer');
let buffer = Buffer.alloc(10);
buffer.write("Hello", 0, 5); // å®‰å…¨ - å¯«å…¥ 5 ä½å…ƒçµ„
// buffer.write("This is too long", 0, 20); // æ‹‹å‡ºéŒ¯èª¤
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ç·©è¡å€æº¢ä½ç¯„ä¾‹
void bufferOverflowExamples() {
    // 1. å †ç–Šç·©è¡å€æº¢ä½
    char buffer[10];
    // strcpy(buffer, "This string is too long for the buffer"); // æº¢ä½ï¼
    
    // å®‰å…¨æ–¹å¼ï¼šä½¿ç”¨ strncpy
    strncpy(buffer, "Hello", sizeof(buffer) - 1);
    buffer[sizeof(buffer) - 1] = '\0'; // ç¢ºä¿ null çµ‚æ­¢
    
    // 2. é™£åˆ—é‚Šç•Œé•å
    int arr[5];
    // arr[10] = 100; // ç·©è¡å€æº¢ä½ï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæª¢æŸ¥é‚Šç•Œ
    int index = 10;
    if (index >= 0 && index < 5) {
        arr[index] = 100;
    } else {
        printf("ç´¢å¼• %d è¶…å‡ºé‚Šç•Œ\n", index);
    }
    
    // 3. æ•´æ•¸æº¢ä½
    int small = 2147483647; // MAX_INT
    // small++; // æ•´æ•¸æº¢ä½ï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæª¢æŸ¥æº¢ä½
    if (small < 2147483647) {
        small++;
    } else {
        printf("æœƒç™¼ç”Ÿæ•´æ•¸æº¢ä½\n");
    }
}

// å®‰å…¨å­—ä¸²å‡½æ•¸
char* safeStringCopy(const char* source, size_t maxLen) {
    char* dest = (char*)malloc(maxLen + 1);
    if (dest == NULL) {
        return NULL;
    }
    
    strncpy(dest, source, maxLen);
    dest[maxLen] = '\0'; // ç¢ºä¿ null çµ‚æ­¢
    return dest;
}

// å®‰å…¨é™£åˆ—å­˜å–
int safeArrayAccess(int* arr, int size, int index) {
    if (index >= 0 && index < size) {
        return arr[index];
    } else {
        printf("ç´¢å¼• %d è¶…å‡ºé‚Šç•Œ (å¤§å°: %d)\n", index, size);
        return -1; // éŒ¯èª¤å€¼
    }
}

// å®‰å…¨æ•´æ•¸æ“ä½œ
int safeAdd(int a, int b) {
    if (a > 0 && b > 0 && a > INT_MAX - b) {
        printf("æœƒç™¼ç”Ÿæ•´æ•¸æº¢ä½\n");
        return -1; // éŒ¯èª¤å€¼
    }
    if (a < 0 && b < 0 && a < INT_MIN - b) {
        printf("æœƒç™¼ç”Ÿæ•´æ•¸ä¸‹æº¢\n");
        return -1; // éŒ¯èª¤å€¼
    }
    return a + b;
}

int main() {
    bufferOverflowExamples();
    
    // å®‰å…¨å­—ä¸²æ“ä½œ
    char* safeStr = safeStringCopy("Hello, World!", 10);
    if (safeStr != NULL) {
        printf("å®‰å…¨å­—ä¸²: %s\n", safeStr);
        free(safeStr);
    }
    
    // å®‰å…¨é™£åˆ—æ“ä½œ
    int arr[5] = {1, 2, 3, 4, 5};
    printf("å®‰å…¨å­˜å–: %d\n", safeArrayAccess(arr, 5, 2));
    printf("ä¸å®‰å…¨å­˜å–: %d\n", safeArrayAccess(arr, 5, 10));
    
    // å®‰å…¨æ•´æ•¸æ“ä½œ
    printf("å®‰å…¨åŠ æ³•: %d\n", safeAdd(100, 200));
    printf("æº¢ä½æª¢æŸ¥: %d\n", safeAdd(2147483647, 1));
    
    return 0;
}
```
</UniversalEditor>

## 5. æœªå®šç¾©è¡Œç‚º

<UniversalEditor title="æœªå®šç¾©è¡Œç‚º" compare={true}>
```javascript !! js
// JavaScript - æ˜ç¢ºå®šç¾©çš„è¡Œç‚º
let x = 5;
let y = x / 0; // Infinity (æ˜ç¢ºå®šç¾©)
let z = x % 0; // NaN (æ˜ç¢ºå®šç¾©)

// é™£åˆ—å­˜å–
let arr = [1, 2, 3];
console.log(arr[5]); // undefined (æ˜ç¢ºå®šç¾©)

// å‹åˆ¥è½‰æ›
console.log("5" + 3); // "53" (æ˜ç¢ºå®šç¾©)
console.log("5" - 3); // 2 (æ˜ç¢ºå®šç¾©)

// null å’Œ undefined
let obj = null;
console.log(obj?.property); // undefined (æ˜ç¢ºå®šç¾©)

// å‡½æ•¸å‘¼å«
function test(a, b) {
    return a + b;
}
console.log(test(1)); // NaN (æ˜ç¢ºå®šç¾©)
console.log(test(1, 2, 3)); // 3 (å¿½ç•¥é¡å¤–åƒæ•¸)

// è‡ªå‹•å‹åˆ¥è½‰æ›
console.log(1 == "1"); // true (æ˜ç¢ºå®šç¾©è½‰æ›)
console.log(1 === "1"); // false (åš´æ ¼ç›¸ç­‰)
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// æœªå®šç¾©è¡Œç‚ºç¯„ä¾‹
void undefinedBehaviorExamples() {
    // 1. é™¤é›¶
    int a = 10;
    // int result = a / 0; // æœªå®šç¾©è¡Œç‚ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæª¢æŸ¥é›¶
    int divisor = 0;
    if (divisor != 0) {
        int result = a / divisor;
        printf("çµæœ: %d\n", result);
    } else {
        printf("é¿å…é™¤é›¶\n");
    }
    
    // 2. å­˜å–æœªåˆå§‹åŒ–çš„è®Šæ•¸
    int uninit;
    // printf("æœªåˆå§‹åŒ–: %d\n", uninit); // æœªå®šç¾©è¡Œç‚ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šåˆå§‹åŒ–
    int init = 0;
    printf("å·²åˆå§‹åŒ–: %d\n", init);
    
    // 3. è§£åƒè€ƒç©ºæŒ‡æ¨™
    int* ptr = NULL;
    // printf("å€¼: %d\n", *ptr); // æœªå®šç¾©è¡Œç‚ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šæª¢æŸ¥æŒ‡æ¨™
    if (ptr != NULL) {
        printf("å€¼: %d\n", *ptr);
    }
    
    // 4. æ•´æ•¸æº¢ä½
    int max = INT_MAX;
    // max++; // æœªå®šç¾©è¡Œç‚ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šéå¢å‰æª¢æŸ¥
    if (max < INT_MAX) {
        max++;
    }
    
    // 5. ä½¿ç”¨å·²é‡‹æ”¾çš„è¨˜æ†¶é«”
    int* dynamic = (int*)malloc(sizeof(int));
    free(dynamic);
    // *dynamic = 100; // æœªå®šç¾©è¡Œç‚ºï¼
    
    // å®‰å…¨æ–¹å¼ï¼šé‡‹æ”¾å¾Œè¨­å®šç‚º NULL
    dynamic = NULL;
}

// å®‰å…¨ç®—è¡“å‡½æ•¸
int safeDivide(int a, int b) {
    if (b == 0) {
        printf("é™¤é›¶\n");
        return 0; // éŒ¯èª¤å€¼
    }
    return a / b;
}

int safeModulo(int a, int b) {
    if (b == 0) {
        printf("æ¨¡é›¶\n");
        return 0; // éŒ¯èª¤å€¼
    }
    return a % b;
}

// å®‰å…¨æŒ‡æ¨™æ“ä½œ
void* safeDereference(void* ptr) {
    if (ptr == NULL) {
        printf("ç„¡æ³•è§£åƒè€ƒç©ºæŒ‡æ¨™\n");
        return NULL;
    }
    return ptr;
}

// å¸¶é‚Šç•Œæª¢æŸ¥çš„å®‰å…¨é™£åˆ—å­˜å–
int safeArrayGet(int* arr, int size, int index) {
    if (arr == NULL) {
        printf("é™£åˆ—ç‚ºç©º\n");
        return -1;
    }
    if (index < 0 || index >= size) {
        printf("ç´¢å¼• %d è¶…å‡ºé‚Šç•Œ\n", index);
        return -1;
    }
    return arr[index];
}

int main() {
    undefinedBehaviorExamples();
    
    // å®‰å…¨ç®—è¡“
    printf("å®‰å…¨é™¤æ³•: %d\n", safeDivide(10, 2));
    printf("å®‰å…¨é™¤é›¶: %d\n", safeDivide(10, 0));
    
    printf("å®‰å…¨æ¨¡é‹ç®—: %d\n", safeModulo(10, 3));
    printf("å®‰å…¨æ¨¡é›¶: %d\n", safeModulo(10, 0));
    
    // å®‰å…¨æŒ‡æ¨™æ“ä½œ
    int value = 42;
    int* ptr = &value;
    safeDereference(ptr);
    safeDereference(NULL);
    
    // å®‰å…¨é™£åˆ—å­˜å–
    int arr[5] = {1, 2, 3, 4, 5};
    printf("å®‰å…¨å–å¾—: %d\n", safeArrayGet(arr, 5, 2));
    printf("ä¸å®‰å…¨å–å¾—: %d\n", safeArrayGet(arr, 5, 10));
    printf("ç©ºé™£åˆ—: %d\n", safeArrayGet(NULL, 5, 0));
    
    return 0;
}
```
</UniversalEditor>

## 6. é™¤éŒ¯å·¥å…·

<UniversalEditor title="é™¤éŒ¯å·¥å…·" compare={true}>
```javascript !! js
// JavaScript - å…§å»ºé™¤éŒ¯å·¥å…·
console.log("é™¤éŒ¯è¨Šæ¯");
console.error("éŒ¯èª¤è¨Šæ¯");
console.warn("è­¦å‘Šè¨Šæ¯");

// å †ç–Šè¿½è¹¤
function debugFunction() {
    console.trace("å‡½æ•¸å‘¼å«å †ç–Š");
}

debugFunction();

// æ•ˆèƒ½æ¸¬é‡
console.time("æ“ä½œ");
// ... ä¸€äº›æ“ä½œ
console.timeEnd("æ“ä½œ");

// è¨˜æ†¶é«”ä½¿ç”¨ (Node.js)
const used = process.memoryUsage();
console.log('è¨˜æ†¶é«”ä½¿ç”¨:', {
    rss: `${Math.round(used.rss / 1024 / 1024 * 100) / 100} MB`,
    heapTotal: `${Math.round(used.heapTotal / 1024 / 1024 * 100) / 100} MB`,
    heapUsed: `${Math.round(used.heapUsed / 1024 / 1024 * 100) / 100} MB`,
    external: `${Math.round(used.external / 1024 / 1024 * 100) / 100} MB`
});

// éŒ¯èª¤è™•ç†
try {
    throw new Error("æ¸¬è©¦éŒ¯èª¤");
} catch (error) {
    console.error("æ•ç²éŒ¯èª¤:", error.message);
    console.error("å †ç–Šè¿½è¹¤:", error.stack);
}

// é™¤éŒ¯å™¨èªå¥
function debugMe() {
    let x = 1;
    debugger; // å¦‚æœé–‹ç™¼å·¥å…·é–‹å•Ÿï¼Œç€è¦½å™¨æœƒåœ¨é€™è£¡æš«åœ
    x = 2;
}
```

```c !! c
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>

// é™¤éŒ¯å·¨é›†
#define DEBUG 1

#if DEBUG
    #define DEBUG_PRINT(fmt, ...) \
        fprintf(stderr, "é™¤éŒ¯: %s:%d: " fmt "\n", \
                __FILE__, __LINE__, ##__VA_ARGS__)
#else
    #define DEBUG_PRINT(fmt, ...) do {} while(0)
#endif

#define ASSERT(condition) \
    do { \
        if (!(condition)) { \
            fprintf(stderr, "æ–·è¨€å¤±æ•—: %s, æª”æ¡ˆ %s, è¡Œ %d\n", \
                    #condition, __FILE__, __LINE__); \
            abort(); \
        } \
    } while(0)

// è¨˜æ†¶é«”é™¤éŒ¯
void* debugMalloc(size_t size) {
    void* ptr = malloc(size);
    DEBUG_PRINT("malloc(%zu) = %p", size, ptr);
    return ptr;
}

void debugFree(void* ptr) {
    DEBUG_PRINT("free(%p)", ptr);
    free(ptr);
}

// æ•ˆèƒ½æ¸¬é‡
clock_t startTimer() {
    return clock();
}

double endTimer(clock_t start) {
    clock_t end = clock();
    return ((double)(end - start)) / CLOCKS_PER_SEC;
}

// éŒ¯èª¤è™•ç†
typedef enum {
    SUCCESS = 0,
    ERROR_NULL_POINTER,
    ERROR_INVALID_SIZE,
    ERROR_MEMORY_ALLOCATION
} ErrorCode;

const char* getErrorMessage(ErrorCode code) {
    switch (code) {
        case SUCCESS: return "æˆåŠŸ";
        case ERROR_NULL_POINTER: return "ç©ºæŒ‡æ¨™";
        case ERROR_INVALID_SIZE: return "ç„¡æ•ˆå¤§å°";
        case ERROR_MEMORY_ALLOCATION: return "è¨˜æ†¶é«”åˆ†é…å¤±æ•—";
        default: return "æœªçŸ¥éŒ¯èª¤";
    }
}

// å¸¶éŒ¯èª¤è™•ç†çš„å®‰å…¨å‡½æ•¸
ErrorCode safeFunction(int* arr, int size) {
    DEBUG_PRINT("safeFunction è¢«å‘¼å«ï¼Œå¤§å° %d", size);
    
    if (arr == NULL) {
        DEBUG_PRINT("éŒ¯èª¤: ç©ºæŒ‡æ¨™");
        return ERROR_NULL_POINTER;
    }
    
    if (size <= 0) {
        DEBUG_PRINT("éŒ¯èª¤: ç„¡æ•ˆå¤§å° %d", size);
        return ERROR_INVALID_SIZE;
    }
    
    // åšå·¥ä½œ
    for (int i = 0; i < size; i++) {
        arr[i] = i * 2;
    }
    
    DEBUG_PRINT("å‡½æ•¸æˆåŠŸå®Œæˆ");
    return SUCCESS;
}

// è¨˜æ†¶é«”æ´©æ¼æª¢æ¸¬
typedef struct {
    void* ptr;
    size_t size;
    const char* file;
    int line;
} MemoryInfo;

#define MAX_ALLOCATIONS 1000
MemoryInfo allocations[MAX_ALLOCATIONS];
int allocationCount = 0;

void* trackMalloc(size_t size, const char* file, int line) {
    void* ptr = malloc(size);
    if (ptr != NULL && allocationCount < MAX_ALLOCATIONS) {
        allocations[allocationCount].ptr = ptr;
        allocations[allocationCount].size = size;
        allocations[allocationCount].file = file;
        allocations[allocationCount].line = line;
        allocationCount++;
    }
    return ptr;
}

void trackFree(void* ptr) {
    for (int i = 0; i < allocationCount; i++) {
        if (allocations[i].ptr == ptr) {
            // å¾è¿½è¹¤ä¸­ç§»é™¤
            for (int j = i; j < allocationCount - 1; j++) {
                allocations[j] = allocations[j + 1];
            }
            allocationCount--;
            break;
        }
    }
    free(ptr);
}

void reportMemoryLeaks() {
    if (allocationCount > 0) {
        printf("æª¢æ¸¬åˆ°è¨˜æ†¶é«”æ´©æ¼:\n");
        for (int i = 0; i < allocationCount; i++) {
            printf("  %p: %zu ä½å…ƒçµ„åˆ†é…åœ¨ %s:%d\n",
                   allocations[i].ptr, allocations[i].size,
                   allocations[i].file, allocations[i].line);
        }
    } else {
        printf("æœªæª¢æ¸¬åˆ°è¨˜æ†¶é«”æ´©æ¼\n");
    }
}

int main() {
    clock_t start = startTimer();
    
    // ä½¿ç”¨é™¤éŒ¯å·¨é›†
    DEBUG_PRINT("ç¨‹å¼é–‹å§‹");
    
    // æ¸¬è©¦æ–·è¨€
    int x = 5;
    ASSERT(x > 0);
    // ASSERT(x < 0); // é€™æœƒä¸­æ­¢ç¨‹å¼
    
    // æ¸¬è©¦éŒ¯èª¤è™•ç†
    int arr[5];
    ErrorCode result = safeFunction(arr, 5);
    if (result != SUCCESS) {
        printf("éŒ¯èª¤: %s\n", getErrorMessage(result));
    }
    
    // æ¸¬è©¦è¨˜æ†¶é«”è¿½è¹¤
    void* ptr1 = trackMalloc(100, __FILE__, __LINE__);
    void* ptr2 = trackMalloc(200, __FILE__, __LINE__);
    
    trackFree(ptr1);
    // ptr2 æ•…æ„ä¸é‡‹æ”¾ä»¥æ¼”ç¤ºæ´©æ¼æª¢æ¸¬
    
    // å ±å‘Šè¨˜æ†¶é«”æ´©æ¼
    reportMemoryLeaks();
    
    double elapsed = endTimer(start);
    printf("ç¨‹å¼åœ¨ %.3f ç§’å…§å®Œæˆ\n", elapsed);
    
    return 0;
}
```
</UniversalEditor>

## 7. å¸¸è¦‹é™·é˜±
- **è§£åƒè€ƒç©ºæŒ‡æ¨™**ï¼šä½¿ç”¨å‰å§‹çµ‚æª¢æŸ¥æŒ‡æ¨™
- **è¨˜æ†¶é«”æ´©æ¼**ï¼šå§‹çµ‚é‡‹æ”¾åˆ†é…çš„è¨˜æ†¶é«”
- **ç·©è¡å€æº¢ä½**ï¼šé™£åˆ—å­˜å–å‰æª¢æŸ¥é‚Šç•Œ
- **æ•´æ•¸æº¢ä½**ï¼šç®—è¡“æ“ä½œå‰æª¢æŸ¥é™åˆ¶
- **é‡‹æ”¾å¾Œä½¿ç”¨**ï¼šé‡‹æ”¾å¾Œå°‡æŒ‡æ¨™è¨­å®šç‚º NULL
- **æœªåˆå§‹åŒ–è®Šæ•¸**ï¼šä½¿ç”¨å‰å§‹çµ‚åˆå§‹åŒ–è®Šæ•¸

## 8. ç·´ç¿’é¡Œ
1. æ’°å¯«ä¸€å€‹æ¼”ç¤ºä¸¦ä¿®å¾©å¸¸è¦‹æŒ‡æ¨™éŒ¯èª¤çš„ç¨‹å¼ã€‚
2. ç‚ºä½ çš„ç¨‹å¼å»ºç«‹ä¸€å€‹è¨˜æ†¶é«”æ´©æ¼æª¢æ¸¬å™¨ã€‚
3. å¯¦ç¾å­—ä¸²å’Œé™£åˆ—å‡½æ•¸çš„å®‰å…¨ç‰ˆæœ¬ã€‚
4. ä½¿ç”¨é™¤éŒ¯å·¥å…·å°‹æ‰¾å’Œä¿®å¾©ç¾æœ‰ç¨‹å¼ç¢¼ä¸­çš„éŒ¯èª¤ã€‚

## 9. æ•ˆèƒ½åˆ†æ
- **é™¤éŒ¯å»ºç½®**ï¼šåŒ…å«é™¤éŒ¯è³‡è¨Šå’Œæª¢æŸ¥
- **ç™¼å¸ƒå»ºç½®**ï¼šæœ€ä½³åŒ–æ•ˆèƒ½ï¼Œç§»é™¤é™¤éŒ¯ç¨‹å¼ç¢¼
- **è¨˜æ†¶é«”åˆ†æ**ï¼šç›£æ§è¨˜æ†¶é«”ä½¿ç”¨å’Œæ´©æ¼
- **æ•ˆèƒ½åˆ†æ**ï¼šè­˜åˆ¥ç“¶é ¸ä¸¦æœ€ä½³åŒ–

---

> **å°çµ**ï¼šç†è§£ C å¸¸è¦‹é™·é˜±å’Œé™¤éŒ¯æŠ€è¡“å°æ–¼æ’°å¯«å¯é ç¨‹å¼è‡³é—œé‡è¦ã€‚ä½¿ç”¨é©ç•¶çš„å·¥å…·ä¸¦éµå¾ªæœ€ä½³å¯¦è¸ä¾†é¿å…å’Œä¿®å¾©å•é¡Œã€‚ 