---
title: "面向对象编程"
description: "学习 Kotlin 的面向对象编程特性，与 JavaScript 的类系统和对象模式进行对比"
---

# 面向对象编程

欢迎来到 JavaScript 到 Kotlin 转换的第五个模块！在本模块中，我们将探索 Kotlin 强大的面向对象编程特性，以及它们如何提供比 JavaScript 的类系统和对象模式更健壮、类型安全的解决方案。

## 学习目标

通过本模块的学习，你将能够：
- 理解 Kotlin 的类系统和构造函数模式
- 比较 Kotlin 类与 JavaScript 类的差异
- 有效实现继承和多态
- 使用接口和抽象类
- 使用数据类和密封类
- 理解对象声明和伴生对象
- 在 Kotlin 项目中应用 OOP 原则

## 理解 Kotlin 类

### 类声明

Kotlin 提供了比 JavaScript 更简洁、更强大的类系统。让我们从基本的类声明开始。

<UniversalEditor title="基本类声明" compare={true}>
```javascript !! js
// JavaScript 类声明
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    }
    
    getInfo() {
        return `${this.name}, ${this.age} years old`;
    }
}

// 使用
const person = new Person("Alice", 30);
person.sayHello();
console.log(person.getInfo());
```

```kotlin !! kt
// Kotlin 类声明
class Person(
    val name: String,
    val age: Int
) {
    fun sayHello() {
        println("Hello, my name is $name")
    }
    
    fun getInfo(): String {
        return "$name, $age years old"
    }
}

// 使用
val person = Person("Alice", 30)
person.sayHello()
println(person.getInfo())
```
</UniversalEditor>

### 主构造函数和次构造函数

Kotlin 提供了比 JavaScript 更灵活的构造函数模式。

<UniversalEditor title="构造函数" compare={true}>
```javascript !! js
// JavaScript 构造函数模式
class Employee {
    constructor(name, department, salary = 50000) {
        this.name = name;
        this.department = department;
        this.salary = salary;
        this.id = Math.random().toString(36).substr(2, 9);
    }
    
    // 静态方法
    static createManager(name, department) {
        return new Employee(name, department, 80000);
    }
}

// 使用
const emp1 = new Employee("Bob", "Engineering");
const manager = Employee.createManager("Carol", "Management");
```

```kotlin !! kt
// Kotlin 主构造函数和次构造函数
class Employee(
    val name: String,
    val department: String,
    val salary: Int = 50000
) {
    val id: String = generateId()
    
    // 次构造函数
    constructor(name: String, department: String, isManager: Boolean) : 
        this(name, department, if (isManager) 80000 else 50000)
    
    companion object {
        private fun generateId(): String {
            return (0..8).map { ('a'..'z').random() }.joinToString("")
        }
        
        fun createManager(name: String, department: String): Employee {
            return Employee(name, department, true)
        }
    }
}

// 使用
val emp1 = Employee("Bob", "Engineering")
val manager = Employee.createManager("Carol", "Management")
```
</UniversalEditor>

## 继承和多态

### 类继承

Kotlin 的继承系统比 JavaScript 更明确、类型更安全。

<UniversalEditor title="类继承" compare={true}>
```javascript !! js
// JavaScript 继承
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    makeSound() {
        console.log("Some sound");
    }
    
    getInfo() {
        return `Animal: ${this.name}`;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    makeSound() {
        console.log("Woof! Woof!");
    }
    
    getInfo() {
        return `${super.getInfo()}, Breed: ${this.breed}`;
    }
    
    fetch() {
        console.log(`${this.name} is fetching the ball`);
    }
}

// 使用
const dog = new Dog("Buddy", "Golden Retriever");
dog.makeSound();
console.log(dog.getInfo());
dog.fetch();
```

```kotlin !! kt
// Kotlin 继承
open class Animal(val name: String) {
    open fun makeSound() {
        println("Some sound")
    }
    
    open fun getInfo(): String {
        return "Animal: $name"
    }
}

class Dog(
    name: String,
    val breed: String
) : Animal(name) {
    
    override fun makeSound() {
        println("Woof! Woof!")
    }
    
    override fun getInfo(): String {
        return "${super.getInfo()}, Breed: $breed"
    }
    
    fun fetch() {
        println("$name is fetching the ball")
    }
}

// 使用
val dog = Dog("Buddy", "Golden Retriever")
dog.makeSound()
println(dog.getInfo())
dog.fetch()
```
</UniversalEditor>

### 抽象类

Kotlin 的抽象类为继承提供了更结构化的方法。

<UniversalEditor title="抽象类" compare={true}>
```javascript !! js
// JavaScript 抽象类模式
class Shape {
    constructor(color) {
        if (new.target === Shape) {
            throw new Error("Shape is abstract and cannot be instantiated");
        }
        this.color = color;
    }
    
    getArea() {
        throw new Error("getArea must be implemented");
    }
    
    getPerimeter() {
        throw new Error("getPerimeter must be implemented");
    }
    
    getInfo() {
        return `Shape: ${this.constructor.name}, Color: ${this.color}`;
    }
}

class Circle extends Shape {
    constructor(color, radius) {
        super(color);
        this.radius = radius;
    }
    
    getArea() {
        return Math.PI * this.radius * this.radius;
    }
    
    getPerimeter() {
        return 2 * Math.PI * this.radius;
    }
}

// 使用
const circle = new Circle("red", 5);
console.log(circle.getArea());
console.log(circle.getPerimeter());
```

```kotlin !! kt
// Kotlin 抽象类
abstract class Shape(val color: String) {
    abstract fun getArea(): Double
    abstract fun getPerimeter(): Double
    
    fun getInfo(): String {
        return "Shape: ${this::class.simpleName}, Color: $color"
    }
}

class Circle(color: String, val radius: Double) : Shape(color) {
    override fun getArea(): Double {
        return Math.PI * radius * radius
    }
    
    override fun getPerimeter(): Double {
        return 2 * Math.PI * radius
    }
}

// 使用
val circle = Circle("red", 5.0)
println(circle.getArea())
println(circle.getPerimeter())
```
</UniversalEditor>

## 接口

### 接口实现

Kotlin 的接口比 JavaScript 更强大，支持默认实现和属性。

<UniversalEditor title="接口" compare={true}>
```javascript !! js
// JavaScript 接口模式
class Drawable {
    draw() {
        throw new Error("draw method must be implemented");
    }
}

class Movable {
    move() {
        throw new Error("move method must be implemented");
    }
}

class GameObject extends Drawable {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    
    draw() {
        console.log(`Drawing at position (${this.x}, ${this.y})`);
    }
    
    move(dx, dy) {
        this.x += dx;
        this.y += dy;
        console.log(`Moved to (${this.x}, ${this.y})`);
    }
}

// 使用
const gameObject = new GameObject(10, 20);
gameObject.draw();
gameObject.move(5, 10);
```

```kotlin !! kt
// Kotlin 接口
interface Drawable {
    fun draw()
}

interface Movable {
    fun move(dx: Double, dy: Double)
}

class GameObject(
    var x: Double,
    var y: Double
) : Drawable, Movable {
    
    override fun draw() {
        println("Drawing at position ($x, $y)")
    }
    
    override fun move(dx: Double, dy: Double) {
        x += dx
        y += dy
        println("Moved to ($x, $y)")
    }
}

// 使用
val gameObject = GameObject(10.0, 20.0)
gameObject.draw()
gameObject.move(5.0, 10.0)
```
</UniversalEditor>

### 带默认实现的接口

Kotlin 接口可以有默认实现，这与 JavaScript 不同。

<UniversalEditor title="接口默认实现" compare={true}>
```javascript !! js
// JavaScript mixin 模式
const LoggerMixin = {
    log(message) {
        console.log(`[${this.constructor.name}] ${message}`);
    }
};

class UserService {
    constructor() {
        Object.assign(this, LoggerMixin);
    }
    
    getUser(id) {
        this.log(`Fetching user with id: ${id}`);
        return { id, name: "User" };
    }
}

// 使用
const userService = new UserService();
userService.getUser(123);
```

```kotlin !! kt
// Kotlin 带默认实现的接口
interface Logger {
    fun log(message: String) {
        println("[${this::class.simpleName}] $message")
    }
}

class UserService : Logger {
    fun getUser(id: Int): User {
        log("Fetching user with id: $id")
        return User(id, "User")
    }
}

data class User(val id: Int, val name: String)

// 使用
val userService = UserService()
userService.getUser(123)
```
</UniversalEditor>

## 数据类

### 数据类与普通对象

Kotlin 的数据类提供常见方法的自动实现。

<UniversalEditor title="数据类" compare={true}>
```javascript !! js
// JavaScript 普通对象
const user = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};

// 手动实现 toString, equals 等
class User {
    constructor(id, name, email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    toString() {
        return `User(id=${this.id}, name='${this.name}', email='${this.email}')`;
    }
    
    equals(other) {
        if (!(other instanceof User)) return false;
        return this.id === other.id && 
               this.name === other.name && 
               this.email === other.email;
    }
    
    copy(updates = {}) {
        return new User(
            updates.id !== undefined ? updates.id : this.id,
            updates.name !== undefined ? updates.name : this.name,
            updates.email !== undefined ? updates.email : this.email
        );
    }
}

// 使用
const user1 = new User(1, "Alice", "alice@example.com");
const user2 = user1.copy({ name: "Alice Updated" });
console.log(user1.toString());
console.log(user1.equals(user2));
```

```kotlin !! kt
// Kotlin 数据类
data class User(
    val id: Int,
    val name: String,
    val email: String
)

// 使用
val user1 = User(1, "Alice", "alice@example.com")
val user2 = user1.copy(name = "Alice Updated")
println(user1.toString())
println(user1 == user2)
```
</UniversalEditor>

### 数据类特性

数据类提供许多有用的特性。

<UniversalEditor title="数据类特性" compare={true}>
```javascript !! js
// JavaScript 手动实现
class Product {
    constructor(id, name, price, category) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.category = category;
    }
    
    // 解构
    static destructure(product) {
        const { id, name, price, category } = product;
        return [id, name, price, category];
    }
    
    // 组件比较
    equals(other) {
        return this.id === other.id &&
               this.name === other.name &&
               this.price === other.price &&
               this.category === other.category;
    }
    
    // 哈希码
    hashCode() {
        return this.id * 31 + this.name.length;
    }
}

// 使用
const product = new Product(1, "Laptop", 999.99, "Electronics");
const [id, name, price, category] = Product.destructure(product);
console.log(`ID: ${id}, Name: ${name}, Price: ${price}, Category: ${category}`);
```

```kotlin !! kt
// Kotlin 数据类自动特性
data class Product(
    val id: Int,
    val name: String,
    val price: Double,
    val category: String
)

// 使用
val product = Product(1, "Laptop", 999.99, "Electronics")
val (id, name, price, category) = product // 解构
println("ID: $id, Name: $name, Price: $price, Category: $category")

// 自动 equals, hashCode, toString, copy
val product2 = product.copy(price = 899.99)
println(product == product2)
```
</UniversalEditor>

## 密封类

### 密封类的类型安全

Kotlin 的密封类为层次结构提供编译时类型安全。

<UniversalEditor title="密封类" compare={true}>
```javascript !! js
// JavaScript 联合类型模式
class Result {
    static success(data) {
        return new SuccessResult(data);
    }
    
    static error(message) {
        return new ErrorResult(message);
    }
}

class SuccessResult extends Result {
    constructor(data) {
        super();
        this.data = data;
    }
    
    isSuccess() {
        return true;
    }
    
    isError() {
        return false;
    }
}

class ErrorResult extends Result {
    constructor(message) {
        super();
        this.message = message;
    }
    
    isSuccess() {
        return false;
    }
    
    isError() {
        return true;
    }
}

// 使用
function processResult(result) {
    if (result.isSuccess()) {
        console.log("Success:", result.data);
    } else {
        console.log("Error:", result.message);
    }
}

const successResult = Result.success({ id: 1, name: "User" });
const errorResult = Result.error("User not found");
processResult(successResult);
processResult(errorResult);
```

```kotlin !! kt
// Kotlin 密封类
sealed class Result {
    data class Success(val data: Any) : Result()
    data class Error(val message: String) : Result()
}

// 使用 when 表达式
fun processResult(result: Result) {
    when (result) {
        is Result.Success -> println("Success: ${result.data}")
        is Result.Error -> println("Error: ${result.message}")
    }
}

val successResult = Result.Success(mapOf("id" to 1, "name" to "User"))
val errorResult = Result.Error("User not found")
processResult(successResult)
processResult(errorResult)
```
</UniversalEditor>

## 对象声明和伴生对象

### 单例对象

Kotlin 的对象声明提供了实现单例的简洁方法。

<UniversalEditor title="单例对象" compare={true}>
```javascript !! js
// JavaScript 单例模式
class DatabaseConnection {
    constructor() {
        if (DatabaseConnection.instance) {
            return DatabaseConnection.instance;
        }
        this.connection = null;
        DatabaseConnection.instance = this;
    }
    
    connect() {
        if (!this.connection) {
            this.connection = { status: "connected" };
            console.log("Database connected");
        }
        return this.connection;
    }
    
    disconnect() {
        if (this.connection) {
            this.connection = null;
            console.log("Database disconnected");
        }
    }
}

// 使用
const db1 = new DatabaseConnection();
const db2 = new DatabaseConnection();
console.log(db1 === db2); // true
db1.connect();
db2.disconnect();
```

```kotlin !! kt
// Kotlin 对象声明（单例）
object DatabaseConnection {
    private var connection: Any? = null
    
    fun connect(): Any {
        if (connection == null) {
            connection = mapOf("status" to "connected")
            println("Database connected")
        }
        return connection!!
    }
    
    fun disconnect() {
        if (connection != null) {
            connection = null
            println("Database disconnected")
        }
    }
}

// 使用
val db1 = DatabaseConnection
val db2 = DatabaseConnection
println(db1 === db2) // true
db1.connect()
db2.disconnect()
```
</UniversalEditor>

### 伴生对象

伴生对象在 Kotlin 中提供类似静态的功能。

<UniversalEditor title="伴生对象" compare={true}>
```javascript !! js
// JavaScript 静态方法
class MathUtils {
    static PI = 3.14159;
    
    static add(a, b) {
        return a + b;
    }
    
    static multiply(a, b) {
        return a * b;
    }
    
    static createRandom() {
        return Math.random();
    }
}

// 使用
console.log(MathUtils.PI);
console.log(MathUtils.add(5, 3));
console.log(MathUtils.multiply(4, 7));
console.log(MathUtils.createRandom());
```

```kotlin !! kt
// Kotlin 伴生对象
class MathUtils {
    companion object {
        const val PI = 3.14159
        
        fun add(a: Double, b: Double): Double {
            return a + b
        }
        
        fun multiply(a: Double, b: Double): Double {
            return a * b
        }
        
        fun createRandom(): Double {
            return Math.random()
        }
    }
}

// 使用
println(MathUtils.PI)
println(MathUtils.add(5.0, 3.0))
println(MathUtils.multiply(4.0, 7.0))
println(MathUtils.createRandom())
```
</UniversalEditor>

## 高级 OOP 模式

### 扩展函数

Kotlin 的扩展函数允许为现有类添加功能。

<UniversalEditor title="扩展函数" compare={true}>
```javascript !! js
// JavaScript 原型扩展
String.prototype.reverse = function() {
    return this.split('').reverse().join('');
};

String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
};

// 使用
const text = "hello world";
console.log(text.reverse());
console.log(text.capitalize());
```

```kotlin !! kt
// Kotlin 扩展函数
fun String.reverse(): String {
    return this.reversed()
}

fun String.capitalize(): String {
    return this.replaceFirstChar { it.uppercase() }
}

// 使用
val text = "hello world"
println(text.reverse())
println(text.capitalize())
```
</UniversalEditor>

### 运算符重载

Kotlin 允许为自定义类型重载运算符。

<UniversalEditor title="运算符重载" compare={true}>
```javascript !! js
// JavaScript 运算符重载模拟
class Vector {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    
    add(other) {
        return new Vector(this.x + other.x, this.y + other.y);
    }
    
    multiply(scalar) {
        return new Vector(this.x * scalar, this.y * scalar);
    }
    
    toString() {
        return `Vector(${this.x}, ${this.y})`;
    }
}

// 使用
const v1 = new Vector(1, 2);
const v2 = new Vector(3, 4);
const result = v1.add(v2);
const scaled = v1.multiply(2);
console.log(result.toString());
console.log(scaled.toString());
```

```kotlin !! kt
// Kotlin 运算符重载
data class Vector(val x: Double, val y: Double) {
    operator fun plus(other: Vector): Vector {
        return Vector(x + other.x, y + other.y)
    }
    
    operator fun times(scalar: Double): Vector {
        return Vector(x * scalar, y * scalar)
    }
}

// 使用
val v1 = Vector(1.0, 2.0)
val v2 = Vector(3.0, 4.0)
val result = v1 + v2
val scaled = v1 * 2.0
println(result)
println(scaled)
```
</UniversalEditor>

## 实践示例

### 构建简单的银行系统

让我们创建一个展示 Kotlin OOP 特性的实践示例。

<UniversalEditor title="银行系统示例" compare={true}>
```javascript !! js
// JavaScript 银行系统
class Account {
    constructor(accountNumber, balance = 0) {
        this.accountNumber = accountNumber;
        this.balance = balance;
        this.transactions = [];
    }
    
    deposit(amount) {
        if (amount > 0) {
            this.balance += amount;
            this.transactions.push({
                type: 'deposit',
                amount: amount,
                timestamp: new Date()
            });
            return true;
        }
        return false;
    }
    
    withdraw(amount) {
        if (amount > 0 && amount <= this.balance) {
            this.balance -= amount;
            this.transactions.push({
                type: 'withdraw',
                amount: amount,
                timestamp: new Date()
            });
            return true;
        }
        return false;
    }
    
    getBalance() {
        return this.balance;
    }
    
    getTransactionHistory() {
        return [...this.transactions];
    }
}

class SavingsAccount extends Account {
    constructor(accountNumber, balance = 0, interestRate = 0.02) {
        super(accountNumber, balance);
        this.interestRate = interestRate;
    }
    
    addInterest() {
        const interest = this.balance * this.interestRate;
        this.deposit(interest);
        return interest;
    }
}

// 使用
const account = new SavingsAccount("12345", 1000, 0.05);
account.deposit(500);
account.withdraw(200);
account.addInterest();
console.log("Balance:", account.getBalance());
console.log("Transactions:", account.getTransactionHistory());
```

```kotlin !! kt
// Kotlin 银行系统
sealed class Transaction {
    data class Deposit(val amount: Double, val timestamp: Long = System.currentTimeMillis()) : Transaction()
    data class Withdraw(val amount: Double, val timestamp: Long = System.currentTimeMillis()) : Transaction()
    data class Interest(val amount: Double, val timestamp: Long = System.currentTimeMillis()) : Transaction()
}

open class Account(
    val accountNumber: String,
    protected var balance: Double = 0.0
) {
    private val transactions = mutableListOf<Transaction>()
    
    fun deposit(amount: Double): Boolean {
        return if (amount > 0) {
            balance += amount
            transactions.add(Transaction.Deposit(amount))
            true
        } else false
    }
    
    fun withdraw(amount: Double): Boolean {
        return if (amount > 0 && amount <= balance) {
            balance -= amount
            transactions.add(Transaction.Withdraw(amount))
            true
        } else false
    }
    
    fun getBalance(): Double = balance
    
    fun getTransactionHistory(): List<Transaction> = transactions.toList()
}

class SavingsAccount(
    accountNumber: String,
    balance: Double = 0.0,
    private val interestRate: Double = 0.02
) : Account(accountNumber, balance) {
    
    fun addInterest(): Double {
        val interest = balance * interestRate
        deposit(interest)
        return interest
    }
}

// 使用
val account = SavingsAccount("12345", 1000.0, 0.05)
account.deposit(500.0)
account.withdraw(200.0)
account.addInterest()
println("Balance: ${account.getBalance()}")
println("Transactions: ${account.getTransactionHistory()}")
```
</UniversalEditor>

## 最佳实践和模式

### 何时使用不同的类类型

<UniversalEditor title="类类型指南" compare={true}>
```javascript !! js
// JavaScript 类使用指南
// 1. 常规类用于具有行为的复杂对象
class UserService {
    constructor() {
        this.users = new Map();
    }
    
    addUser(user) {
        this.users.set(user.id, user);
    }
    
    getUser(id) {
        return this.users.get(id);
    }
}

// 2. 普通对象用于简单数据结构
const userData = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};

// 3. 工厂函数用于对象创建
function createUser(id, name, email) {
    return {
        id,
        name,
        email,
        toString() {
            return `User(id=${this.id}, name='${this.name}')`;
        }
    };
}
```

```kotlin !! kt
// Kotlin 类使用指南
// 1. 常规类用于具有行为的复杂对象
class UserService {
    private val users = mutableMapOf<Int, User>()
    
    fun addUser(user: User) {
        users[user.id] = user
    }
    
    fun getUser(id: Int): User? {
        return users[id]
    }
}

// 2. 数据类用于简单数据结构
data class UserData(
    val id: Int,
    val name: String,
    val email: String
)

// 3. 对象声明用于单例
object UserFactory {
    fun createUser(id: Int, name: String, email: String): UserData {
        return UserData(id, name, email)
    }
}
```
</UniversalEditor>

## 总结

在本模块中，我们探索了 Kotlin 强大的面向对象编程特性：

### 关键要点

1. **类声明**: Kotlin 的主构造函数语法比 JavaScript 的类构造函数更简洁
2. **继承**: Kotlin 使用 `open` 关键字和显式继承 `:`
3. **接口**: Kotlin 接口支持默认实现和属性
4. **数据类**: 自动生成 `equals()`、`hashCode()`、`toString()` 和 `copy()`
5. **密封类**: 类层次结构的编译时类型安全
6. **对象声明**: 简洁的单例实现
7. **伴生对象**: 类内的静态功能
8. **扩展函数**: 为现有类添加功能
9. **运算符重载**: 用户定义类型的自定义运算符

### 与 JavaScript 的对比

| 特性 | JavaScript | Kotlin |
|------|------------|--------|
| 类声明 | `class` 带构造函数 | 主构造函数语法 |
| 继承 | `extends` | `:` 带 `open` 关键字 |
| 接口 | 无原生支持 | 完整接口支持 |
| 数据类 | 手动实现 | 使用 `data class` 自动实现 |
| 单例 | 手动模式 | `object` 声明 |
| 静态方法 | `static` 关键字 | `companion object` |
| 扩展方法 | 原型修改 | 扩展函数 |

### 下一步

在下一个模块中，我们将探索 Kotlin 的 Android 开发，包括：
- Android 项目结构
- Activity 和 Fragment 生命周期
- 布局和 UI 组件
- 事件处理和数据绑定
- 使用 Jetpack Compose 的现代 Android 开发

Kotlin OOP 特性的这个基础对于构建健壮的 Android 应用程序和理解现代 Kotlin 开发模式至关重要。 