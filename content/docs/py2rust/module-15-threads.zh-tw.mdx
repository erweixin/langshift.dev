---
title: "模組 15: 線程與並發 - 無畏並發"
description: "掌握 Rust 的線程模型、通道、互斥鎖和無畏並發,與 Python 的線程和多進程進行比較。"
---

# 模組 15: 線程與並發 - 無畏並發

在最後一個模組中,你將學習 Rust 如何處理**線程和並發**,通過編譯時保證防止數據競爭,提供**無畏並發**。

## 學習目標

完成本模組後,你將能夠:
- 在 Rust 中生成線程
- 使用通道進行消息傳遞
- 使用 Mutex 進行共享狀態
- 理解 Rust 在並發上下文中的所有權模型
- 比較 Rust 的並發與 Python 的線程

## 生成線程

<UniversalEditor compare={true} title="創建線程">
```python !! py
# Python: 基本線程
import threading

def worker(name):
    print(f"Worker {name}")

thread = threading.Thread(target=worker, args=("Alice",))
thread.start()
thread.join()
```

```rust !! rs
// Rust: 生成線程
use std::thread;

fn worker(name: &str) {
    println!("Worker {}", name);
}

fn main() {
    let handle = thread::spawn(|| {
        worker("Alice");
    });

    handle.join().unwrap();
}
```
</UniversalEditor>

## 通道:消息傳遞

<UniversalEditor compare={true} title="通道通信">
```python !! py
# Python: Queue 用於線程通信
import threading
import queue

q = queue.Queue()

def producer():
    for i in range(5):
        q.put(i)

def consumer():
    while True:
        item = q.get()
        print(f"Received: {item}")

t1 = threading.Thread(target=producer)
t2 = threading.Thread(target=consumer)
t1.start()
t2.start()
t1.join()
t2.join()
```

```rust !! rs
// Rust: mpsc 通道用於消息傳遞
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let producer = thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
        }
    });

    let consumer = thread::spawn(move || {
        for received in rx {
            println!("Received: {}", received);
        }
    });

    producer.join().unwrap();
    consumer.join().unwrap();
}
```
</UniversalEditor>

## 共享狀態: Mutex

<UniversalEditor compare={true} title="Mutex 用於共享狀態">
```python !! py
# Python: threading.Lock 用於共享狀態
import threading

counter = [0]
lock = threading.Lock()

def increment():
    for _ in range(1000):
        with lock:
            counter[0] += 1

threads = []
for _ in range(5):
    t = threading.Thread(target=increment)
    t.start()
    threads.append(t)

for t in threads:
    t.join()

print(f"Counter: {counter[0]}")
```

```rust !! rs
// Rust: Mutex 用於共享可變狀態
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..5 {
        let counter_clone = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            for _ in 0..1000 {
                let mut num = counter_clone.lock().unwrap();
                *num += 1;
            }
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Counter: {}", *counter.lock().unwrap());
}
```
</UniversalEditor>

## 最佳實踐

### 應該做:

1. **使用通道進行消息傳遞** - 優先於共享狀態
2. **對共享狀態使用 `Arc<Mutex<T>>`** - 必要時
3. **將數據移入線程** - 使用 `move` 閉包

### 不應該做:

1. **在沒有同步的情況下共享狀態** - 數據競爭是未定義行為
2. **跨線程使用 Rc** - 改用 Arc

## 總結

- **線程**在 Rust 中提供真正的並行
- **通道**實現安全消息傳遞
- **Mutex** 提供線程安全的共享狀態
- **Rust 在編譯時防止數據競爭**
- **Rust 的無畏並發**更安全更快

## 練習

1. 使用線程構建並行網頁爬蟲
2. 實現並行 map-reduce 模式

## 恭喜!

你已完成 Python → Rust 學習路徑的全部 15 個模組!繼續你的旅程,構建真實項目並探索 Rust 生態系統!
