---
title: "模块 16: 异步编程"
description: "掌握 Rust 中的异步编程,包括 async/await、tokio 和 Future trait,并与 Python 的 asyncio 进行对比"
---

# 模块 16: 异步编程

## 学习目标

完成本模块后,你将能够:
- 理解 Rust 的 async/await 语法及其与 Python asyncio 的区别
- 使用 Future trait 和异步运行时
- 使用 Tokio 构建实际异步应用
- 处理异步流和通道
- 避免常见的异步编程陷阱

## Rust 异步简介

Python 的 `asyncio` 使用带有 `async`/`await` 语法的协程。Rust 有类似的语法,但底层机制完全不同。

### 关键区别

<UniversalEditor compare={true} title="异步函数声明">
```python !! py
# Python - 协程是隐式的
import asyncio

async def fetch_data(url: str) -> dict:
    await asyncio.sleep(1)  # 模拟网络延迟
    return {"status": "ok", "data": [1, 2, 3]}

# Python 协程启动时即暂停,需要事件循环
async def main():
    result = await fetch_data("https://api.example.com")
    print(result)

asyncio.run(main())
```

```rust !! rs
// Rust - Future 是显式的且是惰性的
use tokio::time::{sleep, Duration};

async fn fetch_data(url: &str) -> serde_json::Value {
    // Tokio 提供异步睡眠
    sleep(Duration::from_secs(1)).await;
    json!({"status": "ok", "data": [1, 2, 3]})
}

// Rust 需要在入口点显式运行时
#[tokio::main]
async fn main() {
    let result = fetch_data("https://api.example.com").await;
    println!("{}", result);
}
```
</UniversalEditor>

**核心洞察:** 在 Python 中,`async def` 创建一个暂停的协程对象。在 Rust 中,`async fn` 返回一个 `Future`,在被轮询之前什么都不做。

## Future Trait

理解 `Future` trait 对于掌握 Rust 异步编程至关重要。

<UniversalEditor compare={true} title="Future Trait vs Python 协程">
```python !! py
# Python - 事件循环管理协程
import asyncio

async def compute():
    print("Computing...")
    await asyncio.sleep(0.1)
    return 42

# 事件循环处理一切
coro = compute()  # 返回协程对象
print(type(coro))  # <class 'coroutine'>

result = asyncio.run(coro)
```

```rust !! rs
// Rust - Future trait 需要显式轮询
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// 简化的 Future trait(实际的 std::future::Future)
pub trait SimpleFuture {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}

// async fn 脱糖为实现 Future 的类型
async fn compute() -> i32 {
    println!("Computing...");
    tokio::time::sleep(Duration::from_millis(100)).await;
    42
}

// 运行时处理轮询
#[tokio::main]
async fn main() {
    let future = compute();  // 返回 Future
    let result = future.await;  // 运行时轮询直到就绪
    println!("{}", result);
}
```
</UniversalEditor>

## 异步运行时: Tokio

Tokio 是 Rust 中最流行的异步运行时,类似于 asyncio 在 Python 中的地位。

### 基本 Tokio 使用

<UniversalEditor compare={true} title="任务生成">
```python !! py
# Python - asyncio 任务
import asyncio

async def worker(name: str, duration: int):
    print(f"{name} started")
    await asyncio.sleep(duration)
    print(f"{name} completed after {duration}s")

async def main():
    # 创建并发运行的任务
    task1 = asyncio.create_task(worker("Task 1", 2))
    task2 = asyncio.create_task(worker("Task 2", 1))

    # 等待两者完成
    await asyncio.gather(task1, task2)

asyncio.run(main())
```

```rust !! rs
// Rust - Tokio 任务
use tokio::time::{sleep, Duration};

async fn worker(name: &str, duration: u64) {
    println!("{} started", name);
    sleep(Duration::from_secs(duration)).await;
    println!("{} completed after {}s", name, duration);
}

#[tokio::main]
async fn main() {
    // 生成并发运行的任务
    let task1 = tokio::spawn(worker("Task 1", 2));
    let task2 = tokio::spawn(worker("Task 2", 1));

    // 等待两者完成
    let (result1, result2) = tokio::join!(task1, task2);

    // 处理结果(任务返回 Result)
    result1.unwrap();
    result2.unwrap();
}
```
</UniversalEditor>

### 异步通道

<UniversalEditor compare={true} title="异步通信通道">
```python !! py
# Python - asyncio 队列
import asyncio

async def producer(queue: asyncio.Queue):
    for i in range(5):
        await asyncio.sleep(0.1)
        await queue.put(i)
        print(f"Produced: {i}")
    await queue.put(None)  # 发送结束信号

async def consumer(queue: asyncio.Queue):
    while True:
        item = await queue.get()
        if item is None:
            break
        print(f"Consumed: {item}")
        queue.task_done()

async def main():
    queue = asyncio.Queue(maxsize=10)
    producer_task = asyncio.create_task(producer(queue))
    consumer_task = asyncio.create_task(consumer(queue))
    await asyncio.gather(producer_task, consumer_task)

asyncio.run(main())
```

```rust !! rs
// Rust - Tokio 通道
use tokio::sync::mpsc;
use tokio::time::{sleep, Duration};

async fn producer(mut tx: mpsc::Sender<i32>) {
    for i in 0..5 {
        sleep(Duration::from_millis(100)).await;
        tx.send(i).await.unwrap();
        println!("Produced: {}", i);
    }
    // 丢弃 sender 以信号完成
}

async fn consumer(mut rx: mpsc::Receiver<i32>) {
    while let Some(item) = rx.recv().await {
        println!("Consumed: {}", item);
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);

    let producer_task = tokio::spawn(producer(tx));
    let consumer_task = tokio::spawn(consumer(rx));

    tokio::join!(producer_task, consumer_task);
}
```
</UniversalEditor>

## 异步流

Rust 的异步流类似于 Python 的异步生成器。

<UniversalEditor compare={true} title="异步迭代">
```python !! py
# Python - 异步生成器
import asyncio

async def countdown(n: int):
    """异步生成器产生值"""
    for i in range(n, 0, -1):
        await asyncio.sleep(0.1)
        yield i

async def main():
    async for value in countdown(5):
        print(f"Count: {value}")

asyncio.run(main())
```

```rust !! rs
// Rust - 使用 futures::stream 的异步流
use futures::stream::{self, StreamExt};
use tokio::time::{sleep, Duration};

async fn countdown(n: i32) -> impl Stream<Item = i32> {
    // 从迭代器创建带延迟的流
    stream::iter((1..=n).rev())
        .then(|n| async move {
            sleep(Duration::from_millis(100)).await;
            n
        })
}

#[tokio::main]
async fn main() {
    let mut stream = countdown(5).await;

    while let Some(value) = stream.next().await {
        println!("Count: {}", value);
    }
}
```
</UniversalEditor>

## 异步 HTTP 客户端

<UniversalEditor compare={true} title="HTTP 请求">
```python !! py
# Python - aiohttp 客户端
import aiohttp
import asyncio

async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = [
        "https://httpbin.org/get",
        "https://httpbin.org/delay/1",
        "https://httpbin.org/json",
    ]

    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        for result in results:
            print(f"Fetched {len(result)} bytes")

asyncio.run(main())
```

```rust !! rs
// Rust - Reqwest 异步客户端
use reqwest;
use futures::future::join_all;

async fn fetch_url(url: &str) -> Result<String, reqwest::Error> {
    let response = reqwest::get(url).await?;
    let text = response.text().await?;
    Ok(text)
}

#[tokio::main]
async fn main() {
    let urls = [
        "https://httpbin.org/get",
        "https://httpbin.org/delay/1",
        "https://httpbin.org/json",
    ];

    let fetch_futures: Vec<_> = urls.iter()
        .map(|&url| fetch_url(url))
        .collect();

    let results = join_all(fetch_futures).await;

    for result in results {
        match result {
            Ok(text) => println!("Fetched {} bytes", text.len()),
            Err(e) => println!("Error: {}", e),
        }
    }
}
```
</UniversalEditor>

## 异步文件 I/O

<UniversalEditor compare={true} title="文件操作">
```python !! py
# Python - aiofiles 异步文件操作
import aiofiles
import asyncio

async def process_file(filename: str):
    async with aiofiles.open(filename, 'r') as f:
        content = await f.read()
        lines = content.splitlines()
        print(f"Read {len(lines)} lines from {filename}")

async def main():
    await asyncio.gather(
        process_file('file1.txt'),
        process_file('file2.txt'),
    )

asyncio.run(main())
```

```rust !! rs
// Rust - Tokio fs
use tokio::fs::File;
use tokio::io::{AsyncBufReadExt, BufReader};

async fn process_file(filename: &str) -> Result<(), Box<dyn std::error::Error>> {
    let file = File::open(filename).await?;
    let reader = BufReader::new(file);
    let mut lines = reader.lines();
    let mut count = 0;

    while let Some(_line) = lines.next_line().await? {
        count += 1;
    }

    println!("Read {} lines from {}", count, filename);
    Ok(())
}

#[tokio::main]
async fn main() {
    let results = tokio::join!(
        process_file("file1.txt"),
        process_file("file2.txt"),
    );

    results.0.unwrap();
    results.1.unwrap();
}
```
</UniversalEditor>

## 异步中的错误处理

<UniversalEditor compare={true} title="异步错误处理">
```python !! py
# Python - 异步中的异常处理
import asyncio

async def fetch_data(url: str) -> dict:
    if "error" in url:
        raise ValueError("Invalid URL")
    await asyncio.sleep(0.1)
    return {"data": "success"}

async def main():
    try:
        result = await fetch_data("https://error.api")
    except ValueError as e:
        print(f"Caught error: {e}")
    else:
        print(result)

asyncio.run(main())
```

```rust !! rs
// Rust - 异步中的 Result 类型
use tokio::time::{sleep, Duration};

async fn fetch_data(url: &str) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    if url.contains("error") {
        Err("Invalid URL".into())
    } else {
        sleep(Duration::from_millis(100)).await;
        Ok(json!({"data": "success"}))
    }
}

#[tokio::main]
async fn main() {
    match fetch_data("https://error.api").await {
        Ok(result) => println!("{}", result),
        Err(e) => println!("Caught error: {}", e),
    }
}
```
</UniversalEditor>

## 常见异步陷阱

### 1. 在异步上下文中阻塞

<UniversalEditor compare={true} title="避免阻塞操作">
```python !! py
# Python - 异步中的阻塞(不良实践)
import asyncio
import time

async def bad_blocking():
    time.sleep(2)  # 阻塞整个事件循环!
    print("Done")

async def good_nonblocking():
    await asyncio.sleep(2)  # 让出控制权
    print("Done")
```

```rust !! rs
// Rust - 对 CPU 密集型工作使用 spawn_blocking
use tokio::task::spawn_blocking;
use tokio::time::{sleep, Duration};

async fn bad_blocking() {
    std::thread::sleep(Duration::from_secs(2)); // 阻塞运行时!
    println!("Done");
}

async fn good_nonblocking() {
    sleep(Duration::from_secs(2)).await; // 让出控制
    println!("Done");
}

async fn good_cpu_bound() {
    // 将阻塞工作卸载到线程池
    let result = spawn_blocking(|| {
        // CPU 密集型工作在这里
        42
    }).await.unwrap();

    println!("Result: {}", result);
}

#[tokio::main]
async fn main() {
    good_nonblocking().await;
    good_cpu_bound().await;
}
```
</UniversalEditor>

### 2. 取消

<UniversalEditor compare={true} title="异步取消">
```python !! py
# Python - 任务取消
import asyncio

async def cancellable_task():
    try:
        print("Task started")
        await asyncio.sleep(5)
        print("Task completed")
    except asyncio.CancelledError:
        print("Task was cancelled")
        raise

async def main():
    task = asyncio.create_task(cancellable_task())
    await asyncio.sleep(1)
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print("Main caught cancellation")

asyncio.run(main())
```

```rust !! rs
// Rust - 使用 tokio::select! 的协作式取消
use tokio::time::{sleep, Duration, timeout};
use tokio::signal::ctrl_c;

async fn cancellable_task() -> Result<(), Box<dyn std::error::Error>> {
    println!("Task started");

    // 使用 select! 等待多个 future
    tokio::select! {
        _ = sleep(Duration::from_secs(5)) => {
            println!("Task completed");
        }
        _ = ctrl_c() => {
            println!("Task received Ctrl+C");
            return Err("Cancelled".into());
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() {
    // 超时后取消
    match timeout(Duration::from_secs(1), cancellable_task()).await {
        Ok(Ok(())) => println!("Task succeeded"),
        Ok(Err(e)) => println!("Task error: {}", e),
        Err(_) => println!("Task timed out"),
    }
}
```
</UniversalEditor>

## 实战示例: 网页爬虫

<UniversalEditor compare={true} title="并发网页爬虫">
```python !! py
# Python - 异步网页爬虫
import asyncio
import aiohttp
from bs4 import BeautifulSoup

async def scrape_page(session: aiohttp.ClientSession, url: str) -> dict:
    async with session.get(url) as response:
        html = await response.text()
        soup = BeautifulSoup(html, 'html.parser')
        return {
            'url': url,
            'title': soup.title.string if soup.title else 'No title',
            'links': len(soup.find_all('a'))
        }

async def main(urls: list[str]):
    async with aiohttp.ClientSession() as session:
        tasks = [scrape_page(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        return results

if __name__ == "__main__":
    urls = [
        "https://example.com",
        "https://example.org",
        "https://example.net",
    ]
    results = asyncio.run(main(urls))
    for result in results:
        print(f"{result['url']}: {result['title']} ({result['links']} links)")
```

```rust !! rs
// Rust - 并发网页爬虫
use reqwest::Client;
use scraper::{Html, Selector};
use futures::future::join_all;

struct ScrapedData {
    url: String,
    title: String,
    links: usize,
}

async fn scrape_page(client: &Client, url: &str) -> Result<ScrapedData, Box<dyn std::error::Error>> {
    let response = client.get(url).send().await?;
    let html = response.text().await?;

    let document = Html::parse_document(&html);
    let title_selector = Selector::parse("title").unwrap();
    let link_selector = Selector::parse("a").unwrap();

    let title = document
        .select(&title_selector)
        .next()
        .map(|t| t.text().collect::<String>())
        .unwrap_or_else(|| "No title".to_string());

    let links = document.select(&link_selector).count();

    Ok(ScrapedData {
        url: url.to_string(),
        title,
        links,
    })
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let urls = [
        "https://example.com",
        "https://example.org",
        "https://example.net",
    ];

    let client = Client::new();
    let scrape_futures: Vec<_> = urls.iter()
        .map(|&url| scrape_page(&client, url))
        .collect();

    let results = join_all(scrape_futures).await;

    for result in results {
        match result {
            Ok(data) => println!("{}: {} ({} links)", data.url, data.title, data.links),
            Err(e) => println!("Error scraping: {}", e),
        }
    }

    Ok(())
}
```
</UniversalEditor>

## 关键要点

### Python 中的异步
- 基于协程和事件循环
- 运行时隐式调度
- 易于使用但有运行时开销
- 使用 `async`/`await` 语法

### Rust 中的异步
- 基于 Future 的零成本抽象
- 需要显式运行时(Tokio)
- 编译器强制异步代码安全
- 不使用异步时无运行时开销
- 异步入口点需要 `#[tokio::main]`

### 何时使用异步
- **使用异步** 处理 I/O 密集型操作(网络、文件)
- **使用同步** 处理 CPU 密集型任务(或使用 `spawn_blocking`)
- **避免异步** 用于简单的顺序代码
- **优先使用通道** 而非共享状态

## 练习

1. 实现一个并发文件下载器,并行下载多个文件
2. 使用异步通道构建聊天服务器
3. 创建异步数据库连接池
4. 实现指数退避的重试逻辑
5. 构建带速率限制的并发网页爬虫

## 下一模块

在模块 17 中,我们将探索 **Rust 测试**,包括单元测试、集成测试、基于属性的测试和模拟策略。
