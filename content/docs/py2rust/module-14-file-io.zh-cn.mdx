---
title: "模块 14: 文件 I/O 和标准库 - 文件操作"
description: "学习 Rust 的文件输入/输出、路径操作、命令行参数和环境变量,与 Python 的方法进行比较。"
---

# 模块 14: 文件 I/O 和标准库 - 文件操作

在本模块中,你将学习 Rust 如何处理文件 I/O 和系统交互,以及这与 Python 的方法的比较。

## 学习目标

完成本模块后,你将能够:
- 在 Rust 中读写文件
- 操作文件系统路径
- 处理命令行参数
- 使用环境变量
- 有效地使用 Rust 的标准库
- 比较 Rust 的 I/O 与 Python 的文件处理

## 读取文件

### 读取整个文件

<UniversalEditor compare={true} title="读取整个文件">
```python !! py
# Python: 简单文件读取
with open('file.txt', 'r') as f:
    content = f.read()  # 整个文件作为字符串
    print(content)
```

```rust !! rs
// Rust: 读取整个文件
use std::fs;

fn main() {
    match fs::read_to_string("file.txt") {
        Ok(content) => println!("{}", content),
        Err(e) => eprintln!("错误: {}", e),
    }
}
```
</UniversalEditor>

## 写入文件

<UniversalEditor compare={true} title="写入文件">
```python !! py
# Python: 写入文件
with open('output.txt', 'w') as f:
    f.write("Hello, World!\n")

# 追加模式
with open('output.txt', 'a') as f:
    f.write("追加的行\n")
```

```rust !! rs
// Rust: 写入文件
use std::fs::File;
use std::io::Write;

fn write_file() -> std::io::Result<()> {
    let mut file = File::create("output.txt")?;
    file.write_all(b"Hello, World!\n")?;
    Ok(())
}
```
</UniversalEditor>

## 路径操作

<UniversalEditor compare={true} title="路径操作">
```python !! py
# Python: pathlib 用于跨平台路径
from pathlib import Path

path = Path("data") / "files" / "example.txt"
print(path.parent)  # data/files
print(path.name)  # example.txt
```

```rust !! rs
// Rust: std::path::Path 用于跨平台路径
use std::path::Path;

fn path_operations() {
    let path = Path::new("data/files/example.txt");

    println!("父目录: {:?}", path.parent());
    println!("文件名: {:?}", path.file_name());
}
```
</UniversalEditor>

## 命令行参数

<UniversalEditor compare={true} title="命令行参数">
```python !! py
# Python: sys.argv 用于命令行参数
import sys

if len(sys.argv) < 2:
    print(f"用法: {sys.argv[0]} <文件名>")
    sys.exit(1)

filename = sys.argv[1]
print(f"处理: {filename}")
```

```rust !! rs
// Rust: std::env::args 用于命令行参数
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        eprintln!("用法: {} <文件名>", args[0]);
        std::process::exit(1);
    }

    let filename = &args[1];
    println!("处理: {}", filename);
}
```
</UniversalEditor>

## 环境变量

<UniversalEditor compare={true} title="环境变量">
```python !! py
# Python: os.environ 用于环境变量
import os

home = os.environ.get("HOME", "/default/home")
print(f"主目录: {home}")

os.environ["MY_VAR"] = "value"
```

```rust !! rs
// Rust: std::env 用于环境变量
use std::env;

fn env_vars() {
    let home = env::var("HOME").unwrap_or("/default/home".to_string());
    println!("主目录: {}", home);

    env::set_var("MY_VAR", "value");
}
```
</UniversalEditor>

## 最佳实践

### 应该做:

1. **使用 `BufReader` 逐行读取** - 更高效
2. **使用 `?` 操作符传播错误** - 代码更清晰
3. **使用 `Path` 和 `PathBuf`** - 跨平台兼容
4. **正确处理错误** - 生产环境中不要使用 `.unwrap()`

### 不应该做:

1. **不必要地将整个文件读入内存** - 使用流式处理
2. **忽略 I/O 错误** - 正确处理它们
3. **使用字符串拼接路径** - 使用 Path 方法

## 总结

- **文件 I/O** 使用 `std::fs` 和 `std::io`
- **路径** 使用 `std::path` 进行跨平台支持
- **命令行参数** 通过 `std::env::args`
- **环境变量** 通过 `std::env`
- **错误处理** 使用 `Result` 类型显式处理
- **Rust 的方法**比 Python 的更冗长但更安全

## 练习

1. 创建一个程序读取文件并统计词频
2. 构建一个简单的文件复制工具
3. 创建递归遍历的目录列表工具

## 下一模块

在最后一个模块中,我们将探索**线程和并发**,包括生成线程、通道、互斥锁,以及 Rust 的无畏并发如何与 Python 的线程模型进行比较。
