---
title: "模块 8：枚举和模式匹配"
description: "探索 Rust 强大的枚举系统和模式匹配功能，与 Python 的类层次结构和控制流进行对比"
---

# 模块 8：枚举和模式匹配

欢迎来到模块 8！这是 Rust 真正闪耀的地方。Rust 的枚举系统和模式匹配远比 Python 中的任何功能都强大，能够实现类型安全、表达性强的代码，这在动态语言中是无法复制的。

## 学习目标

完成本模块后，你将能够：
- 定义和使用带有数据变体的枚举
- 利用 `Option<T>` 实现空值安全编程
- 使用 `Result<T, E>` 进行错误处理
- 使用 `match` 表达式编写强大的模式匹配
- 使用 `if let` 和 `while let` 进行简洁的模式匹配
- 理解穷尽匹配和编译器保证

## 8.1 枚举：不仅仅是常量

### Python：有限的枚举支持

Python 的枚举相对简单：

```python
# Python - 基本枚举
from enum import Enum

class Color(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3

# 使用
color = Color.RED
print(color.value)  # 1
```

### Rust：携带数据的枚举

Rust 枚举要强大得多 - 它们可以携带数据：

<UniversalEditor compare={true} title="枚举基础">
```python !! py
# Python - 使用类模拟数据变体
class Color:
    def __init__(self, value):
        self.value = value

class RGB(Color):
    def __init__(self, r, g, b):
        self.r = r
        self.g = g
        self.b = b

class HSV(Color):
    def __init__(self, h, s, v):
        self.h = h
        self.s = s
        self.v = v

# 类型检查是手动的
color = RGB(255, 0, 0)
if isinstance(color, RGB):
    print(f"R={color.r}, G={color.g}, B={color.b}")
```

```rust !! rs
// Rust - 代数数据类型
enum Color {
    RGB(u8, u8, u8),
    HSV(u8, u8, u8),
}

// 使用
let color = Color::RGB(255, 0, 0);

// 模式匹配提取数据
match color {
    Color::RGB(r, g, b) => {
        println!("R={}, G={}, B={}", r, g, b);
    }
    Color::HSV(h, s, v) => {
        println!("H={}, S={}, V={}", h, s, v);
    }
}

// 使用命名字段
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8),
}

let msg = Message::Move { x: 10, y: 20 };
```
</UniversalEditor>

### 枚举的威力

<UniversalEditor compare={true} title="真实世界的枚举示例">
```python !! py
# Python - 手动类型检查和错误
class Shape:
    pass

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

def area(shape):
    if isinstance(shape, Circle):
        return 3.14 * shape.radius ** 2
    elif isinstance(shape, Rectangle):
        return shape.width * shape.height
    else:
        raise ValueError("Unknown shape")
```

```rust !! rs
// Rust - 使用穷尽匹配的类型安全
enum Shape {
    Circle(f64),
    Rectangle { width: f64, height: f64 },
}

fn area(shape: &Shape) -> f64 {
    match shape {
        Shape::Circle(radius) => 3.14 * radius * radius,
        Shape::Rectangle { width, height } => width * height,
    }
}

// 编译器确保所有情况都被覆盖！
let circle = Shape::Circle(5.0);
println!("Area: {}", area(&circle));
```
</UniversalEditor>

## 8.2 `Option<T>`：消除 Null

### Python：None 和运行时错误

Python 使用 `None` 表示不存在，但这可能导致运行时错误：

<UniversalEditor compare={true} title="空值安全对比">
```python !! py
# Python - None 无处不在
def find_user(user_id):
    if user_id == 1:
        return {"name": "Alice", "email": "alice@example.com"}
    return None

# 如果忘记检查会出现运行时错误！
user = find_user(2)
print(user["name"])  # TypeError: 'NoneType' is not subscriptable

# 必须手动检查
user = find_user(2)
if user is not None:
    print(user["name"])
else:
    print("User not found")
```

```rust !! rs
// Rust - Option<T> 强制处理
fn find_user(user_id: u32) -> Option<&'static str> {
    if user_id == 1 {
        Some("Alice")
    } else {
        None
    }
}

// 编译器强制你处理 None 情况
let user = find_user(2);
match user {
    Some(name) => println!("User: {}", name),
    None => println!("User not found"),
}

// 或使用辅助方法
let user = find_user(1);
println!("User: {}", user.unwrap_or("Unknown"));

// 链式操作
let user = find_user(2)
    .map(|name| name.to_uppercase())
    .unwrap_or_else(|| "DEFAULT".to_string());
```
</UniversalEditor>

### Option 方法

<UniversalEditor compare={true} title="使用 Option">
```python !! py
# Python - 手动 None 处理
def get_score(name):
    scores = {"Alice": 95, "Bob": 87}
    return scores.get(name)

# 手动检查
score = get_score("Charlie")
if score is not None:
    print(f"Score: {score}")
else:
    print("No score")

# 提供默认值
score = get_score("Charlie") or 0
print(f"Score: {score}")
```

```rust !! rs
// Rust - 丰富的 Option API
fn get_score(name: &str) -> Option<i32> {
    let scores = [("Alice", 95), ("Bob", 87)];
    scores.iter()
        .find(|(n, _)| *n == name)
        .map(|(_, score)| *score)
}

// 模式匹配
let score = get_score("Charlie");
match score {
    Some(s) => println!("Score: {}", s),
    None => println!("No score"),
}

// 提供默认值
let score = get_score("Charlie").unwrap_or(0);
println!("Score: {}", score);

// 使用 map 转换
let doubled = get_score("Alice").map(|s| s * 2);
println!("Doubled: {:?}", doubled);

// 链式操作
let result = get_score("Charlie")
    .or(Some(0))
    .map(|s| s * 2)
    .unwrap_or(0);
```
</UniversalEditor>

## 8.3 `Result<T, E>`：正确的错误处理

### Python：异常和 Try/Catch

Python 使用异常进行错误处理：

<UniversalEditor compare={true} title="错误处理方法">
```python !! py
# Python - 异常
def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

# 必须使用 try/catch
try:
    result = divide(10, 0)
except ValueError as e:
    print(f"Error: {e}")
else:
    print(f"Result: {result}")

# 多种异常类型
try:
    result = divide(10, "2")
except ValueError as e:
    print(f"ValueError: {e}")
except TypeError as e:
    print(f"TypeError: {e}")
```

```rust !! rs
// Rust - Result<T, E> 用于显式错误
fn divide(a: f64, b: f64) -> Result<f64, String> {
    if b == 0.0 {
        Err(String::from("Cannot divide by zero"))
    } else {
        Ok(a / b)
    }
}

// 必须处理两种情况
let result = divide(10.0, 0.0);
match result {
    Ok(value) => println!("Result: {}", value),
    Err(e) => println!("Error: {}", e),
}

// 或在返回 Result 的函数中使用 ? 运算符
fn calculate() -> Result<(), String> {
    let result = divide(10.0, 2.0)?;
    println!("Result: {}", result);
    Ok(())
}

// 使用自定义错误枚举处理多种错误类型
#[derive(Debug)]
enum MathError {
    DivisionByZero,
    InvalidInput(String),
}

fn divide_safe(a: f64, b: f64) -> Result<f64, MathError> {
    if b == 0.0 {
        Err(MathError::DivisionByZero)
    } else if a.is_nan() || b.is_nan() {
        Err(MathError::InvalidInput("NaN detected".to_string()))
    } else {
        Ok(a / b)
    }
}
```
</UniversalEditor>

### 组合 Result

<UniversalEditor compare={true} title="链式 Result">
```python !! py
# Python - 手动错误传播
def step1():
    return "data"

def step2(data):
    if data == "error":
        raise ValueError("Step 2 failed")
    return data + "_processed"

def pipeline():
    try:
        data = step1()
        result = step2(data)
        return result
    except ValueError as e:
        print(f"Pipeline failed: {e}")
        return None
```

```rust !! rs
// Rust - 可组合的 Result 操作
fn step1() -> Result<&'static str, String> {
    Ok("data")
}

fn step2(data: &str) -> Result<String, String> {
    if data == "error" {
        Err("Step 2 failed".to_string())
    } else {
        Ok(format!("{}_processed", data))
    }
}

// 使用 match 手动传播
fn pipeline() -> Result<String, String> {
    let data = step1()?;
    let result = step2(&data)?;
    Ok(result)
}

// 或使用 and_then 进行链式调用
fn pipeline() -> Result<String, String> {
    step1()
        .and_then(|data| step2(data))
}

// 组合多个操作
fn pipeline_complex() -> Result<String, String> {
    step1()
        .and_then(|data| step2(data))
        .map(|result| result.to_uppercase())
        .map_err(|e| format!("Pipeline failed: {}", e))
}
```
</UniversalEditor>

## 8.4 使用 match 进行模式匹配

### Python：if/elif/else 链

Python 依赖 if/elif/else 链：

```python
# Python - if/elif/else
def describe_number(n):
    if n < 0:
        return "negative"
    elif n == 0:
        return "zero"
    elif n < 10:
        return "small"
    else:
        return "large"
```

### Rust：穷尽模式匹配

<UniversalEditor compare={true} title="Match 表达式基础">
```python !! py
# Python - 多个条件
def get_day_name(n):
    if n == 1:
        return "Monday"
    elif n == 2:
        return "Tuesday"
    elif n == 3:
        return "Wednesday"
    elif n == 4:
        return "Thursday"
    elif n == 5:
        return "Friday"
    elif n == 6:
        return "Saturday"
    elif n == 7:
        return "Sunday"
    else:
        return "Invalid day"
```

```rust !! rs
// Rust - 穷尽 match
fn get_day_name(n: u32) -> &'static str {
    match n {
        1 => "Monday",
        2 => "Tuesday",
        3 => "Wednesday",
        4 => "Thursday",
        5 => "Friday",
        6 => "Saturday",
        7 => "Sunday",
        _ => "Invalid day",  // 捕获所有
    }
}

// 或使用范围
fn classify_number(n: i32) -> &'static str {
    match n {
        0 => "zero",
        1..=9 => "single digit",  // 包含范围
        10..=99 => "double digit",
        _ => "other",
    }
}
```
</UniversalEditor>

### 模式中的解构

<UniversalEditor compare={true} title="模式解构">
```python !! py
# Python - 手动字段访问
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def describe_point(point):
    if point.x == 0 and point.y == 0:
        return "origin"
    elif point.x == 0:
        return "on y-axis"
    elif point.y == 0:
        return "on x-axis"
    else:
        return f"at ({point.x}, {point.y})"
```

```rust !! rs
// Rust - match 中的解构
struct Point {
    x: i32,
    y: i32,
}

fn describe_point(point: &Point) -> String {
    match point {
        Point { x: 0, y: 0 } => String::from("origin"),
        Point { x: 0, y } => format!("on y-axis at y={}", y),
        Point { x, y: 0 } => format!("on x-axis at x={}", x),
        Point { x, y } => format!("at ({}, {})", x, y),
    }
}

// 或使用简写
fn describe_point_short(point: &Point) -> String {
    match point {
        Point { x: 0, y: 0 } => String::from("origin"),
        Point { x: 0, y } => format!("y={}", y),
        Point { x, y: 0 } => format!("x={}", x),
        Point { x, y } => format!("({}, {})", x, y),
    }
}
```
</UniversalEditor>

### 匹配枚举

<UniversalEditor compare={true} title="匹配枚举">
```python !! py
# Python - 实例检查
class Message:
    pass

class Quit(Message):
    pass

class Move(Message):
    def __init__(self, x, y):
        self.x = x
        self.y = y

def handle_message(msg):
    if isinstance(msg, Quit):
        print("Quitting...")
    elif isinstance(msg, Move):
        print(f"Moving to ({msg.x}, {msg.y})")
    else:
        print("Unknown message")
```

```rust !! rs
// Rust - 枚举上的模式匹配
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn handle_message(msg: &Message) {
    match msg {
        Message::Quit => {
            println!("Quitting...");
        }
        Message::Move { x, y } => {
            println!("Moving to ({}, {})", x, y);
        }
        Message::Write(text) => {
            println!("Writing: {}", text);
        }
        Message::ChangeColor(r, g, b) => {
            println!("Color: {}, {}, {}", r, g, b);
        }
    }
}

// match 分支中的守卫
fn handle_message_with_guard(msg: &Message) {
    match msg {
        Message::Move { x, y } if x < 0 || y < 0 => {
            println!("Invalid move!");
        }
        Message::Move { x, y } => {
            println!("Moving to ({}, {})", x, y);
        }
        _ => println!("Other message"),
    }
}
```
</UniversalEditor>

## 8.5 简洁模式：if let 和 while let

### if let：匹配单个模式

<UniversalEditor compare={true} title="if let vs match">
```python !! py
# Python - 检查和提取
def process_option(value):
    if value is not None:
        # 使用 value 工作
        print(f"Got: {value}")
    else:
        # 处理 None
        print("Got nothing")
```

```rust !! rs
// Rust - if let 用于单模式匹配
fn process_option(value: Option<&str>) {
    // 只匹配 Some，忽略 None
    if let Some(v) = value {
        println!("Got: {}", v);
    } else {
        println!("Got nothing");
    }
}

// 或更简洁
fn process_option_concise(value: Option<&str>) {
    if let Some(v) = value {
        println!("Got: {}", v);
    }
    // else 是可选的！
}

// if let with else
fn process_option_else(value: Option<&str>) {
    if let Some(v) = value {
        println!("Processing: {}", v);
    } else {
        println!("No value provided");
    }
}
```
</UniversalEditor>

### while let：重复匹配

<UniversalEditor compare={true} title="while let 模式">
```python !! py
# Python - 循环直到条件满足
def pop_until_empty(stack):
    results = []
    while stack:
        results.append(stack.pop())
    return results
```

```rust !! rs
// Rust - while let 用于重复匹配
fn pop_until_empty(stack: &mut Vec<i32>) -> Vec<i32> {
    let mut results = Vec::new();

    // 保持弹出直到没有元素
    while let Some(val) = stack.pop() {
        results.push(val);
    }

    results
}

// 更复杂的例子
fn process_results(values: Vec<Option<i32>>) -> Vec<i32> {
    let mut results = Vec::new();

    for mut opt in values {
        // 持续获取值直到 None
        while let Some(val) = opt {
            results.push(val);
            opt = None;  // 模拟状态变化
        }
    }

    results
}
```
</UniversalEditor>

## 8.6 高级模式

### 匹配多个模式

<UniversalEditor compare={true} title="模式组合">
```python !! py
# Python - 多个条件
def describe_value(x):
    if x == 1 or x == 3 or x == 5 or x == 7 or x == 9:
        return "odd digit"
    elif x == 0 or x == 2 or x == 4 or x == 6 or x == 8:
        return "even digit"
    else:
        return "other"
```

```rust !! rs
// Rust - 使用 | 的多个模式
fn describe_value(x: i32) -> &'static str {
    match x {
        1 | 3 | 5 | 7 | 9 => "odd digit",
        0 | 2 | 4 | 6 | 8 => "even digit",
        _ => "other",
    }
}

// 范围和多个模式
fn classify_number_advanced(x: i32) -> &'static str {
    match x {
        1..=10 => "1-10",
        20 | 30 | 40 => "20, 30, or 40",
        _ => "other",
    }
}
```
</UniversalEditor>

### 忽略值

<UniversalEditor compare={true} title="忽略模式">
```python !! py
# Python - 使用 _ 忽略
result, _ = some_function()  # 忽略第二个值
```

```rust !! rs
// Rust - 多种忽略方式
// 忽略单个值
let (x, _) = (1, 2);  // x = 1，忽略 2

// 忽略多个值
let _ = (1, 2, 3);  // 忽略整个元组

// 结构体模式中的忽略
struct Point3D {
    x: i32,
    y: i32,
    z: i32,
}

fn get_x(point: Point3D) -> i32 {
    match point {
        Point3D { x, .. } => x,  // 只关心 x
    }
}

// 使用 _ 前缀忽略（抑制未使用变量警告）
let _x = 5;  // 使用 _ 前缀抑制警告
```
</UniversalEditor>

### @ 绑定

<UniversalEditor compare={true} title="@ 绑定模式">
```python !! py
# Python - 需要同时测试和捕获
class Message:
    pass

class Move(Message):
    def __init__(self, x, y):
        self.x = x
        self.y = y

msg = Move(10, 20)
if isinstance(msg, Move) and msg.x > 5:
    print(f"Large move: {msg.x}, {msg.y}")
```

```rust !! rs
// Rust - @ 绑定用于匹配和捕获
enum Message {
    Move { x: i32, y: i32 },
}

fn describe_message(msg: &Message) -> String {
    match msg {
        // 使用 @ 匹配和绑定
        Message::Move { x: x_val @ (10 | 20 | 30), y } => {
            format!("Special move at x={}, y={}", x_val, y)
        }
        Message::Move { x, y } => {
            format!("Normal move at x={}, y={}", x, y)
        }
    }
}

// 另一个例子
fn classify_range(n: i32) -> &'static str {
    match n {
        m @ 0..=10 => "small",
        m @ 11..=100 => "medium",
        m @ 101..=1000 => "large",
        _ => "huge",
    }
}
```
</UniversalEditor>

## 常见陷阱

### 陷阱 1：忘记处理 None

```rust
// 不要：忘记处理 None
let opt: Option<i32> = None;
let val = opt.unwrap();  // 恐慌！

// 应该：正确处理 None
let opt: Option<i32> = None;
let val = opt.unwrap_or(0);
```

### 陷阱 2：非穷尽匹配

```rust
// 不要：忘记 match 情况（不会编译）
enum Color { Red, Blue, Green }
let color = Color::Red;
match color {
    Color::Red => println!("Red"),
    Color::Blue => println!("Blue"),
    // 缺少 Green！编译器错误！
}

// 应该：处理所有情况
match color {
    Color::Red => println!("Red"),
    Color::Blue => println!("Blue"),
    Color::Green => println!("Green"),
}
```

### 陷阱 3：使用 Expect 而不是 Unwrap

```rust
// 不要：在生产中使用 unwrap
let val = opt.unwrap();  // 恐慌，带有通用消息

// 应该：使用 expect 获得更好的错误消息
let val = opt.expect("Failed to get value from config");
```

## 最佳实践

1. **优先使用 `Option` 而不是 null 值** - 永远不要使用空指针值
2. **对可恢复错误使用 `Result`** - 将 `panic!` 用于不可恢复的错误
3. **利用 `match` 进行穷尽处理** - 让编译器确保正确性
4. **对单个模式使用 `if let`** - 比完整的 match 更简洁
5. **与 `?` 运算符结合** - 清晰的错误传播
6. **创建自定义错误类型** - 类型安全的错误处理

## 总结

在本模块中，我们涵盖了：

- **枚举**：用于类型安全建模的数据携带变体
- **`Option<T>`**：没有运行时错误的空值安全编程
- **`Result<T, E>`**：没有异常的显式错误处理
- **模式匹配**：穷尽的、编译器检查的控制流
- **简洁模式**：`if let` 和 `while let` 提高可读性

关键要点：
- Rust 的枚举是代数数据类型，远比 Python 的强大
- Option 和 Result 消除了整类运行时错误
- 模式匹配是穷尽的且经过编译器验证
- ? 运算符提供清晰的错误传播
- 模式匹配实现了无法复制的类型安全性

## 练习

创建一个简单的表达式求值器：
1. 定义表达式枚举（Number、Add、Multiply 等）
2. 使用模式匹配实现 eval 函数
3. 使用 Result 优雅地处理错误
4. 展示嵌套模式匹配

<details>
<summary>查看解决方案</summary>

```rust
#[derive(Debug)]
enum Expr {
    Number(f64),
    Add(Box<Expr>, Box<Expr>),
    Multiply(Box<Expr>, Box<Expr>),
    Variable(String),
}

#[derive(Debug)]
enum EvalError {
    DivisionByZero,
    UnknownVariable(String),
}

fn eval(expr: &Expr, vars: &std::collections::HashMap<String, f64>) -> Result<f64, EvalError> {
    match expr {
        Expr::Number(n) => Ok(*n),
        Expr::Add(left, right) => {
            let l = eval(left, vars)?;
            let r = eval(right, vars)?;
            Ok(l + r)
        }
        Expr::Multiply(left, right) => {
            let l = eval(left, vars)?;
            let r = eval(right, vars)?;
            Ok(l * r)
        }
        Expr::Variable(name) => {
            vars.get(name)
                .copied()
                .ok_or(EvalError::UnknownVariable(name.clone()))
        }
    }
}

fn main() {
    let expr = Expr::Add(
        Box::new(Expr::Number(5.0)),
        Box::new(Expr::Multiply(
            Box::new(Expr::Number(3.0)),
            Box::new(Expr::Number(2.0)),
        )),
    );

    match eval(&expr, &std::collections::HashMap::new()) {
        Ok(result) => println!("Result: {}", result),  // 11.0
        Err(e) => println!("Error: {:?}", e),
    }
}
```

</details>

接下来：**模块 9 - 错误处理**，我们将深入研究 Rust 的错误处理模式和最佳实践！
