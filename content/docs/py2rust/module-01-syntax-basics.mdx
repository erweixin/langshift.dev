---
title: "Module 1: Syntax Basics"
description: "Learn Rust syntax by comparing it with Python. Understand variables, types, functions, and basic expressions."
---

# Module 1: Syntax Basics

Now that your Rust environment is set up, let's dive into Rust syntax! This module will be your bridge from Python to Rust, showing you how familiar concepts map to Rust.

## Learning Objectives

By the end of this module, you'll understand:
- ‚úÖ Variable declarations and mutability
- ‚úÖ Basic data types and type annotations
- ‚úÖ Functions and expressions vs statements
- ‚úÖ Comments and code organization
- ‚úÖ Printing and output
- ‚úÖ Basic operators and precedence

## Variables and Mutability

The first major difference you'll notice is how Rust handles variables.

<UniversalEditor compare={true} title="Variable Declaration: Python vs Rust">
```python !! py
# Python: Variables are references, mutable by default
name = "Alice"
age = 25
height = 5.6

# Can reassign anytime
age = 26

# Can even change type
age = "twenty-six"  # This works!
```

```rust !! rs
// Rust: Variables are bindings, immutable by default
let name = "Alice";
let age: i32 = 25;        // Explicit type
let height = 5.6;         // Type inferred

// Cannot reassign immutable variables
// age = 26;  // ERROR: cannot assign twice to immutable variable

// Use mut for mutable variables
let mut age = 25;
age = 26;  // OK

// Cannot change type
// age = "twenty-six";  // ERROR: type mismatch
```
</UniversalEditor>

### Why Immutability by Default?

Rust's default immutability prevents bugs:
- **Clearer code**: You know variables won't change
- **Compiler optimizations**: Easier to optimize
- **Concurrency**: Safer sharing between threads

<UniversalEditor compare={true} title="Mutability in Practice">
```python !! py
# Python: Everything can change
def process(items):
    result = []
    for item in items:
        result.append(item * 2)
    return result

data = [1, 2, 3]
processed = process(data)
print(data)  # Still [1, 2, 3] - not modified
```

```rust !! rs
// Rust: Explicit control over mutations
fn process(items: &[i32]) -> Vec<i32> {
    items.iter().map(|x| x * 2).collect()
}

let data = vec![1, 2, 3];
let processed = process(&data);
println!("{:?}", data);  // Still [1, 2, 3] - guaranteed!
```
</UniversalEditor>

### Variable Naming

<UniversalEditor compare={true} title="Naming Conventions">
```python !! py
# Python: snake_case for variables and functions
my_variable = 42
def calculate_sum():
    pass

# CONSTANT-LIKE for constants
MAX_SIZE = 100
```

```rust !! rs
// Rust: snake_case for variables and functions
let my_variable = 42;
fn calculate_sum() {}

// SCREAMING_SNAKE_CASE for constants
const MAX_SIZE: usize = 100;

// Types are PascalCase
struct MyStruct {}
enum MyEnum {}
```
</UniversalEditor>

## Basic Data Types

Rust has a static type system, but the compiler is good at type inference.

### Integer Types

<UniversalEditor compare={true} title="Integer Types">
```python !! py
# Python: Arbitrary precision integers
x = 42
x = 2**100  # Works! Python handles big integers
```

```rust !! rs
// Rust: Fixed-size integers
let x: i32 = 42;           // 32-bit signed
let y: u64 = 100;          // 64-bit unsigned
let z: i8 = -5;            // 8-bit signed

// Integer literals
let decimal = 98_222;      // Underscore for readability
let hex = 0xff;            // Prefix 0x
let octal = 0o77;          // Prefix 0o
let binary = 0b1111_0000;  // Prefix 0b
let byte = b'A';           // u8 only
```
</UniversalEditor>

**Integer types in Rust:**
- `i8, i16, i32, i64, i128, isize` (signed)
- `u8, u16, u32, u64, u128, usize` (unsigned)
- Default is `i32`
- `isize`/`usize` are pointer-sized

### Floating-Point Types

<UniversalEditor compare={true} title="Float Types">
```python !! py
# Python: float is usually double precision
x = 3.14
y = 2.0  # Also a float
```

```rust !! rs
// Rust: f32 and f64
let x: f32 = 3.14;   // 32-bit
let y: f64 = 2.0;    // 64-bit (default)

let z = 3.14;        // Inferred as f64
```
</UniversalEditor>

### Boolean Type

<UniversalEditor compare={true} title="Booleans">
```python !! py
# Python: bool type
is_active = True
is_deleted = False

# Truthy and falsy values
if 0:  # Falsy
    pass
if "":  # Falsy
    pass
```

```rust !! rs
// Rust: bool type (no truthy/falsy)
let is_active: bool = true;
let is_deleted: bool = false;

// Must use explicit boolean in conditionals
if x != 0 {  // Cannot just use `if x`
    // ...
}

// Explicit comparison for strings
if !s.is_empty() {  // Cannot just use `if s`
    // ...
}
```
</UniversalEditor>

### Character Type

<UniversalEditor compare={true} title="Characters">
```python !! py
# Python: str for strings, individual chars are just strings
c = 'A'
s = "Hello"
```

```rust !! rs
// Rust: char is a Unicode scalar value (4 bytes)
let c: char = 'A';  // Note single quotes
let emoji = 'üòÄ';   // Works!

// String uses double quotes
let s: &str = "Hello";

// char is NOT a byte - it's Unicode!
let heart = '‚ù§';   // Valid char
```
</UniversalEditor>

### Type Inference

<UniversalEditor compare={true} title="Type Inference">
```python !! py
# Python: Dynamic typing - type determined at runtime
x = 42      # int
x = "hello" # Now str - type can change
```

```rust !! rs
// Rust: Static typing with inference
let x = 42;              // Type inferred as i32
let y: i32 = x;          // Explicit type annotation

// Type is set at declaration and cannot change
// x = "hello";  // ERROR: expected i32, found &str

// Compiler infers from usage
let mut x = 5;           // i32
x = 10;                  // Still i32
```
</UniversalEditor>

## Functions

Functions are where you'll see more significant differences.

<UniversalEditor compare={true} title="Function Definition">
```python !! py
# Python: Dynamic typing, no return type annotation required
def add(a, b):
    return a + b

# With type hints (optional)
def add_with_hints(a: int, b: int) -> int:
    return a + b

# Can return different types
def flexible(x):
    if x > 0:
        return 42
    return "negative"
```

```rust !! rs
// Rust: Static typing, explicit return type
fn add(a: i32, b: i32) -> i32 {
    a + b  // No semicolon = return value
}

// Must declare return type
// fn add(a: i32, b: i32) {  // ERROR: missing return type
//     a + b
// }

// Cannot return different types
// fn flexible(x: i32) -> ??? {  // What type?
//     if x > 0 {
//         return 42;
//     }
//     return "negative";  // ERROR: type mismatch
// }
```
</UniversalEditor>

### Statements vs Expressions

This is a crucial Rust concept!

<UniversalEditor compare={true} title="Statements vs Expressions">
```python !! py
# Python: Everything is a statement (returns None)
x = 5  # Statement
y = (x := 10)  # Assignment expression (Python 3.8+)

# if is a statement
if x > 0:
    result = "positive"
else:
    result = "negative"
```

```rust !! rs
// Rust: Statements don't return values, expressions do
let x = 5;  // Statement (note the semicolon)

// Expressions return values
let y = {
    let x = 3;
    x + 1  // Expression (no semicolon)
};  // y = 4

// if is an expression!
let result = if x > 0 {
    "positive"
} else {
    "negative"
};  // No ternary operator needed
```
</UniversalEditor>

**Key rule**: In Rust, expressions end without a semicolon, statements end with a semicolon.

<UniversalEditor compare={true} title="Expression Examples">
```python !! py
# Python: Statements and expressions mixed
def calculate(x):
    if x > 0:
        return x * 2
    return x * 3

result = calculate(5)
```

```rust !! rs
// Rust: Everything can be an expression
fn calculate(x: i32) -> i32 {
    if x > 0 {
        x * 2  // Expression value returned
    } else {
        x * 3
    }  // No semicolon for the block
}

// Can use match for cleaner code
fn calculate_match(x: i32) -> i32 {
    match x.cmp(&0) {
        std::cmp::Ordering::Greater => x * 2,
        _ => x * 3,
    }
}
```
</UniversalEditor>

### Return Values

<UniversalEditor compare={true} title="Return Values">
```python !! py
# Python: Explicit return or implicit None
def add(a, b):
    return a + b

def no_return():
    x = 5
    # Implicitly returns None
```

```rust !! rs
// Rust: Last expression is return value
fn add(a: i32, b: i32) -> i32 {
    a + b  // No semicolon = returns this
}

// Can use return keyword (but uncommon)
fn add_explicit(a: i32, b: i32) -> i32 {
    return a + b;  // Semicolon OK with return
}

// Functions with no return type return ()
fn no_return() {
    let x = 5;
    // Implicitly returns the unit type ()
}
```
</UniversalEditor>

## Comments

<UniversalEditor compare={true} title="Comments">
```python !! py
# Single-line comment

"""
Multi-line docstring
Used for documentation
"""

def my_function():
    """Function docstring."""
    pass
```

```rust !! rs
// Single-line comment

/// Outer documentation (for users)
/// This is a doc comment - it becomes documentation!
///
/// # Examples
/// ```
/// let x = add(1, 2);
/// ```
fn add(a: i32, b: i32) -> i32 {
    a + b
}

//! Inner documentation (for crate authors)
//! Rarely used outside of library crates

/* Multi-line comment
   Less common in Rust */
```
</UniversalEditor>

## Printing and Output

<UniversalEditor compare={true} title="Printing">
```python !! py
# Python: print function
print("Hello, world!")
print("Value:", x)
print(f"Formatted: {x}")

# Multiple ways to format
name = "Alice"
age = 25
print(f"{name} is {age} years old")
print("{} is {} years old".format(name, age))
```

```rust !! rs
// Rust: Macros for printing
println!("Hello, world!");
println!("Value: {}", x);
println!("Formatted: {}", x);

// Multiple placeholders
let name = "Alice";
let age = 25;
println!("{} is {} years old", name, age);

// Named parameters
println!("{name} is {age} years old", name=name, age=age);

// Debug output (use {:?})
println!("{:?}", vec![1, 2, 3]);

// Pretty debug (use {:#?})
println!("{:#?}", vec![1, 2, 3]);

// Print without newline
print!("No newline");
```
</UniversalEditor>

### Format Specifiers

<UniversalEditor compare={true} title="Format Specifiers">
```python !! py
# Python: Format specifications
x = 42
y = 3.14159

print(f"{x:5}")  # Width 5
print(f"{y:.2}")  # 2 decimal places
print(f"{x:#x}")  # Hexadecimal
```

```rust !! rs
// Rust: Format specifications
let x: i32 = 42;
let y: f64 = 3.14159;

println!("{:5}", x);  // Width 5
println!("{:.2}", y);  // 2 decimal places
println!("{:#x}", x);  // Hexadecimal
println!("{:?}", x);  // Debug
println!("{:b}", x);  // Binary
```
</UniversalEditor>

## Operators

Most operators are similar, but there are some differences.

<UniversalEditor compare={true} title="Arithmetic Operators">
```python !! py
# Python
a = 10 + 5   # 15
b = 10 - 5   # 5
c = 10 * 5   # 50
d = 10 / 3   # 3.333...
e = 10 // 3  # 3 (floor division)
f = 10 % 3   # 1
g = 2 ** 3   # 8 (exponentiation)
```

```rust !! rs
// Rust
let a = 10 + 5;   // 15
let b = 10 - 5;   // 5
let c = 10 * 5;   // 50
let d = 10 / 3;   // 3 (integer division!)
let e = 10 % 3;   // 1
let f = 2_i32.pow(3);  // 8 (method, not operator)

// For floating point
let d = 10.0 / 3.0;  // 3.333...
```
</UniversalEditor>

<UniversalEditor compare={true} title="Comparison Operators">
```python !! py
# Python
a = 5
b = 10

a == b  # False
a != b  # True
a < b   # True
a <= b  # True
a > b   # False
a >= b  # False
```

```rust !! rs
// Rust (same as Python)
let a = 5;
let b = 10;

a == b  // False
a != b  // True
a < b   // True
a <= b  // True
a > b   // False
a >= b  // False
```
</UniversalEditor>

<UniversalEditor compare={true} title="Logical Operators">
```python !! py
# Python: words, not symbols
a = True
b = False

a and b   # False
a or b    # True
not a     # False
```

```rust !! rs
// Rust: symbols, not words
let a: bool = true;
let b: bool = false;

a && b   // False (AND)
a || b   // True (OR)
!a       // False (NOT)
```
</UniversalEditor>

## String Types

Rust has multiple string types - a common source of confusion!

<UniversalEditor compare={true} title="String Types">
```python !! py
# Python: Just str
s1 = "Hello"
s2 = "World"
s3 = s1 + s2  # "HelloWorld"
```

```rust !! rs
// Rust: &str (string slice) and String (owned)
let s1: &str = "Hello";  // &str - immutable, fixed size
let s2: String = String::from("World");  // String - growable

let s3: String = s1.to_string() + &s2;  // "HelloWorld"

// More on strings in Module 7!
```
</UniversalEditor>

**Quick summary:**
- `&str`: String slice, immutable, borrowed
- `String`: Heap-allocated, mutable, owned

## Code Blocks and Scope

<UniversalEditor compare={true} title="Scope">
```python !! py
# Python: Function-level scope
x = 10

def my_function():
    # x is accessible here
    print(x)
    y = 5
    # y is also accessible outside in Python!

# print(y)  # This would fail, but only because y isn't defined yet
```

```rust !! rs
// Rust: Block-level scope
let x = 10;

{
    // x is accessible here
    println!("{}", x);
    let y = 5;
    println!("{}", y);
}  // y is dropped here

// println!("{}", y);  // ERROR: y not found
```
</UniversalEditor>

## Shadowing

Rust allows shadowing - declaring a new variable with the same name.

<UniversalEditor compare={true} title="Shadowing">
```python !! py
# Python: No shadowing, just reassignment
x = 5
x = "hello"  # Same variable, different type
```

```rust !! rs
// Rust: Shadowing creates a new variable
let x = 5;
let x = x + 1;  // Shadow x
let x = "hello";  // Shadow with different type!

// This is different from mut
let mut x = 5;
x = x + 1;  // Same variable, new value
// x = "hello";  // ERROR: type mismatch
```
</UniversalEditor>

**When to use shadowing:**
- Transforming a value through steps
- Changing types
- Keeping the name meaningful

## Common Patterns

<UniversalEditor compare={true} title="Variable Initialization">
```python !! py
# Python: Variables can be uninitialized
x = None
if condition:
    x = calculate()

print(x)  # Might be None
```

```rust !! rs
// Rust: Variables must be initialized
let x;  // Declared but not initialized
// println!("{}", x);  // ERROR: use of possibly uninitialized variable

if condition {
    x = calculate();
}

// Must be initialized before use
if condition {
    println!("{}", x);  // OK
}

// Better: use Option
let x = if condition {
    Some(calculate())
} else {
    None
};
```
</UniversalEditor>

## Putting It All Together

Let's write a more complex example:

<UniversalEditor compare={true} title="Complete Example">
```python !! py
def calculate_stats(numbers):
    """Calculate sum and average."""
    if not numbers:
        return 0, 0.0

    total = sum(numbers)
    average = total / len(numbers)

    return total, average

def main():
    data = [1, 2, 3, 4, 5]
    total, avg = calculate_stats(data)

    print(f"Total: {total}")
    print(f"Average: {avg:.2}")

if __name__ == "__main__":
    main()
```

```rust !! rs
fn calculate_stats(numbers: &[i32]) -> (i32, f64) {
    if numbers.is_empty() {
        return (0, 0.0);
    }

    let total: i32 = numbers.iter().sum();
    let average: f64 = total as f64 / numbers.len() as f64;

    (total, average)
}

fn main() {
    let data = vec![1, 2, 3, 4, 5];
    let (total, avg) = calculate_stats(&data);

    println!("Total: {}", total);
    println!("Average: {:.2}", avg);
}
```
</UniversalEditor>

## Summary

In this module, you learned:
- ‚úÖ Variables are immutable by default (`let` vs `let mut`)
- ‚úÖ Rust has static types with inference
- ‚úÖ Functions require explicit types
- ‚úÖ Expressions (no semicolon) vs statements (semicolon)
- ‚úÖ `println!` macro for output
- ‚úÖ Block-level scope
- ‚úÖ Shadowing for transforming values

## Key Differences from Python

1. **Immutability**: Rust defaults to immutable variables
2. **Static typing**: Types checked at compile time
3. **Explicit return**: Last expression is returned, not `return` keyword
4. **Block scope**: Variables limited to their block
5. **No truthy/falsy**: Must use explicit boolean conditions
6. **String types**: Multiple string types (`&str` vs `String`)

## Exercises

### Exercise 1: Temperature Conversion

Write a function that converts Celsius to Fahrenheit:
- Formula: `F = C * 9/5 + 32`
- Use proper types and annotations
- Print the result with 1 decimal place

<details>
<summary>Solution</summary>

```rust
fn celsius_to_fahrenheit(celsius: f64) -> f64 {
    celsius * 9.0 / 5.0 + 32.0
}

fn main() {
    let celsius = 25.0;
    let fahrenheit = celsius_to_fahrenheit(celsius);
    println!("{:.1}¬∞C = {:.1}¬∞F", celsius, fahrenheit);
}
```

</details>

### Exercise 2: Circle Properties

Calculate the area and circumference of a circle:
- Use `f64` for calculations
- Return a tuple `(area, circumference)`
- œÄ = 3.14159

<details>
<summary>Solution</summary>

```rust
fn circle_properties(radius: f64) -> (f64, f64) {
    let pi = 3.14159;
    let area = pi * radius * radius;
    let circumference = 2.0 * pi * radius;
    (area, circumference)
}

fn main() {
    let radius = 5.0;
    let (area, circumference) = circle_properties(radius);
    println!("Radius: {}", radius);
    println!("Area: {:.2}", area);
    println!("Circumference: {:.2}", circumference);
}
```

</details>

## Next Steps

Now that you understand basic syntax:
1. **[Module 2: Ownership](./module-02-ownership)** - Learn Rust's unique memory management
2. Practice with small programs
3. Experiment with different types

---

**Next:** [Module 2 - Ownership & Memory Management](./module-02-ownership) ‚Üí
