---
title: "模組 10：特徵和泛型"
description: "掌握 Rust 的特徵系統和泛型，用於編寫靈活、可重用和型別安全的程式碼"
---

# 模組 10：特徵和泛型

歡迎來到模組 10！這是 Rust 型別系統真正閃耀的地方。特徵和泛型使你能夠編寫靈活、可重用的程式碼，而不犧牲型別安全或效能。

## 學習目標

完成本模組後，你將能夠：
- 定義和實現特徵以共享行為
- 使用泛型編寫型別無關程式碼
- 理解特徵邊界和約束
- 利用標準庫特徵
- 使用特徵物件進行動態分發
- 應用高級特徵模式

## 10.1 特徵：共享行為

### Python：鴨子型別

Python 使用鴨子型別（"如果它走路像鴨子..."）：

```python
# Python - 鴨子型別
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"

def make_sound(animal):
    return animal.speak()
```

### Rust：用於共享行為的特徵

<UniversalEditor compare={true} title="定義特徵">
```python !! py
# Python - 非正式介面
class Dog:
    def speak(self):
        return "Woof!"

class Cat:
    def speak(self):
        return "Meow!"
```

```rust !! rs
// Rust - 形式化特徵定義
trait Speak {
    fn speak(&self) -> String;
}

struct Dog;
impl Speak for Dog {
    fn speak(&self) -> String {
        String::from("Woof!")
    }
}

struct Cat;
impl Speak for Cat {
    fn speak(&self) -> String {
        String::from("Meow!")
    }
}

fn make_sound(animal: &impl Speak) -> String {
    animal.speak()
}

// 使用
println!("{}", make_sound(&Dog));  // Woof!
println!("{}", make_sound(&Cat));  // Meow!
```
</UniversalEditor>

### 特徵作為參數

<UniversalEditor compare={true} title="特徵邊界語法">
```rust !! rs
// 編寫特徵邊界的三種方式

// 1. impl Trait 語法（簡單，簡潔）
fn print_speak(speaker: &impl Speak) {
    println!("{}", speaker.speak());
}

// 2. 特徵邊界語法（更明確）
fn print_speak<T: Speak>(speaker: &T) {
    println!("{}", speaker.speak());
}

// 3. where 子句（用於複雜邊界）
fn print_speak<T>(speaker: &T)
where
    T: Speak,
{
    println!("{}", speaker.speak());
}

// 多個特徵邊界
fn compare_speakers<T>(a: &T, b: &T) -> bool
where
    T: Speak + PartialEq,
{
    a.speak() == b.speak()
}
```
</UniversalEditor>

## 10.2 標準庫特徵

Rust 的標準庫提供了許多有用的特徵：

<UniversalEditor compare={true} title="常見標準特徵">
```python !! py
# Python - 特殊方法
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Point({self.x}, {self.y})"
```

```rust !! rs
// Rust - 派生和實現特徵
#[derive(Debug, PartialEq)]  // 自動實現這些特徵
struct Point {
    x: i32,
    y: i32,
}

// 自定義 Display 實現
impl std::fmt::Display for Point {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Point({}, {})", self.x, self.y)
    }
}

// 使用
let p1 = Point { x: 1, y: 2 };
let p2 = p1;  // 拷貝，不是移動！
println!("{}", p1);  // 仍然有效
println!("{:?}", p1);  // Debug 輸出
```
</UniversalEditor>

### Iterator 特徵

<UniversalEditor compare={true} title="實現 Iterator">
```python !! py
# Python - 迭代器協議
class Counter:
    def __init__(self, max):
        self.max = max
        self.current = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.current < self.max:
            value = self.current
            self.current += 1
            return value
        raise StopIteration
```

```rust !! rs
// Rust - Iterator 特徵
struct Counter {
    max: u32,
    current: u32,
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.max {
            let value = self.current;
            self.current += 1;
            Some(value)
        } else {
            None
        }
    }
}

// 迭代器方法自動可用
let sum: u32 = Counter::new(5).sum();
println!("Sum: {}", sum);  // 10
```
</UniversalEditor>

## 10.3 泛型：型別無關程式碼

### Python：動態型別

Python 動態處理不同型別：

```python
# Python - 適用於任何型別
def first(items):
    return items[0] if items else None
```

### Rust：泛型函數

<UniversalEditor compare={true} title="泛型函數">
```python !! py
# Python - 動態型別
def get_first(items):
    if not items:
        return None
    return items[0]
```

```rust !! rs
// Rust - 泛型函數
fn get_first<T>(items: &[T]) -> Option<&T> {
    if items.is_empty() {
        None
    } else {
        Some(&items[0])
    }
}

// 使用不同型別
let numbers = vec![1, 2, 3];
let strings = vec!["a", "b", "c"];

println!("{:?}", get_first(&numbers));  // Some(1)
println!("{:?}", get_first(&strings));  // Some("a")

// 多個泛型參數
fn pair<A, B>(a: A, b: B) -> (A, B) {
    (a, b)
}
```
</UniversalEditor>

### 泛型結構體

<UniversalEditor compare={true} title="泛型資料結構">
```python !! py
# Python - 適用於任何型別
class Container:
    def __init__(self, value):
        self.value = value
```

```rust !! rs
// Rust - 泛型結構體
struct Container<T> {
    value: T,
}

impl<T> Container<T> {
    fn new(value: T) -> Self {
        Container { value }
    }

    fn get(&self) -> &T {
        &self.value
    }
}

// 使用不同型別
let container1: Container<i32> = Container::new(42);
let container2: Container<&str> = Container::new("hello");
```
</UniversalEditor>

## 10.4 特徵邊界和約束

### 基本特徵邊界

<UniversalEditor compare={true} title="特徵邊界範例">
```python !! py
# Python - 鴨子型別（執行時檢查）
def process(items):
    for item in items:
        print(item)
    return len(items)
```

```rust !! rs
// Rust - 特徵邊界（編譯時檢查）
fn process<T: std::fmt::Display>(items: &[T]) -> usize {
    for item in items {
        println!("{}", item);  // 需要 Display
    }
    items.len()
}

// 多個邊界
fn clone_and_compare<T>(item: &T) -> T
where
    T: Clone + PartialEq,
{
    let cloned = item.clone();
    cloned
}
```
</UniversalEditor>

## 10.5 特徵物件：動態分發

### 靜態 vs 動態分發

<UniversalEditor compare={true} title="分發比較">
```python !! py
# Python - 始終動態分發
def process(obj):
    obj.speak()  # 執行時解析
```

```rust !! rs
// Rust - 靜態分發（預設，更快）
fn process_static<T: Speak>(speaker: T) {
    speaker.speak();  // 編譯時解析
}

// 動態分發（特徵物件）
fn process_dynamic(speaker: &dyn Speak) {
    speaker.speak();  // 執行時通過 vtable 解析
}

// 何時使用哪個
// 靜態分發：編譯時知道型別時（更快）
// 動態分發：需要不同型別的集合時
```
</UniversalEditor>

### 特徵物件實踐

<UniversalEditor compare={true} title="特徵物件集合">
```python !! py
# Python - 異質集合
animals = [Dog("Fido"), Cat("Whiskers")]
for animal in animals:
    print(animal.speak())
```

```rust !! rs
// Rust - 異質集合的特徵物件
trait Speak {
    fn speak(&self) -> String;
}

struct Dog { name: String }
impl Speak for Dog {
    fn speak(&self) -> String {
        format!("{} says Woof!", self.name)
    }
}

struct Cat { name: String }
impl Speak for Cat {
    fn speak(&self) -> String {
        format!("{} says Meow!", self.name)
    }
}

// 特徵物件集合
let dog = Dog { name: String::from("Fido") };
let cat = Cat { name: String::from("Whiskers") };

// 必須使用引用 (&dyn Speak) 或 Box<dyn Speak>
let animals: Vec<Box<dyn Speak>> = vec![
    Box::new(dog),
    Box::new(cat),
];

for animal in animals.iter() {
    println!("{}", animal.speak());
}
```
</UniversalEditor>

## 10.6 高級特徵模式

### 關聯型別

<UniversalEditor compare={true} title="關聯型別">
```rust !! rs
// Rust - 關聯型別（比泛型更精確）
trait Iterator {
    type Item;  // 關聯型別

    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter;
impl Iterator for Counter {
    type Item = i32;  // 指定關聯型別

    fn next(&mut self) -> Option<Self::Item> {
        Some(42)
    }
}
```
</UniversalEditor>

### 預設實現

<UniversalEditor compare={true} title="預設特徵方法">
```rust !! rs
// 特徵可以提供預設實現
trait Animal {
    fn speak(&self) -> String {
        String::from("Unknown sound")
    }

    fn intro(&self) -> String {
        format!("I say: {}", self.speak())
    }
}

struct Dog;
impl Animal for Dog {
    fn speak(&self) -> String {
        String::from("Woof!")
    }
    // intro() 使用預設實現
}

// 使用
let dog = Dog;
println!("{}", dog.intro());  // I say: Woof!
```
</UniversalEditor>

### 超特徵

<UniversalEditor compare={true} title="特徵繼承">
```rust !! rs
// Rust - 超特徵（特徵繼承）
trait Animal {
    fn name(&self) -> &str;
}

trait Pet: Animal {  // Pet 要求 Animal
    fn cuddle(&self) {
        println!("{} is being cuddled", self.name());
    }
}

struct Dog { name: String }

impl Animal for Dog {
    fn name(&self) -> &str {
        &self.name
    }
}

impl Pet for Dog {
    // cuddle() 使用預設，也可以覆蓋
}
```
</UniversalEditor>

## 常見陷阱

### 陷阱 1：孤兒規則

```rust
// 不要：在外部型別上實現外部特徵
// impl Display for Vec<i32> { }  // 錯誤！

// 應該：使用 newtype 模式
struct MyVec(Vec<i32>);

impl std::fmt::Display for MyVec {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{:?}", self.0)
    }
}
```

### 陷阱 2：過度使用特徵物件

```rust
// 不要：靜態分發可行時使用特徵物件
fn process(items: &[&dyn Speak]) { }  // 更慢

// 應該：盡可能使用泛型
fn process<T: Speak>(items: &[T]) { }  // 更快
```

## 最佳實踐

1. **優先使用靜態分發** - 盡可能使用泛型而不是特徵物件
2. **保持特徵聚焦** - 小型、內聚的特徵比大型特徵更好
3. **提供預設實現** - 使特徵更容易實現
4. **使用標準庫特徵** - 不要重新發明 Display、Debug、Clone 等
5. **考慮物件安全** - 決定特徵是否應該可用作特徵物件
6. **記錄特徵契約** - 清楚地記錄實現者必須提供什麼

## 總結

在本模組中，我們涵蓋了：

- **特徵**：具有形式化契約的共享行為
- **泛型**：型別安全的型別無關程式碼
- **特徵邊界**：泛型型別的編譯時約束
- **標準庫特徵**：Display、Debug、Clone、Iterator 等
- **特徵物件**：執行時多態的動態分發
- **高級模式**：關聯型別、預設實現、超特徵

關鍵要點：
- 特徵提供零成本抽象的共享行為
- 泛型實現靈活、型別安全的程式碼
- 優先靜態分發，需要時使用特徵物件
- 標準庫提供許多有用的特徵
- 特徵邊界實現強大的編譯時多態
- Rust 的型別系統同時實現靈活性和效能

## 練習

創建一個通用資料處理庫：
1. 定義帶有 `process` 方法的 `Processable` 特徵
2. 為多個型別實現它
3. 使用泛型處理集合
4. 演示靜態和動態分發
5. 使用特徵邊界約束功能

<details>
<summary>檢視解決方案</summary>

```rust
use std::fmt::Display;

trait Processable {
    type Output;
    fn process(&self) -> Self::Output;
}

#[derive(Debug)]
struct Number(i32);

impl Processable for Number {
    type Output = String;

    fn process(&self) -> Self::Output {
        format!("Doubled: {}", self.0 * 2)
    }
}

fn process_item<T: Processable>(item: &T) -> String {
    format!("{:?}", item.process())
}

fn main() {
    let num = Number(42);
    println!("{}", process_item(&num));  // "Doubled: 84"
}
```

</details>

恭喜完成模組 10！你現在對 Rust 的特徵和泛型系統有了紮實的理解。這些功能使你能夠編寫靈活、可重用和高效能的型別安全程式碼。繼續通過實際項目練習以掌握這些概念！
