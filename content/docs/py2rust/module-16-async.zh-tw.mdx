---
title: "模組 16: 非同步程式設計"
description: "掌握 Rust 中的非同步程式設計,包括 async/await、tokio 和 Future trait,並與 Python 的 asyncio 進行對比"
---

# 模組 16: 非同步程式設計

## 學習目標

完成本模組後,你將能夠:
- 理解 Rust 的 async/await 語法及其與 Python asyncio 的區別
- 使用 Future trait 和非同步執行時
- 使用 Tokio 建構實際非同步應用
- 處理非同步流和通道
- 避免常見的非同步程式設計陷阱

## Rust 非同步簡介

Python 的 `asyncio` 使用帶有 `async`/`await` 語法的協程。Rust 有類似的語法,但底層機制完全不同。

### 關鍵區別

<UniversalEditor compare={true} title="非同步函式宣告">
```python !! py
# Python - 協程是隱式的
import asyncio

async def fetch_data(url: str) -> dict:
    await asyncio.sleep(1)  # 模擬網路延遲
    return {"status": "ok", "data": [1, 2, 3]}

# Python 協程啟動時即暫停,需要事件循環
async def main():
    result = await fetch_data("https://api.example.com")
    print(result)

asyncio.run(main())
```

```rust !! rs
// Rust - Future 是顯式的且是惰性的
use tokio::time::{sleep, Duration};

async fn fetch_data(url: &str) -> serde_json::Value {
    // Tokio 提供非同步睡眠
    sleep(Duration::from_secs(1)).await;
    json!({"status": "ok", "data": [1, 2, 3]})
}

// Rust 需要在入口點顯式執行時
#[tokio::main]
async fn main() {
    let result = fetch_data("https://api.example.com").await;
    println!("{}", result);
}
```
</UniversalEditor>

**核心洞察:** 在 Python 中,`async def` 建立一個暫停的協程物件。在 Rust 中,`async fn` 返回一個 `Future`,在被輪詢之前什麼都不做。

## Future Trait

理解 `Future` trait 對於掌握 Rust 非同步程式設計至關重要。

<UniversalEditor compare={true} title="Future Trait vs Python 協程">
```python !! py
# Python - 事件循環管理協程
import asyncio

async def compute():
    print("Computing...")
    await asyncio.sleep(0.1)
    return 42

# 事件循環處理一切
coro = compute()  # 返回協程物件
print(type(coro))  # <class 'coroutine'>

result = asyncio.run(coro)
```

```rust !! rs
// Rust - Future trait 需要顯式輪詢
use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};

// 簡化的 Future trait(實際的 std::future::Future)
pub trait SimpleFuture {
    type Output;
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output>;
}

// async fn 脫糖為實作 Future 的型別
async fn compute() -> i32 {
    println!("Computing...");
    tokio::time::sleep(Duration::from_millis(100)).await;
    42
}

// 執行時處理輪詢
#[tokio::main]
async fn main() {
    let future = compute();  // 返回 Future
    let result = future.await;  // 執行時輪詢直到就緒
    println!("{}", result);
}
```
</UniversalEditor>

## 非同步執行時: Tokio

Tokio 是 Rust 中最受歡迎的非同步執行時,類似於 asyncio 在 Python 中的地位。

### 基本 Tokio 使用

<UniversalEditor compare={true} title="任務產生">
```python !! py
# Python - asyncio 任務
import asyncio

async def worker(name: str, duration: int):
    print(f"{name} started")
    await asyncio.sleep(duration)
    print(f"{name} completed after {duration}s")

async def main():
    # 建立並發執行的任務
    task1 = asyncio.create_task(worker("Task 1", 2))
    task2 = asyncio.create_task(worker("Task 2", 1))

    # 等待兩者完成
    await asyncio.gather(task1, task2)

asyncio.run(main())
```

```rust !! rs
// Rust - Tokio 任務
use tokio::time::{sleep, Duration};

async fn worker(name: &str, duration: u64) {
    println!("{} started", name);
    sleep(Duration::from_secs(duration)).await;
    println!("{} completed after {}s", name, duration);
}

#[tokio::main]
async fn main() {
    // 產生並發執行的任務
    let task1 = tokio::spawn(worker("Task 1", 2));
    let task2 = tokio::spawn(worker("Task 2", 1));

    // 等待兩者完成
    let (result1, result2) = tokio::join!(task1, task2);

    // 處理結果(任務返回 Result)
    result1.unwrap();
    result2.unwrap();
}
```
</UniversalEditor>

### 非同步通道

<UniversalEditor compare={true} title="非同步通訊通道">
```python !! py
# Python - asyncio 佇列
import asyncio

async def producer(queue: asyncio.Queue):
    for i in range(5):
        await asyncio.sleep(0.1)
        await queue.put(i)
        print(f"Produced: {i}")
    await queue.put(None)  # 發送結束信號

async def consumer(queue: asyncio.Queue):
    while True:
        item = await queue.get()
        if item is None:
            break
        print(f"Consumed: {item}")
        queue.task_done()

async def main():
    queue = asyncio.Queue(maxsize=10)
    producer_task = asyncio.create_task(producer(queue))
    consumer_task = asyncio.create_task(consumer(queue))
    await asyncio.gather(producer_task, consumer_task)

asyncio.run(main())
```

```rust !! rs
// Rust - Tokio 通道
use tokio::sync::mpsc;
use tokio::time::{sleep, Duration};

async fn producer(mut tx: mpsc::Sender<i32>) {
    for i in 0..5 {
        sleep(Duration::from_millis(100)).await;
        tx.send(i).await.unwrap();
        println!("Produced: {}", i);
    }
    // 丟棄 sender 以信號完成
}

async fn consumer(mut rx: mpsc::Receiver<i32>) {
    while let Some(item) = rx.recv().await {
        println!("Consumed: {}", item);
    }
}

#[tokio::main]
async fn main() {
    let (tx, rx) = mpsc::channel(10);

    let producer_task = tokio::spawn(producer(tx));
    let consumer_task = tokio::spawn(consumer(rx));

    tokio::join!(producer_task, consumer_task);
}
```
</UniversalEditor>

## 非同步流

Rust 的非同步流類似於 Python 的非同步產生器。

<UniversalEditor compare={true} title="非同步迭代">
```python !! py
# Python - 非同步產生器
import asyncio

async def countdown(n: int):
    """非同步產生器產生值"""
    for i in range(n, 0, -1):
        await asyncio.sleep(0.1)
        yield i

async def main():
    async for value in countdown(5):
        print(f"Count: {value}")

asyncio.run(main())
```

```rust !! rs
// Rust - 使用 futures::stream 的非同步流
use futures::stream::{self, StreamExt};
use tokio::time::{sleep, Duration};

async fn countdown(n: i32) -> impl Stream<Item = i32> {
    // 從迭代器建立帶延遲的流
    stream::iter((1..=n).rev())
        .then(|n| async move {
            sleep(Duration::from_millis(100)).await;
            n
        })
}

#[tokio::main]
async fn main() {
    let mut stream = countdown(5).await;

    while let Some(value) = stream.next().await {
        println!("Count: {}", value);
    }
}
```
</UniversalEditor>

## 非同步 HTTP 客戶端

<UniversalEditor compare={true} title="HTTP 請求">
```python !! py
# Python - aiohttp 客戶端
import aiohttp
import asyncio

async def fetch_url(session: aiohttp.ClientSession, url: str) -> str:
    async with session.get(url) as response:
        return await response.text()

async def main():
    urls = [
        "https://httpbin.org/get",
        "https://httpbin.org/delay/1",
        "https://httpbin.org/json",
    ]

    async with aiohttp.ClientSession() as session:
        tasks = [fetch_url(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        for result in results:
            print(f"Fetched {len(result)} bytes")

asyncio.run(main())
```

```rust !! rs
// Rust - Reqwest 非同步客戶端
use reqwest;
use futures::future::join_all;

async fn fetch_url(url: &str) -> Result<String, reqwest::Error> {
    let response = reqwest::get(url).await?;
    let text = response.text().await?;
    Ok(text)
}

#[tokio::main]
async fn main() {
    let urls = [
        "https://httpbin.org/get",
        "https://httpbin.org/delay/1",
        "https://httpbin.org/json",
    ];

    let fetch_futures: Vec<_> = urls.iter()
        .map(|&url| fetch_url(url))
        .collect();

    let results = join_all(fetch_futures).await;

    for result in results {
        match result {
            Ok(text) => println!("Fetched {} bytes", text.len()),
            Err(e) => println!("Error: {}", e),
        }
    }
}
```
</UniversalEditor>

## 非同步檔案 I/O

<UniversalEditor compare={true} title="檔案操作">
```python !! py
# Python - aiofiles 非同步檔案操作
import aiofiles
import asyncio

async def process_file(filename: str):
    async with aiofiles.open(filename, 'r') as f:
        content = await f.read()
        lines = content.splitlines()
        print(f"Read {len(lines)} lines from {filename}")

async def main():
    await asyncio.gather(
        process_file('file1.txt'),
        process_file('file2.txt'),
    )

asyncio.run(main())
```

```rust !! rs
// Rust - Tokio fs
use tokio::fs::File;
use tokio::io::{AsyncBufReadExt, BufReader};

async fn process_file(filename: &str) -> Result<(), Box<dyn std::error::Error>> {
    let file = File::open(filename).await?;
    let reader = BufReader::new(file);
    let mut lines = reader.lines();
    let mut count = 0;

    while let Some(_line) = lines.next_line().await? {
        count += 1;
    }

    println!("Read {} lines from {}", count, filename);
    Ok(())
}

#[tokio::main]
async fn main() {
    let results = tokio::join!(
        process_file("file1.txt"),
        process_file("file2.txt"),
    );

    results.0.unwrap();
    results.1.unwrap();
}
```
</UniversalEditor>

## 非同步中的錯誤處理

<UniversalEditor compare={true} title="非同步錯誤處理">
```python !! py
# Python - 非同步中的例外處理
import asyncio

async def fetch_data(url: str) -> dict:
    if "error" in url:
        raise ValueError("Invalid URL")
    await asyncio.sleep(0.1)
    return {"data": "success"}

async def main():
    try:
        result = await fetch_data("https://error.api")
    except ValueError as e:
        print(f"Caught error: {e}")
    else:
        print(result)

asyncio.run(main())
```

```rust !! rs
// Rust - 非同步中的 Result 型別
use tokio::time::{sleep, Duration};

async fn fetch_data(url: &str) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
    if url.contains("error") {
        Err("Invalid URL".into())
    } else {
        sleep(Duration::from_millis(100)).await;
        Ok(json!({"data": "success"}))
    }
}

#[tokio::main]
async fn main() {
    match fetch_data("https://error.api").await {
        Ok(result) => println!("{}", result),
        Err(e) => println!("Caught error: {}", e),
    }
}
```
</UniversalEditor>

## 常見非同步陷阱

### 1. 在非同步上下文中阻塞

<UniversalEditor compare={true} title="避免阻塞操作">
```python !! py
# Python - 非同步中的阻塞(不良實踐)
import asyncio
import time

async def bad_blocking():
    time.sleep(2)  # 阻塞整個事件循環!
    print("Done")

async def good_nonblocking():
    await asyncio.sleep(2)  # 讓出控制權
    print("Done")
```

```rust !! rs
// Rust - 對 CPU 密集型工作使用 spawn_blocking
use tokio::task::spawn_blocking;
use tokio::time::{sleep, Duration};

async fn bad_blocking() {
    std::thread::sleep(Duration::from_secs(2)); // 阻塞執行時!
    println!("Done");
}

async fn good_nonblocking() {
    sleep(Duration::from_secs(2)).await; // 讓出控制
    println!("Done");
}

async fn good_cpu_bound() {
    // 將阻塞工作卸載到線程池
    let result = spawn_blocking(|| {
        // CPU 密集型工作在這裡
        42
    }).await.unwrap();

    println!("Result: {}", result);
}

#[tokio::main]
async fn main() {
    good_nonblocking().await;
    good_cpu_bound().await;
}
```
</UniversalEditor>

### 2. 取消

<UniversalEditor compare={true} title="非同步取消">
```python !! py
# Python - 任務取消
import asyncio

async def cancellable_task():
    try:
        print("Task started")
        await asyncio.sleep(5)
        print("Task completed")
    except asyncio.CancelledError:
        print("Task was cancelled")
        raise

async def main():
    task = asyncio.create_task(cancellable_task())
    await asyncio.sleep(1)
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print("Main caught cancellation")

asyncio.run(main())
```

```rust !! rs
// Rust - 使用 tokio::select! 的協作式取消
use tokio::time::{sleep, Duration, timeout};
use tokio::signal::ctrl_c;

async fn cancellable_task() -> Result<(), Box<dyn std::error::Error>> {
    println!("Task started");

    // 使用 select! 等待多個 future
    tokio::select! {
        _ = sleep(Duration::from_secs(5)) => {
            println!("Task completed");
        }
        _ = ctrl_c() => {
            println!("Task received Ctrl+C");
            return Err("Cancelled".into());
        }
    }

    Ok(())
}

#[tokio::main]
async fn main() {
    // 超時後取消
    match timeout(Duration::from_secs(1), cancellable_task()).await {
        Ok(Ok(())) => println!("Task succeeded"),
        Ok(Err(e)) => println!("Task error: {}", e),
        Err(_) => println!("Task timed out"),
    }
}
```
</UniversalEditor>

## 實戰示例: 網頁爬蟲

<UniversalEditor compare={true} title="並發網頁爬蟲">
```python !! py
# Python - 非同步網頁爬蟲
import asyncio
import aiohttp
from bs4 import BeautifulSoup

async def scrape_page(session: aiohttp.ClientSession, url: str) -> dict:
    async with session.get(url) as response:
        html = await response.text()
        soup = BeautifulSoup(html, 'html.parser')
        return {
            'url': url,
            'title': soup.title.string if soup.title else 'No title',
            'links': len(soup.find_all('a'))
        }

async def main(urls: list[str]):
    async with aiohttp.ClientSession() as session:
        tasks = [scrape_page(session, url) for url in urls]
        results = await asyncio.gather(*tasks)
        return results

if __name__ == "__main__":
    urls = [
        "https://example.com",
        "https://example.org",
        "https://example.net",
    ]
    results = asyncio.run(main(urls))
    for result in results:
        print(f"{result['url']}: {result['title']} ({result['links']} links)")
```

```rust !! rs
// Rust - 並發網頁爬蟲
use reqwest::Client;
use scraper::{Html, Selector};
use futures::future::join_all;

struct ScrapedData {
    url: String,
    title: String,
    links: usize,
}

async fn scrape_page(client: &Client, url: &str) -> Result<ScrapedData, Box<dyn std::error::Error>> {
    let response = client.get(url).send().await?;
    let html = response.text().await?;

    let document = Html::parse_document(&html);
    let title_selector = Selector::parse("title").unwrap();
    let link_selector = Selector::parse("a").unwrap();

    let title = document
        .select(&title_selector)
        .next()
        .map(|t| t.text().collect::<String>())
        .unwrap_or_else(|| "No title".to_string());

    let links = document.select(&link_selector).count();

    Ok(ScrapedData {
        url: url.to_string(),
        title,
        links,
    })
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let urls = [
        "https://example.com",
        "https://example.org",
        "https://example.net",
    ];

    let client = Client::new();
    let scrape_futures: Vec<_> = urls.iter()
        .map(|&url| scrape_page(&client, url))
        .collect();

    let results = join_all(scrape_futures).await;

    for result in results {
        match result {
            Ok(data) => println!("{}: {} ({} links)", data.url, data.title, data.links),
            Err(e) => println!("Error scraping: {}", e),
        }
    }

    Ok(())
}
```
</UniversalEditor>

## 關鍵要點

### Python 中的非同步
- 基於協程和事件循環
- 執行時隱式調度
- 易於使用但有執行時開銷
- 使用 `async`/`await` 語法

### Rust 中的非同步
- 基於 Future 的零成本抽象
- 需要顯式執行時(Tokio)
- 編譯器強制非同步程式碼安全
- 不使用非同步時無執行時開銷
- 非同步入口點需要 `#[tokio::main]`

### 何時使用非同步
- **使用非同步** 處理 I/O 密集型操作(網路、檔案)
- **使用同步** 處理 CPU 密集型任務(或使用 `spawn_blocking`)
- **避免非同步** 用於簡單的順序程式碼
- **優先使用通道** 而非共享狀態

## 練習

1. 實作一個並發檔案下載器,並行下載多個檔案
2. 使用非同步通道建構聊天伺服器
3. 建立非同步資料庫連線池
4. 實作指數退避的重試邏輯
5. 建構帶速率限制的並發網頁爬蟲

## 下一模組

在模組 17 中,我們將探索 **Rust 測試**,包括單元測試、整合測試、基於屬性的測試和模擬策略。
