---
title: "模組 19: 效能優化"
description: "掌握 Rust 效能優化,包括零成本抽象、迭代器、基準測試和效能分析"
---

# 模組 19: 效能優化

## 學習目標

完成本模組後,你將能夠:
- 理解零成本抽象
- 使用迭代器高效處理資料
- 使用 Criterion 編寫基準測試
- 分析 Rust 應用程式
- 優化記憶體分配

## 零成本抽象

Rust 的零成本抽象意味著高級結構不會帶來效能損失。

<UniversalEditor compare={true} title="抽象成本">
```python !! py
# Python - 抽象有執行時開銷
def process_list(items):
    return [x * 2 for x in items if x > 0]
```

```rust !! rs
// Rust - 抽象編譯為高效的機器碼
fn process_list(items: &[i32]) -> Vec<i32> {
    items.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .collect()
}

// 這編譯成的程式碼與手寫迴圈一樣高效
```
</UniversalEditor>

**核心洞察:** Rust 編譯器優化迭代器鏈,使其與手寫迴圈一樣快。

## 使用 Criterion 基準測試

<UniversalEditor compare={true} title="基準測試設置">
```python !! py
# Python - pytest-benchmark
import pytest

def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

@pytest.mark.benchmark(group="fib")
def test_fib_10(benchmark):
    result = benchmark(fibonacci, 10)
    assert result == 55
```

```rust !! rs
// Rust - Criterion 基準測試
// Cargo.toml:
// [dev-dependencies]
// criterion = "0.5"

fn fibonacci(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

// benches/fibonacci.rs:
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_fibonacci(c: &mut Criterion) {
    c.bench_function("fib 10", |b| {
        b.iter(|| fibonacci(black_box(10)))
    });
}

criterion_group!(benches, benchmark_fibonacci);
criterion_main!(benches);

// 執行: cargo bench
```
</UniversalEditor>

## 效能技巧總結

### 記憶體
- 大小已知時使用 `Vec::with_capacity()`
- 函式參數優先使用 `&str` 而非 `String`
- 小型固定大小資料使用棧陣列 `[T; N]`

### 演算法
- 選擇合適的資料結構
- 使用迭代器進行惰性求值
- 考慮使用 Rayon 平行處理

### Rust 效能優勢
- 無垃圾回收暫停
- 可預測的效能
- 零成本抽象
- 手動記憶體控制

## 練習

1. 基準測試不同的排序演算法
2. 使用迭代器優化資料處理管道
3. 分析應用程式並優化瓶頸

## 下一模組

在模組 20(最後一個模組)中,我們將建構一個**完整的 REST API 專案**。
