---
title: "Module 0: Introduction & Environment Setup"
description: "Get started with Rust by understanding why it matters, installing the toolchain, and writing your first Rust program."
---

# Module 0: Introduction & Environment Setup

Welcome to your Rust journey! In this module, you'll learn why Rust is worth your time, install the Rust toolchain, and write your first Rust program.

## Learning Objectives

By the end of this module, you'll be able to:
- ✅ Understand what makes Rust unique and valuable
- ✅ Install Rust and set up your development environment
- ✅ Use Cargo, Rust's package manager and build tool
- ✅ Write and run your first Rust program
- ✅ Navigate the Rust ecosystem and resources

## Why Rust? A Python Developer's Perspective

As a Python developer, you might wonder: "Why learn another language?" Let's explore what Rust brings to the table.

<UniversalEditor compare={true} title="Development Experience: Python vs Rust">
```python !! py
# Python: Quick to write, slower to run
def process_data(items):
    result = []
    for item in items:
        result.append(item * 2)
    return result

# Runs ~100x slower than optimized Rust
# But took 5 seconds to write
```

```rust !! rs
// Rust: More verbose, blazingly fast
fn process_data(items: &[i32]) -> Vec<i32> {
    items.iter().map(|x| x * 2).collect()
}

// Runs at C/C++ speed
// Takes a bit longer to write initially
// But compiler catches bugs before runtime
```
</UniversalEditor>

### The Rust Value Proposition

#### 1. Performance Without Sacrificing Safety

Python uses a Global Interpreter Lock (GIL) and garbage collection, which limit performance and make true parallelism challenging. Rust gives you:
- **C/C++ performance** without the memory safety risks
- **True parallelism** through fearless concurrency
- **Predictable performance** with no garbage collection pauses

<UniversalEditor compare={true} title="Performance Comparison: Fibonacci">
```python !! py
# Python: ~2.5 seconds for fib(35)
import time

def fib(n):
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

start = time.time()
print(fib(35))
print(f"Time: {time.time() - start:.2f}s")
```

```rust !! rs
// Rust: ~0.7 seconds for fib(35) (3.5x faster)
use std::time::Instant;

fn fib(n: u64) -> u64 {
    match n {
        0 => 0,
        1 => 1,
        _ => fib(n-1) + fib(n-2),
    }
}

fn main() {
    let start = Instant::now();
    println!("{}", fib(35));
    println!("Time: {:?}", start.elapsed());
}
```
</UniversalEditor>

#### 2. Memory Safety at Compile Time

This is Rust's superpower. The Rust compiler prevents entire classes of bugs:
- **Null pointer dereferences** → Rust has no null
- **Dangling pointers** → Borrow checker prevents invalid references
- **Data races** → Type system prevents concurrent data access issues
- **Buffer overflows** → Bounds checking by default

In Python, these would be runtime errors. In Rust, they're **compile-time errors** - you find them before your code ever runs.

#### 3. Modern Tooling

Cargo is one of the best package managers in existence:

<UniversalEditor compare={true} title="Package Management: pip vs Cargo">
```python !! py
# Python: Multiple tools, scattered configuration
# Create project
mkdir myproject
cd myproject
python -m venv venv
source venv/bin/activate

# Add dependencies (manual editing)
echo "numpy==1.24.0" >> requirements.txt
pip install -r requirements.txt

# Run tests (needs separate test framework)
pytest

# Building (for distribution)
python setup.py sdist bdist_wheel
```

```rust !! rs
// Rust: Single unified tool
// Create project
cargo new myproject
cd myproject

// Add dependencies
cargo add serde

// Run tests (built-in)
cargo test

// Build optimized binary
cargo build --release
```
</UniversalEditor>

#### 4. Growing Ecosystem

Rust has a rapidly growing ecosystem with excellent crates:
- **Web**: Actix-web, Axum, Rocket
- **Async**: Tokio, async-std
- **Serialization**: Serde (JSON, YAML, etc.)
- **Database**: Diesel, SQLx
- **CLI**: Clap, structopt

Many Python libraries now have Rust acceleration (e.g., PyO3 for Python bindings).

## Installing Rust

### Step 1: Install rustup (Rust Toolchain Installer)

**macOS / Linux:**
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

**Windows:**
Download and run `rustup-init.exe` from [rustup.rs](https://rustup.rs/)

The installer will:
1. Install Rust compiler (`rustc`)
2. Install Cargo (package manager and build tool)
3. Add Rust to your system PATH
4. Install stable Rust toolchain

**Verify installation:**
```bash
rustc --version
cargo --version
```

You should see something like:
```
rustc 1.75.0 (82e1608df 2023-12-21)
cargo 1.75.0 (1d8b05cdd 2023-11-20)
```

### Step 2: Install a Code Editor

**Recommended: VS Code + rust-analyzer**

1. Install [VS Code](https://code.visualstudio.com/)
2. Install the `rust-analyzer` extension (NOT "Rust" - use rust-analyzer)
3. Install `CodeLLDB` for debugging support

**Alternative editors:**
- IntelliJ IDEA with Rust plugin
- Vim/Neovim with rust-tools.nvim
- Emacs with rust-mode

rust-analyzer provides:
- ✅ Autocompletion
- ✅ Inline type hints
- ✅ Go to definition
- ✅ Inline error messages
- ✅ Code actions (quick fixes)

## Your First Rust Program

Let's create and run your first Rust project!

### Creating a New Project

```bash
cargo new hello_rust
cd hello_rust
```

Cargo creates:
```
hello_rust/
├── Cargo.toml      # Project metadata and dependencies
└── src/
    └── main.rs     # Your source code
```

### Understanding the Project Structure

**`Cargo.toml`** - Project manifest:
```toml
[package]
name = "hello_rust"
version = "0.1.0"
edition = "2021"

[dependencies]
# External crates go here
```

**`src/main.rs`** - Entry point:
```rust
fn main() {
    println!("Hello, world!");
}
```

### Running Your Project

```bash
cargo run
```

You should see:
```
Compiling hello_rust v0.1.0
Finished dev profile [unoptimized + debuginfo] target(s)
Running `target/debug/hello_rust`
Hello, world!
```

## Understanding the Code

Let's break down what's happening:

<UniversalEditor compare={true} title="Hello World: Python vs Rust">
```python !! py
# Python: Script-style execution
# No main function required - just execute top to bottom

def main():
    print("Hello, world!")

if __name__ == "__main__":
    main()

# Actually, in Python you'd usually just:
print("Hello, world!")
```

```rust !! rs
// Rust: Compiled, with explicit entry point
// Every Rust program needs a main() function

fn main() {  // fn declares a function
    println!("Hello, world!");  // ! indicates a macro
}

// Key points:
// - fn: function keyword
// - main(): entry point (like if __name__ == "__main__")
// - {}: function body
// - println!: macro call (note the !)
// - ;: statement terminator
```
</UniversalEditor>

### Key Rust Concepts (Preview)

1. **`fn main()`**: Entry point function
2. **`println!`**: It's a **macro** (note the `!`), not a function
3. **`;`**: Statements must end with semicolons
4. **`{}`**: Blocks for scoping

## Cargo Commands Deep Dive

Cargo is your Swiss Army knife for Rust development:

### Build Commands

```bash
# Build for development (unoptimized, fast compile)
cargo build

# Build for release (optimized, slow compile, fast binary)
cargo build --release

# Run immediately (builds if necessary)
cargo run

# Run release version
cargo run --release
```

### Development Commands

```bash
# Check code without building (fastest)
cargo check

# Run tests
cargo test

# Generate documentation
cargo doc --open

# Start new project (binary)
cargo new project_name

# Start new project (library)
cargo new --lib project_name

# Update dependencies
cargo update
```

### Useful Cargo Flags

```bash
# Show verbose output
cargo build --verbose

# Compile only specific target
cargo build --bin hello_rust

# Compile specific example
cargo build --example my_example

# Run with custom arguments
cargo run -- --some-arg
```

## Comparing Python and Rust Workflows

<UniversalEditor compare={true} title="Project Structure Comparison">
```python !! py
# Python project structure
myproject/
├── src/
│   └── mymodule.py
├── tests/
│   └── test_mymodule.py
├── requirements.txt
├── setup.py or pyproject.toml
└── README.md

# Install dependencies
pip install -r requirements.txt

# Run module
python -m src.mymodule

# Run tests
pytest

# Package
python setup.py sdist
```

```rust !! rs
// Rust project structure
myproject/
├── src/
│   ├── main.rs       # Binary entry point
│   └── lib.rs        # Library entry point (if --lib)
├── tests/
│   └── integration_test.rs
├── examples/
│   └── example.rs
├── Cargo.toml        # All dependencies here
└── README.md

// Build and run
cargo build
cargo run
cargo test

// Everything managed by Cargo
```
</UniversalEditor>

## Setting Up Development Environment

### Recommended VS Code Extensions

1. **rust-analyzer** (Required)
   - Official language server
   - Provides IDE features

2. **CodeLLDB**
   - Debugging support

3. **Even Better TOML**
   - Syntax highlighting for Cargo.toml

4. **Error Lens**
   - Inline error display

### VS Code Settings

Create `.vscode/settings.json`:
```json
{
    "rust-analyzer.checkOnSave.command": "clippy",
    "rust-analyzer.cargo.features": "all",
    "editor.formatOnSave": true,
    "rust-analyzer.rustfmt.extraArgs": ["+nightly"]
}
```

## The Rust Compilation Model

Understanding how Rust compiles helps you work with it effectively.

<UniversalEditor compare={true} title="Execution Model: Python vs Rust">
```python !! py
# Python: Interpreted
# Source → Bytecode (.pyc) → Python VM → Execute

def add(a, b):
    return a + b

# Executes line by line
# Type errors happen at runtime
# No compilation step (technically bytecode compilation)
```

```rust !! rs
// Rust: Compiled ahead-of-time
// Source → LLVM IR → Machine Code → Execute

fn add(a: i32, b: i32) -> i32 {
    a + b
}

// Fully compiled before execution
// Type errors caught at compile time
// Produces native binary executable
```
</UniversalEditor>

### The Compilation Process

1. **Parsing**: Rust source → AST (Abstract Syntax Tree)
2. **HIR lowering**: AST → HIR (High-level IR)
3. **MIR lowering**: HIR → MIR (Mid-level IR)
4. **LLVM**: MIR → LLVM IR → Machine code
5. **Linking**: Machine code + libraries → Executable

This is why `cargo build` takes longer than `python script.py`, but the resulting binary runs much faster.

## Basic Rust Syntax (Quick Preview)

Let's look at some basic Rust syntax compared to Python:

### Variables

<UniversalEditor compare={true} title="Variables: Python vs Rust">
```python !! py
# Python: Dynamic typing, mutable by default
name = "Alice"       # string
age = 25             # int
height = 5.6         # float

# Can reassign with different type
name = 42  # This works!

# Everything is mutable
age = 26
```

```rust !! rs
// Rust: Static typing, immutable by default
let name = "Alice";   // &str
let age: i32 = 25;    // i32 (explicit type)
let height = 5.6;     // f64 (inferred)

// Cannot reassign with different type
// name = 42;  // ERROR: type mismatch

// Variables are immutable by default
// age = 26;  // ERROR: cannot assign twice

// Use mut for mutable variables
let mut age = 25;
age = 26;  // OK
```
</UniversalEditor>

### Functions

<UniversalEditor compare={true} title="Functions: Python vs Rust">
```python !! py
# Python: Dynamic typing, optional return
def greet(name, age):
    message = f"Hello, {name}!"
    print(message)
    return age * 2

# Call
result = greet("Alice", 25)
```

```rust !! rs
// Rust: Static typing, explicit return type
fn greet(name: &str, age: i32) -> i32 {
    let message = format!("Hello, {}!", name);
    println!("{}", message);
    age * 2  // No semicolon = return value
}

// Call
let result = greet("Alice", 25);
```
</UniversalEditor>

## Rust Editions

Rust has "editions" that allow incremental improvements:

- **Rust 2015**: Original edition
- **Rust 2018**: Major improvements (modules, async prep)
- **Rust 2021**: Current edition (default)

New projects should use Rust 2021. All editions work together - you can use Rust 2015 crates in a Rust 2021 project.

## The Rust Community

Rust has one of the friendliest programming communities:

### Official Resources
- **The Rust Programming Language**: [doc.rust-lang.org/book](https://doc.rust-lang.org/book/) (The "Book")
- **Rust by Example**: [doc.rust-lang.org/rust-by-example](https://doc.rust-lang.org/rust-by-example/)
- **Rust Standard Library**: [doc.rust-lang.org/std](https://doc.rust-lang.org/std/)

### Community Resources
- **Rust Users Forum**: [users.rust-lang.org](https://users.rust-lang.org/)
- **Rust Discord**: [discord.gg/rust-lang](https://discord.gg/rust-lang)
- **Reddit**: r/rust
- **Crates.io**: [crates.io](https://crates.io/) (Package registry)

## Common First-Time Challenges

### 1. The Borrow Checker

You'll encounter this error often:
```rust
let s1 = String::from("hello");
let s2 = s1;
// println!("{}", s1);  // ERROR: value borrowed after move
```

This is Rust's ownership system preventing use-after-move. We'll cover this in detail in Module 2.

### 2. Verbosity

Rust is more verbose than Python:
```rust
// Rust: Explicit types everywhere
fn process(items: Vec<i32>) -> Vec<i32> {
    items.into_iter().map(|x| x * 2).collect()
}
```

This verbosity buys you safety and performance. You'll learn to appreciate it.

### 3. Compilation Time

Rust compiles slower than Python runs. Tips:
- Use `cargo check` for quick validation
- Use `cargo build` only when needed
- The compiler is catching bugs you'd find at runtime in Python

## Your Second Rust Program

Let's write something more interesting:

<UniversalEditor compare={true} title="Fibonacci: Python vs Rust">
```python !! py
def fibonacci(n):
    """Calculate the nth Fibonacci number."""
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

if __name__ == "__main__":
    n = 10
    result = fibonacci(n)
    print(f"Fibonacci({n}) = {result}")
```

```rust !! rs
fn fibonacci(n: u64) -> u64 {
    /// Calculate the nth Fibonacci number
    if n <= 1 {
        return n;
    }
    let (mut a, mut b) = (0, 1);
    for _ in 2..=n {
        let temp = a + b;
        a = b;
        b = temp;
    }
    b
}

fn main() {
    let n = 10;
    let result = fibonacci(n);
    println!("Fibonacci({}) = {}", n, result);
}
```
</UniversalEditor>

Create this in `src/main.rs` and run with `cargo run`.

## Testing Your Installation

Verify everything works:

```bash
# Check Rust version
rustc --version

# Check Cargo
cargo --version

# Create test project
cargo new test_project && cd test_project

# Build it
cargo build

# Run it
cargo run

# Run tests
cargo test
```

If all commands succeed, you're ready to learn Rust!

## Summary

In this module, you learned:
- ✅ Why Rust is valuable for Python developers
- ✅ How to install Rust and Cargo
- ✅ How to create and run a Rust project
- ✅ Basic Cargo commands
- ✅ The difference between Python's interpretation and Rust's compilation
- ✅ How to set up your development environment

## Next Steps

Now that your environment is set up:
1. **[Module 1: Syntax Basics](./module-01-syntax-basics)** - Learn Rust syntax by comparing with Python
2. Practice with small programs
3. Explore the [Rust Playground](https://play.rust-lang.org/) for quick experiments

## Exercises

### Exercise 1: Create a Project

Create a new Cargo project called `greeting` that:
- Asks for the user's name
- Prints a personalized greeting
- Uses variables and functions

### Exercise 2: Temperature Converter

Write a program that converts Fahrenheit to Celsius:
- Formula: `C = (F - 32) * 5/9`
- Create a function for the conversion
- Test with a few values

<details>
<summary>Solution</summary>

```rust
fn fahrenheit_to_celsius(f: f64) -> f64 {
    (f - 32.0) * 5.0 / 9.0
}

fn main() {
    let fahrenheit = 98.6;
    let celsius = fahrenheit_to_celsius(fahrenheit);
    println!("{}°F = {}°C", fahrenheit, celsius);
}
```

</details>

---

**Remember**: Rust has a learning curve, but the compiler is your friend. Read error messages carefully - they're incredibly helpful!

**Next:** [Module 1 - Syntax Basics](./module-01-syntax-basics) →
