---
title: "模块 13: 模块与包 - 代码组织"
description: "学习 Rust 的模块系统、如何使用 Cargo.toml 组织代码,以及发布包到 crates.io,与 Python 的打包生态系统进行比较。"
---

# 模块 13: 模块与包 - 代码组织

在本模块中,你将学习 Rust 如何将代码组织成**模块**和**包**,以及这与 Python 的导入系统和包管理的比较。

## 学习目标

完成本模块后,你将能够:
- 理解 Rust 的模块系统
- 使用 `mod`、`use` 和 `pub` 关键字
- 使用文件层次结构组织代码
- 使用 Cargo.toml 进行依赖管理
- 从 crates.io 发布和消费包
- 比较 Rust 的打包与 Python 的 setuptools/PyPI

## 模块系统基础

Rust 的模块系统提供**命名空间**和**访问控制**。与 Python 的隐式模块系统不同,Rust 的是显式的和基于文件的。

### 定义模块

<UniversalEditor compare={true} title="模块定义">
```python !! py
# Python: 模块本身就是文件
# math_utils.py
def add(a, b):
    return a + b

class Calculator:
    def multiply(self, a, b):
        return a * b

PI = 3.14159

# 使用:
# from math_utils import add, Calculator, PI
# result = add(1, 2)
```

```rust !! rs
// Rust: 模块是显式声明的
// math_utils.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub struct Calculator {
    pub value: i32,
}

impl Calculator {
    pub fn multiply(&self, a: i32, b: i32) -> i32 {
        a * b
    }
}

pub const PI: f64 = 3.14159;

// 在 main.rs 或 lib.rs 中:
mod math_utils;  // 声明模块

fn main() {
    let result = math_utils::add(1, 2);
    println!("Result: {}", result);
}
```
</UniversalEditor>

## Use 声明

`use` 关键字将项引入作用域,类似于 Python 的 `import`。

<UniversalEditor compare={true} title="Import vs Use">
```python !! py
# Python: 导入语句
import os
from collections import defaultdict
from math import pi as PI
from mymodule import MyClass, my_function

# 直接使用
path = os.path.join("a", "b")
d = defaultdict(int)
```

```rust !! rs
// Rust: Use 声明
use std::fs;  // 类似于: import fs
use std::collections::HashMap;  // 类似于: from collections import HashMap
use std::io::{self, Write};  // 类似于: from io import io, Write

fn main() {
    let path = fs::File::create("test.txt").unwrap();
}
```
</UniversalEditor>

## Cargo.toml 和依赖

`Cargo.toml` 类似于 Python 的 `setup.py` 或 `pyproject.toml`,但更具规范性。

<UniversalEditor compare={true} title="包配置">
```python !! py
# Python: pyproject.toml 或 setup.py
[project]
name = "mypackage"
version = "1.0.0"
dependencies = [
    "requests>=2.28.0",
    "pandas>=1.5.0",
]
```

```rust !! rs
// Rust: Cargo.toml
[package]
name = "mycrate"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
tokio = { version = "1.0", features = ["full"] }

[dev-dependencies]
criterion = "0.5"
```
</UniversalEditor>

## 发布到 crates.io

<UniversalEditor compare={true} title="发布包">
```python !! py
# Python: 发布到 PyPI
# 1. 在 PyPI 注册账户
# 2. 构建发行版
python -m build

# 3. 上传
twine upload dist/*
```

```rust !! rs
// Rust: 发布到 crates.io
// 1. 登录 crates.io
cargo login

// 2. 确保包文档
//! # My Crate
//!
//! This crate does amazing things.

/// This function does X
pub fn amazing_function() -> i32 {
    42
}

// 3. 发布
cargo publish
```
</UniversalEditor>

## 最佳实践

### 应该做:

1. **使用模块组织代码** - 分组相关功能
2. **使 API 公开,实现私有** - 封装
3. **使用 `pub use` 提供便利** - 重新导出常见项
4. **利用工作空间** - 用于多包项目
5. **记录公共 API** - 使用 `///` 和 `//!` 注释

### 不应该做:

1. **过度使用 `use *`** - 明确导入
2. **使所有内容公开** - 尊重封装
3. **忽略 Cargo 警告** - 它们捕获真正的问题

## 总结

- **模块**提供命名空间组织
- **Use** 声明将项引入作用域
- **Cargo.toml** 是依赖的唯一真实来源
- **crates.io** 是官方包注册表
- **Rust 的系统**比 Python 的更显式
- **两个生态系统**都提供依赖管理和发布

## 下一模块

在下一个模块中,我们将探索**文件 I/O 和标准库**,包括读/写文件、路径操作、命令行参数和环境变量。你将学习 Rust 的方法如何与 Python 的文件处理进行比较。
