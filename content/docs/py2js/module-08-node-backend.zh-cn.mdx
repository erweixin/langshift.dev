---
title: Node.js 后端开发
description: 学习如何使用 Node.js 构建服务端应用，对比 Python 后端开发的异同点
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';

# Node.js 后端开发

Node.js 允许开发者使用 JavaScript 构建服务端应用，这为 Python 开发者提供了一个有趣的对比学习机会。本章将深入探讨 Node.js 后端开发的核心概念，并与 Python 后端开发进行详细对比。

## 1. Node.js 运行时概述

### 运行环境对比

<Tabs items={['Python 运行时', 'Node.js 运行时']}>

<Tab value="Python 运行时">

```python
# Python 运行时特性
import sys
import os
import asyncio
from threading import Thread

# 全局解释器锁 (GIL)
print(f"Python 版本: {sys.version}")
print(f"平台: {sys.platform}")

# Python 中的并发
def cpu_bound_task():
    """CPU 密集型任务"""
    total = 0
    for i in range(1000000):
        total += i ** 2
    return total

# 多线程（受 GIL 限制）
import threading
threads = []
for i in range(4):
    t = threading.Thread(target=cpu_bound_task)
    threads.append(t)
    t.start()

for t in threads:
    t.join()

# 异步编程
async def io_bound_task():
    """IO 密集型任务"""
    await asyncio.sleep(1)
    return "任务完成"

async def main():
    tasks = [io_bound_task() for _ in range(10)]
    results = await asyncio.gather(*tasks)
    print(f"完成 {len(results)} 个任务")

asyncio.run(main())
```

</Tab>

<Tab value="Node.js 运行时">

```javascript
// Node.js 运行时特性
console.log(`Node.js 版本: ${process.version}`);
console.log(`平台: ${process.platform}`);
console.log(`架构: ${process.arch}`);

// 单线程事件循环
console.log("事件循环阶段:");
console.log("1. Timer 阶段");
console.log("2. Pending callbacks 阶段");
console.log("3. Poll 阶段");
console.log("4. Check 阶段");
console.log("5. Close callbacks 阶段");

// CPU 密集型任务处理
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

if (isMainThread) {
    // 主线程
    const workers = [];
    const numWorkers = 4;
    
    for (let i = 0; i < numWorkers; i++) {
        const worker = new Worker(__filename, {
            workerData: { start: i * 250000, end: (i + 1) * 250000 }
        });
        
        worker.on('message', (result) => {
            console.log(`Worker ${i} 完成: ${result}`);
        });
        
        workers.push(worker);
    }
} else {
    // Worker 线程
    function cpuBoundTask(start, end) {
        let total = 0;
        for (let i = start; i < end; i++) {
            total += i ** 2;
        }
        return total;
    }
    
    const result = cpuBoundTask(workerData.start, workerData.end);
    parentPort.postMessage(result);
}

// 异步编程 (原生 Promise)
async function ioBoundTask() {
    return new Promise(resolve => {
        setTimeout(() => resolve("任务完成"), 1000);
    });
}

async function main() {
    const tasks = Array(10).fill().map(() => ioBoundTask());
    const results = await Promise.all(tasks);
    console.log(`完成 ${results.length} 个任务`);
}

main();
```

</Tab>

</Tabs>

## 2. HTTP 服务器对比

[简化的内容，重点展示核心差异]

## 3. 数据库集成

[简化的数据库操作示例]

## 4. 实时通信

[WebSocket 基础示例]

## 小结

通过本章的学习，你应该了解到：

1. **运行时差异**: Node.js 单线程事件循环 vs Python 多线程 + GIL
2. **异步模型**: JavaScript Promise/async-await vs Python asyncio
3. **文件操作**: Node.js fs 模块 vs Python pathlib/aiofiles
4. **数据库集成**: 不同 ORM/ODM 的使用方式和特点
5. **实时通信**: WebSocket 在两种语言中的实现差异

<Callout type="tip">
**下一步**: 在下一章中，我们将学习包管理与生态系统，了解 npm 与 pip 的差异。
</Callout>
