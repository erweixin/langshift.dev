---
title: 全栈开发最佳实践
description: 从 Python 开发者的角度掌握全栈 JavaScript 开发，包括架构模式、部署策略和生产环境考虑因素
---

# 模块 13：全栈开发最佳实践

## 学习目标

完成本模块后，你将能够：
- 理解全栈 JavaScript 架构模式
- 实施安全的身份验证和授权
- 将应用部署到生产环境
- 监控和优化生产应用
- 有效扩展应用
- 在整个技术栈中应用安全最佳实践

## 全栈架构模式

### 对比 Python 和 JavaScript 架构

<PythonEditor title="全栈架构对比" compare={true}>
```python !! py
# Python 全栈架构（Django + React/Vue）
# 传统的前后端分离

# 后端：Django 项目结构
# myproject/
# ├── manage.py
# ├── myproject/
# │   ├── settings/
# │   │   ├── base.py
# │   │   ├── development.py
# │   │   └── production.py
# │   ├── urls.py
# │   └── wsgi.py
# ├── apps/
# │   ├── authentication/
# │   ├── users/
# │   └── api/
# ├── requirements/
# │   ├── base.txt
# │   ├── development.txt
# │   └── production.txt
# └── frontend/  (独立的 React/Vue 应用)

# Django settings/base.py
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent.parent

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'rest_framework',
    'corsheaders',
    'apps.authentication',
    'apps.users',
    'apps.api',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'apps.authentication.middleware.JWTAuthenticationMiddleware',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
}

# Django 认证
from rest_framework_simplejwt.views import TokenObtainPairView
from django.contrib.auth import authenticate

class CustomTokenObtainPairView(TokenObtainPairView):
    def post(self, request, *args, **kwargs):
        response = super().post(request, *args, **kwargs)
        if response.status_code == 200:
            # 向响应添加自定义数据
            user = authenticate(
                username=request.data['username'],
                password=request.data['password']
            )
            response.data['user'] = {
                'id': user.id,
                'username': user.username,
                'email': user.email,
            }
        return response
```

```javascript !! js
// JavaScript 全栈架构（Node.js + React/Next.js）
// 现代统一或 monorepo 方法

// 现代全栈 JavaScript 项目结构：
// my-app/
// ├── package.json
// ├── apps/
// │   ├── web/          (Next.js 前端)
// │   │   ├── pages/
// │   │   ├── components/
// │   │   └── package.json
// │   └── api/          (Express.js 后端)
// │       ├── src/
// │       ├── routes/
// │       └── package.json
// ├── packages/
// │   ├── shared/       (共享工具)
// │   ├── ui/          (组件库)
// │   └── database/    (数据库模型)
// └── docker-compose.yml

// 后端：Express.js with TypeScript
// apps/api/src/app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { authRouter } from './routes/auth';
import { usersRouter } from './routes/users';
import { errorHandler } from './middleware/errorHandler';
import { authMiddleware } from './middleware/auth';

const app = express();

// 安全中间件
app.use(helmet());
app.use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
}));

// 速率限制
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 分钟
    max: 100, // 限制每个 IP 在窗口期内最多 100 个请求
    message: '来自此 IP 的请求过多'
});
app.use('/api/', limiter);

// 请求体解析
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// 路由
app.use('/api/auth', authRouter);
app.use('/api/users', authMiddleware, usersRouter);

// 健康检查
app.get('/health', (req, res) => {
    res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// 错误处理
app.use(errorHandler);

export default app;

// 认证中间件
// apps/api/src/middleware/auth.ts
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { User } from '../models/User';

interface AuthenticatedRequest extends Request {
    user?: User;
}

export const authMiddleware = async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        
        if (!token) {
            return res.status(401).json({ error: '未提供令牌' });
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
        const user = await User.findById(decoded.userId);
        
        if (!user) {
            return res.status(401).json({ error: '无效令牌' });
        }

        req.user = user;
        next();
    } catch (error) {
        return res.status(401).json({ error: '无效令牌' });
    }
};

// 前端：Next.js with TypeScript
// apps/web/pages/_app.tsx
import type { AppProps } from 'next/app';
import { AuthProvider } from '../contexts/AuthContext';
import { QueryClient, QueryClientProvider } from 'react-query';
import { Toaster } from 'react-hot-toast';
import '../styles/globals.css';

const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 5 * 60 * 1000, // 5 分钟
            cacheTime: 10 * 60 * 1000, // 10 分钟
        },
    },
});

function MyApp({ Component, pageProps }: AppProps) {
    return (
        <QueryClientProvider client={queryClient}>
            <AuthProvider>
                <Component {...pageProps} />
                <Toaster position="top-right" />
            </AuthProvider>
        </QueryClientProvider>
    );
}

export default MyApp;

// 认证上下文
// apps/web/contexts/AuthContext.tsx
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import { authAPI } from '../services/api';

interface User {
    id: string;
    username: string;
    email: string;
}

interface AuthContextType {
    user: User | null;
    login: (username: string, password: string) => Promise<void>;
    logout: () => void;
    loading: boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const router = useRouter();

    useEffect(() => {
        const token = localStorage.getItem('token');
        if (token) {
            authAPI.verifyToken(token)
                .then(setUser)
                .catch(() => localStorage.removeItem('token'))
                .finally(() => setLoading(false));
        } else {
            setLoading(false);
        }
    }, []);

    const login = async (username: string, password: string) => {
        const { user, token } = await authAPI.login(username, password);
        localStorage.setItem('token', token);
        setUser(user);
        router.push('/dashboard');
    };

    const logout = () => {
        localStorage.removeItem('token');
        setUser(null);
        router.push('/login');
    };

    return (
        <AuthContext.Provider value={{ user, login, logout, loading }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth 必须在 AuthProvider 内使用');
    }
    return context;
};
```
</PythonEditor>

## 身份验证和授权

### 安全认证实施

<PythonEditor title="认证与授权" compare={true}>
```python !! py
# Python：Django with JWT 认证
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

@api_view(['POST'])
def login(request):
    username = request.data.get('username')
    password = request.data.get('password')
    
    user = authenticate(username=username, password=password)
    if user:
        refresh = RefreshToken.for_user(user)
        return Response({
            'access': str(refresh.access_token),
            'refresh': str(refresh),
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
            }
        })
    return Response(
        {'error': '凭据无效'}, 
        status=status.HTTP_401_UNAUTHORIZED
    )

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def protected_view(request):
    return Response({
        'message': f'你好 {request.user.username}',
        'user_id': request.user.id
    })

# 基于角色的权限
from django.contrib.auth.models import Group

class IsAdminOrReadOnly:
    def has_permission(self, request, view):
        if request.method in ['GET', 'HEAD', 'OPTIONS']:
            return True
        return request.user.groups.filter(name='Admin').exists()

# 自定义用户模型
from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):
    email = models.EmailField(unique=True)
    role = models.CharField(max_length=20, choices=[
        ('admin', '管理员'),
        ('user', '用户'),
        ('moderator', '版主')
    ], default='user')
    
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']
```

```javascript !! js
// JavaScript：Node.js with JWT 和基于角色的授权
// apps/api/src/services/authService.ts
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { User, UserRole } from '../models/User';

export class AuthService {
    static generateTokens(userId: string) {
        const accessToken = jwt.sign(
            { userId, type: 'access' },
            process.env.JWT_SECRET!,
            { expiresIn: '15m' }
        );
        
        const refreshToken = jwt.sign(
            { userId, type: 'refresh' },
            process.env.JWT_REFRESH_SECRET!,
            { expiresIn: '7d' }
        );
        
        return { accessToken, refreshToken };
    }
    
    static async login(email: string, password: string) {
        const user = await User.findOne({ email });
        if (!user || !await bcrypt.compare(password, user.password)) {
            throw new Error('凭据无效');
        }
        
        const tokens = this.generateTokens(user.id);
        
        // 存储刷新令牌
        user.refreshToken = tokens.refreshToken;
        await user.save();
        
        return {
            user: {
                id: user.id,
                email: user.email,
                username: user.username,
                role: user.role
            },
            ...tokens
        };
    }
    
    static async refreshToken(refreshToken: string) {
        try {
            const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET!) as any;
            const user = await User.findById(decoded.userId);
            
            if (!user || user.refreshToken !== refreshToken) {
                throw new Error('无效的刷新令牌');
            }
            
            return this.generateTokens(user.id);
        } catch (error) {
            throw new Error('无效的刷新令牌');
        }
    }
    
    static async register(userData: {
        email: string;
        username: string;
        password: string;
        role?: UserRole;
    }) {
        const existingUser = await User.findOne({
            $or: [{ email: userData.email }, { username: userData.username }]
        });
        
        if (existingUser) {
            throw new Error('用户已存在');
        }
        
        const hashedPassword = await bcrypt.hash(userData.password, 12);
        
        const user = new User({
            ...userData,
            password: hashedPassword,
            role: userData.role || UserRole.USER
        });
        
        await user.save();
        
        const tokens = this.generateTokens(user.id);
        
        return {
            user: {
                id: user.id,
                email: user.email,
                username: user.username,
                role: user.role
            },
            ...tokens
        };
    }
}

// 基于角色的授权中间件
// apps/api/src/middleware/authorization.ts
import { Request, Response, NextFunction } from 'express';
import { UserRole } from '../models/User';

interface AuthorizedRequest extends Request {
    user?: {
        id: string;
        role: UserRole;
    };
}

export const authorize = (requiredRoles: UserRole[]) => {
    return (req: AuthorizedRequest, res: Response, next: NextFunction) => {
        if (!req.user) {
            return res.status(401).json({ error: '需要身份验证' });
        }
        
        if (!requiredRoles.includes(req.user.role)) {
            return res.status(403).json({ error: '权限不足' });
        }
        
        next();
    };
};

// 在路由中使用
import { authorize } from '../middleware/authorization';

router.get('/admin/users', 
    authMiddleware, 
    authorize([UserRole.ADMIN]), 
    getUsersController
);

router.delete('/admin/users/:id', 
    authMiddleware, 
    authorize([UserRole.ADMIN, UserRole.MODERATOR]), 
    deleteUserController
);

// 密码重置功能
// apps/api/src/services/passwordResetService.ts
import crypto from 'crypto';
import { EmailService } from './emailService';

export class PasswordResetService {
    static async initiateReset(email: string) {
        const user = await User.findOne({ email });
        if (!user) {
            // 不泄露邮箱是否存在
            return { message: '如果邮箱存在，将发送重置链接' };
        }
        
        const resetToken = crypto.randomBytes(32).toString('hex');
        const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 小时
        
        user.resetToken = resetToken;
        user.resetTokenExpiry = resetTokenExpiry;
        await user.save();
        
        await EmailService.sendPasswordReset(email, resetToken);
        
        return { message: '如果邮箱存在，将发送重置链接' };
    }
    
    static async resetPassword(token: string, newPassword: string) {
        const user = await User.findOne({
            resetToken: token,
            resetTokenExpiry: { $gt: new Date() }
        });
        
        if (!user) {
            throw new Error('无效或过期的重置令牌');
        }
        
        user.password = await bcrypt.hash(newPassword, 12);
        user.resetToken = undefined;
        user.resetTokenExpiry = undefined;
        await user.save();
        
        return { message: '密码重置成功' };
    }
}

// 前端：安全认证钩子
// apps/web/hooks/useAuth.ts
import { useState, useEffect } from 'react';
import { authAPI } from '../services/api';

export const useAuth = () => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        const token = localStorage.getItem('accessToken');
        if (token) {
            authAPI.verifyToken(token)
                .then(setUser)
                .catch(() => {
                    localStorage.removeItem('accessToken');
                    localStorage.removeItem('refreshToken');
                })
                .finally(() => setLoading(false));
        } else {
            setLoading(false);
        }
    }, []);
    
    const login = async (email: string, password: string) => {
        const response = await authAPI.login(email, password);
        localStorage.setItem('accessToken', response.accessToken);
        localStorage.setItem('refreshToken', response.refreshToken);
        setUser(response.user);
        return response;
    };
    
    const logout = () => {
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        setUser(null);
    };
    
    return { user, login, logout, loading };
};

// 自动令牌刷新
// apps/web/services/api.ts
import axios, { AxiosResponse } from 'axios';

const api = axios.create({
    baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api',
});

// 请求拦截器添加认证令牌
api.interceptors.request.use((config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// 响应拦截器处理令牌刷新
api.interceptors.response.use(
    (response: AxiosResponse) => response,
    async (error) => {
        const originalRequest = error.config;
        
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;
            
            const refreshToken = localStorage.getItem('refreshToken');
            if (refreshToken) {
                try {
                    const response = await axios.post('/api/auth/refresh', {
                        refreshToken
                    });
                    
                    localStorage.setItem('accessToken', response.data.accessToken);
                    originalRequest.headers.Authorization = `Bearer ${response.data.accessToken}`;
                    
                    return api(originalRequest);
                } catch (refreshError) {
                    localStorage.removeItem('accessToken');
                    localStorage.removeItem('refreshToken');
                    window.location.href = '/login';
                }
            }
        }
        
        return Promise.reject(error);
    }
);

export default api;
```
</PythonEditor>

## 部署策略

### 生产部署对比

<PythonEditor title="部署策略" compare={true}>
```python !! py
# Python 使用 Docker 和 Docker Compose 部署
# Django 的 Dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# 安装 Python 依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# 收集静态文件
RUN python manage.py collectstatic --noinput

EXPOSE 8000

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "myproject.wsgi:application"]

# 全栈的 docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: myproject
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine

  web:
    build: .
    command: gunicorn --bind 0.0.0.0:8000 myproject.wsgi:application
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/myproject
      - REDIS_URL=redis://redis:6379/0

  worker:
    build: .
    command: celery -A myproject worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/myproject
      - REDIS_URL=redis://redis:6379/0

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./static:/app/static
    depends_on:
      - web

volumes:
  postgres_data:

# Kubernetes 部署
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: django-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: django-app
  template:
    metadata:
      labels:
        app: django-app
    spec:
      containers:
      - name: django
        image: myregistry/django-app:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: django-secrets
              key: database-url
```

```javascript !! js
// JavaScript 使用 Docker 和现代平台部署
// Next.js 的多阶段 Dockerfile
FROM node:18-alpine AS deps
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci --only=production

FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000

CMD ["node", "server.js"]

// 全栈 JavaScript 的 Docker Compose
# docker-compose.yml
version: '3.8'

services:
  # 数据库
  postgres:
    image: postgres:13-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  # Redis 用于缓存和会话
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  # 后端 API
  api:
    build:
      context: ./apps/api
      dockerfile: Dockerfile
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/myapp
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
    ports:
      - "3001:3001"
    depends_on:
      - postgres
      - redis
    volumes:
      - ./apps/api:/app
      - /app/node_modules

  # 前端
  web:
    build:
      context: ./apps/web
      dockerfile: Dockerfile
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:3001/api
    ports:
      - "3000:3000"
    depends_on:
      - api

  # Nginx 反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - web
      - api

volumes:
  postgres_data:

// Vercel 部署（无服务器）
// vercel.json
{
    "version": 2,
    "builds": [
        {
            "src": "apps/web/package.json",
            "use": "@vercel/next"
        },
        {
            "src": "apps/api/src/index.ts",
            "use": "@vercel/node"
        }
    ],
    "routes": [
        {
            "src": "/api/(.*)",
            "dest": "apps/api/src/index.ts"
        },
        {
            "src": "/(.*)",
            "dest": "apps/web/$1"
        }
    ],
    "env": {
        "DATABASE_URL": "@database-url",
        "JWT_SECRET": "@jwt-secret"
    }
}

// Railway 部署配置
// railway.toml
[build]
builder = "nixpacks"

[deploy]
healthcheckPath = "/health"
healthcheckTimeout = 300
restartPolicyType = "on_failure"

[[services]]
name = "web"
source = "apps/web"
[services.env]
NODE_ENV = "production"

[[services]]
name = "api"
source = "apps/api"
[services.env]
NODE_ENV = "production"
DATABASE_URL = "${{Postgres.DATABASE_URL}}"

// 使用 CDK 的 AWS 部署
// infrastructure/stack.ts
import * as cdk from 'aws-cdk-lib';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as rds from 'aws-cdk-lib/aws-rds';
import * as cloudfront from 'aws-cdk-lib/aws-cloudfront';

export class MyAppStack extends cdk.Stack {
    constructor(scope: Construct, id: string, props?: cdk.StackProps) {
        super(scope, id, props);

        // VPC
        const vpc = new ec2.Vpc(this, 'MyAppVpc', {
            maxAzs: 2
        });

        // 数据库
        const database = new rds.DatabaseInstance(this, 'Database', {
            engine: rds.DatabaseInstanceEngine.postgres({
                version: rds.PostgresEngineVersion.VER_13_7
            }),
            instanceType: ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.MICRO),
            vpc,
            credentials: rds.Credentials.fromGeneratedSecret('postgres'),
            deletionProtection: false
        });

        // ECS 集群
        const cluster = new ecs.Cluster(this, 'Cluster', {
            vpc
        });

        // API 服务
        const apiTaskDefinition = new ecs.FargateTaskDefinition(this, 'ApiTaskDef');
        apiTaskDefinition.addContainer('api', {
            image: ecs.ContainerImage.fromRegistry('myregistry/api:latest'),
            environment: {
                DATABASE_URL: database.instanceEndpoint.socketAddress
            },
            logging: ecs.LogDrivers.awsLogs({
                streamPrefix: 'api'
            })
        });

        const apiService = new ecs.FargateService(this, 'ApiService', {
            cluster,
            taskDefinition: apiTaskDefinition
        });

        // 前端（S3 + CloudFront）
        const bucket = new s3.Bucket(this, 'WebBucket', {
            websiteIndexDocument: 'index.html',
            publicReadAccess: true
        });

        const distribution = new cloudfront.CloudFrontWebDistribution(this, 'Distribution', {
            originConfigs: [{
                s3OriginSource: {
                    s3BucketSource: bucket
                },
                behaviors: [{ isDefaultBehavior: true }]
            }]
        });
    }
}

// GitHub Actions 部署
# .github/workflows/deploy.yml
name: 部署到生产环境

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: 设置 Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: 安装依赖
        run: npm ci
      
      - name: 运行测试
        run: npm test
      
      - name: 构建应用
        run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: 配置 AWS 凭据
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: 构建和推送 Docker 镜像
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./apps/api
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      
      - name: 部署到 ECS
        run: |
          aws ecs update-service --cluster production --service api-service --force-new-deployment
      
      - name: 部署前端到 S3
        run: |
          aws s3 sync ./apps/web/out s3://my-app-frontend --delete
          aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"
```
</PythonEditor>

## 生产监控和优化

### 监控和性能

<PythonEditor title="生产监控" compare={true}>
```python !! py
# Python 使用 Django 进行监控
# settings.py
import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration
from sentry_sdk.integrations.celery import CeleryIntegration

sentry_sdk.init(
    dsn="your-sentry-dsn",
    integrations=[
        DjangoIntegration(),
        CeleryIntegration(),
    ],
    traces_sample_rate=0.1,
    send_default_pii=True
)

# 监控自定义中间件
class MonitoringMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start_time = time.time()
        
        response = self.get_response(request)
        
        # 记录请求指标
        duration = time.time() - start_time
        logger.info(f"请求 {request.path} 耗时 {duration:.2f}s")
        
        # 发送指标到监控服务
        send_metric('request_duration', duration, {
            'path': request.path,
            'method': request.method,
            'status_code': response.status_code
        })
        
        return response

# 健康检查端点
from django.http import JsonResponse
from django.db import connection

def health_check(request):
    try:
        # 检查数据库连接
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
        
        # 检查 Redis 连接
        from django.core.cache import cache
        cache.set('health_check', 'ok', 10)
        
        return JsonResponse({
            'status': 'healthy',
            'timestamp': timezone.now().isoformat(),
            'version': settings.VERSION
        })
    except Exception as e:
        return JsonResponse({
            'status': 'unhealthy',
            'error': str(e)
        }, status=503)

# 性能监控
import cProfile
import pstats

def profile_view(view_func):
    def wrapper(request, *args, **kwargs):
        if settings.DEBUG:
            profiler = cProfile.Profile()
            profiler.enable()
            
            response = view_func(request, *args, **kwargs)
            
            profiler.disable()
            stats = pstats.Stats(profiler)
            stats.sort_stats('cumulative')
            stats.print_stats()
            
            return response
        return view_func(request, *args, **kwargs)
    return wrapper
```

```javascript !! js
// JavaScript 使用 Node.js 进行监控
// apps/api/src/monitoring/index.ts
import * as Sentry from '@sentry/node';
import * as Tracing from '@sentry/tracing';
import express from 'express';
import prometheus from 'prom-client';

// 初始化 Sentry
Sentry.init({
    dsn: process.env.SENTRY_DSN,
    integrations: [
        new Sentry.Integrations.Http({ tracing: true }),
        new Tracing.Integrations.Express({ app: express() }),
    ],
    tracesSampleRate: 0.1,
    environment: process.env.NODE_ENV,
});

// Prometheus 指标
const collectDefaultMetrics = prometheus.collectDefaultMetrics;
collectDefaultMetrics({ timeout: 5000 });

const httpRequestDuration = new prometheus.Histogram({
    name: 'http_request_duration_seconds',
    help: 'HTTP 请求持续时间（秒）',
    labelNames: ['method', 'route', 'status_code'],
    buckets: [0.1, 0.5, 1, 2, 5]
});

const httpRequestTotal = new prometheus.Counter({
    name: 'http_requests_total',
    help: 'HTTP 请求总数',
    labelNames: ['method', 'route', 'status_code']
});

const activeConnections = new prometheus.Gauge({
    name: 'active_connections',
    help: '活跃连接数'
});

// 监控中间件
export const monitoringMiddleware = (req: express.Request, res: express.Response, next: express.NextFunction) => {
    const start = Date.now();
    
    res.on('finish', () => {
        const duration = (Date.now() - start) / 1000;
        const route = req.route?.path || req.path;
        
        httpRequestDuration
            .labels(req.method, route, res.statusCode.toString())
            .observe(duration);
            
        httpRequestTotal
            .labels(req.method, route, res.statusCode.toString())
            .inc();
    });
    
    next();
};

// 健康检查端点
export const healthCheck = async (req: express.Request, res: express.Response) => {
    const checks = {
        timestamp: new Date().toISOString(),
        version: process.env.npm_package_version,
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        database: false,
        redis: false
    };
    
    try {
        // 检查数据库连接
        await User.findOne().limit(1);
        checks.database = true;
    } catch (error) {
        console.error('数据库健康检查失败:', error);
    }
    
    try {
        // 检查 Redis 连接
        await redisClient.ping();
        checks.redis = true;
    } catch (error) {
        console.error('Redis 健康检查失败:', error);
    }
    
    const isHealthy = checks.database && checks.redis;
    
    res.status(isHealthy ? 200 : 503).json({
        status: isHealthy ? 'healthy' : 'unhealthy',
        checks
    });
};

// 应用性能监控（APM）
// apps/api/src/monitoring/apm.ts
import { performance, PerformanceObserver } from 'perf_hooks';

class APMMonitor {
    private metrics: Map<string, number[]> = new Map();
    
    constructor() {
        this.setupPerformanceObserver();
    }
    
    private setupPerformanceObserver() {
        const obs = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.duration > 100) { // 记录慢操作
                    console.warn(`检测到慢操作: ${entry.name} 耗时 ${entry.duration}ms`);
                }
            }
        });
        obs.observe({ entryTypes: ['measure'] });
    }
    
    startTimer(name: string): string {
        const timerName = `${name}-${Date.now()}`;
        performance.mark(`${timerName}-start`);
        return timerName;
    }
    
    endTimer(timerName: string): number {
        performance.mark(`${timerName}-end`);
        performance.measure(timerName, `${timerName}-start`, `${timerName}-end`);
        
        const measure = performance.getEntriesByName(timerName)[0];
        const duration = measure.duration;
        
        // 存储指标
        const baseName = timerName.split('-')[0];
        if (!this.metrics.has(baseName)) {
            this.metrics.set(baseName, []);
        }
        this.metrics.get(baseName)!.push(duration);
        
        // 清理
        performance.clearMarks(`${timerName}-start`);
        performance.clearMarks(`${timerName}-end`);
        performance.clearMeasures(timerName);
        
        return duration;
    }
    
    getMetrics() {
        const result: Record<string, any> = {};
        
        for (const [name, values] of this.metrics.entries()) {
            result[name] = {
                count: values.length,
                avg: values.reduce((a, b) => a + b, 0) / values.length,
                min: Math.min(...values),
                max: Math.max(...values),
                p95: this.percentile(values, 0.95),
                p99: this.percentile(values, 0.99)
            };
        }
        
        return result;
    }
    
    private percentile(values: number[], p: number): number {
        const sorted = values.slice().sort((a, b) => a - b);
        const index = Math.ceil(sorted.length * p) - 1;
        return sorted[index];
    }
}

export const apmMonitor = new APMMonitor();

// 在控制器中使用
export const getUsersController = async (req: Request, res: Response) => {
    const timer = apmMonitor.startTimer('get-users');
    
    try {
        const users = await User.find({});
        apmMonitor.endTimer(timer);
        
        res.json(users);
    } catch (error) {
        apmMonitor.endTimer(timer);
        throw error;
    }
};

// 前端使用 Next.js 进行监控
// apps/web/lib/monitoring.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

export function initMonitoring() {
    // Web Vitals
    getCLS(sendToAnalytics);
    getFID(sendToAnalytics);
    getFCP(sendToAnalytics);
    getLCP(sendToAnalytics);
    getTTFB(sendToAnalytics);
    
    // 错误边界
    window.addEventListener('error', (event) => {
        console.error('全局错误:', event.error);
        sendErrorToSentry(event.error);
    });
    
    // 未处理的 Promise 拒绝
    window.addEventListener('unhandledrejection', (event) => {
        console.error('未处理的 Promise 拒绝:', event.reason);
        sendErrorToSentry(event.reason);
    });
}

function sendToAnalytics(metric: any) {
    // 发送到分析服务
    if (process.env.NODE_ENV === 'production') {
        fetch('/api/analytics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                ...metric,
                timestamp: Date.now(),
                userAgent: navigator.userAgent,
                url: window.location.href
            })
        }).catch(console.error);
    }
}

function sendErrorToSentry(error: any) {
    if (process.env.NODE_ENV === 'production') {
        import('@sentry/browser').then(Sentry => {
            Sentry.captureException(error);
        });
    }
}

// 真实用户监控（RUM）
export class RUMMonitor {
    private sessionId: string;
    private userId?: string;
    
    constructor() {
        this.sessionId = this.generateSessionId();
        this.trackPageView();
        this.trackUserInteractions();
    }
    
    private generateSessionId(): string {
        return Math.random().toString(36).substring(2) + Date.now().toString(36);
    }
    
    setUserId(userId: string) {
        this.userId = userId;
    }
    
    trackPageView() {
        this.sendEvent('page_view', {
            url: window.location.href,
            referrer: document.referrer,
            timestamp: Date.now()
        });
    }
    
    trackUserInteractions() {
        document.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            this.sendEvent('click', {
                element: target.tagName,
                id: target.id,
                className: target.className,
                text: target.textContent?.substring(0, 100)
            });
        });
    }
    
    trackCustomEvent(name: string, data: any) {
        this.sendEvent(name, data);
    }
    
    private sendEvent(name: string, data: any) {
        if (process.env.NODE_ENV === 'production') {
            fetch('/api/rum', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    event: name,
                    sessionId: this.sessionId,
                    userId: this.userId,
                    timestamp: Date.now(),
                    data
                })
            }).catch(console.error);
        }
    }
}

export const rumMonitor = new RUMMonitor();
```
</PythonEditor>

## 安全最佳实践

### 全面安全实施

<PythonEditor title="安全最佳实践" compare={true}>
```python !! py
# Python 使用 Django 的安全配置
# settings/production.py
import os

# 安全设置
SECURE_SSL_REDIRECT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
SECURE_HSTS_SECONDS = 31536000
SECURE_HSTS_INCLUDE_SUBDOMAINS = True
SECURE_HSTS_PRELOAD = True
SECURE_CONTENT_TYPE_NOSNIFF = True
SECURE_BROWSER_XSS_FILTER = True
X_FRAME_OPTIONS = 'DENY'

# CSRF 保护
CSRF_COOKIE_SECURE = True
CSRF_COOKIE_HTTPONLY = True
CSRF_COOKIE_SAMESITE = 'Strict'

# 会话安全
SESSION_COOKIE_SECURE = True
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SAMESITE = 'Strict'
SESSION_COOKIE_AGE = 3600  # 1 小时

# 内容安全策略
CSP_DEFAULT_SRC = ["'self'"]
CSP_SCRIPT_SRC = ["'self'", "'unsafe-inline'", "https://cdn.example.com"]
CSP_STYLE_SRC = ["'self'", "'unsafe-inline'"]
CSP_IMG_SRC = ["'self'", "data:", "https:"]

# 速率限制
from django_ratelimit.decorators import ratelimit

@ratelimit(key='ip', rate='10/m', method='POST')
def login_view(request):
    # 登录实现
    pass

# 输入验证
from django import forms
from django.core.validators import EmailValidator

class UserForm(forms.Form):
    email = forms.EmailField(validators=[EmailValidator()])
    password = forms.CharField(min_length=8, max_length=128)
    
    def clean_password(self):
        password = self.cleaned_data['password']
        if not re.match(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)', password):
            raise forms.ValidationError("密码必须包含大写字母、小写字母和数字")
        return password

# SQL 注入防护（Django ORM 自动处理）
# 使用参数化查询
users = User.objects.filter(email=user_email)  # 安全
# 绝不这样做：User.objects.raw(f"SELECT * FROM users WHERE email = '{user_email}'")  # 危险

# 文件上传安全
import magic

def validate_file_type(file):
    allowed_types = ['image/jpeg', 'image/png', 'application/pdf']
    file_type = magic.from_buffer(file.read(1024), mime=True)
    if file_type not in allowed_types:
        raise ValidationError("不允许的文件类型")
    file.seek(0)  # 重置文件指针
    return file
```

```javascript !! js
// JavaScript 使用 Node.js 和 Express 的安全配置
// apps/api/src/security/index.ts
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import slowDown from 'express-slow-down';
import mongoSanitize from 'express-mongo-sanitize';
import hpp from 'hpp';
import cors from 'cors';
import { body, validationResult } from 'express-validator';

// 安全中间件设置
export const setupSecurity = (app: Express) => {
    // Helmet 用于各种安全头
    app.use(helmet({
        contentSecurityPolicy: {
            directives: {
                defaultSrc: ["'self'"],
                scriptSrc: ["'self'", "'unsafe-inline'", "https://cdn.jsdelivr.net"],
                styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
                imgSrc: ["'self'", "data:", "https:"],
                connectSrc: ["'self'"],
                fontSrc: ["'self'", "https://fonts.gstatic.com"],
                objectSrc: ["'none'"],
                mediaSrc: ["'self'"],
                frameSrc: ["'none'"],
            },
        },
        hsts: {
            maxAge: 31536000,
            includeSubDomains: true,
            preload: true
        }
    }));
    
    // CORS 配置
    app.use(cors({
        origin: process.env.FRONTEND_URL || 'http://localhost:3000',
        credentials: true,
        optionsSuccessStatus: 200
    }));
    
    // 速率限制
    const limiter = rateLimit({
        windowMs: 15 * 60 * 1000, // 15 分钟
        max: 100, // 限制每个 IP 在窗口期内最多 100 个请求
        message: '来自此 IP 的请求过多',
        standardHeaders: true,
        legacyHeaders: false,
    });
    app.use('/api/', limiter);
    
    // 认证端点的严格速率限制
    const authLimiter = rateLimit({
        windowMs: 15 * 60 * 1000,
        max: 5, // 限制每个 IP 在窗口期内最多 5 个请求
        skipSuccessfulRequests: true,
    });
    app.use('/api/auth/login', authLimiter);
    app.use('/api/auth/register', authLimiter);
    
    // 速度限制
    const speedLimiter = slowDown({
        windowMs: 15 * 60 * 1000,
        delayAfter: 50,
        delayMs: 500
    });
    app.use('/api/', speedLimiter);
    
    // 清理用户输入
    app.use(mongoSanitize());
    
    // 防止 HTTP 参数污染
    app.use(hpp());
};

// 输入验证和清理
// apps/api/src/validators/userValidator.ts
import { body, param, query } from 'express-validator';
import { Request, Response, NextFunction } from 'express';
import DOMPurify from 'isomorphic-dompurify';

export const validateUserRegistration = [
    body('email')
        .isEmail()
        .normalizeEmail()
        .custom(async (email) => {
            const existingUser = await User.findOne({ email });
            if (existingUser) {
                throw new Error('邮箱已被使用');
            }
        }),
    body('password')
        .isLength({ min: 8 })
        .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/)
        .withMessage('密码必须包含至少一个大写字母、一个小写字母、一个数字和一个特殊字符'),
    body('username')
        .isLength({ min: 3, max: 30 })
        .matches(/^[a-zA-Z0-9_]+$/)
        .withMessage('用户名只能包含字母、数字和下划线'),
    body('firstName')
        .trim()
        .isLength({ min: 1, max: 50 })
        .customSanitizer(value => DOMPurify.sanitize(value)),
    body('lastName')
        .trim()
        .isLength({ min: 1, max: 50 })
        .customSanitizer(value => DOMPurify.sanitize(value))
];

export const handleValidationErrors = (req: Request, res: Response, next: NextFunction) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({
            error: '验证失败',
            details: errors.array()
        });
    }
    next();
};

// SQL 注入防护（对于 SQL 数据库）
// apps/api/src/database/queries.ts
import { Pool } from 'pg';

class DatabaseService {
    private pool: Pool;
    
    constructor() {
        this.pool = new Pool({
            connectionString: process.env.DATABASE_URL,
            ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
        });
    }
    
    // 始终使用参数化查询
    async getUserById(id: string) {
        const query = 'SELECT * FROM users WHERE id = $1';
        const result = await this.pool.query(query, [id]);
        return result.rows[0];
    }
    
    async searchUsers(searchTerm: string) {
        // 参数化查询防止 SQL 注入
        const query = 'SELECT id, username, email FROM users WHERE username ILIKE $1 OR email ILIKE $1';
        const result = await this.pool.query(query, [`%${searchTerm}%`]);
        return result.rows;
    }
}

// 文件上传安全
// apps/api/src/middleware/fileUpload.ts
import multer from 'multer';
import path from 'path';
import crypto from 'crypto';
import { fileTypeFromBuffer } from 'file-type';

const allowedMimeTypes = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'application/pdf',
    'text/plain'
];

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, 'uploads/');
    },
    filename: (req, file, cb) => {
        // 生成唯一文件名
        const uniqueName = crypto.randomUUID() + path.extname(file.originalname);
        cb(null, uniqueName);
    }
});

const fileFilter = async (req: Request, file: Express.Multer.File, cb: multer.FileFilterCallback) => {
    // 检查 MIME 类型
    if (!allowedMimeTypes.includes(file.mimetype)) {
        return cb(new Error('不允许的文件类型'));
    }
    
    // 上传后在中间件中进行额外文件验证
    cb(null, true);
};

export const upload = multer({
    storage,
    fileFilter,
    limits: {
        fileSize: 10 * 1024 * 1024, // 10MB 限制
        files: 5 // 最多 5 个文件
    }
});

// 额外文件验证中间件
export const validateFileType = async (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) return next();
    
    try {
        const buffer = await fs.readFile(req.file.path);
        const fileType = await fileTypeFromBuffer(buffer);
        
        if (!fileType || !allowedMimeTypes.includes(fileType.mime)) {
            // 删除上传的文件
            await fs.unlink(req.file.path);
            return res.status(400).json({ error: '无效的文件类型' });
        }
        
        next();
    } catch (error) {
        console.error('文件验证错误:', error);
        res.status(500).json({ error: '文件验证失败' });
    }
};

// XSS 防护
// apps/api/src/middleware/xssProtection.ts
import DOMPurify from 'isomorphic-dompurify';

export const sanitizeInput = (req: Request, res: Response, next: NextFunction) => {
    const sanitizeObject = (obj: any): any => {
        if (typeof obj === 'string') {
            return DOMPurify.sanitize(obj);
        }
        if (Array.isArray(obj)) {
            return obj.map(sanitizeObject);
        }
        if (obj && typeof obj === 'object') {
            const sanitized: any = {};
            for (const key in obj) {
                sanitized[key] = sanitizeObject(obj[key]);
            }
            return sanitized;
        }
        return obj;
    };
    
    if (req.body) {
        req.body = sanitizeObject(req.body);
    }
    if (req.query) {
        req.query = sanitizeObject(req.query);
    }
    if (req.params) {
        req.params = sanitizeObject(req.params);
    }
    
    next();
};

// 表单的 CSRF 保护
// apps/api/src/middleware/csrf.ts
import csrf from 'csurf';

export const csrfProtection = csrf({
    cookie: {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict'
    }
});

// 前端安全（Next.js）
// apps/web/next.config.js
const nextConfig = {
    async headers() {
        return [
            {
                source: '/(.*)',
                headers: [
                    {
                        key: 'X-Frame-Options',
                        value: 'DENY'
                    },
                    {
                        key: 'X-Content-Type-Options',
                        value: 'nosniff'
                    },
                    {
                        key: 'Referrer-Policy',
                        value: 'strict-origin-when-cross-origin'
                    },
                    {
                        key: 'Permissions-Policy',
                        value: 'camera=(), microphone=(), geolocation=()'
                    }
                ]
            }
        ];
    }
};

// 环境变量验证
// apps/api/src/config/env.ts
import { z } from 'zod';

const envSchema = z.object({
    NODE_ENV: z.enum(['development', 'production', 'test']),
    PORT: z.string().transform(Number),
    DATABASE_URL: z.string().url(),
    JWT_SECRET: z.string().min(32),
    JWT_REFRESH_SECRET: z.string().min(32),
    FRONTEND_URL: z.string().url(),
    SENTRY_DSN: z.string().url().optional()
});

export const env = envSchema.parse(process.env);

// 安全 cookie 设置
// apps/api/src/config/session.ts
import session from 'express-session';
import MongoStore from 'connect-mongo';

export const sessionConfig = session({
    secret: process.env.SESSION_SECRET!,
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
        mongoUrl: process.env.DATABASE_URL
    }),
    cookie: {
        secure: process.env.NODE_ENV === 'production',
        httpOnly: true,
        maxAge: 1000 * 60 * 60 * 24, // 24 小时
        sameSite: 'strict'
    },
    name: 'sessionId' // 不使用默认会话名称
});
```
</PythonEditor>

## 扩展策略

### 水平和垂直扩展

<PythonEditor title="扩展策略" compare={true}>
```python !! py
# Python 使用 Django 和 Celery 进行扩展
# settings/production.py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myapp_primary',
        'USER': 'postgres',
        'PASSWORD': 'password',
        'HOST': 'db-primary.example.com',
        'PORT': '5432',
    },
    'read_replica': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'myapp_replica',
        'USER': 'postgres',
        'PASSWORD': 'password',
        'HOST': 'db-replica.example.com',
        'PORT': '5432',
    }
}

DATABASE_ROUTERS = ['myapp.routers.DatabaseRouter']

# 读写分离的数据库路由器
class DatabaseRouter:
    def db_for_read(self, model, **hints):
        return 'read_replica'
    
    def db_for_write(self, model, **hints):
        return 'default'
    
    def allow_migrate(self, db, app_label, model_name=None, **hints):
        return db == 'default'

# Celery 异步任务
# celery_app.py
from celery import Celery
import os

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

app = Celery('myproject')
app.config_from_object('django.conf:settings', namespace='CELERY')
app.autodiscover_tasks()

# 缓存配置
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://redis-cluster.example.com:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        }
    },
    'sessions': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://redis-cluster.example.com:6379/2',
    }
}

# 负载均衡器配置（nginx）
# nginx.conf
upstream django_app {
    server app1.example.com:8000;
    server app2.example.com:8000;
    server app3.example.com:8000;
}

server {
    listen 80;
    server_name example.com;
    
    location / {
        proxy_pass http://django_app;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

```javascript !! js
// JavaScript 使用 Node.js 和微服务进行扩展
// 使用 PM2 进行负载均衡
// ecosystem.config.js
module.exports = {
    apps: [
        {
            name: 'api',
            script: './dist/index.js',
            instances: 'max', // 使用所有 CPU 核心
            exec_mode: 'cluster',
            env: {
                NODE_ENV: 'production',
                PORT: 3001
            },
            max_memory_restart: '1G'
        }
    ]
};

// 数据库连接池
// apps/api/src/database/pool.ts
import { Pool } from 'pg';

class DatabasePool {
    private writePool: Pool;
    private readPool: Pool;
    
    constructor() {
        this.writePool = new Pool({
            connectionString: process.env.DATABASE_WRITE_URL,
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000
        });
        
        this.readPool = new Pool({
            connectionString: process.env.DATABASE_READ_URL,
            max: 30,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 2000
        });
    }
    
    getWriteConnection() {
        return this.writePool;
    }
    
    getReadConnection() {
        return this.readPool;
    }
}

export const dbPool = new DatabasePool();

// Redis 集群缓存
// apps/api/src/cache/redis.ts
import Redis from 'ioredis';

const redisCluster = new Redis.Cluster([
    { host: 'redis-node1.example.com', port: 6379 },
    { host: 'redis-node2.example.com', port: 6379 },
    { host: 'redis-node3.example.com', port: 6379 }
], {
    redisOptions: {
        password: process.env.REDIS_PASSWORD
    }
});

export class CacheService {
    static async get(key: string): Promise<any> {
        const value = await redisCluster.get(key);
        return value ? JSON.parse(value) : null;
    }
    
    static async set(key: string, value: any, ttl: number = 3600): Promise<void> {
        await redisCluster.setex(key, ttl, JSON.stringify(value));
    }
    
    static async invalidate(pattern: string): Promise<void> {
        const keys = await redisCluster.keys(pattern);
        if (keys.length > 0) {
            await redisCluster.del(...keys);
        }
    }
}

// 微服务架构
// services/user-service/src/app.ts
import express from 'express';
import { setupSecurity } from './security';
import { userRoutes } from './routes/users';
import { healthCheck } from './routes/health';

const app = express();

setupSecurity(app);

app.use('/api/users', userRoutes);
app.use('/health', healthCheck);

const PORT = process.env.PORT || 3002;
app.listen(PORT, () => {
    console.log(`用户服务运行在端口 ${PORT}`);
});

// 使用 Express 的 API 网关
// gateway/src/app.ts
import express from 'express';
import httpProxy from 'http-proxy-middleware';
import rateLimit from 'express-rate-limit';

const app = express();

// 速率限制
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100
});
app.use(limiter);

// 服务发现和负载均衡
const services = {
    users: ['http://user-service-1:3002', 'http://user-service-2:3002'],
    orders: ['http://order-service-1:3003', 'http://order-service-2:3003'],
    notifications: ['http://notification-service:3004']
};

let currentIndex = 0;

const getServiceUrl = (serviceName: string): string => {
    const serviceUrls = services[serviceName];
    const url = serviceUrls[currentIndex % serviceUrls.length];
    currentIndex++;
    return url;
};

// 带负载均衡的代理中间件
const createProxy = (serviceName: string) => {
    return httpProxy({
        target: getServiceUrl(serviceName),
        changeOrigin: true,
        pathRewrite: {
            [`^/api/${serviceName}`]: '/api'
        },
        onError: (err, req, res) => {
            console.error(`${serviceName} 代理错误:`, err);
            res.status(502).json({ error: '服务不可用' });
        }
    });
};

app.use('/api/users', createProxy('users'));
app.use('/api/orders', createProxy('orders'));
app.use('/api/notifications', createProxy('notifications'));

// 使用 Bull 的消息队列
// apps/api/src/queues/emailQueue.ts
import Bull from 'bull';
import { EmailService } from '../services/emailService';

export const emailQueue = new Bull('邮件队列', {
    redis: {
        host: process.env.REDIS_HOST,
        port: parseInt(process.env.REDIS_PORT || '6379'),
        password: process.env.REDIS_PASSWORD
    }
});

emailQueue.process('send-email', async (job) => {
    const { to, subject, body } = job.data;
    await EmailService.send(to, subject, body);
});

emailQueue.process('send-bulk-email', 5, async (job) => {
    const { recipients, subject, body } = job.data;
    const promises = recipients.map(to => 
        EmailService.send(to, subject, body)
    );
    await Promise.all(promises);
});

// 静态资源的 CDN 集成
// apps/web/next.config.js
const nextConfig = {
    assetPrefix: process.env.NODE_ENV === 'production' 
        ? 'https://cdn.example.com' 
        : '',
    images: {
        domains: ['cdn.example.com'],
        loader: 'custom',
        loaderFile: './image-loader.js'
    }
};

// apps/web/image-loader.js
export default function cloudinaryLoader({ src, width, quality }) {
    const params = ['f_auto', 'c_limit', `w_${width}`, `q_${quality || 'auto'}`];
    return `https://res.cloudinary.com/your-cloud-name/image/upload/${params.join(',')}/${src}`;
}

// 使用 Kubernetes 自动扩展
// k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: myregistry/api:latest
        ports:
        - containerPort: 3001
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: api-deployment
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```
</PythonEditor>

## 最佳实践总结

### 全栈开发最佳实践

1. **架构**：从一开始就设计可扩展的架构
2. **安全**：在每一层实施安全措施
3. **性能**：持续监控和优化
4. **测试**：跨技术栈的全面测试策略
5. **部署**：自动化、可靠的部署流水线
6. **监控**：实时监控和告警

### JavaScript 特定全栈考虑因素

1. **统一语言**：在整个技术栈中利用 JavaScript
2. **包管理**：使用 monorepo 实现更好的代码共享
3. **类型安全**：实施 TypeScript 以获得更好的开发体验
4. **现代工具**：使用现代构建工具和框架
5. **无服务器**：考虑无服务器架构进行扩展

## 结论

恭喜！你已经完成了从 Python 到 JavaScript 的全面学习之旅。你现在拥有以下知识和技能：

- 使用 JavaScript 构建现代全栈应用
- 在整个应用中应用安全最佳实践
- 在生产环境中部署和扩展应用
- 监控和优化应用性能
- 从 Python 开发顺利过渡到 JavaScript 开发

### 下一步

1. **实践**：使用所学概念构建真实项目
2. **社区**：加入 JavaScript 和 Node.js 社区
3. **保持更新**：跟上快速发展的 JavaScript 生态系统
4. **专业化**：选择 React、Vue、Node.js 或特定框架等领域深化专业知识
5. **分享知识**：以你独特的 Python + JavaScript 视角回馈社区

从 Python 到 JavaScript 的学习之路为你在 Web 开发、移动开发等领域开启了新的机会。你的 Python 背景为你在 JavaScript 开发中取得成功提供了坚实的基础。

---

*你已经完成了完整的 Python → JavaScript 学习路径！🎉*
