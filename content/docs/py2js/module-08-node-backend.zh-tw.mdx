---
title: Node.js 後端開發
description: 學習如何使用 Node.js 構建服務端應用，對比 Python 後端開發的異同點
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';

# Node.js 後端開發

Node.js 允許開發者使用 JavaScript 構建服務端應用，這為 Python 開發者提供了一個有趣的對比學習機會。本章將深入探討 Node.js 後端開發的核心概念，並與 Python 後端開發進行詳細對比。

## 1. Node.js 運行時概述

### 運行環境對比

<Tabs items={['Python 運行時', 'Node.js 運行時']}>

<Tab value="Python 運行時">

```python
# Python 運行時特性
import sys
import os
import asyncio
from threading import Thread

# 全局解釋器鎖 (GIL)
print(f"Python 版本: {sys.version}")
print(f"平台: {sys.platform}")

# Python 中的併發
def cpu_bound_task():
    """CPU 密集型任務"""
    total = 0
    for i in range(1000000):
        total += i ** 2
    return total

# 多線程（受 GIL 限制）
import threading
threads = []
for i in range(4):
    t = threading.Thread(target=cpu_bound_task)
    threads.append(t)
    t.start()

for t in threads:
    t.join()

# 異步編程
async def io_bound_task():
    """IO 密集型任務"""
    await asyncio.sleep(1)
    return "任務完成"

async def main():
    tasks = [io_bound_task() for _ in range(10)]
    results = await asyncio.gather(*tasks)
    print(f"完成 {len(results)} 個任務")

asyncio.run(main())
```

</Tab>

<Tab value="Node.js 運行時">

```javascript
// Node.js 運行時特性
console.log(`Node.js 版本: ${process.version}`);
console.log(`平台: ${process.platform}`);
console.log(`架構: ${process.arch}`);

// 單線程事件循環
console.log("事件循環階段:");
console.log("1. Timer 階段");
console.log("2. Pending callbacks 階段");
console.log("3. Poll 階段");
console.log("4. Check 階段");
console.log("5. Close callbacks 階段");

// CPU 密集型任務處理
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

if (isMainThread) {
    // 主線程
    const workers = [];
    const numWorkers = 4;
    
    for (let i = 0; i < numWorkers; i++) {
        const worker = new Worker(__filename, {
            workerData: { start: i * 250000, end: (i + 1) * 250000 }
        });
        
        worker.on('message', (result) => {
            console.log(`Worker ${i} 完成: ${result}`);
        });
        
        workers.push(worker);
    }
} else {
    // Worker 線程
    function cpuBoundTask(start, end) {
        let total = 0;
        for (let i = start; i < end; i++) {
            total += i ** 2;
        }
        return total;
    }
    
    const result = cpuBoundTask(workerData.start, workerData.end);
    parentPort.postMessage(result);
}

// 異步編程 (原生 Promise)
async function ioBoundTask() {
    return new Promise(resolve => {
        setTimeout(() => resolve("任務完成"), 1000);
    });
}

async function main() {
    const tasks = Array(10).fill().map(() => ioBoundTask());
    const results = await Promise.all(tasks);
    console.log(`完成 ${results.length} 個任務`);
}

main();
```

</Tab>

</Tabs>

## 2. HTTP 服務器對比

[簡化的內容，重點展示核心差異]

## 3. 數據庫集成

[簡化的數據庫操作示例]

## 4. 實時通信

[WebSocket 基礎示例]

## 小結

通過本章的學習，你應該了解到：

1. **運行時差異**: Node.js 單線程事件循環 vs Python 多線程 + GIL
2. **異步模型**: JavaScript Promise/async-await vs Python asyncio
3. **文件操作**: Node.js fs 模塊 vs Python pathlib/aiofiles
4. **數據庫集成**: 不同 ORM/ODM 的使用方式和特點
5. **實時通信**: WebSocket 在兩種語言中的實現差異

<Callout type="tip">
**下一步**: 在下一章中，我們將學習包管理與生態系統，了解 npm 與 pip 的差異。
</Callout>
