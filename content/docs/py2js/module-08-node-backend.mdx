---
title: Node.js 后端开发
description: 学习如何使用 Node.js 构建服务端应用，对比 Python 后端开发的异同点
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';

# Node.js 后端开发

Node.js 允许开发者使用 JavaScript 构建服务端应用，这为 Python 开发者提供了一个有趣的对比学习机会。本章将深入探讨 Node.js 后端开发的核心概念，并与 Python 后端开发进行详细对比。

## 1. Node.js 运行时概述

### 运行环境对比

<Tabs items={['Python 运行时', 'Node.js 运行时']}>

<Tab value="Python 运行时">

```python
# Python 运行时特性
import sys
import os
import asyncio
from threading import Thread

# 全局解释器锁 (GIL)
print(f"Python 版本: {sys.version}")
print(f"平台: {sys.platform}")

# Python 中的并发
def cpu_bound_task():
    """CPU 密集型任务"""
    total = 0
    for i in range(1000000):
        total += i ** 2
    return total

# 多线程（受 GIL 限制）
import threading
threads = []
for i in range(4):
    t = threading.Thread(target=cpu_bound_task)
    threads.append(t)
    t.start()

for t in threads:
    t.join()

# 异步编程
async def io_bound_task():
    """IO 密集型任务"""
    await asyncio.sleep(1)
    return "任务完成"

async def main():
    tasks = [io_bound_task() for _ in range(10)]
    results = await asyncio.gather(*tasks)
    print(f"完成 {len(results)} 个任务")

asyncio.run(main())
```

</Tab>

<Tab value="Node.js 运行时">

```javascript
// Node.js 运行时特性
console.log(`Node.js 版本: ${process.version}`);
console.log(`平台: ${process.platform}`);
console.log(`架构: ${process.arch}`);

// 单线程事件循环
console.log("事件循环阶段:");
console.log("1. Timer 阶段");
console.log("2. Pending callbacks 阶段");
console.log("3. Poll 阶段");
console.log("4. Check 阶段");
console.log("5. Close callbacks 阶段");

// CPU 密集型任务处理
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

if (isMainThread) {
    // 主线程
    const workers = [];
    const numWorkers = 4;
    
    for (let i = 0; i < numWorkers; i++) {
        const worker = new Worker(__filename, {
            workerData: { start: i * 250000, end: (i + 1) * 250000 }
        });
        
        worker.on('message', (result) => {
            console.log(`Worker ${i} 完成: ${result}`);
        });
        
        workers.push(worker);
    }
} else {
    // Worker 线程
    function cpuBoundTask(start, end) {
        let total = 0;
        for (let i = start; i < end; i++) {
            total += i ** 2;
        }
        return total;
    }
    
    const result = cpuBoundTask(workerData.start, workerData.end);
    parentPort.postMessage(result);
}

// 异步编程 (原生 Promise)
async function ioBoundTask() {
    return new Promise(resolve => {
        setTimeout(() => resolve("任务完成"), 1000);
    });
}

async function main() {
    const tasks = Array(10).fill().map(() => ioBoundTask());
    const results = await Promise.all(tasks);
    console.log(`完成 ${results.length} 个任务`);
}

main();
```

</Tab>

</Tabs>

### 内存管理对比

```javascript
// Node.js 内存管理
console.log("Node.js 内存使用情况:");
console.log(process.memoryUsage());

// 垃圾回收控制
if (global.gc) {
    global.gc(); // 手动触发垃圾回收
    console.log("垃圾回收后:", process.memoryUsage());
}

// 内存泄漏检测
const memwatch = require('@airbnb/node-memwatch');

memwatch.on('leak', (info) => {
    console.log('内存泄漏检测:', info);
});

memwatch.on('stats', (stats) => {
    console.log('内存统计:', stats);
});

// 对比 Python 的内存管理
/*
Python 自动内存管理:
- 引用计数 + 循环垃圾回收
- 内存池管理小对象
- gc 模块控制垃圾回收

Node.js V8 内存管理:
- 分代垃圾回收
- 新生代 (Scavenge) + 老生代 (Mark-Sweep-Compact)
- --max-old-space-size 控制内存限制
*/
```

## 2. HTTP 服务器对比

### 基础 HTTP 服务器

<Tabs items={['Python HTTP 服务器', 'Node.js HTTP 服务器']}>

<Tab value="Python HTTP 服务器">

```python
# Python 内置 HTTP 服务器
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
from urllib.parse import urlparse, parse_qs

class RequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed_path = urlparse(self.path)
        query_params = parse_qs(parsed_path.query)
        
        if parsed_path.path == '/':
            self.send_response(200)
            self.send_header('Content-Type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'Hello from Python!')
            
        elif parsed_path.path == '/api/users':
            self.send_response(200)
            self.send_header('Content-Type', 'application/json')
            self.end_headers()
            
            users = [
                {'id': 1, 'name': 'Alice'},
                {'id': 2, 'name': 'Bob'}
            ]
            self.wfile.write(json.dumps(users).encode())
            
        else:
            self.send_response(404)
            self.end_headers()
    
    def do_POST(self):
        if self.path == '/api/users':
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            
            try:
                user_data = json.loads(post_data.decode())
                # 处理用户数据
                response = {'status': 'success', 'user': user_data}
                
                self.send_response(201)
                self.send_header('Content-Type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(response).encode())
            except json.JSONDecodeError:
                self.send_response(400)
                self.end_headers()

# 启动服务器
server = HTTPServer(('localhost', 8000), RequestHandler)
print("Python 服务器运行在 http://localhost:8000")
server.serve_forever()

# 使用 Flask 的简化版本
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/')
def home():
    return 'Hello from Flask!'

@app.route('/api/users', methods=['GET'])
def get_users():
    users = [
        {'id': 1, 'name': 'Alice'},
        {'id': 2, 'name': 'Bob'}
    ]
    return jsonify(users)

@app.route('/api/users', methods=['POST'])
def create_user():
    user_data = request.get_json()
    response = {'status': 'success', 'user': user_data}
    return jsonify(response), 201

if __name__ == '__main__':
    app.run(host='localhost', port=8000, debug=True)
```

</Tab>

<Tab value="Node.js HTTP 服务器">

```javascript
// Node.js 内置 HTTP 服务器
const http = require('http');
const url = require('url');
const querystring = require('querystring');

const server = http.createServer((req, res) => {
    const parsedUrl = url.parse(req.url, true);
    const method = req.method;
    const pathname = parsedUrl.pathname;
    const query = parsedUrl.query;
    
    // 设置 CORS 头
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (method === 'GET' && pathname === '/') {
        res.writeHead(200, { 'Content-Type': 'text/plain' });
        res.end('Hello from Node.js!');
        
    } else if (method === 'GET' && pathname === '/api/users') {
        const users = [
            { id: 1, name: 'Alice' },
            { id: 2, name: 'Bob' }
        ];
        
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(users));
        
    } else if (method === 'POST' && pathname === '/api/users') {
        let body = '';
        
        req.on('data', chunk => {
            body += chunk.toString();
        });
        
        req.on('end', () => {
            try {
                const userData = JSON.parse(body);
                const response = { status: 'success', user: userData };
                
                res.writeHead(201, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify(response));
            } catch (error) {
                res.writeHead(400, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Invalid JSON' }));
            }
        });
        
    } else {
        res.writeHead(404, { 'Content-Type': 'text/plain' });
        res.end('Not Found');
    }
});

server.listen(8000, 'localhost', () => {
    console.log('Node.js 服务器运行在 http://localhost:8000');
});

// 使用 Express 的简化版本
const express = require('express');
const app = express();

app.use(express.json());

app.get('/', (req, res) => {
    res.send('Hello from Express!');
});

app.get('/api/users', (req, res) => {
    const users = [
        { id: 1, name: 'Alice' },
        { id: 2, name: 'Bob' }
    ];
    res.json(users);
});

app.post('/api/users', (req, res) => {
    const userData = req.body;
    const response = { status: 'success', user: userData };
    res.status(201).json(response);
});

app.listen(8000, () => {
    console.log('Express 服务器运行在 http://localhost:8000');
});
```

</Tab>

</Tabs>

## 3. 文件系统操作对比

<Tabs items={['Python 文件操作', 'Node.js 文件操作']}>

<Tab value="Python 文件操作">

```python
# Python 文件系统操作
import os
import shutil
import json
import asyncio
import aiofiles
from pathlib import Path

# 同步文件操作
def sync_file_operations():
    # 读取文件
    try:
        with open('data.txt', 'r', encoding='utf-8') as file:
            content = file.read()
            print(f"文件内容: {content}")
    except FileNotFoundError:
        print("文件不存在")
    
    # 写入文件
    with open('output.txt', 'w', encoding='utf-8') as file:
        file.write("Hello from Python!")
    
    # JSON 操作
    data = {'name': 'Alice', 'age': 30}
    with open('data.json', 'w', encoding='utf-8') as file:
        json.dump(data, file, ensure_ascii=False, indent=2)
    
    with open('data.json', 'r', encoding='utf-8') as file:
        loaded_data = json.load(file)
        print(f"JSON 数据: {loaded_data}")
    
    # 目录操作
    os.makedirs('test_dir', exist_ok=True)
    
    # 遍历目录
    for root, dirs, files in os.walk('.'):
        for file in files:
            file_path = os.path.join(root, file)
            print(f"文件: {file_path}")
    
    # 文件信息
    stat = os.stat('data.json')
    print(f"文件大小: {stat.st_size} 字节")
    print(f"修改时间: {stat.st_mtime}")

# 异步文件操作
async def async_file_operations():
    # 异步读取文件
    try:
        async with aiofiles.open('data.txt', 'r', encoding='utf-8') as file:
            content = await file.read()
            print(f"异步读取: {content}")
    except FileNotFoundError:
        print("文件不存在")
    
    # 异步写入文件
    async with aiofiles.open('async_output.txt', 'w', encoding='utf-8') as file:
        await file.write("Hello from async Python!")
    
    # 并发文件操作
    async def process_file(filename):
        async with aiofiles.open(filename, 'w', encoding='utf-8') as file:
            await file.write(f"内容 - {filename}")
        return f"处理完成: {filename}"
    
    tasks = [process_file(f'file_{i}.txt') for i in range(5)]
    results = await asyncio.gather(*tasks)
    print("并发文件操作结果:", results)

# 执行文件操作
sync_file_operations()
asyncio.run(async_file_operations())

# 使用 pathlib (推荐)
def modern_file_operations():
    # 路径操作
    path = Path('data/users/profile.json')
    path.parent.mkdir(parents=True, exist_ok=True)
    
    # 写入 JSON
    data = {'users': [{'id': 1, 'name': 'Alice'}]}
    path.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding='utf-8')
    
    # 读取 JSON
    content = path.read_text(encoding='utf-8')
    loaded_data = json.loads(content)
    print(f"现代方式读取: {loaded_data}")
    
    # 路径信息
    print(f"文件存在: {path.exists()}")
    print(f"是否为文件: {path.is_file()}")
    print(f"文件大小: {path.stat().st_size}")

modern_file_operations()
```

</Tab>

<Tab value="Node.js 文件操作">

```javascript
// Node.js 文件系统操作
const fs = require('fs');
const fsPromises = require('fs').promises;
const path = require('path');

// 同步文件操作（阻塞）
function syncFileOperations() {
    try {
        // 读取文件
        const content = fs.readFileSync('data.txt', 'utf8');
        console.log(`文件内容: ${content}`);
    } catch (error) {
        console.log('文件不存在');
    }
    
    // 写入文件
    fs.writeFileSync('output.txt', 'Hello from Node.js!');
    
    // JSON 操作
    const data = { name: 'Alice', age: 30 };
    fs.writeFileSync('data.json', JSON.stringify(data, null, 2));
    
    const loadedData = JSON.parse(fs.readFileSync('data.json', 'utf8'));
    console.log(`JSON 数据: ${JSON.stringify(loadedData)}`);
    
    // 目录操作
    if (!fs.existsSync('test_dir')) {
        fs.mkdirSync('test_dir', { recursive: true });
    }
    
    // 遍历目录
    function walkDir(dir) {
        const files = fs.readdirSync(dir);
        files.forEach(file => {
            const filePath = path.join(dir, file);
            const stat = fs.statSync(filePath);
            
            if (stat.isDirectory()) {
                walkDir(filePath);
            } else {
                console.log(`文件: ${filePath}`);
            }
        });
    }
    
    walkDir('.');
    
    // 文件信息
    const stat = fs.statSync('data.json');
    console.log(`文件大小: ${stat.size} 字节`);
    console.log(`修改时间: ${stat.mtime}`);
}

// 异步文件操作（回调方式）
function callbackFileOperations() {
    // 读取文件
    fs.readFile('data.txt', 'utf8', (err, content) => {
        if (err) {
            console.log('文件不存在');
        } else {
            console.log(`回调读取: ${content}`);
        }
    });
    
    // 写入文件
    fs.writeFile('callback_output.txt', 'Hello from callback!', (err) => {
        if (err) throw err;
        console.log('回调写入完成');
    });
    
    // 并发文件操作
    const filenames = Array.from({ length: 5 }, (_, i) => `callback_file_${i}.txt`);
    let completed = 0;
    
    filenames.forEach((filename, index) => {
        fs.writeFile(filename, `内容 - ${filename}`, (err) => {
            if (err) throw err;
            completed++;
            console.log(`回调处理完成: ${filename}`);
            
            if (completed === filenames.length) {
                console.log('所有回调文件操作完成');
            }
        });
    });
}

// 异步文件操作（Promise 方式）
async function promiseFileOperations() {
    try {
        // 读取文件
        const content = await fsPromises.readFile('data.txt', 'utf8');
        console.log(`Promise 读取: ${content}`);
    } catch (error) {
        console.log('文件不存在');
    }
    
    // 写入文件
    await fsPromises.writeFile('promise_output.txt', 'Hello from Promise!');
    console.log('Promise 写入完成');
    
    // JSON 操作
    const data = { users: [{ id: 1, name: 'Alice' }] };
    await fsPromises.writeFile('promise_data.json', JSON.stringify(data, null, 2));
    
    const loadedData = JSON.parse(await fsPromises.readFile('promise_data.json', 'utf8'));
    console.log(`Promise JSON: ${JSON.stringify(loadedData)}`);
    
    // 目录操作
    await fsPromises.mkdir('data/users', { recursive: true });
    
    // 并发文件操作
    const processFile = async (filename) => {
        await fsPromises.writeFile(filename, `内容 - ${filename}`);
        return `Promise 处理完成: ${filename}`;
    };
    
    const tasks = Array.from({ length: 5 }, (_, i) => 
        processFile(`promise_file_${i}.txt`)
    );
    
    const results = await Promise.all(tasks);
    console.log('Promise 并发结果:', results);
    
    // 文件信息
    const stat = await fsPromises.stat('promise_data.json');
    console.log(`Promise 文件大小: ${stat.size} 字节`);
    console.log(`Promise 修改时间: ${stat.mtime}`);
}

// 现代异步文件操作（Node.js 14+）
async function modernFileOperations() {
    try {
        // 使用 fs/promises
        const { readFile, writeFile, mkdir, stat } = require('fs/promises');
        
        // 路径操作
        const filePath = path.join('data', 'users', 'profile.json');
        await mkdir(path.dirname(filePath), { recursive: true });
        
        // 写入 JSON
        const data = { users: [{ id: 1, name: 'Alice' }] };
        await writeFile(filePath, JSON.stringify(data, null, 2));
        
        // 读取 JSON
        const content = await readFile(filePath, 'utf8');
        const loadedData = JSON.parse(content);
        console.log(`现代方式读取: ${JSON.stringify(loadedData)}`);
        
        // 文件信息
        const filestat = await stat(filePath);
        console.log(`文件存在: ${filestat.isFile()}`);
        console.log(`文件大小: ${filestat.size}`);
        
        // Stream 操作（处理大文件）
        const { createReadStream, createWriteStream } = require('fs');
        const readline = require('readline');
        
        // 创建大文件
        const writeStream = createWriteStream('large_file.txt');
        for (let i = 0; i < 100000; i++) {
            writeStream.write(`Line ${i}: This is a test line\n`);
        }
        writeStream.end();
        
        // 逐行读取大文件
        const fileStream = createReadStream('large_file.txt');
        const rl = readline.createInterface({
            input: fileStream,
            crlfDelay: Infinity
        });
        
        let lineCount = 0;
        for await (const line of rl) {
            lineCount++;
            if (lineCount <= 5) {
                console.log(`Stream 读取行 ${lineCount}: ${line}`);
            }
        }
        console.log(`Stream 总行数: ${lineCount}`);
        
    } catch (error) {
        console.error('现代文件操作错误:', error);
    }
}

// 执行文件操作
console.log('=== 同步文件操作 ===');
syncFileOperations();

console.log('\n=== 回调文件操作 ===');
callbackFileOperations();

console.log('\n=== Promise 文件操作 ===');
promiseFileOperations().then(() => {
    console.log('\n=== 现代文件操作 ===');
    return modernFileOperations();
});
```

</Tab>

</Tabs>

## 4. 数据库集成对比

### SQL 数据库操作

<Tabs items={['Python + SQLAlchemy', 'Node.js + Sequelize']}>

<Tab value="Python + SQLAlchemy">

```python
# Python SQLAlchemy ORM
from sqlalchemy import create_engine, Column, Integer, String, DateTime, ForeignKey, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
from sqlalchemy.sql import func
import asyncio
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine

Base = declarative_base()

# 模型定义
class User(Base):
    __tablename__ = 'users'
    
    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    created_at = Column(DateTime, server_default=func.now())
    
    posts = relationship("Post", back_populates="author")
    
    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

class Post(Base):
    __tablename__ = 'posts'
    
    id = Column(Integer, primary_key=True)
    title = Column(String(200), nullable=False)
    content = Column(Text)
    author_id = Column(Integer, ForeignKey('users.id'))
    created_at = Column(DateTime, server_default=func.now())
    
    author = relationship("User", back_populates="posts")
    
    def to_dict(self):
        return {
            'id': self.id,
            'title': self.title,
            'content': self.content,
            'author_id': self.author_id,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }

# 同步数据库操作
def sync_database_operations():
    engine = create_engine('sqlite:///blog.db', echo=True)
    Base.metadata.create_all(engine)
    Session = sessionmaker(bind=engine)
    session = Session()
    
    try:
        # 创建用户
        user = User(username='alice', email='alice@example.com')
        session.add(user)
        session.commit()
        
        # 创建文章
        post = Post(title='我的第一篇文章', content='这是内容...', author_id=user.id)
        session.add(post)
        session.commit()
        
        # 查询操作
        users = session.query(User).all()
        print("所有用户:", [user.to_dict() for user in users])
        
        # 关联查询
        posts_with_authors = session.query(Post).join(User).all()
        for post in posts_with_authors:
            print(f"文章: {post.title}, 作者: {post.author.username}")
        
        # 复杂查询
        recent_posts = session.query(Post)\
            .join(User)\
            .filter(User.username.like('%alice%'))\
            .order_by(Post.created_at.desc())\
            .limit(10).all()
        
        print("最近文章:", [post.to_dict() for post in recent_posts])
        
    finally:
        session.close()

# 异步数据库操作
async def async_database_operations():
    engine = create_async_engine('sqlite+aiosqlite:///async_blog.db', echo=True)
    
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    
    async with AsyncSession(engine) as session:
        try:
            # 创建用户
            user = User(username='bob', email='bob@example.com')
            session.add(user)
            await session.commit()
            
            # 创建文章
            post = Post(title='异步文章', content='异步内容...', author_id=user.id)
            session.add(post)
            await session.commit()
            
            # 异步查询
            from sqlalchemy import select
            
            result = await session.execute(select(User))
            users = result.scalars().all()
            print("异步用户:", [user.to_dict() for user in users])
            
            # 异步关联查询
            result = await session.execute(
                select(Post).join(User).where(User.username == 'bob')
            )
            posts = result.scalars().all()
            print("异步文章:", [post.to_dict() for post in posts])
            
        finally:
            await session.close()
    
    await engine.dispose()

# 执行数据库操作
sync_database_operations()
asyncio.run(async_database_operations())
```

</Tab>

<Tab value="Node.js + Sequelize">

```javascript
// Node.js Sequelize ORM
const { Sequelize, DataTypes, Op } = require('sequelize');

// 数据库连接
const sequelize = new Sequelize({
    dialect: 'sqlite',
    storage: 'blog.db',
    logging: console.log
});

// 模型定义
const User = sequelize.define('User', {
    username: {
        type: DataTypes.STRING(50),
        allowNull: false,
        unique: true
    },
    email: {
        type: DataTypes.STRING(100),
        allowNull: false,
        unique: true
    }
}, {
    tableName: 'users',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at'
});

const Post = sequelize.define('Post', {
    title: {
        type: DataTypes.STRING(200),
        allowNull: false
    },
    content: {
        type: DataTypes.TEXT
    }
}, {
    tableName: 'posts',
    timestamps: true,
    createdAt: 'created_at',
    updatedAt: 'updated_at'
});

// 关联关系
User.hasMany(Post, { 
    foreignKey: 'author_id',
    as: 'posts'
});

Post.belongsTo(User, { 
    foreignKey: 'author_id',
    as: 'author'
});

// 同步数据库操作（不推荐在生产环境）
async function syncDatabaseOperations() {
    try {
        // 同步模型到数据库
        await sequelize.sync({ force: true });
        console.log('数据库同步完成');
        
        // 创建用户
        const user = await User.create({
            username: 'alice',
            email: 'alice@example.com'
        });
        console.log('用户创建:', user.toJSON());
        
        // 创建文章
        const post = await Post.create({
            title: '我的第一篇文章',
            content: '这是内容...',
            author_id: user.id
        });
        console.log('文章创建:', post.toJSON());
        
        // 查询操作
        const users = await User.findAll();
        console.log('所有用户:', users.map(u => u.toJSON()));
        
        // 关联查询
        const postsWithAuthors = await Post.findAll({
            include: [{
                model: User,
                as: 'author'
            }]
        });
        
        postsWithAuthors.forEach(post => {
            console.log(`文章: ${post.title}, 作者: ${post.author.username}`);
        });
        
        // 复杂查询
        const recentPosts = await Post.findAll({
            include: [{
                model: User,
                as: 'author',
                where: {
                    username: {
                        [Op.like]: '%alice%'
                    }
                }
            }],
            order: [['created_at', 'DESC']],
            limit: 10
        });
        
        console.log('最近文章:', recentPosts.map(p => p.toJSON()));
        
        // 事务操作
        const transaction = await sequelize.transaction();
        try {
            const newUser = await User.create({
                username: 'charlie',
                email: 'charlie@example.com'
            }, { transaction });
            
            await Post.create({
                title: '事务文章',
                content: '事务内容...',
                author_id: newUser.id
            }, { transaction });
            
            await transaction.commit();
            console.log('事务提交成功');
        } catch (error) {
            await transaction.rollback();
            console.error('事务回滚:', error);
        }
        
    } catch (error) {
        console.error('数据库操作错误:', error);
    }
}

// 异步数据库服务类
class DatabaseService {
    static async initialize() {
        try {
            await sequelize.authenticate();
            console.log('数据库连接成功');
            
            await sequelize.sync({ alter: true });
            console.log('数据库模型同步完成');
        } catch (error) {
            console.error('数据库初始化失败:', error);
            throw error;
        }
    }
    
    static async createUser(userData) {
        try {
            const user = await User.create(userData);
            return user.toJSON();
        } catch (error) {
            if (error.name === 'SequelizeUniqueConstraintError') {
                throw new Error('用户名或邮箱已存在');
            }
            throw error;
        }
    }
    
    static async getUserWithPosts(userId) {
        const user = await User.findByPk(userId, {
            include: [{
                model: Post,
                as: 'posts',
                order: [['created_at', 'DESC']]
            }]
        });
        
        if (!user) {
            throw new Error('用户不存在');
        }
        
        return user.toJSON();
    }
    
    static async searchPosts(searchTerm, page = 1, limit = 10) {
        const offset = (page - 1) * limit;
        
        const { count, rows } = await Post.findAndCountAll({
            where: {
                [Op.or]: [
                    { title: { [Op.like]: `%${searchTerm}%` } },
                    { content: { [Op.like]: `%${searchTerm}%` } }
                ]
            },
            include: [{
                model: User,
                as: 'author',
                attributes: ['id', 'username']
            }],
            order: [['created_at', 'DESC']],
            limit,
            offset
        });
        
        return {
            posts: rows.map(post => post.toJSON()),
            pagination: {
                page,
                limit,
                total: count,
                pages: Math.ceil(count / limit)
            }
        };
    }
    
    static async bulkCreatePosts(postsData, authorId) {
        const transaction = await sequelize.transaction();
        
        try {
            const posts = postsData.map(postData => ({
                ...postData,
                author_id: authorId
            }));
            
            const createdPosts = await Post.bulkCreate(posts, {
                transaction,
                returning: true
            });
            
            await transaction.commit();
            return createdPosts.map(post => post.toJSON());
        } catch (error) {
            await transaction.rollback();
            throw error;
        }
    }
    
    static async cleanup() {
        await sequelize.close();
        console.log('数据库连接已关闭');
    }
}

// 原生 SQL 查询示例
async function rawSQLOperations() {
    try {
        // 原生查询
        const [results, metadata] = await sequelize.query(`
            SELECT u.username, COUNT(p.id) as post_count
            FROM users u
            LEFT JOIN posts p ON u.id = p.author_id
            GROUP BY u.id, u.username
            ORDER BY post_count DESC
        `);
        
        console.log('用户文章统计:', results);
        
        // 参数化查询
        const posts = await sequelize.query(`
            SELECT p.title, p.created_at, u.username
            FROM posts p
            JOIN users u ON p.author_id = u.id
            WHERE p.created_at > :date
            ORDER BY p.created_at DESC
        `, {
            replacements: { date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) },
            type: sequelize.QueryTypes.SELECT
        });
        
        console.log('最近一周的文章:', posts);
        
    } catch (error) {
        console.error('原生 SQL 查询错误:', error);
    }
}

// 执行数据库操作
async function main() {
    try {
        await DatabaseService.initialize();
        await syncDatabaseOperations();
        await rawSQLOperations();
        
        // 测试服务方法
        const user = await DatabaseService.createUser({
            username: 'david',
            email: 'david@example.com'
        });
        
        const userWithPosts = await DatabaseService.getUserWithPosts(user.id);
        console.log('用户详情:', userWithPosts);
        
        const searchResults = await DatabaseService.searchPosts('文章', 1, 5);
        console.log('搜索结果:', searchResults);
        
    } catch (error) {
        console.error('主函数错误:', error);
    } finally {
        await DatabaseService.cleanup();
    }
}

main();
```

</Tab>

</Tabs>

### NoSQL 数据库操作

<Tabs items={['Python + MongoDB', 'Node.js + MongoDB']}>

<Tab value="Python + MongoDB">

```python
# Python MongoDB 操作
from pymongo import MongoClient
from motor.motor_asyncio import AsyncIOMotorClient
import asyncio
from datetime import datetime
from bson import ObjectId

# 同步 MongoDB 操作
def sync_mongodb_operations():
    # 连接数据库
    client = MongoClient('mongodb://localhost:27017/')
    db = client['blog_db']
    users_collection = db['users']
    posts_collection = db['posts']
    
    try:
        # 插入用户
        user_doc = {
            'username': 'alice',
            'email': 'alice@example.com',
            'created_at': datetime.utcnow()
        }
        user_result = users_collection.insert_one(user_doc)
        user_id = user_result.inserted_id
        print(f"用户创建: {user_id}")
        
        # 插入文章
        post_doc = {
            'title': '我的第一篇文章',
            'content': '这是内容...',
            'author_id': user_id,
            'tags': ['python', 'mongodb'],
            'created_at': datetime.utcnow()
        }
        post_result = posts_collection.insert_one(post_doc)
        print(f"文章创建: {post_result.inserted_id}")
        
        # 查询操作
        users = list(users_collection.find())
        print("所有用户:", users)
        
        # 复杂查询
        recent_posts = list(posts_collection.find(
            {'tags': {'$in': ['python']}},
            {'title': 1, 'created_at': 1, 'author_id': 1}
        ).sort('created_at', -1).limit(10))
        
        print("最近文章:", recent_posts)
        
        # 聚合查询
        pipeline = [
            {
                '$lookup': {
                    'from': 'users',
                    'localField': 'author_id',
                    'foreignField': '_id',
                    'as': 'author'
                }
            },
            {
                '$unwind': '$author'
            },
            {
                '$project': {
                    'title': 1,
                    'author.username': 1,
                    'created_at': 1
                }
            },
            {
                '$sort': {'created_at': -1}
            }
        ]
        
        posts_with_authors = list(posts_collection.aggregate(pipeline))
        print("文章与作者:", posts_with_authors)
        
        # 更新操作
        update_result = posts_collection.update_one(
            {'_id': post_result.inserted_id},
            {
                '$set': {'title': '更新的标题'},
                '$push': {'tags': 'updated'}
            }
        )
        print(f"更新结果: {update_result.modified_count}")
        
        # 批量操作
        bulk_posts = [
            {
                'title': f'批量文章 {i}',
                'content': f'内容 {i}',
                'author_id': user_id,
                'created_at': datetime.utcnow()
            }
            for i in range(5)
        ]
        bulk_result = posts_collection.insert_many(bulk_posts)
        print(f"批量插入: {len(bulk_result.inserted_ids)}")
        
    finally:
        client.close()

# 异步 MongoDB 操作
async def async_mongodb_operations():
    # 异步连接
    client = AsyncIOMotorClient('mongodb://localhost:27017/')
    db = client['async_blog_db']
    users_collection = db['users']
    posts_collection = db['posts']
    
    try:
        # 异步插入用户
        user_doc = {
            'username': 'bob',
            'email': 'bob@example.com',
            'created_at': datetime.utcnow()
        }
        user_result = await users_collection.insert_one(user_doc)
        user_id = user_result.inserted_id
        print(f"异步用户创建: {user_id}")
        
        # 异步插入文章
        post_doc = {
            'title': '异步文章',
            'content': '异步内容...',
            'author_id': user_id,
            'created_at': datetime.utcnow()
        }
        post_result = await posts_collection.insert_one(post_doc)
        print(f"异步文章创建: {post_result.inserted_id}")
        
        # 异步查询
        users = []
        async for user in users_collection.find():
            users.append(user)
        print("异步用户:", users)
        
        # 异步聚合
        pipeline = [
            {
                '$lookup': {
                    'from': 'users',
                    'localField': 'author_id',
                    'foreignField': '_id',
                    'as': 'author'
                }
            }
        ]
        
        posts_with_authors = []
        async for post in posts_collection.aggregate(pipeline):
            posts_with_authors.append(post)
        print("异步聚合结果:", posts_with_authors)
        
        # 并发操作
        tasks = []
        for i in range(5):
            task = posts_collection.insert_one({
                'title': f'并发文章 {i}',
                'content': f'并发内容 {i}',
                'author_id': user_id,
                'created_at': datetime.utcnow()
            })
            tasks.append(task)
        
        results = await asyncio.gather(*tasks)
        print(f"并发插入: {len(results)} 个文章")
        
    finally:
        client.close()

# 执行 MongoDB 操作
sync_mongodb_operations()
asyncio.run(async_mongodb_operations())
```

</Tab>

<Tab value="Node.js + MongoDB">

```javascript
// Node.js MongoDB 操作
const { MongoClient, ObjectId } = require('mongodb');
const mongoose = require('mongoose');

// 使用原生 MongoDB 驱动
async function nativeMongoDB() {
    const client = new MongoClient('mongodb://localhost:27017/');
    
    try {
        await client.connect();
        console.log('MongoDB 连接成功');
        
        const db = client.db('blog_db');
        const usersCollection = db.collection('users');
        const postsCollection = db.collection('posts');
        
        // 插入用户
        const userDoc = {
            username: 'alice',
            email: 'alice@example.com',
            createdAt: new Date()
        };
        const userResult = await usersCollection.insertOne(userDoc);
        const userId = userResult.insertedId;
        console.log(`用户创建: ${userId}`);
        
        // 插入文章
        const postDoc = {
            title: '我的第一篇文章',
            content: '这是内容...',
            authorId: userId,
            tags: ['javascript', 'mongodb'],
            createdAt: new Date()
        };
        const postResult = await postsCollection.insertOne(postDoc);
        console.log(`文章创建: ${postResult.insertedId}`);
        
        // 查询操作
        const users = await usersCollection.find().toArray();
        console.log('所有用户:', users);
        
        // 复杂查询
        const recentPosts = await postsCollection.find(
            { tags: { $in: ['javascript'] } },
            { projection: { title: 1, createdAt: 1, authorId: 1 } }
        ).sort({ createdAt: -1 }).limit(10).toArray();
        
        console.log('最近文章:', recentPosts);
        
        // 聚合查询
        const pipeline = [
            {
                $lookup: {
                    from: 'users',
                    localField: 'authorId',
                    foreignField: '_id',
                    as: 'author'
                }
            },
            {
                $unwind: '$author'
            },
            {
                $project: {
                    title: 1,
                    'author.username': 1,
                    createdAt: 1
                }
            },
            {
                $sort: { createdAt: -1 }
            }
        ];
        
        const postsWithAuthors = await postsCollection.aggregate(pipeline).toArray();
        console.log('文章与作者:', postsWithAuthors);
        
        // 更新操作
        const updateResult = await postsCollection.updateOne(
            { _id: postResult.insertedId },
            {
                $set: { title: '更新的标题' },
                $push: { tags: 'updated' }
            }
        );
        console.log(`更新结果: ${updateResult.modifiedCount}`);
        
        // 批量操作
        const bulkPosts = Array.from({ length: 5 }, (_, i) => ({
            title: `批量文章 ${i}`,
            content: `内容 ${i}`,
            authorId: userId,
            createdAt: new Date()
        }));
        
        const bulkResult = await postsCollection.insertMany(bulkPosts);
        console.log(`批量插入: ${bulkResult.insertedCount}`);
        
        // 事务操作（需要副本集）
        const session = client.startSession();
        try {
            await session.withTransaction(async () => {
                await usersCollection.insertOne({
                    username: 'charlie',
                    email: 'charlie@example.com',
                    createdAt: new Date()
                }, { session });
                
                await postsCollection.insertOne({
                    title: '事务文章',
                    content: '事务内容',
                    authorId: userId,
                    createdAt: new Date()
                }, { session });
            });
            console.log('事务完成');
        } finally {
            await session.endSession();
        }
        
    } finally {
        await client.close();
    }
}

// 使用 Mongoose ODM
async function mongooseOperations() {
    try {
        await mongoose.connect('mongodb://localhost:27017/mongoose_blog');
        console.log('Mongoose 连接成功');
        
        // 用户模式
        const userSchema = new mongoose.Schema({
            username: { type: String, required: true, unique: true },
            email: { type: String, required: true, unique: true },
            createdAt: { type: Date, default: Date.now }
        });
        
        // 文章模式
        const postSchema = new mongoose.Schema({
            title: { type: String, required: true },
            content: String,
            author: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
            tags: [String],
            createdAt: { type: Date, default: Date.now }
        });
        
        // 添加实例方法
        userSchema.methods.getPublicProfile = function() {
            return {
                id: this._id,
                username: this.username,
                createdAt: this.createdAt
            };
        };
        
        // 添加静态方法
        userSchema.statics.findByUsername = function(username) {
            return this.findOne({ username });
        };
        
        // 添加中间件
        postSchema.pre('save', function(next) {
            console.log(`保存文章: ${this.title}`);
            next();
        });
        
        const User = mongoose.model('User', userSchema);
        const Post = mongoose.model('Post', postSchema);
        
        // 创建用户
        const user = new User({
            username: 'alice',
            email: 'alice@example.com'
        });
        await user.save();
        console.log('Mongoose 用户创建:', user.getPublicProfile());
        
        // 创建文章
        const post = new Post({
            title: 'Mongoose 文章',
            content: 'Mongoose 内容...',
            author: user._id,
            tags: ['mongoose', 'mongodb']
        });
        await post.save();
        console.log('Mongoose 文章创建:', post.toObject());
        
        // 查询操作
        const users = await User.find();
        console.log('Mongoose 用户:', users.map(u => u.getPublicProfile()));
        
        // 关联查询
        const postsWithAuthors = await Post.find()
            .populate('author', 'username email')
            .sort({ createdAt: -1 });
        
        console.log('Mongoose 文章与作者:', postsWithAuthors);
        
        // 静态方法使用
        const foundUser = await User.findByUsername('alice');
        console.log('按用户名查找:', foundUser?.getPublicProfile());
        
        // 聚合操作
        const userStats = await Post.aggregate([
            {
                $group: {
                    _id: '$author',
                    postCount: { $sum: 1 },
                    lastPost: { $max: '$createdAt' }
                }
            },
            {
                $lookup: {
                    from: 'users',
                    localField: '_id',
                    foreignField: '_id',
                    as: 'userInfo'
                }
            },
            {
                $unwind: '$userInfo'
            },
            {
                $project: {
                    username: '$userInfo.username',
                    postCount: 1,
                    lastPost: 1
                }
            }
        ]);
        
        console.log('Mongoose 用户统计:', userStats);
        
        // 批量操作
        const bulkOps = [
            {
                insertOne: {
                    document: {
                        title: '批量文章 1',
                        content: '内容 1',
                        author: user._id
                    }
                }
            },
            {
                updateOne: {
                    filter: { _id: post._id },
                    update: { $push: { tags: 'bulk-updated' } }
                }
            }
        ];
        
        const bulkResult = await Post.bulkWrite(bulkOps);
        console.log('Mongoose 批量操作:', bulkResult);
        
    } catch (error) {
        console.error('Mongoose 错误:', error);
    } finally {
        await mongoose.disconnect();
    }
}

// MongoDB 服务类
class MongoDBService {
    constructor() {
        this.client = null;
        this.db = null;
    }
    
    async connect(uri = 'mongodb://localhost:27017/', dbName = 'service_blog') {
        this.client = new MongoClient(uri);
        await this.client.connect();
        this.db = this.client.db(dbName);
        console.log('MongoDB 服务连接成功');
    }
    
    async createUser(userData) {
        try {
            const result = await this.db.collection('users').insertOne({
                ...userData,
                createdAt: new Date()
            });
            return { id: result.insertedId, ...userData };
        } catch (error) {
            if (error.code === 11000) {
                throw new Error('用户名或邮箱已存在');
            }
            throw error;
        }
    }
    
    async getUserPosts(userId) {
        const pipeline = [
            { $match: { _id: ObjectId(userId) } },
            {
                $lookup: {
                    from: 'posts',
                    localField: '_id',
                    foreignField: 'authorId',
                    as: 'posts'
                }
            },
            {
                $project: {
                    username: 1,
                    email: 1,
                    'posts.title': 1,
                    'posts.createdAt': 1
                }
            }
        ];
        
        const result = await this.db.collection('users').aggregate(pipeline).toArray();
        return result[0] || null;
    }
    
    async searchPosts(searchTerm, page = 1, limit = 10) {
        const skip = (page - 1) * limit;
        
        const filter = {
            $or: [
                { title: { $regex: searchTerm, $options: 'i' } },
                { content: { $regex: searchTerm, $options: 'i' } }
            ]
        };
        
        const [posts, total] = await Promise.all([
            this.db.collection('posts')
                .find(filter)
                .sort({ createdAt: -1 })
                .skip(skip)
                .limit(limit)
                .toArray(),
            this.db.collection('posts').countDocuments(filter)
        ]);
        
        return {
            posts,
            pagination: {
                page,
                limit,
                total,
                pages: Math.ceil(total / limit)
            }
        };
    }
    
    async disconnect() {
        if (this.client) {
            await this.client.close();
            console.log('MongoDB 服务连接已关闭');
        }
    }
}

// 执行操作
async function main() {
    console.log('=== 原生 MongoDB 操作 ===');
    await nativeMongoDB();
    
    console.log('\n=== Mongoose ODM 操作 ===');
    await mongooseOperations();
    
    console.log('\n=== MongoDB 服务类 ===');
    const service = new MongoDBService();
    try {
        await service.connect();
        
        const user = await service.createUser({
            username: 'service_user',
            email: 'service@example.com'
        });
        console.log('服务创建用户:', user);
        
        const searchResults = await service.searchPosts('文章', 1, 5);
        console.log('服务搜索结果:', searchResults);
        
    } finally {
        await service.disconnect();
    }
}

main().catch(console.error);
```

</Tab>

</Tabs>

## 5. 实时通信对比

<Tabs items={['Python WebSocket', 'Node.js WebSocket']}>

<Tab value="Python WebSocket">

```python
# Python WebSocket 服务器
import asyncio
import websockets
import json
from datetime import datetime

# 存储连接的客户端
connected_clients = set()

async def websocket_handler(websocket, path):
    # 新客户端连接
    connected_clients.add(websocket)
    client_id = id(websocket)
    print(f"客户端 {client_id} 连接")
    
    try:
        # 发送欢迎消息
        welcome_msg = {
            'type': 'welcome',
            'message': f'欢迎客户端 {client_id}',
            'timestamp': datetime.now().isoformat()
        }
        await websocket.send(json.dumps(welcome_msg))
        
        # 广播新用户加入
        join_msg = {
            'type': 'user_join',
            'user_id': client_id,
            'timestamp': datetime.now().isoformat()
        }
        await broadcast_message(join_msg, exclude=websocket)
        
        # 处理客户端消息
        async for message in websocket:
            try:
                data = json.loads(message)
                await handle_message(websocket, data)
            except json.JSONDecodeError:
                error_msg = {
                    'type': 'error',
                    'message': '无效的 JSON 格式'
                }
                await websocket.send(json.dumps(error_msg))
                
    except websockets.exceptions.ConnectionClosed:
        print(f"客户端 {client_id} 断开连接")
    finally:
        connected_clients.remove(websocket)
        
        # 广播用户离开
        leave_msg = {
            'type': 'user_leave',
            'user_id': client_id,
            'timestamp': datetime.now().isoformat()
        }
        await broadcast_message(leave_msg)

async def handle_message(websocket, data):
    message_type = data.get('type')
    client_id = id(websocket)
    
    if message_type == 'chat':
        # 聊天消息
        chat_msg = {
            'type': 'chat',
            'user_id': client_id,
            'message': data.get('message', ''),
            'timestamp': datetime.now().isoformat()
        }
        await broadcast_message(chat_msg)
        
    elif message_type == 'private':
        # 私人消息
        target_id = data.get('target_id')
        target_client = None
        
        for client in connected_clients:
            if id(client) == target_id:
                target_client = client
                break
        
        if target_client:
            private_msg = {
                'type': 'private',
                'from_user_id': client_id,
                'message': data.get('message', ''),
                'timestamp': datetime.now().isoformat()
            }
            await target_client.send(json.dumps(private_msg))
        else:
            error_msg = {
                'type': 'error',
                'message': '目标用户不存在'
            }
            await websocket.send(json.dumps(error_msg))
            
    elif message_type == 'ping':
        # 心跳检测
        pong_msg = {
            'type': 'pong',
            'timestamp': datetime.now().isoformat()
        }
        await websocket.send(json.dumps(pong_msg))

async def broadcast_message(message, exclude=None):
    """广播消息给所有连接的客户端"""
    if not connected_clients:
        return
    
    message_str = json.dumps(message)
    tasks = []
    
    for client in connected_clients:
        if client != exclude:
            tasks.append(client.send(message_str))
    
    if tasks:
        await asyncio.gather(*tasks, return_exceptions=True)

# 定时任务 - 服务器状态广播
async def status_broadcaster():
    while True:
        await asyncio.sleep(30)  # 每30秒广播一次
        
        status_msg = {
            'type': 'server_status',
            'connected_clients': len(connected_clients),
            'timestamp': datetime.now().isoformat()
        }
        await broadcast_message(status_msg)

# 启动 WebSocket 服务器
async def start_server():
    print("启动 Python WebSocket 服务器在 ws://localhost:8765")
    
    # 启动状态广播任务
    asyncio.create_task(status_broadcaster())
    
    # 启动 WebSocket 服务器
    await websockets.serve(websocket_handler, "localhost", 8765)

if __name__ == "__main__":
    asyncio.run(start_server())

# 使用 FastAPI 的 WebSocket 示例
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse

app = FastAPI()

class ConnectionManager:
    def __init__(self):
        self.active_connections = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)
    
    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(f"你说: {data}", websocket)
            await manager.broadcast(f"客户端 #{client_id} 说: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"客户端 #{client_id} 离开了聊天室")

@app.get("/")
async def get():
    return HTMLResponse("""
    <!DOCTYPE html>
    <html>
        <head>
            <title>Chat</title>
        </head>
        <body>
            <h1>WebSocket Chat</h1>
            <form action="" onsubmit="sendMessage(event)">
                <input type="text" id="messageText" autocomplete="off"/>
                <button>Send</button>
            </form>
            <ul id='messages'>
            </ul>
            <script>
                var client_id = Date.now()
                var ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`);
                ws.onmessage = function(event) {
                    var messages = document.getElementById('messages')
                    var message = document.createElement('li')
                    var content = document.createTextNode(event.data)
                    message.appendChild(content)
                    messages.appendChild(message)
                };
                function sendMessage(event) {
                    var input = document.getElementById("messageText")
                    ws.send(input.value)
                    input.value = ''
                    event.preventDefault()
                }
            </script>
        </body>
    </html>
    """)
```

</Tab>

<Tab value="Node.js WebSocket">

```javascript
// Node.js WebSocket 服务器
const WebSocket = require('ws');
const http = require('http');
const express = require('express');

// 创建 Express 应用
const app = express();
const server = http.createServer(app);

// 存储连接的客户端
const clients = new Map();

// 创建 WebSocket 服务器
const wss = new WebSocket.Server({ server });

wss.on('connection', (ws, req) => {
    const clientId = Date.now() + Math.random();
    clients.set(clientId, ws);
    
    console.log(`客户端 ${clientId} 连接`);
    
    // 发送欢迎消息
    const welcomeMsg = {
        type: 'welcome',
        message: `欢迎客户端 ${clientId}`,
        clientId: clientId,
        timestamp: new Date().toISOString()
    };
    ws.send(JSON.stringify(welcomeMsg));
    
    // 广播新用户加入
    const joinMsg = {
        type: 'user_join',
        userId: clientId,
        timestamp: new Date().toISOString()
    };
    broadcast(joinMsg, clientId);
    
    // 处理消息
    ws.on('message', (data) => {
        try {
            const message = JSON.parse(data);
            handleMessage(ws, clientId, message);
        } catch (error) {
            const errorMsg = {
                type: 'error',
                message: '无效的 JSON 格式'
            };
            ws.send(JSON.stringify(errorMsg));
        }
    });
    
    // 处理连接关闭
    ws.on('close', () => {
        console.log(`客户端 ${clientId} 断开连接`);
        clients.delete(clientId);
        
        // 广播用户离开
        const leaveMsg = {
            type: 'user_leave',
            userId: clientId,
            timestamp: new Date().toISOString()
        };
        broadcast(leaveMsg);
    });
    
    // 处理错误
    ws.on('error', (error) => {
        console.error(`客户端 ${clientId} 错误:`, error);
        clients.delete(clientId);
    });
    
    // 心跳检测
    ws.isAlive = true;
    ws.on('pong', () => {
        ws.isAlive = true;
    });
});

function handleMessage(ws, clientId, data) {
    const messageType = data.type;
    
    switch (messageType) {
        case 'chat':
            // 聊天消息
            const chatMsg = {
                type: 'chat',
                userId: clientId,
                message: data.message || '',
                timestamp: new Date().toISOString()
            };
            broadcast(chatMsg);
            break;
            
        case 'private':
            // 私人消息
            const targetId = data.targetId;
            const targetClient = clients.get(targetId);
            
            if (targetClient && targetClient.readyState === WebSocket.OPEN) {
                const privateMsg = {
                    type: 'private',
                    fromUserId: clientId,
                    message: data.message || '',
                    timestamp: new Date().toISOString()
                };
                targetClient.send(JSON.stringify(privateMsg));
            } else {
                const errorMsg = {
                    type: 'error',
                    message: '目标用户不存在或已断开连接'
                };
                ws.send(JSON.stringify(errorMsg));
            }
            break;
            
        case 'ping':
            // 心跳检测
            const pongMsg = {
                type: 'pong',
                timestamp: new Date().toISOString()
            };
            ws.send(JSON.stringify(pongMsg));
            break;
            
        case 'get_users':
            // 获取在线用户列表
            const usersMsg = {
                type: 'users_list',
                users: Array.from(clients.keys()),
                timestamp: new Date().toISOString()
            };
            ws.send(JSON.stringify(usersMsg));
            break;
            
        default:
            const unknownMsg = {
                type: 'error',
                message: '未知的消息类型'
            };
            ws.send(JSON.stringify(unknownMsg));
    }
}

function broadcast(message, excludeClientId = null) {
    const messageStr = JSON.stringify(message);
    
    clients.forEach((client, clientId) => {
        if (clientId !== excludeClientId && 
            client.readyState === WebSocket.OPEN) {
            client.send(messageStr);
        }
    });
}

// 定时清理断开的连接
setInterval(() => {
    wss.clients.forEach((ws) => {
        if (!ws.isAlive) {
            return ws.terminate();
        }
        
        ws.isAlive = false;
        ws.ping();
    });
}, 30000);

// 定时广播服务器状态
setInterval(() => {
    const statusMsg = {
        type: 'server_status',
        connectedClients: clients.size,
        timestamp: new Date().toISOString()
    };
    broadcast(statusMsg);
}, 30000);

// 提供静态文件
app.use(express.static('public'));

// 聊天室页面
app.get('/', (req, res) => {
    res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>WebSocket Chat</title>
        <style>
            #messages { list-style: none; padding: 0; }
            #messages li { padding: 5px; margin: 5px 0; background: #f0f0f0; }
            #messageInput { width: 300px; }
        </style>
    </head>
    <body>
        <h1>WebSocket 聊天室</h1>
        <div>
            <ul id="messages"></ul>
        </div>
        <div>
            <input type="text" id="messageInput" placeholder="输入消息..." />
            <button onclick="sendMessage()">发送</button>
            <button onclick="getUsers()">获取用户列表</button>
        </div>
        
        <script>
            const ws = new WebSocket('ws://localhost:8080');
            let clientId = null;
            
            ws.onopen = () => {
                console.log('WebSocket 连接建立');
                addMessage('系统', '连接到服务器');
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };
            
            ws.onclose = () => {
                console.log('WebSocket 连接关闭');
                addMessage('系统', '与服务器断开连接');
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket 错误:', error);
                addMessage('系统', '连接错误');
            };
            
            function handleMessage(data) {
                switch (data.type) {
                    case 'welcome':
                        clientId = data.clientId;
                        addMessage('系统', data.message);
                        break;
                    case 'chat':
                        addMessage(\`用户 \${data.userId}\`, data.message);
                        break;
                    case 'private':
                        addMessage(\`私聊来自 \${data.fromUserId}\`, data.message);
                        break;
                    case 'user_join':
                        addMessage('系统', \`用户 \${data.userId} 加入聊天室\`);
                        break;
                    case 'user_leave':
                        addMessage('系统', \`用户 \${data.userId} 离开聊天室\`);
                        break;
                    case 'users_list':
                        addMessage('系统', \`在线用户: \${data.users.join(', ')}\`);
                        break;
                    case 'server_status':
                        addMessage('系统', \`服务器状态: \${data.connectedClients} 个连接\`);
                        break;
                    case 'error':
                        addMessage('错误', data.message);
                        break;
                }
            }
            
            function addMessage(sender, message) {
                const messages = document.getElementById('messages');
                const li = document.createElement('li');
                li.textContent = \`[\${new Date().toLocaleTimeString()}] \${sender}: \${message}\`;
                messages.appendChild(li);
                messages.scrollTop = messages.scrollHeight;
            }
            
            function sendMessage() {
                const input = document.getElementById('messageInput');
                const message = input.value.trim();
                
                if (message) {
                    const data = {
                        type: 'chat',
                        message: message
                    };
                    ws.send(JSON.stringify(data));
                    input.value = '';
                }
            }
            
            function getUsers() {
                const data = { type: 'get_users' };
                ws.send(JSON.stringify(data));
            }
            
            // 回车发送消息
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
        </script>
    </body>
    </html>
    `);
});

// 启动服务器
const PORT = process.env.PORT || 8080;
server.listen(PORT, () => {
    console.log(`WebSocket 服务器运行在 http://localhost:${PORT}`);
});

// 使用 Socket.IO 的高级示例
const express2 = require('express');
const http2 = require('http');
const socketIo = require('socket.io');

const app2 = express2();
const server2 = http2.createServer(app2);
const io = socketIo(server2);

// 房间管理
const rooms = new Map();

io.on('connection', (socket) => {
    console.log('用户连接:', socket.id);
    
    // 加入房间
    socket.on('join-room', (roomName) => {
        socket.join(roomName);
        
        if (!rooms.has(roomName)) {
            rooms.set(roomName, new Set());
        }
        rooms.get(roomName).add(socket.id);
        
        socket.to(roomName).emit('user-joined', {
            userId: socket.id,
            message: \`用户 \${socket.id} 加入了房间 \${roomName}\`
        });
        
        socket.emit('joined-room', {
            roomName,
            users: Array.from(rooms.get(roomName))
        });
    });
    
    // 离开房间
    socket.on('leave-room', (roomName) => {
        socket.leave(roomName);
        
        if (rooms.has(roomName)) {
            rooms.get(roomName).delete(socket.id);
            if (rooms.get(roomName).size === 0) {
                rooms.delete(roomName);
            }
        }
        
        socket.to(roomName).emit('user-left', {
            userId: socket.id,
            message: \`用户 \${socket.id} 离开了房间 \${roomName}\`
        });
    });
    
    // 房间消息
    socket.on('room-message', (data) => {
        socket.to(data.room).emit('room-message', {
            userId: socket.id,
            message: data.message,
            timestamp: new Date().toISOString()
        });
    });
    
    // 私人消息
    socket.on('private-message', (data) => {
        socket.to(data.targetId).emit('private-message', {
            fromUserId: socket.id,
            message: data.message,
            timestamp: new Date().toISOString()
        });
    });
    
    // 断开连接
    socket.on('disconnect', () => {
        console.log('用户断开连接:', socket.id);
        
        // 从所有房间中移除
        rooms.forEach((users, roomName) => {
            if (users.has(socket.id)) {
                users.delete(socket.id);
                socket.to(roomName).emit('user-left', {
                    userId: socket.id,
                    message: \`用户 \${socket.id} 断开连接\`
                });
                
                if (users.size === 0) {
                    rooms.delete(roomName);
                }
            }
        });
    });
});

// Socket.IO 服务器
const SOCKET_PORT = 8081;
server2.listen(SOCKET_PORT, () => {
    console.log(\`Socket.IO 服务器运行在 http://localhost:\${SOCKET_PORT}\`);
});
```

</Tab>

</Tabs>

## 小结

通过本章的学习，你应该了解到：

1. **运行时差异**: Node.js 单线程事件循环 vs Python 多线程 + GIL
2. **异步模型**: JavaScript Promise/async-await vs Python asyncio
3. **文件操作**: Node.js fs 模块 vs Python pathlib/aiofiles
4. **数据库集成**: 不同 ORM/ODM 的使用方式和特点
5. **实时通信**: WebSocket 在两种语言中的实现差异

<Callout type="tip">
**下一步**: 在下一章中，我们将学习包管理与生态系统，了解 npm 与 pip 的差异。
</Callout>
