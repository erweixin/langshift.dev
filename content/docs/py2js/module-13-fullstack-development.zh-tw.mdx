---
title: å…¨ç«¯é–‹ç™¼æœ€ä½³å¯¦å‹™
description: å¾ Python é–‹ç™¼è€…çš„è§’åº¦æŒæ¡å…¨ç«¯ JavaScript é–‹ç™¼ï¼ŒåŒ…æ‹¬æ¶æ§‹æ¨¡å¼ã€éƒ¨ç½²ç­–ç•¥å’Œç”Ÿç”¢ç’°å¢ƒè€ƒæ…®å› ç´ 
---

# æ¨¡çµ„ 13ï¼šå…¨ç«¯é–‹ç™¼æœ€ä½³å¯¦å‹™

## å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬æ¨¡çµ„å¾Œï¼Œä½ å°‡èƒ½å¤ ï¼š
- ç†è§£å…¨ç«¯ JavaScript æ¶æ§‹æ¨¡å¼
- å¯¦æ–½å®‰å…¨çš„èº«ä»½é©—è­‰å’Œæˆæ¬Š
- å°‡æ‡‰ç”¨ç¨‹å¼éƒ¨ç½²åˆ°ç”Ÿç”¢ç’°å¢ƒ
- ç›£æ§å’Œæœ€ä½³åŒ–ç”Ÿç”¢æ‡‰ç”¨ç¨‹å¼
- æœ‰æ•ˆæ“´å±•æ‡‰ç”¨ç¨‹å¼
- åœ¨æ•´å€‹æŠ€è¡“å †ç–Šä¸­æ‡‰ç”¨å®‰å…¨æœ€ä½³å¯¦å‹™

## å…¨ç«¯æ¶æ§‹æ¨¡å¼

### å°æ¯” Python å’Œ JavaScript æ¶æ§‹

<PythonEditor title="å…¨ç«¯æ¶æ§‹å°æ¯”" compare={true}>
```python !! py
# Python å…¨ç«¯æ¶æ§‹ï¼ˆDjango + React/Vueï¼‰
# å‚³çµ±çš„å‰å¾Œç«¯åˆ†é›¢

# å¾Œç«¯ï¼šDjango å°ˆæ¡ˆçµæ§‹
# myproject/
# â”œâ”€â”€ manage.py
# â”œâ”€â”€ myproject/
# â”‚   â”œâ”€â”€ settings/
# â”‚   â”‚   â”œâ”€â”€ base.py
# â”‚   â”‚   â”œâ”€â”€ development.py
# â”‚   â”‚   â””â”€â”€ production.py
# â”‚   â”œâ”€â”€ urls.py
# â”‚   â””â”€â”€ wsgi.py
# â”œâ”€â”€ apps/
# â”‚   â”œâ”€â”€ authentication/
# â”‚   â”œâ”€â”€ users/
# â”‚   â””â”€â”€ api/
# â”œâ”€â”€ requirements/
# â”‚   â”œâ”€â”€ base.txt
# â”‚   â”œâ”€â”€ development.txt
# â”‚   â””â”€â”€ production.txt
# â””â”€â”€ frontend/  (ç¨ç«‹çš„ React/Vue æ‡‰ç”¨ç¨‹å¼)

# Django settings/base.py
import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent.parent

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'rest_framework',
    'corsheaders',
    'apps.authentication',
    'apps.users',
    'apps.api',
]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'apps.authentication.middleware.JWTAuthenticationMiddleware',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 20,
}

# Django é©—è­‰
from rest_framework_simplejwt.views import TokenObtainPairView
from django.contrib.auth import authenticate

class CustomTokenObtainPairView(TokenObtainPairView):
    def post(self, request, *args, **kwargs):
        response = super().post(request, *args, **kwargs)
        if response.status_code == 200:
            # å‘å›æ‡‰æ–°å¢è‡ªè¨‚è³‡æ–™
            user = authenticate(
                username=request.data['username'],
                password=request.data['password']
            )
            response.data['user'] = {
                'id': user.id,
                'username': user.username,
                'email': user.email,
            }
        return response
```

```javascript !! js
// JavaScript å…¨ç«¯æ¶æ§‹ï¼ˆNode.js + React/Next.jsï¼‰
// ç¾ä»£çµ±ä¸€æˆ– monorepo æ–¹æ³•

// ç¾ä»£å…¨ç«¯ JavaScript å°ˆæ¡ˆçµæ§‹ï¼š
// my-app/
// â”œâ”€â”€ package.json
// â”œâ”€â”€ apps/
// â”‚   â”œâ”€â”€ web/          (Next.js å‰ç«¯)
// â”‚   â”‚   â”œâ”€â”€ pages/
// â”‚   â”‚   â”œâ”€â”€ components/
// â”‚   â”‚   â””â”€â”€ package.json
// â”‚   â””â”€â”€ api/          (Express.js å¾Œç«¯)
// â”‚       â”œâ”€â”€ src/
// â”‚       â”œâ”€â”€ routes/
// â”‚       â””â”€â”€ package.json
// â”œâ”€â”€ packages/
// â”‚   â”œâ”€â”€ shared/       (å…±äº«å·¥å…·)
// â”‚   â”œâ”€â”€ ui/          (å…ƒä»¶åº«)
// â”‚   â””â”€â”€ database/    (è³‡æ–™åº«æ¨¡å‹)
// â””â”€â”€ docker-compose.yml

// å¾Œç«¯ï¼šExpress.js with TypeScript
// apps/api/src/app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';
import { authRouter } from './routes/auth';
import { usersRouter } from './routes/users';
import { errorHandler } from './middleware/errorHandler';
import { authMiddleware } from './middleware/auth';

const app = express();

// å®‰å…¨ä¸­ä»‹è»Ÿé«”
app.use(helmet());
app.use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
}));

// é€Ÿç‡é™åˆ¶
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 åˆ†é˜
    max: 100, // é™åˆ¶æ¯å€‹ IP åœ¨è¦–çª—æœŸå…§æœ€å¤š 100 å€‹è«‹æ±‚
    message: 'ä¾†è‡ªæ­¤ IP çš„è«‹æ±‚éå¤š'
});
app.use('/api/', limiter);

// è«‹æ±‚ä¸»é«”è§£æ
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// è·¯ç”±
app.use('/api/auth', authRouter);
app.use('/api/users', authMiddleware, usersRouter);

// å¥åº·æª¢æŸ¥
app.get('/health', (req, res) => {
    res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// éŒ¯èª¤è™•ç†
app.use(errorHandler);

export default app;

// é©—è­‰ä¸­ä»‹è»Ÿé«”
// apps/api/src/middleware/auth.ts
import jwt from 'jsonwebtoken';
import { Request, Response, NextFunction } from 'express';
import { User } from '../models/User';

interface AuthenticatedRequest extends Request {
    user?: User;
}

export const authMiddleware = async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
) => {
    try {
        const token = req.headers.authorization?.replace('Bearer ', '');
        
        if (!token) {
            return res.status(401).json({ error: 'æœªæä¾›æ¬Šæ–' });
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
        const user = await User.findById(decoded.userId);
        
        if (!user) {
            return res.status(401).json({ error: 'ç„¡æ•ˆæ¬Šæ–' });
        }

        req.user = user;
        next();
    } catch (error) {
        return res.status(401).json({ error: 'ç„¡æ•ˆæ¬Šæ–' });
    }
};

// å‰ç«¯ï¼šNext.js with TypeScript
// apps/web/pages/_app.tsx
import type { AppProps } from 'next/app';
import { AuthProvider } from '../contexts/AuthContext';
import { QueryClient, QueryClientProvider } from 'react-query';
import { Toaster } from 'react-hot-toast';
import '../styles/globals.css';

const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 5 * 60 * 1000, // 5 åˆ†é˜
            cacheTime: 10 * 60 * 1000, // 10 åˆ†é˜
        },
    },
});

function MyApp({ Component, pageProps }: AppProps) {
    return (
        <QueryClientProvider client={queryClient}>
            <AuthProvider>
                <Component {...pageProps} />
                <Toaster position="top-right" />
            </AuthProvider>
        </QueryClientProvider>
    );
}

export default MyApp;

// é©—è­‰ä¸Šä¸‹æ–‡
// apps/web/contexts/AuthContext.tsx
import React, { createContext, useContext, useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import { authAPI } from '../services/api';

interface User {
    id: string;
    username: string;
    email: string;
}

interface AuthContextType {
    user: User | null;
    login: (username: string, password: string) => Promise<void>;
    logout: () => void;
    loading: boolean;
}

const AuthContext = createContext<AuthContextType | null>(null);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
    const [user, setUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const router = useRouter();

    useEffect(() => {
        const token = localStorage.getItem('token');
        if (token) {
            authAPI.verifyToken(token)
                .then(setUser)
                .catch(() => localStorage.removeItem('token'))
                .finally(() => setLoading(false));
        } else {
            setLoading(false);
        }
    }, []);

    const login = async (username: string, password: string) => {
        const { user, token } = await authAPI.login(username, password);
        localStorage.setItem('token', token);
        setUser(user);
        router.push('/dashboard');
    };

    const logout = () => {
        localStorage.removeItem('token');
        setUser(null);
        router.push('/login');
    };

    return (
        <AuthContext.Provider value={{ user, login, logout, loading }}>
            {children}
        </AuthContext.Provider>
    );
};

export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth å¿…é ˆåœ¨ AuthProvider å…§ä½¿ç”¨');
    }
    return context;
};
```
</PythonEditor>

## èº«ä»½é©—è­‰å’Œæˆæ¬Š

### å®‰å…¨é©—è­‰å¯¦æ–½

<PythonEditor title="é©—è­‰èˆ‡æˆæ¬Š" compare={true}>
```python !! py
# Pythonï¼šDjango with JWT é©—è­‰
from rest_framework_simplejwt.tokens import RefreshToken
from django.contrib.auth import authenticate
from django.contrib.auth.models import User
from rest_framework.decorators import api_view, permission_classes
from rest_framework.permissions import IsAuthenticated
from rest_framework.response import Response
from rest_framework import status

@api_view(['POST'])
def login(request):
    username = request.data.get('username')
    password = request.data.get('password')
    
    user = authenticate(username=username, password=password)
    if user:
        refresh = RefreshToken.for_user(user)
        return Response({
            'access': str(refresh.access_token),
            'refresh': str(refresh),
            'user': {
                'id': user.id,
                'username': user.username,
                'email': user.email,
            }
        })
    return Response(
        {'error': 'æ†‘æ“šç„¡æ•ˆ'}, 
        status=status.HTTP_401_UNAUTHORIZED
    )

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def protected_view(request):
    return Response({
        'message': f'ä½ å¥½ {request.user.username}',
        'user_id': request.user.id
    })

# åŸºæ–¼è§’è‰²çš„æ¬Šé™
from django.contrib.auth.models import Group

class IsAdminOrReadOnly:
    def has_permission(self, request, view):
        if request.method in ['GET', 'HEAD', 'OPTIONS']:
            return True
        return request.user.groups.filter(name='Admin').exists()

# è‡ªè¨‚ä½¿ç”¨è€…æ¨¡å‹
from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):
    email = models.EmailField(unique=True)
    role = models.CharField(max_length=20, choices=[
        ('admin', 'ç®¡ç†å“¡'),
        ('user', 'ä½¿ç”¨è€…'),
        ('moderator', 'ç‰ˆä¸»')
    ], default='user')
    
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username']
```

```javascript !! js
// JavaScriptï¼šNode.js with JWT å’ŒåŸºæ–¼è§’è‰²çš„æˆæ¬Š
// apps/api/src/services/authService.ts
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { User, UserRole } from '../models/User';

export class AuthService {
    static generateTokens(userId: string) {
        const accessToken = jwt.sign(
            { userId, type: 'access' },
            process.env.JWT_SECRET!,
            { expiresIn: '15m' }
        );
        
        const refreshToken = jwt.sign(
            { userId, type: 'refresh' },
            process.env.JWT_REFRESH_SECRET!,
            { expiresIn: '7d' }
        );
        
        return { accessToken, refreshToken };
    }
    
    static async login(email: string, password: string) {
        const user = await User.findOne({ email });
        if (!user || !await bcrypt.compare(password, user.password)) {
            throw new Error('æ†‘æ“šç„¡æ•ˆ');
        }
        
        const tokens = this.generateTokens(user.id);
        
        // å„²å­˜é‡æ–°æ•´ç†æ¬Šæ–
        user.refreshToken = tokens.refreshToken;
        await user.save();
        
        return {
            user: {
                id: user.id,
                email: user.email,
                username: user.username,
                role: user.role
            },
            ...tokens
        };
    }
    
    static async refreshToken(refreshToken: string) {
        try {
            const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET!) as any;
            const user = await User.findById(decoded.userId);
            
            if (!user || user.refreshToken !== refreshToken) {
                throw new Error('ç„¡æ•ˆçš„é‡æ–°æ•´ç†æ¬Šæ–');
            }
            
            return this.generateTokens(user.id);
        } catch (error) {
            throw new Error('ç„¡æ•ˆçš„é‡æ–°æ•´ç†æ¬Šæ–');
        }
    }
    
    static async register(userData: {
        email: string;
        username: string;
        password: string;
        role?: UserRole;
    }) {
        const existingUser = await User.findOne({
            $or: [{ email: userData.email }, { username: userData.username }]
        });
        
        if (existingUser) {
            throw new Error('ä½¿ç”¨è€…å·²å­˜åœ¨');
        }
        
        const hashedPassword = await bcrypt.hash(userData.password, 12);
        
        const user = new User({
            ...userData,
            password: hashedPassword,
            role: userData.role || UserRole.USER
        });
        
        await user.save();
        
        const tokens = this.generateTokens(user.id);
        
        return {
            user: {
                id: user.id,
                email: user.email,
                username: user.username,
                role: user.role
            },
            ...tokens
        };
    }
}

// åŸºæ–¼è§’è‰²çš„æˆæ¬Šä¸­ä»‹è»Ÿé«”
// apps/api/src/middleware/authorization.ts
import { Request, Response, NextFunction } from 'express';
import { UserRole } from '../models/User';

interface AuthorizedRequest extends Request {
    user?: {
        id: string;
        role: UserRole;
    };
}

export const authorize = (requiredRoles: UserRole[]) => {
    return (req: AuthorizedRequest, res: Response, next: NextFunction) => {
        if (!req.user) {
            return res.status(401).json({ error: 'éœ€è¦èº«ä»½é©—è­‰' });
        }
        
        if (!requiredRoles.includes(req.user.role)) {
            return res.status(403).json({ error: 'æ¬Šé™ä¸è¶³' });
        }
        
        next();
    };
};

// åœ¨è·¯ç”±ä¸­ä½¿ç”¨
import { authorize } from '../middleware/authorization';

router.get('/admin/users', 
    authMiddleware, 
    authorize([UserRole.ADMIN]), 
    getUsersController
);

router.delete('/admin/users/:id', 
    authMiddleware, 
    authorize([UserRole.ADMIN, UserRole.MODERATOR]), 
    deleteUserController
);

// å¯†ç¢¼é‡è¨­åŠŸèƒ½
// apps/api/src/services/passwordResetService.ts
import crypto from 'crypto';
import { EmailService } from './emailService';

export class PasswordResetService {
    static async initiateReset(email: string) {
        const user = await User.findOne({ email });
        if (!user) {
            // ä¸æ´©éœ²ä¿¡ç®±æ˜¯å¦å­˜åœ¨
            return { message: 'å¦‚æœä¿¡ç®±å­˜åœ¨ï¼Œå°‡å‚³é€é‡è¨­é€£çµ' };
        }
        
        const resetToken = crypto.randomBytes(32).toString('hex');
        const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 å°æ™‚
        
        user.resetToken = resetToken;
        user.resetTokenExpiry = resetTokenExpiry;
        await user.save();
        
        await EmailService.sendPasswordReset(email, resetToken);
        
        return { message: 'å¦‚æœä¿¡ç®±å­˜åœ¨ï¼Œå°‡å‚³é€é‡è¨­é€£çµ' };
    }
    
    static async resetPassword(token: string, newPassword: string) {
        const user = await User.findOne({
            resetToken: token,
            resetTokenExpiry: { $gt: new Date() }
        });
        
        if (!user) {
            throw new Error('ç„¡æ•ˆæˆ–éæœŸçš„é‡è¨­æ¬Šæ–');
        }
        
        user.password = await bcrypt.hash(newPassword, 12);
        user.resetToken = undefined;
        user.resetTokenExpiry = undefined;
        await user.save();
        
        return { message: 'å¯†ç¢¼é‡è¨­æˆåŠŸ' };
    }
}

// å‰ç«¯ï¼šå®‰å…¨é©—è­‰æ›é‰¤
// apps/web/hooks/useAuth.ts
import { useState, useEffect } from 'react';
import { authAPI } from '../services/api';

export const useAuth = () => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        const token = localStorage.getItem('accessToken');
        if (token) {
            authAPI.verifyToken(token)
                .then(setUser)
                .catch(() => {
                    localStorage.removeItem('accessToken');
                    localStorage.removeItem('refreshToken');
                })
                .finally(() => setLoading(false));
        } else {
            setLoading(false);
        }
    }, []);
    
    const login = async (email: string, password: string) => {
        const response = await authAPI.login(email, password);
        localStorage.setItem('accessToken', response.accessToken);
        localStorage.setItem('refreshToken', response.refreshToken);
        setUser(response.user);
        return response;
    };
    
    const logout = () => {
        localStorage.removeItem('accessToken');
        localStorage.removeItem('refreshToken');
        setUser(null);
    };
    
    return { user, login, logout, loading };
};

// è‡ªå‹•æ¬Šæ–é‡æ–°æ•´ç†
// apps/web/services/api.ts
import axios, { AxiosResponse } from 'axios';

const api = axios.create({
    baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api',
});

// è«‹æ±‚æ””æˆªå™¨æ–°å¢é©—è­‰æ¬Šæ–
api.interceptors.request.use((config) => {
    const token = localStorage.getItem('accessToken');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// å›æ‡‰æ””æˆªå™¨è™•ç†æ¬Šæ–é‡æ–°æ•´ç†
api.interceptors.response.use(
    (response: AxiosResponse) => response,
    async (error) => {
        const originalRequest = error.config;
        
        if (error.response?.status === 401 && !originalRequest._retry) {
            originalRequest._retry = true;
            
            const refreshToken = localStorage.getItem('refreshToken');
            if (refreshToken) {
                try {
                    const response = await axios.post('/api/auth/refresh', {
                        refreshToken
                    });
                    
                    localStorage.setItem('accessToken', response.data.accessToken);
                    originalRequest.headers.Authorization = `Bearer ${response.data.accessToken}`;
                    
                    return api(originalRequest);
                } catch (refreshError) {
                    localStorage.removeItem('accessToken');
                    localStorage.removeItem('refreshToken');
                    window.location.href = '/login';
                }
            }
        }
        
        return Promise.reject(error);
    }
);

export default api;
```
</PythonEditor>

## éƒ¨ç½²ç­–ç•¥

### ç”Ÿç”¢éƒ¨ç½²å°æ¯”

<PythonEditor title="éƒ¨ç½²ç­–ç•¥" compare={true}>
```python !! py
# Python ä½¿ç”¨ Docker å’Œ Docker Compose éƒ¨ç½²
# Django çš„ Dockerfile
FROM python:3.9-slim

WORKDIR /app

# å®‰è£ç³»çµ±ç›¸ä¾æ€§
RUN apt-get update && apt-get install -y \
    gcc \
    postgresql-client \
    && rm -rf /var/lib/apt/lists/*

# å®‰è£ Python ç›¸ä¾æ€§
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# æ”¶é›†éœæ…‹æª”æ¡ˆ
RUN python manage.py collectstatic --noinput

EXPOSE 8000

CMD ["gunicorn", "--bind", "0.0.0.0:8000", "myproject.wsgi:application"]

# å…¨ç«¯çš„ docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:13
    environment:
      POSTGRES_DB: myproject
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:6-alpine

  web:
    build: .
    command: gunicorn --bind 0.0.0.0:8000 myproject.wsgi:application
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/myproject
      - REDIS_URL=redis://redis:6379/0

  worker:
    build: .
    command: celery -A myproject worker -l info
    volumes:
      - .:/app
    depends_on:
      - db
      - redis
    environment:
      - DATABASE_URL=postgresql://postgres:postgres@db:5432/myproject
      - REDIS_URL=redis://redis:6379/0

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./static:/app/static
    depends_on:
      - web

volumes:
  postgres_data:

# Kubernetes éƒ¨ç½²
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: django-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: django-app
  template:
    metadata:
      labels:
        app: django-app
    spec:
      containers:
      - name: django
        image: myregistry/django-app:latest
        ports:
        - containerPort: 8000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: django-secrets
              key: database-url
```

```javascript !! js
// JavaScript ä½¿ç”¨ Docker å’Œç¾ä»£å¹³å°éƒ¨ç½²
// Next.js çš„å¤šéšæ®µ Dockerfile
FROM node:18-alpine AS deps
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci --only=production

FROM node:18-alpine AS builder
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:18-alpine AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000

CMD ["node", "server.js"]

// å…¨ç«¯ JavaScript çš„ Docker Compose
# docker-compose.yml
version: '3.8'

services:
  # è³‡æ–™åº«
  postgres:
    image: postgres:13-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  # Redis ç”¨æ–¼å¿«å–å’Œå·¥ä½œéšæ®µ
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  # å¾Œç«¯ API
  api:
    build:
      context: ./apps/api
      dockerfile: Dockerfile
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:postgres@postgres:5432/myapp
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
    ports:
      - "3001:3001"
    depends_on:
      - postgres
      - redis
    volumes:
      - ./apps/api:/app
      - /app/node_modules

  # å‰ç«¯
  web:
    build:
      context: ./apps/web
      dockerfile: Dockerfile
    environment:
      - NEXT_PUBLIC_API_URL=http://localhost:3001/api
    ports:
      - "3000:3000"
    depends_on:
      - api

  # Nginx åå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - web
      - api

volumes:
  postgres_data:

// Vercel éƒ¨ç½²ï¼ˆç„¡ä¼ºæœå™¨ï¼‰
// vercel.json
{
    "version": 2,
    "builds": [
        {
            "src": "apps/web/package.json",
            "use": "@vercel/next"
        },
        {
            "src": "apps/api/src/index.ts",
            "use": "@vercel/node"
        }
    ],
    "routes": [
        {
            "src": "/api/(.*)",
            "dest": "apps/api/src/index.ts"
        },
        {
            "src": "/(.*)",
            "dest": "apps/web/$1"
        }
    ],
    "env": {
        "DATABASE_URL": "@database-url",
        "JWT_SECRET": "@jwt-secret"
    }
}

// Railway éƒ¨ç½²è¨­å®š
// railway.toml
[build]
builder = "nixpacks"

[deploy]
healthcheckPath = "/health"
healthcheckTimeout = 300
restartPolicyType = "on_failure"

[[services]]
name = "web"
source = "apps/web"
[services.env]
NODE_ENV = "production"

[[services]]
name = "api"
source = "apps/api"
[services.env]
NODE_ENV = "production"
DATABASE_URL = "${{Postgres.DATABASE_URL}}"

// ä½¿ç”¨ CDK çš„ AWS éƒ¨ç½²
// infrastructure/stack.ts
import * as cdk from 'aws-cdk-lib';
import * as ecs from 'aws-cdk-lib/aws-ecs';
import * as ec2 from 'aws-cdk-lib/aws-ec2';
import * as rds from 'aws-cdk-lib/aws-rds';
import * as cloudfront from 'aws-cdk-lib/aws-cloudfront';

export class MyAppStack extends cdk.Stack {
    constructor(scope: Construct, id: string, props?: cdk.StackProps) {
        super(scope, id, props);

        // VPC
        const vpc = new ec2.Vpc(this, 'MyAppVpc', {
            maxAzs: 2
        });

        // è³‡æ–™åº«
        const database = new rds.DatabaseInstance(this, 'Database', {
            engine: rds.DatabaseInstanceEngine.postgres({
                version: rds.PostgresEngineVersion.VER_13_7
            }),
            instanceType: ec2.InstanceType.of(ec2.InstanceClass.T3, ec2.InstanceSize.MICRO),
            vpc,
            credentials: rds.Credentials.fromGeneratedSecret('postgres'),
            deletionProtection: false
        });

        // ECS å¢é›†
        const cluster = new ecs.Cluster(this, 'Cluster', {
            vpc
        });

        // API æœå‹™
        const apiTaskDefinition = new ecs.FargateTaskDefinition(this, 'ApiTaskDef');
        apiTaskDefinition.addContainer('api', {
            image: ecs.ContainerImage.fromRegistry('myregistry/api:latest'),
            environment: {
                DATABASE_URL: database.instanceEndpoint.socketAddress
            },
            logging: ecs.LogDrivers.awsLogs({
                streamPrefix: 'api'
            })
        });

        const apiService = new ecs.FargateService(this, 'ApiService', {
            cluster,
            taskDefinition: apiTaskDefinition
        });

        // å‰ç«¯ï¼ˆS3 + CloudFrontï¼‰
        const bucket = new s3.Bucket(this, 'WebBucket', {
            websiteIndexDocument: 'index.html',
            publicReadAccess: true
        });

        const distribution = new cloudfront.CloudFrontWebDistribution(this, 'Distribution', {
            originConfigs: [{
                s3OriginSource: {
                    s3BucketSource: bucket
                },
                behaviors: [{ isDefaultBehavior: true }]
            }]
        });
    }
}

// GitHub Actions éƒ¨ç½²
# .github/workflows/deploy.yml
name: éƒ¨ç½²åˆ°ç”Ÿç”¢ç’°å¢ƒ

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: è¨­å®š Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: å®‰è£ç›¸ä¾æ€§
        run: npm ci
      
      - name: åŸ·è¡Œæ¸¬è©¦
        run: npm test
      
      - name: å»ºç½®æ‡‰ç”¨ç¨‹å¼
        run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: è¨­å®š AWS æ†‘è­‰
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: å»ºç½®å’Œæ¨é€ Docker æ˜ åƒ
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: my-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./apps/api
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
      
      - name: éƒ¨ç½²åˆ° ECS
        run: |
          aws ecs update-service --cluster production --service api-service --force-new-deployment
      
      - name: éƒ¨ç½²å‰ç«¯åˆ° S3
        run: |
          aws s3 sync ./apps/web/out s3://my-app-frontend --delete
          aws cloudfront create-invalidation --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} --paths "/*"
```
</PythonEditor>

## ç”Ÿç”¢ç›£æ§å’Œæœ€ä½³åŒ–

### ç›£æ§å’Œæ•ˆèƒ½

<PythonEditor title="ç”Ÿç”¢ç›£æ§" compare={true}>
```python !! py
# Python ä½¿ç”¨ Django é€²è¡Œç›£æ§
# settings.py
import sentry_sdk
from sentry_sdk.integrations.django import DjangoIntegration
from sentry_sdk.integrations.celery import CeleryIntegration

sentry_sdk.init(
    dsn="your-sentry-dsn",
    integrations=[
        DjangoIntegration(),
        CeleryIntegration(),
    ],
    traces_sample_rate=0.1,
    send_default_pii=True
)

# ç›£æ§è‡ªè¨‚ä¸­ä»‹è»Ÿé«”
class MonitoringMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        start_time = time.time()
        
        response = self.get_response(request)
        
        # è¨˜éŒ„è«‹æ±‚æŒ‡æ¨™
        duration = time.time() - start_time
        logger.info(f"è«‹æ±‚ {request.path} è€—æ™‚ {duration:.2f}s")
        
        # å‚³é€æŒ‡æ¨™åˆ°ç›£æ§æœå‹™
        send_metric('request_duration', duration, {
            'path': request.path,
            'method': request.method,
            'status_code': response.status_code
        })
        
        return response

# å¥åº·æª¢æŸ¥ç«¯é»
from django.http import JsonResponse
from django.db import connection

def health_check(request):
    try:
        # æª¢æŸ¥è³‡æ–™åº«é€£ç·š
        with connection.cursor() as cursor:
            cursor.execute("SELECT 1")
        
        # æª¢æŸ¥ Redis é€£ç·š
        from django.core.cache import cache
        cache.set('health_check', 'ok', 10)
        
        return JsonResponse({
            'status': 'healthy',
            'timestamp': timezone.now().isoformat(),
            'version': settings.VERSION
        })
    except Exception as e:
        return JsonResponse({
            'status': 'unhealthy',
            'error': str(e)
        }, status=503)

# æ•ˆèƒ½ç›£æ§
import cProfile
import pstats

def profile_view(view_func):
    def wrapper(request, *args, **kwargs):
        if settings.DEBUG:
            profiler = cProfile.Profile()
            profiler.enable()
            
            response = view_func(request, *args, **kwargs)
            
            profiler.disable()
            stats = pstats.Stats(profiler)
            stats.sort_stats('cumulative')
            stats.print_stats()
            
            return response
        return view_func(request, *args, **kwargs)
    return wrapper
```

```javascript !! js
// JavaScript ä½¿ç”¨ Node.js é€²è¡Œç›£æ§
// apps/api/src/monitoring/index.ts
import * as Sentry from '@sentry/node';
import * as Tracing from '@sentry/tracing';
import express from 'express';
import prometheus from 'prom-client';

// åˆå§‹åŒ– Sentry
Sentry.init({
    dsn: process.env.SENTRY_DSN,
    integrations: [
        new Sentry.Integrations.Http({ tracing: true }),
        new Tracing.Integrations.Express({ app: express() }),
    ],
    tracesSampleRate: 0.1,
    environment: process.env.NODE_ENV,
});

// Prometheus æŒ‡æ¨™
const collectDefaultMetrics = prometheus.collectDefaultMetrics;
collectDefaultMetrics({ timeout: 5000 });

const httpRequestDuration = new prometheus.Histogram({
    name: 'http_request_duration_seconds',
    help: 'HTTP è«‹æ±‚æŒçºŒæ™‚é–“ï¼ˆç§’ï¼‰',
    labelNames: ['method', 'route', 'status_code'],
    buckets: [0.1, 0.5, 1, 2, 5]
});

const httpRequestTotal = new prometheus.Counter({
    name: 'http_requests_total',
    help: 'HTTP è«‹æ±‚ç¸½æ•¸',
    labelNames: ['method', 'route', 'status_code']
});

const activeConnections = new prometheus.Gauge({
    name: 'active_connections',
    help: 'æ´»èºé€£ç·šæ•¸'
});

// ç›£æ§ä¸­ä»‹è»Ÿé«”
export const monitoringMiddleware = (req: express.Request, res: express.Response, next: express.NextFunction) => {
    const start = Date.now();
    
    res.on('finish', () => {
        const duration = (Date.now() - start) / 1000;
        const route = req.route?.path || req.path;
        
        httpRequestDuration
            .labels(req.method, route, res.statusCode.toString())
            .observe(duration);
            
        httpRequestTotal
            .labels(req.method, route, res.statusCode.toString())
            .inc();
    });
    
    next();
};

// å¥åº·æª¢æŸ¥ç«¯é»
export const healthCheck = async (req: express.Request, res: express.Response) => {
    const checks = {
        timestamp: new Date().toISOString(),
        version: process.env.npm_package_version,
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        database: false,
        redis: false
    };
    
    try {
        // æª¢æŸ¥è³‡æ–™åº«é€£ç·š
        await User.findOne().limit(1);
        checks.database = true;
    } catch (error) {
        console.error('è³‡æ–™åº«å¥åº·æª¢æŸ¥å¤±æ•—:', error);
    }
    
    try {
        // æª¢æŸ¥ Redis é€£ç·š
        await redisClient.ping();
        checks.redis = true;
    } catch (error) {
        console.error('Redis å¥åº·æª¢æŸ¥å¤±æ•—:', error);
    }
    
    const isHealthy = checks.database && checks.redis;
    
    res.status(isHealthy ? 200 : 503).json({
        status: isHealthy ? 'healthy' : 'unhealthy',
        checks
    });
};

// æ‡‰ç”¨ç¨‹å¼æ•ˆèƒ½ç›£æ§ï¼ˆAPMï¼‰
// apps/api/src/monitoring/apm.ts
import { performance, PerformanceObserver } from 'perf_hooks';

class APMMonitor {
    private metrics: Map<string, number[]> = new Map();
    
    constructor() {
        this.setupPerformanceObserver();
    }
    
    private setupPerformanceObserver() {
        const obs = new PerformanceObserver((list) => {
            for (const entry of list.getEntries()) {
                if (entry.duration > 100) { // è¨˜éŒ„æ…¢æ“ä½œ
                    console.warn(`æª¢æ¸¬åˆ°æ…¢æ“ä½œ: ${entry.name} è€—æ™‚ ${entry.duration}ms`);
                }
            }
        });
        obs.observe({ entryTypes: ['measure'] });
    }
    
    startTimer(name: string): string {
        const timerName = `${name}-${Date.now()}`;
        performance.mark(`${timerName}-start`);
        return timerName;
    }
    
    endTimer(timerName: string): number {
        performance.mark(`${timerName}-end`);
        performance.measure(timerName, `${timerName}-start`, `${timerName}-end`);
        
        const measure = performance.getEntriesByName(timerName)[0];
        const duration = measure.duration;
        
        // å„²å­˜æŒ‡æ¨™
        const baseName = timerName.split('-')[0];
        if (!this.metrics.has(baseName)) {
            this.metrics.set(baseName, []);
        }
        this.metrics.get(baseName)!.push(duration);
        
        // æ¸…ç†
        performance.clearMarks(`${timerName}-start`);
        performance.clearMarks(`${timerName}-end`);
        performance.clearMeasures(timerName);
        
        return duration;
    }
    
    getMetrics() {
        const result: Record<string, any> = {};
        
        for (const [name, values] of this.metrics.entries()) {
            result[name] = {
                count: values.length,
                avg: values.reduce((a, b) => a + b, 0) / values.length,
                min: Math.min(...values),
                max: Math.max(...values),
                p95: this.percentile(values, 0.95),
                p99: this.percentile(values, 0.99)
            };
        }
        
        return result;
    }
    
    private percentile(values: number[], p: number): number {
        const sorted = values.slice().sort((a, b) => a - b);
        const index = Math.ceil(sorted.length * p) - 1;
        return sorted[index];
    }
}

export const apmMonitor = new APMMonitor();

// åœ¨æ§åˆ¶å™¨ä¸­ä½¿ç”¨
export const getUsersController = async (req: Request, res: Response) => {
    const timer = apmMonitor.startTimer('get-users');
    
    try {
        const users = await User.find({});
        apmMonitor.endTimer(timer);
        
        res.json(users);
    } catch (error) {
        apmMonitor.endTimer(timer);
        throw error;
    }
};

// å‰ç«¯ä½¿ç”¨ Next.js é€²è¡Œç›£æ§
// apps/web/lib/monitoring.ts
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

export function initMonitoring() {
    // Web Vitals
    getCLS(sendToAnalytics);
    getFID(sendToAnalytics);
    getFCP(sendToAnalytics);
    getLCP(sendToAnalytics);
    getTTFB(sendToAnalytics);
    
    // éŒ¯èª¤é‚Šç•Œ
    window.addEventListener('error', (event) => {
        console.error('å…¨åŸŸéŒ¯èª¤:', event.error);
        sendErrorToSentry(event.error);
    });
    
    // æœªè™•ç†çš„ Promise æ‹’çµ•
    window.addEventListener('unhandledrejection', (event) => {
        console.error('æœªè™•ç†çš„ Promise æ‹’çµ•:', event.reason);
        sendErrorToSentry(event.reason);
    });
}

function sendToAnalytics(metric: any) {
    // å‚³é€åˆ°åˆ†ææœå‹™
    if (process.env.NODE_ENV === 'production') {
        fetch('/api/analytics', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                ...metric,
                timestamp: Date.now(),
                userAgent: navigator.userAgent,
                url: window.location.href
            })
        }).catch(console.error);
    }
}

function sendErrorToSentry(error: any) {
    if (process.env.NODE_ENV === 'production') {
        import('@sentry/browser').then(Sentry => {
            Sentry.captureException(error);
        });
    }
}

// çœŸå¯¦ä½¿ç”¨è€…ç›£æ§ï¼ˆRUMï¼‰
export class RUMMonitor {
    private sessionId: string;
    private userId?: string;
    
    constructor() {
        this.sessionId = this.generateSessionId();
        this.trackPageView();
        this.trackUserInteractions();
    }
    
    private generateSessionId(): string {
        return Math.random().toString(36).substring(2) + Date.now().toString(36);
    }
    
    setUserId(userId: string) {
        this.userId = userId;
    }
    
    trackPageView() {
        this.sendEvent('page_view', {
            url: window.location.href,
            referrer: document.referrer,
            timestamp: Date.now()
        });
    }
    
    trackUserInteractions() {
        document.addEventListener('click', (event) => {
            const target = event.target as HTMLElement;
            this.sendEvent('click', {
                element: target.tagName,
                id: target.id,
                className: target.className,
                text: target.textContent?.substring(0, 100)
            });
        });
    }
    
    trackCustomEvent(name: string, data: any) {
        this.sendEvent(name, data);
    }
    
    private sendEvent(name: string, data: any) {
        if (process.env.NODE_ENV === 'production') {
            fetch('/api/rum', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    event: name,
                    sessionId: this.sessionId,
                    userId: this.userId,
                    timestamp: Date.now(),
                    data
                })
            }).catch(console.error);
        }
    }
}

export const rumMonitor = new RUMMonitor();
```
</PythonEditor>

## æœ€ä½³å¯¦å‹™ç¸½çµ

### å…¨ç«¯é–‹ç™¼æœ€ä½³å¯¦å‹™

1. **æ¶æ§‹**ï¼šå¾ä¸€é–‹å§‹å°±è¨­è¨ˆå¯æ“´å±•çš„æ¶æ§‹
2. **å®‰å…¨**ï¼šåœ¨æ¯ä¸€å±¤å¯¦æ–½å®‰å…¨æªæ–½
3. **æ•ˆèƒ½**ï¼šæŒçºŒç›£æ§å’Œæœ€ä½³åŒ–
4. **æ¸¬è©¦**ï¼šè·¨æŠ€è¡“å †ç–Šçš„å…¨é¢æ¸¬è©¦ç­–ç•¥
5. **éƒ¨ç½²**ï¼šè‡ªå‹•åŒ–ã€å¯é çš„éƒ¨ç½²æµæ°´ç·š
6. **ç›£æ§**ï¼šå³æ™‚ç›£æ§å’Œå‘Šè­¦

### JavaScript ç‰¹å®šå…¨ç«¯è€ƒæ…®å› ç´ 

1. **çµ±ä¸€èªè¨€**ï¼šåœ¨æ•´å€‹æŠ€è¡“å †ç–Šä¸­é‹ç”¨ JavaScript
2. **å¥—ä»¶ç®¡ç†**ï¼šä½¿ç”¨ monorepo å¯¦ç¾æ›´å¥½çš„ç¨‹å¼ç¢¼å…±äº«
3. **é¡å‹å®‰å…¨**ï¼šå¯¦æ–½ TypeScript ä»¥ç²å¾—æ›´å¥½çš„é–‹ç™¼é«”é©—
4. **ç¾ä»£å·¥å…·**ï¼šä½¿ç”¨ç¾ä»£å»ºç½®å·¥å…·å’Œæ¡†æ¶
5. **ç„¡ä¼ºæœå™¨**ï¼šè€ƒæ…®ç„¡ä¼ºæœå™¨æ¶æ§‹é€²è¡Œæ“´å±•

## çµè«–

æ­å–œï¼ä½ å·²ç¶“å®Œæˆäº†å¾ Python åˆ° JavaScript çš„å…¨é¢å­¸ç¿’ä¹‹æ—…ã€‚ä½ ç¾åœ¨æ“æœ‰ä»¥ä¸‹çŸ¥è­˜å’ŒæŠ€èƒ½ï¼š

- ä½¿ç”¨ JavaScript å»ºç½®ç¾ä»£å…¨ç«¯æ‡‰ç”¨ç¨‹å¼
- åœ¨æ•´å€‹æ‡‰ç”¨ç¨‹å¼ä¸­æ‡‰ç”¨å®‰å…¨æœ€ä½³å¯¦å‹™
- åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­éƒ¨ç½²å’Œæ“´å±•æ‡‰ç”¨ç¨‹å¼
- ç›£æ§å’Œæœ€ä½³åŒ–æ‡‰ç”¨ç¨‹å¼æ•ˆèƒ½
- å¾ Python é–‹ç™¼é †åˆ©éæ¸¡åˆ° JavaScript é–‹ç™¼

### ä¸‹ä¸€æ­¥

1. **å¯¦è¸**ï¼šä½¿ç”¨æ‰€å­¸æ¦‚å¿µå»ºç½®çœŸå¯¦å°ˆæ¡ˆ
2. **ç¤¾ç¾¤**ï¼šåŠ å…¥ JavaScript å’Œ Node.js ç¤¾ç¾¤
3. **ä¿æŒæ›´æ–°**ï¼šè·Ÿä¸Šå¿«é€Ÿç™¼å±•çš„ JavaScript ç”Ÿæ…‹ç³»çµ±
4. **å°ˆæ¥­åŒ–**ï¼šé¸æ“‡ Reactã€Vueã€Node.js æˆ–ç‰¹å®šæ¡†æ¶ç­‰é ˜åŸŸæ·±åŒ–å°ˆæ¥­çŸ¥è­˜
5. **åˆ†äº«çŸ¥è­˜**ï¼šä»¥ä½ ç¨ç‰¹çš„ Python + JavaScript è¦–è§’å›é¥‹ç¤¾ç¾¤

å¾ Python åˆ° JavaScript çš„å­¸ç¿’ä¹‹è·¯ç‚ºä½ åœ¨ Web é–‹ç™¼ã€è¡Œå‹•é–‹ç™¼ç­‰é ˜åŸŸé–‹å•Ÿäº†æ–°çš„æ©Ÿæœƒã€‚ä½ çš„ Python èƒŒæ™¯ç‚ºä½ åœ¨ JavaScript é–‹ç™¼ä¸­å–å¾—æˆåŠŸæä¾›äº†å …å¯¦çš„åŸºç¤ã€‚

---

*ä½ å·²ç¶“å®Œæˆäº†å®Œæ•´çš„ Python â†’ JavaScript å­¸ç¿’è·¯å¾‘ï¼ğŸ‰*
