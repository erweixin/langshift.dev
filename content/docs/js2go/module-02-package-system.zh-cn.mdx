---
title: 包系统与模块化
---

本模块探讨 Go 的包系统和模块管理，这是组织和构建 Go 代码的基础。与 JavaScript 的模块系统不同，Go 使用独特的方法进行包管理和依赖解析。

## 理解 Go 包

Go 中的**包**是一种将相关代码分组在一起的方式。每个 Go 文件都属于一个包，包是代码组织和重用的主要机制。

### 包声明

每个 Go 文件都必须以包声明开始，这决定了包名。

#### 包声明规则

在 Go 中，**同一文件夹里的所有 `.go` 文件必须使用相同的 `package` 声明**。这是 Go 语言的基本规则之一。

<UniversalEditor title="包声明规则对比" compare={true}>
```javascript !! js
// JavaScript: 每个文件可以有不同的模块名
// file: middleware/auth.js
export function authMiddleware() {
    // 认证中间件逻辑
}

// file: middleware/cors.js
export function corsMiddleware() {
    // CORS 中间件逻辑
}

// file: middleware/logging.js
export function loggingMiddleware() {
    // 日志中间件逻辑
}

// 使用时需要分别导入
import { authMiddleware } from './middleware/auth.js';
import { corsMiddleware } from './middleware/cors.js';
import { loggingMiddleware } from './middleware/logging.js';
```

```go !! go
// Go: 同一文件夹所有文件使用相同包名
// file: middleware/auth.go
package middleware

func AuthMiddleware() {
    // 认证中间件逻辑
}

// file: middleware/cors.go
package middleware

func CorsMiddleware() {
    // CORS 中间件逻辑
}

// file: middleware/logging.go
package middleware

func LoggingMiddleware() {
    // 日志中间件逻辑
}

// 使用时只需要导入一次包
import "my-project/middleware"

func main() {
    middleware.AuthMiddleware()
    middleware.CorsMiddleware()
    middleware.LoggingMiddleware()
}
```
</UniversalEditor>

#### 包名约定

<UniversalEditor title="包名约定对比" compare={true}>
```javascript !! js
// JavaScript: 模块系统 (ES6)
// file: math.js
export const PI = 3.14159;
export function add(a, b) {
    return a + b;
}
export function multiply(a, b) {
    return a * b;
}

// file: main.js
import { PI, add, multiply } from './math.js';
console.log(PI);
console.log(add(5, 3));
```

```go !! go
// Go: 包系统
// file: math/math.go
package math

const PI = 3.14159

func Add(a, b int) int {
    return a + b
}

func Multiply(a, b int) int {
    return a * b
}

// file: main.go
package main

import (
    "fmt"
    "./math" // 导入本地包
)

func main() {
    fmt.Println(math.PI)
    fmt.Println(math.Add(5, 3))
    fmt.Println(math.Multiply(4, 6))
}
```
</UniversalEditor>

#### 实际项目示例

让我们通过一个实际的项目结构来理解包声明规则：

<UniversalEditor title="实际项目结构示例" compare={true}>
```javascript !! js
// JavaScript: 项目结构
my-project/
├── src/
│   ├── middleware/
│   │   ├── auth.js        // 独立模块
│   │   ├── cors.js        // 独立模块
│   │   └── logging.js     // 独立模块
│   ├── utils/
│   │   ├── math.js        // 独立模块
│   │   └── string.js      // 独立模块
│   └── main.js
├── package.json
└── node_modules/

// 每个文件都是独立的模块
// file: middleware/auth.js
export function authMiddleware() {
    return "auth logic";
}

// file: middleware/cors.js
export function corsMiddleware() {
    return "cors logic";
}

// 使用时需要分别导入
import { authMiddleware } from './middleware/auth.js';
import { corsMiddleware } from './middleware/cors.js';
```

```go !! go
// Go: 项目结构
my-project/
├── internal/
│   ├── middleware/
│   │   ├── auth.go        // package middleware
│   │   ├── cors.go        // package middleware
│   │   └── logging.go     // package middleware
│   └── utils/
│       ├── math.go        // package utils
│       └── string.go      // package utils
├── cmd/
│   └── main.go           // package main
├── go.mod
└── go.sum

// 同一文件夹的所有文件使用相同包名
// file: internal/middleware/auth.go
package middleware

func AuthMiddleware() string {
    return "auth logic"
}

// file: internal/middleware/cors.go
package middleware

func CorsMiddleware() string {
    return "cors logic"
}

// file: internal/middleware/logging.go
package middleware

func LoggingMiddleware() string {
    return "logging logic"
}

// 使用时只需要导入一次包
import "my-project/internal/middleware"

func main() {
    middleware.AuthMiddleware()
    middleware.CorsMiddleware()
    middleware.LoggingMiddleware()
}
```
</UniversalEditor>

### Go 中的特殊目录

Go 有一些具有特殊含义的目录，这些含义由编译器强制执行或作为广泛采用的约定：

- **`internal/`**: 此目录中的代码**只能**被 `internal` 父目录中的代码导入。这是在项目级别强制封装的一种方式。
    - *对比*: JavaScript 没有直接的等价物，尽管有些工具遵循 `_` 前缀或私有 npm 包。
- **`cmd/`**: 包含项目的主应用程序。每个子目录通常对应可执行文件的名称（例如 `cmd/server/main.go`）。
- **`pkg/`**: （约定）可以被外部应用程序使用的库代码。


#### 重要注意事项

1. **包名一致性**：同一文件夹的所有 `.go` 文件必须使用相同的 `package` 声明
2. **编译错误**：如果违反此规则，Go 编译器会报错
3. **导入方式**：导入时只需要指定包路径，不需要指定具体文件
4. **命名约定**：包名通常使用小写，避免下划线
5. **包名与文件夹名**：包名通常与文件夹名相同，但不是强制的

## Go 模块 vs JavaScript 包管理器

Go 模块是 Go 中管理依赖的现代方式，类似于 JavaScript 中的 npm/yarn，但有一些关键差异。

### 依赖包格式对比

Go 和 JavaScript 在依赖包格式上有根本性的不同：

<UniversalEditor title="依赖包格式对比" compare={true}>
```javascript !! js
// JavaScript: 包名格式
// package.json
{
  "dependencies": {
    "express": "^4.18.2",           // 简单包名
    "@angular/core": "^16.0.0",     // 作用域包
    "lodash": "^4.17.21",           // 简单包名
    "@types/node": "^20.0.0"        // 类型定义包
  }
}

// 安装时使用包名
// npm install express
// npm install @angular/core
// npm install lodash

// 导入时使用包名
import express from 'express';
import { Component } from '@angular/core';
import _ from 'lodash';
```

```go !! go
// Go: 模块路径格式
// go.mod
module my-project

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1        // 完整的 Git 仓库路径
    github.com/go-sql-driver/mysql v1.7.1  // 数据库驱动
    golang.org/x/text v0.14.0              // 官方扩展库
    google.golang.org/grpc v1.59.0         // Google 官方库
    k8s.io/client-go v0.28.0               // Kubernetes 客户端
)

// 安装时使用完整路径
// go get github.com/gin-gonic/gin
// go get golang.org/x/text
// go get google.golang.org/grpc

// 导入时使用完整路径
import (
    "github.com/gin-gonic/gin"
    "golang.org/x/text/transform"
    "google.golang.org/grpc"
)
```
</UniversalEditor>

### 包命名约定的差异

<UniversalEditor title="包命名约定对比" compare={true}>
```javascript !! js
// JavaScript: 灵活的包命名
// 1. 简单包名
"express"
"lodash"
"axios"

// 2. 作用域包（组织/公司）
"@angular/core"
"@types/node"
"@babel/core"

// 3. 私有包（需要 npm 配置）
"@mycompany/private-lib"

// 4. 本地包
"file:../local-package"
"file:./relative-path"

// 5. Git 仓库（较少使用）
"git+https://github.com/user/repo.git"
"git+ssh://git@github.com/user/repo.git#branch"

// 包名可以任意，主要依赖 npm registry
```

```go !! go
// Go: 基于 Git 仓库的模块路径
// 1. GitHub 仓库（最常见）
"github.com/gin-gonic/gin"
"github.com/go-sql-driver/mysql"
"github.com/gorilla/mux"

// 2. 官方扩展库
"golang.org/x/text"
"golang.org/x/net"

// 3. Google 官方库
"google.golang.org/grpc"
"google.golang.org/protobuf"

// 4. 其他 Git 托管服务
"gitlab.com/user/project"
"bitbucket.org/user/project"
"gitee.com/user/project"

// 5. 私有仓库
"git.company.com/team/project"
"internal.company.com/private-lib"

// 6. 本地模块（开发时）
"my-project/internal/utils"
"my-project/pkg/math"

// 模块路径必须对应实际的 Git 仓库路径
```
</UniversalEditor>

### 依赖解析机制对比

<UniversalEditor title="依赖解析机制对比" compare={true}>
```javascript !! js
// JavaScript: 基于 Registry 的解析
// 1. 默认从 npm registry 解析
npm install express
// 解析: https://registry.npmjs.org/express

// 2. 可以配置不同的 registry
npm config set registry https://registry.npm.taobao.org/

// 3. 私有 registry
npm install @mycompany/private-lib
// 解析: https://npm.mycompany.com/@mycompany/private-lib

// 4. 作用域包
npm install @angular/core
// 解析: https://registry.npmjs.org/@angular/core

// 5. 版本解析
"express": "^4.18.2"  // 语义化版本
"lodash": "~4.17.21"  // 补丁版本
"axios": "latest"     // 最新版本

// 6. 依赖树管理
// node_modules/
// ├── express/
// │   ├── package.json
// │   └── node_modules/
// │       └── accepts/
// └── lodash/
```

```go !! go
// Go: 基于 Git 仓库的解析
// 1. 直接从 Git 仓库获取
go get github.com/gin-gonic/gin
// 解析: https://github.com/gin-gonic/gin.git

// 2. 支持多种 Git 协议
// HTTPS: https://github.com/user/repo.git
// SSH: git@github.com:user/repo.git
// Git: git://github.com/user/repo.git

// 3. 私有仓库支持
go get git.company.com/team/project
// 需要配置 Git 认证

// 4. 版本解析（基于 Git tags）
"github.com/gin-gonic/gin v1.9.1"  // 具体版本
"github.com/gin-gonic/gin latest"  // 最新版本
"github.com/gin-gonic/gin master"  // 分支

// 5. 模块缓存
// $GOPATH/pkg/mod/
// ├── github.com/
// │   └── gin-gonic/
// │       └── gin@v1.9.1/

// 6. 代理支持（Go 1.13+）
// GOPROXY=https://proxy.golang.org,direct
// 或私有代理: GOPROXY=https://proxy.company.com,direct
```
</UniversalEditor>

### 模块初始化

<UniversalEditor title="模块初始化对比" compare={true}>
```javascript !! js
// JavaScript: npm/yarn 初始化
// package.json (由 npm init 创建)
{
  "name": "my-project",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "jest": "^29.5.0"
  }
}

// 安装依赖
// npm install
// 或
// yarn install
```

```go !! go
// Go: 模块初始化
// go.mod (由 go mod init 创建)
module my-project

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/go-sql-driver/mysql v1.7.1
)

// 初始化模块
// go mod init my-project

// 添加依赖
// go get github.com/gin-gonic/gin
// go get github.com/go-sql-driver/mysql
```
</UniversalEditor>

## 包组织和结构

Go 有特定的约定来组织包和项目。

### 标准项目布局

<UniversalEditor title="项目结构对比" compare={true}>
```javascript !! js
// JavaScript: 典型项目结构
my-project/
├── package.json
├── node_modules/
├── src/
│   ├── components/
│   │   ├── Header.js
│   │   └── Footer.js
│   ├── utils/
│   │   ├── math.js
│   │   └── helpers.js
│   └── main.js
├── tests/
│   └── test.js
└── README.md
```

```go !! go
// Go: 标准项目结构
my-project/
├── go.mod
├── go.sum
├── cmd/
│   └── main.go
├── internal/
│   ├── handlers/
│   │   └── user.go
│   └── models/
│       └── user.go
├── pkg/
│   ├── math/
│   │   └── math.go
│   └── utils/
│       └── helpers.go
├── api/
│   └── routes.go
├── tests/
│   └── math_test.go
└── README.md
```
</UniversalEditor>

## 导入系统

Go 的导入系统比 JavaScript 更严格，需要显式导入并遵循特定约定。

### 导入类型和用法

<UniversalEditor title="导入系统对比" compare={true}>
```javascript !! js
// JavaScript: 各种导入样式
// 默认导入
import express from 'express';

// 命名导入
import { useState, useEffect } from 'react';

// 命名空间导入
import * as math from './math.js';

// 动态导入
const module = await import('./dynamic-module.js');

// 解构重命名
import { add as addNumbers } from './math.js';

// 默认和命名导入
import defaultExport, { namedExport } from './module.js';
```

```go !! go
// Go: 导入系统
package main

import (
    // 标准库导入
    "fmt"
    "net/http"
    "time"
    
    // 第三方导入
    "github.com/gin-gonic/gin"
    "github.com/go-sql-driver/mysql"
    
    // 本地导入
    "./internal/handlers"
    "./pkg/math"
)

// 带别名的导入
import (
    mymath "./pkg/math"
)

// 带点的导入（将所有名称带入当前作用域）
import (
    . "./pkg/math" // 现在可以直接使用 Add() 而不是 math.Add()
)

// 带下划线的导入（仅用于副作用）
import (
    _ "github.com/go-sql-driver/mysql" // 注册 MySQL 驱动
)

func main() {
    fmt.Println("Hello, Go!")
    fmt.Println(math.Add(5, 3))
    fmt.Println(mymath.Multiply(4, 6))
}
```
</UniversalEditor>

## 包可见性和导出

Go 使用大小写来控制可见性，与 JavaScript 的显式导出/导入系统不同。

<UniversalEditor title="可见性规则对比" compare={true}>
```javascript !! js
// JavaScript: 显式导出
// file: utils.js
export const publicVariable = "我是公开的";
export function publicFunction() {
    return "我是公开的";
}

const privateVariable = "我是私有的";
function privateFunction() {
    return "我是私有的";
}

// 默认导出
export default function mainFunction() {
    return "我是默认导出";
}

// file: main.js
import mainFunction, { publicVariable, publicFunction } from './utils.js';
```

```go !! go
// Go: 基于大小写的可见性
// file: utils/utils.go
package utils

// 导出的（大写）
var PublicVariable = "我是公开的"
func PublicFunction() string {
    return "我是公开的"
}

// 未导出的（小写）
var privateVariable = "我是私有的"
func privateFunction() string {
    return "我是私有的"
}

// file: main.go
package main

import (
    "fmt"
    "./utils"
)

func main() {
    fmt.Println(utils.PublicVariable)    // ✅ 可访问
    fmt.Println(utils.PublicFunction())  // ✅ 可访问
    // fmt.Println(utils.privateVariable) // ❌ 不可访问
    // fmt.Println(utils.privateFunction()) // ❌ 不可访问
}
```
</UniversalEditor>

## Go 模块和依赖管理

Go 模块提供了具有版本控制和可重现构建的现代依赖管理方法。

### 模块文件

<UniversalEditor title="模块文件对比" compare={true}>
```javascript !! js
// JavaScript: package.json 和 package-lock.json
// package.json
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21"
  },
  "devDependencies": {
    "jest": "^29.5.0"
  },
  "scripts": {
    "start": "node index.js",
    "test": "jest"
  }
}

// package-lock.json (自动生成)
// 包含确切版本和依赖树
```

```go !! go
// Go: go.mod 和 go.sum
// go.mod
module my-app

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/go-sql-driver/mysql v1.7.1
)

require (
    github.com/bytedance/sonic v1.9.1 // indirect
    github.com/chenzhuoyu/base64x v0.0.0-20221115062448-fe3a3abad311 // indirect
    // ... 更多间接依赖
)

// go.sum (自动生成)
// 包含用于可重现构建的加密哈希
github.com/bytedance/sonic v1.9.1 h1:6iJ6NqdoxCDr6mbY8h18oSO+cShGSMRGCEo7F2h0x8s=
github.com/bytedance/sonic v1.9.1/go.mod h1:i736AoUSYt75HyZLoJW9ERYxcy6eaN6h4BZXU064P/U=
// ... 更多哈希
```
</UniversalEditor>

### 依赖管理命令

<UniversalEditor title="依赖管理命令" compare={true}>
```javascript !! js
// JavaScript: npm/yarn 命令
// 安装依赖
npm install
yarn install

// 添加新依赖
npm install express
yarn add express

// 添加开发依赖
npm install --save-dev jest
yarn add --dev jest

// 移除依赖
npm uninstall lodash
yarn remove lodash

// 更新依赖
npm update
yarn upgrade

// 列出依赖
npm list
yarn list
```

```go !! go
// Go: go mod 命令
// 初始化模块
go mod init my-project

// 添加依赖
go get github.com/gin-gonic/gin
go get github.com/go-sql-driver/mysql@v1.7.1

// 移除未使用的依赖
go mod tidy

// 下载依赖
go mod download

// 验证依赖
go mod verify

// 列出依赖
go list -m all

// 更新依赖
go get -u github.com/gin-gonic/gin
go get -u all
```
</UniversalEditor>

### Go 模块路径格式详解

Go 的模块路径格式 `github.com/xxxx` 不仅仅是命名约定，而是整个依赖管理系统的核心：

<UniversalEditor title="模块路径格式详解" compare={true}>
```javascript !! js
// JavaScript: 包名与仓库分离
// package.json
{
  "name": "my-awesome-lib",        // 包名可以任意
  "repository": {                  // 仓库信息单独配置
    "type": "git",
    "url": "https://github.com/user/my-awesome-lib.git"
  },
  "dependencies": {
    "express": "^4.18.2"          // 包名，不包含仓库信息
  }
}

// 包名和仓库可以完全不同
// 包名: "lodash"
// 仓库: https://github.com/lodash/lodash.git

// 导入时只使用包名
import express from 'express';
import _ from 'lodash';
```

```go !! go
// Go: 模块路径直接对应仓库
// go.mod
module github.com/user/my-project  // 模块路径必须对应仓库

require (
    github.com/gin-gonic/gin v1.9.1    // 路径 = 仓库地址
    github.com/go-sql-driver/mysql v1.7.1
)

// 模块路径格式规则：
// 1. 必须对应实际的 Git 仓库地址
// 2. 格式: {host}/{owner}/{repo}
// 3. 常见格式：
//    - github.com/user/repo
//    - gitlab.com/user/repo
//    - bitbucket.org/user/repo
//    - golang.org/x/text (官方扩展)
//    - google.golang.org/grpc (Google 官方)

// 导入时使用完整路径
import (
    "github.com/gin-gonic/gin"     // 路径必须与仓库一致
    "github.com/go-sql-driver/mysql"
)
```
</UniversalEditor>

### 模块路径的优势和挑战

<UniversalEditor title="模块路径的优势和挑战" compare={true}>
```javascript !! js
// JavaScript: 包名系统的特点
// 优势：
// 1. 包名简洁，易于记忆
// 2. 包名可以独立于仓库
// 3. 支持作用域包 (@org/package)
// 4. 可以重命名包
// 5. 私有包支持良好

// 挑战：
// 1. 包名可能与仓库名不一致
// 2. 需要额外的仓库配置
// 3. 包名冲突问题
// 4. 依赖来源不够透明

// 示例：包名与仓库分离
{
  "name": "awesome-utils",           // 包名
  "repository": "git://github.com/user/old-repo-name.git"  // 仓库
}

// 用户使用时只看到包名
import utils from 'awesome-utils';  // 不知道实际仓库
```

```go !! go
// Go: 模块路径系统的特点
// 优势：
// 1. 路径直接对应仓库，透明度高
// 2. 避免包名冲突
// 3. 自动处理仓库迁移
// 4. 支持多种 Git 托管服务
// 5. 版本控制与 Git tags 集成

// 挑战：
// 1. 路径较长，不够简洁
// 2. 依赖仓库的可用性
// 3. 私有仓库配置复杂
// 4. 网络依赖问题

// 示例：路径直接对应仓库
require (
    github.com/gin-gonic/gin v1.9.1  // 直接对应 https://github.com/gin-gonic/gin
)

// 用户使用时看到完整路径
import "github.com/gin-gonic/gin"    // 明确知道仓库位置
```
</UniversalEditor>

## 包类型和约定

Go 有几种具有特定目的和约定的包类型。

### Main 包

`main` 包在 Go 中是特殊的 - 它是可执行程序的入口点。

<UniversalEditor title="Main 包示例" compare={true}>
```javascript !! js
// JavaScript: 入口点
// file: index.js
const express = require('express');
const app = express();

app.get('/', (req, res) => {
    res.send('Hello World!');
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});

// package.json
{
  "scripts": {
    "start": "node index.js"
  }
}
```

```go !! go
// Go: Main 包
// file: main.go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "Hello World!")
    })
    
    fmt.Println("Server running on port 3000")
    http.ListenAndServe(":3000", nil)
}

// 构建和运行
// go build
// ./my-app
```
</UniversalEditor>

### 库包

库包是可以被其他包导入的可重用代码。

<UniversalEditor title="库包示例" compare={true}>
```javascript !! js
// JavaScript: 库模块
// file: math-utils.js
export class Calculator {
    static add(a, b) {
        return a + b;
    }
    
    static multiply(a, b) {
        return a * b;
    }
}

export const PI = 3.14159;
export const E = 2.71828;

// file: main.js
import { Calculator, PI } from './math-utils.js';
console.log(Calculator.add(5, 3));
console.log(PI);
```

```go !! go
// Go: 库包
// file: math/calculator.go
package math

const PI = 3.14159
const E = 2.71828

type Calculator struct{}

func (c *Calculator) Add(a, b float64) float64 {
    return a + b
}

func (c *Calculator) Multiply(a, b float64) float64 {
    return a * b
}

// 静态方法（包级函数）
func Add(a, b float64) float64 {
    return a + b
}

func Multiply(a, b float64) float64 {
    return a * b
}

// file: main.go
package main

import (
    "fmt"
    "./math"
)

func main() {
    calc := &math.Calculator{}
    fmt.Println(calc.Add(5, 3))
    fmt.Println(math.Add(5, 3)) // 静态函数
    fmt.Println(math.PI)
}
```
</UniversalEditor>

## 内部包

Go 有一个特殊的 `internal` 目录，用于只能在同一模块内使用的包。

<UniversalEditor title="内部包示例" compare={true}>
```javascript !! js
// JavaScript: 无内置内部概念
// 约定：使用下划线前缀或放在私有目录中
// file: _internal/helpers.js
export function internalHelper() {
    return "internal";
}

// file: main.js
import { internalHelper } from './_internal/helpers.js';
// 注意：这只是约定，不是语言强制执行的
```

```go !! go
// Go: 内部包（由编译器强制执行）
// file: internal/helpers/helpers.go
package helpers

func InternalHelper() string {
    return "internal"
}

// file: main.go
package main

import (
    "fmt"
    "./internal/helpers" // ✅ 可以从 internal 导入
)

func main() {
    fmt.Println(helpers.InternalHelper())
}

// file: another-module/main.go
package main

import (
    "fmt"
    "github.com/user/my-project/internal/helpers" // ❌ 无法从另一个模块的 internal 导入
)

func main() {
    // 这会导致编译错误
    fmt.Println(helpers.InternalHelper())
}
```
</UniversalEditor>

## Vendor 目录和依赖管理

Go 支持供应商依赖，用于离线开发和可重现构建。

<UniversalEditor title="Vendor 目录示例" compare={true}>
```javascript !! js
// JavaScript: 无内置供应商功能
// 约定：使用 npm pack 或复制 node_modules
// npm pack 创建包含依赖的压缩包
// npm pack express

// 或手动复制依赖
// cp -r node_modules vendor/
```

```go !! go
// Go: Vendor 目录
// 创建包含依赖的 vendor 目录
go mod vendor

// 这会创建：
my-project/
├── go.mod
├── go.sum
├── vendor/
│   ├── github.com/
│   │   └── gin-gonic/
│   │       └── gin/
│   │           ├── go.mod
│   │           └── *.go
│   └── modules.txt
└── main.go

// 使用供应商依赖构建
go build -mod=vendor

// 或设置环境变量
export GOFLAGS="-mod=vendor"
go build
```
</UniversalEditor>

## 工作区支持 (Go 1.18+)

Go 工作区允许在单个工作区中管理多个模块，类似于 JavaScript 单体仓库。

<UniversalEditor title="工作区示例" compare={true}>
```javascript !! js
// JavaScript: 带工作区的单体仓库
// package.json (根目录)
{
  "name": "my-monorepo",
  "workspaces": [
    "packages/*"
  ],
  "private": true
}

// packages/app/package.json
{
  "name": "@my-org/app",
  "dependencies": {
    "@my-org/utils": "workspace:*"
  }
}

// packages/utils/package.json
{
  "name": "@my-org/utils",
  "version": "1.0.0"
}
```

```go !! go
// Go: 工作区 (Go 1.18+)
// go.work (根目录)
go 1.21

use (
    ./app
    ./utils
    ./shared
)

// app/go.mod
module my-org/app

go 1.21

require my-org/utils v0.0.0

replace my-org/utils => ../utils

// utils/go.mod
module my-org/utils

go 1.21

// shared/go.mod
module my-org/shared

go 1.21

// 初始化工作区
go work init ./app ./utils ./shared

// 向工作区添加模块
go work use ./new-module

// 从工作区移除模块
go work edit -dropuse ./old-module
```
</UniversalEditor>

---

### 练习题：
1. 解释 Go 的包系统与 JavaScript 模块系统的区别。每种方法的优缺点是什么？
2. Go 中 `internal` 目录的意义是什么，它与 JavaScript 处理私有模块的方法有何不同？
3. Go 基于大小写的可见性系统如何工作，它与 JavaScript 的显式导出/导入系统相比如何？
4. 创建一个具有多个包的 Go 模块，并演示如何使用标准 Go 项目布局组织代码。

### 实际项目对比示例

让我们通过一个实际的 Web 应用项目来对比两种包管理方式：

<UniversalEditor title="实际项目对比" compare={true}>
```javascript !! js
// JavaScript: Express.js Web 应用
// package.json
{
  "name": "my-web-app",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.5.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.5.0"
  }
}

// 安装依赖
npm install

// 项目结构
my-web-app/
├── package.json
├── node_modules/          # 所有依赖都在这里
├── src/
│   ├── routes/
│   ├── models/
│   └── middleware/
└── tests/

// 导入依赖
import express from 'express';
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';
```

```go !! go
// Go: Gin Web 应用
// go.mod
module github.com/user/my-web-app

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    go.mongodb.org/mongo-driver v1.12.1
    golang.org/x/crypto v0.14.0
    github.com/golang-jwt/jwt/v5 v5.0.0
    github.com/gin-contrib/cors v1.4.0
)

// 安装依赖
go mod tidy

// 项目结构
my-web-app/
├── go.mod
├── go.sum
├── cmd/
│   └── main.go
├── internal/
│   ├── handlers/
│   ├── models/
│   └── middleware/
└── tests/

// 导入依赖
import (
    "github.com/gin-gonic/gin"
    "go.mongodb.org/mongo-driver/mongo"
    "golang.org/x/crypto/bcrypt"
    "github.com/golang-jwt/jwt/v5"
)
```
</UniversalEditor>

### 关键差异总结

| 特性 | JavaScript (npm) | Go (go mod) |
|------|------------------|-------------|
| **包标识符** | 简单包名 (`express`) | 完整仓库路径 (`github.com/gin-gonic/gin`) |
| **依赖来源** | npm registry | Git 仓库 |
| **版本控制** | 语义化版本 + package-lock.json | Git tags + go.sum |
| **私有包** | 作用域包 (`@company/pkg`) | 私有 Git 仓库 (`git.company.com/pkg`) |
| **缓存位置** | `node_modules/` | `$GOPATH/pkg/mod/` |
| **依赖解析** | 基于 registry 查询 | 基于 Git 仓库克隆 |
| **网络依赖** | 依赖 npm registry 可用性 | 依赖 Git 仓库可用性 |
| **透明度** | 包名与仓库分离 | 路径直接对应仓库 |

### 项目想法：
* 使用 Go 模块构建一个简单的 Web 应用程序。为处理器、模型和实用程序创建单独的包。使用标准 Go 项目布局，演示正确的包组织、依赖管理和模块结构。

### 下一步：
* 学习 Go 的类型系统和接口
* 探索 Go 强大的并发特性：goroutines 和 channels
* 理解 Go 的错误处理模式和最佳实践
