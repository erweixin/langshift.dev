---
title: 类型系统与接口
---

本模块探讨 Go 的类型系统和接口，这是 Go 设计哲学的基础。Go 的类型系统是静态类型的，但通过接口提供了一些动态特性，在安全性和灵活性之间取得了平衡，这与 JavaScript 的动态类型有显著不同。

## Go 类型系统概述

Go 是一种静态类型语言，意味着类型在编译时检查。与 JavaScript 的动态类型相比，这提供了更好的性能、更早的错误检测和更清晰的代码文档。

### 静态类型 vs 动态类型

<UniversalEditor title="类型系统对比" compare={true}>
```javascript !! js
// JavaScript: 动态类型
let value = 42;           // number
console.log(typeof value); // "number"

value = "hello";          // string
console.log(typeof value); // "string"

value = { name: "John" }; // object
console.log(typeof value); // "object"

// 类型在运行时检查
function processData(data) {
    return data.length; // 对字符串、数组有效，但对数字失败
}

processData("hello"); // 5
processData([1, 2, 3]); // 3
processData(42); // TypeError: data.length is not a function
```

```go !! go
// Go: 静态类型
package main

import "fmt"

func main() {
    var value int = 42
    fmt.Printf("Type: %T, Value: %v\n", value, value) // Type: int, Value: 42
    
    // value = "hello" // 编译错误: cannot use "hello" (type string) as int
    
    // 类型在编译时检查
    processData("hello") // 有效
    // processData([]int{1, 2, 3}) // 编译错误: cannot use []int literal as type string in argument to processData
    // processData(42) // 编译错误: cannot use 42 (type int) as type string in argument to processData
}

func processData(data string) {
    fmt.Println(len(data))
}
```
</UniversalEditor>

## 基本类型

Go 提供了比 JavaScript 原始类型更丰富的显式基本类型集合。

### 数值类型

<UniversalEditor title="数值类型对比" compare={true}>
```javascript !! js
// JavaScript: 单一数字类型 (64位浮点数)
let integer = 42;
let float = 3.14;
let bigInt = 9007199254740991n; // BigInt 用于大整数

console.log(typeof integer); // "number"
console.log(typeof float);   // "number"
console.log(typeof bigInt);  // "bigint"

// 所有数字都是 64 位浮点数 (除了 BigInt)
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
```

```go !! go
// Go: 多种数值类型用于不同用例
package main

import "fmt"

func main() {
    // 整数类型
    var int8Val int8 = 127        // 8位有符号整数 (-128 到 127)
    var int16Val int16 = 32767    // 16位有符号整数
    var int32Val int32 = 2147483647 // 32位有符号整数
    var int64Val int64 = 9223372036854775807 // 64位有符号整数
    var intVal int = 42           // 平台相关 (32 或 64 位)
    
    // 无符号整数类型
    var uint8Val uint8 = 255      // 8位无符号整数 (0 到 255)
    var uint16Val uint16 = 65535  // 16位无符号整数
    var uint32Val uint32 = 4294967295 // 32位无符号整数
    var uint64Val uint64 = 18446744073709551615 // 64位无符号整数
    var uintVal uint = 42         // 平台相关
    
    // 浮点类型
    var float32Val float32 = 3.14 // 32位浮点数
    var float64Val float64 = 3.14159265359 // 64位浮点数
    
    // 复数类型
    var complex64Val complex64 = 3 + 4i  // 64位复数
    var complex128Val complex128 = 3 + 4i // 128位复数
    
    fmt.Printf("int8: %T, uint8: %T, float32: %T\n", int8Val, uint8Val, float32Val)
}
```
</UniversalEditor>

### 字符串和布尔类型

<UniversalEditor title="字符串和布尔类型对比" compare={true}>
```javascript !! js
// JavaScript: 字符串和布尔值
let str = "Hello, World!";
let bool = true;

console.log(typeof str);  // "string"
console.log(typeof bool); // "boolean"

// 字符串操作
console.log(str.length);           // 13
console.log(str.toUpperCase());    // "HELLO, WORLD!"
console.log(str.includes("World")); // true

// 布尔操作
console.log(!bool);                // false
console.log(bool && true);         // true
console.log(bool || false);        // true
```

```go !! go
// Go: 字符串和布尔值
package main

import (
    "fmt"
    "strings"
)

func main() {
    var str string = "Hello, World!"
    var boolVal bool = true
    
    fmt.Printf("str type: %T, bool type: %T\n", str, boolVal)
    
    // 字符串操作
    fmt.Println(len(str))                    // 13
    fmt.Println(strings.ToUpper(str))        // "HELLO, WORLD!"
    fmt.Println(strings.Contains(str, "World")) // true
    
    // 布尔操作
    fmt.Println(!boolVal)                    // false
    fmt.Println(boolVal && true)             // true
    fmt.Println(boolVal || false)            // true
    
    // Go 中的字符串是不可变的
    // str[0] = 'h' // 编译错误: cannot assign to str[0]
}
```
</UniversalEditor>

## 复合类型

Go 提供了几种复合类型，允许将值组合在一起。

### 数组和切片

<UniversalEditor title="数组和切片对比" compare={true}>
```javascript !! js
// JavaScript: 数组 (动态)
let arr = [1, 2, 3, 4, 5];
console.log(arr.length); // 5

// 动态调整大小
arr.push(6);             // [1, 2, 3, 4, 5, 6]
arr.pop();               // [1, 2, 3, 4, 5]
arr.splice(1, 2);        // [1, 4, 5]

// 数组方法
let doubled = arr.map(x => x * 2);     // [2, 8, 10]
let sum = arr.reduce((a, b) => a + b); // 10

// 切片
let slice = arr.slice(1, 3);           // [4, 5]
```

```go !! go
// Go: 数组 (固定大小) 和切片 (动态)
package main

import "fmt"

func main() {
    // 数组: 固定大小
    var arr [5]int = [5]int{1, 2, 3, 4, 5}
    fmt.Println(len(arr)) // 5
    
    // 无法调整数组大小
    // arr = append(arr, 6) // 编译错误: cannot use append with array
    
    // 切片: 动态大小
    var slice []int = []int{1, 2, 3, 4, 5}
    fmt.Println(len(slice)) // 5
    
    // 动态调整大小
    slice = append(slice, 6) // [1, 2, 3, 4, 5, 6]
    slice = slice[:len(slice)-1] // 移除最后一个元素: [1, 2, 3, 4, 5]
    
    // 切片操作
    subSlice := slice[1:3] // [2, 3]
    
    // 数组到切片的转换
    sliceFromArray := arr[:] // 将数组转换为切片
    
    fmt.Printf("Array: %v, Slice: %v\n", arr, slice)
}
```
</UniversalEditor>

### 映射

<UniversalEditor title="映射对比" compare={true}>
```javascript !! js
// JavaScript: 对象和映射
let obj = { name: "John", age: 30 };
let map = new Map();
map.set("name", "John");
map.set("age", 30);

console.log(obj.name);           // "John"
console.log(map.get("name"));    // "John"

// 对象操作
obj.city = "New York";           // 添加属性
delete obj.age;                  // 删除属性
console.log("name" in obj);      // true

// 映射操作
map.set("city", "New York");     // 添加键值对
map.delete("age");               // 删除键
console.log(map.has("name"));    // true
```

```go !! go
// Go: 映射
package main

import "fmt"

func main() {
    // 映射声明和初始化
    var m map[string]int = make(map[string]int)
    m["name"] = 1
    m["age"] = 30
    
    // 或使用字面量语法
    person := map[string]interface{}{
        "name": "John",
        "age":  30,
        "city": "New York",
    }
    
    // 访问值
    fmt.Println(person["name"]) // "John"
    
    // 检查键是否存在
    if age, exists := person["age"]; exists {
        fmt.Printf("Age: %v\n", age)
    }
    
    // 添加/更新值
    person["country"] = "USA"
    
    // 删除值
    delete(person, "age")
    
    // 遍历映射
    for key, value := range person {
        fmt.Printf("%s: %v\n", key, value)
    }
}
```
</UniversalEditor>

### 结构体

<UniversalEditor title="结构体对比" compare={true}>
```javascript !! js
// JavaScript: 对象和类
let person = {
    name: "John",
    age: 30,
    city: "New York"
};

// ES6 类
class Person {
    constructor(name, age, city) {
        this.name = name;
        this.age = age;
        this.city = city;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
}

let john = new Person("John", 30, "New York");
console.log(john.greet()); // "Hello, I'm John"

// 对象解构
let { name, age } = person;
console.log(name, age); // "John" 30
```

```go !! go
// Go: 结构体
package main

import "fmt"

// 结构体定义
type Person struct {
    Name string
    Age  int
    City string
}

// 结构体上的方法
func (p Person) Greet() string {
    return fmt.Sprintf("Hello, I'm %s", p.Name)
}

// 带指针接收者的方法 (可以修改结构体)
func (p *Person) SetAge(age int) {
    p.Age = age
}

func main() {
    // 创建结构体实例
    person := Person{
        Name: "John",
        Age:  30,
        City: "New York",
    }
    
    // 访问字段
    fmt.Println(person.Name) // "John"
    
    // 调用方法
    fmt.Println(person.Greet()) // "Hello, I'm John"
    
    // 修改结构体
    person.SetAge(31)
    fmt.Println(person.Age) // 31
    
    // 结构体嵌入 (组合)
    type Employee struct {
        Person
        Salary float64
    }
    
    emp := Employee{
        Person: Person{Name: "Jane", Age: 25, City: "Boston"},
        Salary: 50000,
    }
    
    // 访问嵌入结构体的方法
    fmt.Println(emp.Greet()) // "Hello, I'm Jane"
}
```
</UniversalEditor>

## 接口

接口是 Go 最强大的特性之一，提供了一种定义行为而不涉及实现细节的方式。

### 接口基础

<UniversalEditor title="接口基础对比" compare={true}>
```javascript !! js
// JavaScript: 鸭子类型 (隐式接口)
function processData(data) {
    if (typeof data.length === 'number' && typeof data[0] !== 'undefined') {
        return data.length;
    }
    return 0;
}

// 任何具有 'length' 属性的对象都可以工作
console.log(processData([1, 2, 3]));     // 3
console.log(processData("hello"));       // 5
console.log(processData({ length: 10 })); // 10

// ES6 类和方法
class Shape {
    area() {
        return 0;
    }
}

class Circle extends Shape {
    constructor(radius) {
        super();
        this.radius = radius;
    }
    
    area() {
        return Math.PI * this.radius ** 2;
    }
}

let circle = new Circle(5);
console.log(circle.area()); // 78.54...
```

```go !! go
// Go: 显式接口
package main

import (
    "fmt"
    "math"
)

// 接口定义
type Measurable interface {
    Area() float64
}

// 实现接口的结构体
type Circle struct {
    Radius float64
}

// 方法实现
func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// 与任何实现 Measurable 的类型一起工作的函数
func processShape(m Measurable) {
    fmt.Printf("Area: %.2f\n", m.Area())
}

func main() {
    circle := Circle{Radius: 5}
    rectangle := Rectangle{Width: 4, Height: 6}
    
    // 两种类型都实现了 Measurable 接口
    processShape(circle)    // Area: 78.54
    processShape(rectangle) // Area: 24.00
    
    // 接口满足是隐式的
    var m Measurable = circle
    fmt.Printf("Type: %T, Area: %.2f\n", m, m.Area())
}
```
</UniversalEditor>

### 接口组合

<UniversalEditor title="接口组合对比" compare={true}>
```javascript !! js
// JavaScript: 对象组合和混入
const Movable = {
    move() {
        return "Moving...";
    }
};

const Drawable = {
    draw() {
        return "Drawing...";
    }
};

// 混入模式
class GameObject {
    constructor() {
        Object.assign(this, Movable, Drawable);
    }
}

let gameObj = new GameObject();
console.log(gameObj.move());  // "Moving..."
console.log(gameObj.draw());  // "Drawing..."

// 或使用组合
class Sprite {
    constructor() {
        this.movable = Movable;
        this.drawable = Drawable;
    }
    
    move() {
        return this.movable.move();
    }
    
    draw() {
        return this.drawable.draw();
    }
}
```

```go !! go
// Go: 接口组合
package main

import "fmt"

// 基础接口
type Movable interface {
    Move() string
}

type Drawable interface {
    Draw() string
}

// 组合接口
type GameObject interface {
    Movable
    Drawable
}

// 实现
type Sprite struct {
    X, Y int
}

func (s *Sprite) Move() string {
    s.X += 1
    s.Y += 1
    return fmt.Sprintf("Moving to (%d, %d)", s.X, s.Y)
}

func (s Sprite) Draw() string {
    return fmt.Sprintf("Drawing at (%d, %d)", s.X, s.Y)
}

// 与任何 GameObject 一起工作的函数
func updateGameObject(obj GameObject) {
    fmt.Println(obj.Move())
    fmt.Println(obj.Draw())
}

func main() {
    sprite := &Sprite{X: 0, Y: 0}
    updateGameObject(sprite)
    
    // 接口组合允许灵活的设计
    var movable Movable = sprite
    var drawable Drawable = sprite
    var gameObj GameObject = sprite
    
    fmt.Println(movable.Move())  // 只能调用 Move()
    fmt.Println(drawable.Draw()) // 只能调用 Draw()
    fmt.Println(gameObj.Move())  // 可以调用 Move() 和 Draw()
    fmt.Println(gameObj.Draw())
}
```
</UniversalEditor>

### 空接口

<UniversalEditor title="空接口对比" compare={true}>
```javascript !! js
// JavaScript: 动态类型允许任何值
function processAnyValue(value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    } else if (typeof value === 'number') {
        return value * 2;
    } else if (Array.isArray(value)) {
        return value.length;
    } else if (typeof value === 'object') {
        return Object.keys(value).length;
    }
    return "Unknown type";
}

console.log(processAnyValue("hello"));     // "HELLO"
console.log(processAnyValue(42));          // 84
console.log(processAnyValue([1, 2, 3]));   // 3
console.log(processAnyValue({a: 1, b: 2})); // 2
```

```go !! go
// Go: 空接口 (interface{}) 接受任何类型
package main

import (
    "fmt"
    "reflect"
)

// 空接口可以保存任何值
func processAnyValue(value interface{}) {
    switch v := value.(type) {
    case string:
        fmt.Printf("String: %s\n", v)
    case int:
        fmt.Printf("Integer: %d\n", v)
    case []int:
        fmt.Printf("Slice: %v (length: %d)\n", v, len(v))
    case map[string]int:
        fmt.Printf("Map: %v (keys: %d)\n", v, len(v))
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

func main() {
    processAnyValue("hello")           // String: hello
    processAnyValue(42)                // Integer: 42
    processAnyValue([]int{1, 2, 3})    // Slice: [1 2 3] (length: 3)
    processAnyValue(map[string]int{"a": 1, "b": 2}) // Map: map[a:1 b:2] (keys: 2)
    
    // 使用 reflect 包进行更动态的行为
    var value interface{} = "hello"
    fmt.Printf("Type: %v, Value: %v\n", reflect.TypeOf(value), reflect.ValueOf(value))
}
```
</UniversalEditor>

## 类型断言和类型开关

Go 提供了与接口类型动态工作的机制。

### 类型断言

<UniversalEditor title="类型断言对比" compare={true}>
```javascript !! js
// JavaScript: 类型检查和转换
function processValue(value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    } else if (Array.isArray(value)) {
        return value.join(', ');
    } else if (typeof value === 'object' && value !== null) {
        return JSON.stringify(value);
    }
    return String(value);
}

console.log(processValue("hello"));     // "HELLO"
console.log(processValue([1, 2, 3]));   // "1, 2, 3"
console.log(processValue({a: 1}));      // '{"a":1}'
console.log(processValue(42));          // "42"
```

```go !! go
// Go: 类型断言
package main

import (
    "encoding/json"
    "fmt"
    "strconv"
)

func processValue(value interface{}) string {
    // 带逗号 ok 惯用法的类型断言
    if str, ok := value.(string); ok {
        return str
    }
    
    if arr, ok := value.([]int); ok {
        return fmt.Sprintf("%v", arr)
    }
    
    if m, ok := value.(map[string]int); ok {
        if jsonBytes, err := json.Marshal(m); err == nil {
            return string(jsonBytes)
        }
    }
    
    if num, ok := value.(int); ok {
        return strconv.Itoa(num)
    }
    
    return "unknown type"
}

func main() {
    fmt.Println(processValue("hello"))                    // "hello"
    fmt.Println(processValue([]int{1, 2, 3}))            // "[1 2 3]"
    fmt.Println(processValue(map[string]int{"a": 1}))    // '{"a":1}'
    fmt.Println(processValue(42))                        // "42"
    
    // 不带逗号 ok 的类型断言 (如果类型错误会 panic)
    var value interface{} = "hello"
    str := value.(string) // 安全断言
    fmt.Println(str)      // "hello"
    
    // 这会 panic:
    // num := value.(int) // panic: interface conversion
}
```
</UniversalEditor>

### 类型开关

<UniversalEditor title="类型开关对比" compare={true}>
```javascript !! js
// JavaScript: 带 typeof 的 switch
function describeType(value) {
    switch (typeof value) {
        case 'string':
            return `String: "${value}"`;
        case 'number':
            return `Number: ${value}`;
        case 'boolean':
            return `Boolean: ${value}`;
        case 'object':
            if (Array.isArray(value)) {
                return `Array with ${value.length} elements`;
            } else if (value === null) {
                return 'Null';
            } else {
                return 'Object';
            }
        default:
            return 'Unknown type';
    }
}

console.log(describeType("hello"));     // "String: \"hello\""
console.log(describeType(42));          // "Number: 42"
console.log(describeType(true));        // "Boolean: true"
console.log(describeType([1, 2, 3]));   // "Array with 3 elements"
console.log(describeType({a: 1}));      // "Object"
```

```go !! go
// Go: 类型开关
package main

import "fmt"

func describeType(value interface{}) string {
    switch v := value.(type) {
    case string:
        return fmt.Sprintf("String: %q", v)
    case int:
        return fmt.Sprintf("Integer: %d", v)
    case bool:
        return fmt.Sprintf("Boolean: %t", v)
    case []int:
        return fmt.Sprintf("Slice with %d elements", len(v))
    case map[string]int:
        return fmt.Sprintf("Map with %d keys", len(v))
    case nil:
        return "Nil"
    default:
        return fmt.Sprintf("Unknown type: %T", v)
    }
}

func main() {
    fmt.Println(describeType("hello"))                    // String: "hello"
    fmt.Println(describeType(42))                        // Integer: 42
    fmt.Println(describeType(true))                      // Boolean: true
    fmt.Println(describeType([]int{1, 2, 3}))            // Slice with 3 elements
    fmt.Println(describeType(map[string]int{"a": 1}))    // Map with 1 keys
    fmt.Println(describeType(nil))                       // Nil
    
    // 类型开关也可以用于控制流
    var values []interface{} = []interface{}{"hello", 42, true, []int{1, 2}}
    
    for _, value := range values {
        switch v := value.(type) {
        case string:
            fmt.Printf("Processing string: %s\n", v)
        case int:
            fmt.Printf("Processing integer: %d\n", v)
        case bool:
            fmt.Printf("Processing boolean: %t\n", v)
        case []int:
            fmt.Printf("Processing slice: %v\n", v)
        }
    }
}
```
</UniversalEditor>

## 指针与内存引用

指针是 Go 语言的重要特性，它允许程序直接访问和操作内存地址。与 JavaScript 的自动内存管理不同，Go 提供了更精确的内存控制能力，这对系统编程和性能优化至关重要。

### JavaScript vs Go 内存模型对比

<UniversalEditor title="内存模型对比" compare={true}>
```javascript !! js
// JavaScript: 自动内存管理
let obj1 = { name: "John", age: 30 };
let obj2 = obj1; // 引用赋值

console.log(obj1.name); // "John"
console.log(obj2.name); // "John"

obj2.name = "Jane";
console.log(obj1.name); // "Jane" - 两个变量指向同一个对象
console.log(obj2.name); // "Jane"

// 基本类型是值传递
let a = 5;
let b = a; // 值拷贝
b = 10;
console.log(a); // 5 - a 没有改变
console.log(b); // 10

// 函数参数传递
function modifyObject(obj) {
    obj.name = "Modified"; // 修改原对象
    obj = { name: "New" }; // 重新赋值不影响原对象
}

function modifyPrimitive(val) {
    val = 100; // 不影响原值
}

let person = { name: "Alice" };
let number = 42;

modifyObject(person);
modifyPrimitive(number);

console.log(person.name); // "Modified" - 对象被修改
console.log(number);      // 42 - 原值未改变
```

```go !! go
// Go: 显式指针操作
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func main() {
    // 值类型
    person1 := Person{Name: "John", Age: 30}
    person2 := person1 // 值拷贝
    
    fmt.Println("person1:", person1.Name) // "John"
    fmt.Println("person2:", person2.Name) // "John"
    
    person2.Name = "Jane"
    fmt.Println("person1:", person1.Name) // "John" - person1 未改变
    fmt.Println("person2:", person2.Name) // "Jane"
    
    // 指针类型
    ptr1 := &person1 // 获取 person1 的地址
    ptr2 := ptr1     // 指针拷贝，指向同一内存地址
    
    fmt.Println("通过 ptr1:", ptr1.Name) // "John"
    fmt.Println("通过 ptr2:", ptr2.Name) // "John"
    
    ptr2.Name = "Alice" // 通过指针修改
    fmt.Println("person1:", person1.Name) // "Alice" - 原变量被修改
    fmt.Println("通过 ptr1:", ptr1.Name) // "Alice"
    
    // 函数参数传递演示
    modifyByValue(person1)     // 值传递
    modifyByPointer(&person1)  // 指针传递
    
    fmt.Println("最终 person1:", person1.Name) // "Modified by pointer"
}

// 值传递 - 不影响原变量
func modifyByValue(p Person) {
    p.Name = "Modified by value"
    fmt.Println("函数内值传递:", p.Name) // "Modified by value"
}

// 指针传递 - 影响原变量
func modifyByPointer(p *Person) {
    p.Name = "Modified by pointer"
    fmt.Println("函数内指针传递:", p.Name) // "Modified by pointer"
}
```
</UniversalEditor>

### 指针基础概念和语法

<UniversalEditor title="指针语法基础" compare={true}>
```javascript !! js
// JavaScript: 没有直接的指针概念
// 但可以通过引用来理解指针的概念

let value = 42;
let reference = { value: 42 }; // 用对象包装来模拟指针

// 无法直接获取变量的内存地址
// console.log(&value); // 语法错误

// 引用操作
function increment(ref) {
    ref.value++; // 修改引用指向的值
}

increment(reference);
console.log(reference.value); // 43

// 数组引用示例
let arr1 = [1, 2, 3];
let arr2 = arr1; // 引用赋值

arr2.push(4);
console.log(arr1); // [1, 2, 3, 4] - 原数组被修改
console.log(arr2); // [1, 2, 3, 4]

// 解除引用
arr2 = null;
console.log(arr1); // [1, 2, 3, 4] - arr1 仍然有效
console.log(arr2); // null
```

```go !! go
// Go: 显式指针语法
package main

import "fmt"

func main() {
    // 基本指针操作
    var value int = 42
    var ptr *int = &value // 获取 value 的地址
    
    fmt.Printf("value: %d\n", value)         // 42
    fmt.Printf("value 的地址: %p\n", &value)   // 0x...
    fmt.Printf("ptr 存储的地址: %p\n", ptr)     // 0x... (与上面相同)
    fmt.Printf("ptr 指向的值: %d\n", *ptr)     // 42 (解引用)
    
    // 通过指针修改值
    *ptr = 100 // 解引用并赋值
    fmt.Printf("修改后的 value: %d\n", value)  // 100
    
    // 指针的零值
    var nilPtr *int
    fmt.Printf("nilPtr: %v\n", nilPtr) // <nil>
    
    // 检查指针是否为 nil
    if nilPtr == nil {
        fmt.Println("nilPtr 是 nil")
    }
    
    // 多级指针
    var ptrToPtr **int = &ptr
    fmt.Printf("ptrToPtr 指向的地址: %p\n", *ptrToPtr)  // ptr 的地址
    fmt.Printf("双重解引用的值: %d\n", **ptrToPtr)      // 100
    
    // 不同类型的指针
    var str string = "Hello"
    var strPtr *string = &str
    
    fmt.Printf("字符串: %s\n", str)
    fmt.Printf("通过指针: %s\n", *strPtr)
    
    *strPtr = "World"
    fmt.Printf("修改后: %s\n", str) // "World"
}
```
</UniversalEditor>

### 指针在函数中的应用

<UniversalEditor title="指针函数参数对比" compare={true}>
```javascript !! js
// JavaScript: 引用传递和值传递
function swapByValue(a, b) {
    // 对于基本类型，这不会影响原变量
    let temp = a;
    a = b;
    b = temp;
    console.log(`函数内: a=${a}, b=${b}`);
}

function swapByReference(obj) {
    // 可以修改对象的属性
    let temp = obj.a;
    obj.a = obj.b;
    obj.b = temp;
}

// 基本类型测试
let x = 10, y = 20;
swapByValue(x, y);
console.log(`函数外: x=${x}, y=${y}`); // x=10, y=20 (未改变)

// 对象引用测试
let values = { a: 10, b: 20 };
swapByReference(values);
console.log(`交换后: a=${values.a}, b=${values.b}`); // a=20, b=10

// 数组作为函数参数
function modifyArray(arr) {
    arr.push(4); // 修改原数组
    arr = [9, 8, 7]; // 重新赋值不影响原数组
}

let myArray = [1, 2, 3];
modifyArray(myArray);
console.log(myArray); // [1, 2, 3, 4] - 只有 push 操作生效
```

```go !! go
// Go: 值传递 vs 指针传递
package main

import "fmt"

// 值传递 - 不影响原变量
func swapByValue(a, b int) {
    fmt.Printf("函数内交换前: a=%d, b=%d\n", a, b)
    a, b = b, a
    fmt.Printf("函数内交换后: a=%d, b=%d\n", a, b)
}

// 指针传递 - 影响原变量
func swapByPointer(a, b *int) {
    fmt.Printf("函数内交换前: a=%d, b=%d\n", *a, *b)
    *a, *b = *b, *a
    fmt.Printf("函数内交换后: a=%d, b=%d\n", *a, *b)
}

// 结构体值传递
func modifyPersonByValue(p Person) {
    p.Name = "Modified"
    p.Age = 100
}

// 结构体指针传递
func modifyPersonByPointer(p *Person) {
    p.Name = "Modified by pointer" // 自动解引用
    p.Age = 100
    // 等价于: (*p).Name = "Modified by pointer"
}

type Person struct {
    Name string
    Age  int
}

func main() {
    // 基本类型测试
    x, y := 10, 20
    fmt.Printf("交换前: x=%d, y=%d\n", x, y)
    
    swapByValue(x, y)
    fmt.Printf("值传递后: x=%d, y=%d\n", x, y) // 未改变
    
    swapByPointer(&x, &y)
    fmt.Printf("指针传递后: x=%d, y=%d\n", x, y) // 已交换
    
    // 结构体测试
    person := Person{Name: "Alice", Age: 25}
    fmt.Printf("原始: %+v\n", person)
    
    modifyPersonByValue(person)
    fmt.Printf("值传递后: %+v\n", person) // 未改变
    
    modifyPersonByPointer(&person)
    fmt.Printf("指针传递后: %+v\n", person) // 已修改
    
    // 切片和映射的特殊情况
    slice := []int{1, 2, 3}
    modifySlice(slice)
    fmt.Printf("切片修改后: %v\n", slice) // [1, 2, 3, 4] - 切片header是值传递，但底层数组是共享的
}

func modifySlice(s []int) {
    s[0] = 999 // 修改切片元素
    s = append(s, 4) // 在某些情况下可能影响原切片
}
```
</UniversalEditor>

### 指针在结构体方法中的应用

<UniversalEditor title="结构体方法接收者对比" compare={true}>
```javascript !! js
// JavaScript: 类方法和 this 绑定
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }
    
    // 方法自动绑定到实例
    area() {
        return this.width * this.height;
    }
    
    // 修改实例状态
    scale(factor) {
        this.width *= factor;
        this.height *= factor;
        return this; // 返回 this 支持链式调用
    }
    
    // 获取副本
    copy() {
        return new Rectangle(this.width, this.height);
    }
    
    // 比较方法
    equals(other) {
        return this.width === other.width && 
               this.height === other.height;
    }
}

let rect1 = new Rectangle(10, 5);
let rect2 = rect1; // 引用赋值

console.log(rect1.area()); // 50

rect1.scale(2);
console.log(rect1.area()); // 200
console.log(rect2.area()); // 200 - 同一个对象

// 创建独立副本
let rect3 = rect1.copy();
rect3.scale(0.5);
console.log(rect1.area()); // 200 - 不受影响
console.log(rect3.area()); // 50
```

```go !! go
// Go: 值接收者 vs 指针接收者
package main

import "fmt"

type Rectangle struct {
    Width  float64
    Height float64
}

// 值接收者 - 不修改原结构体
func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

// 值接收者 - 不能修改原结构体
func (r Rectangle) ScaleByValue(factor float64) Rectangle {
    r.Width *= factor  // 只修改副本
    r.Height *= factor
    return r // 返回修改后的副本
}

// 指针接收者 - 可以修改原结构体
func (r *Rectangle) Scale(factor float64) {
    r.Width *= factor  // 修改原结构体
    r.Height *= factor // Go 自动解引用，等价于 (*r).Width
}

// 指针接收者 - 避免大结构体的拷贝开销
func (r *Rectangle) String() string {
    return fmt.Sprintf("Rectangle{Width: %.2f, Height: %.2f}", r.Width, r.Height)
}

// 值接收者 - 用于不需要修改的操作
func (r Rectangle) Equals(other Rectangle) bool {
    return r.Width == other.Width && r.Height == other.Height
}

// 指针接收者 - 设置方法
func (r *Rectangle) SetDimensions(width, height float64) {
    r.Width = width
    r.Height = height
}

func main() {
    rect1 := Rectangle{Width: 10, Height: 5}
    rect2 := rect1 // 值拷贝
    
    fmt.Printf("rect1: %s, Area: %.2f\n", rect1.String(), rect1.Area())
    
    // 值接收者方法 - 不修改原结构体
    scaledRect := rect1.ScaleByValue(2)
    fmt.Printf("原始 rect1: %s\n", rect1.String()) // 未改变
    fmt.Printf("缩放后副本: %s\n", scaledRect.String())
    
    // 指针接收者方法 - 修改原结构体
    rect1.Scale(2)
    fmt.Printf("Scale后 rect1: %s\n", rect1.String()) // 已改变
    fmt.Printf("rect2: %s\n", rect2.String()) // 未改变（是副本）
    
    // 通过指针调用
    rectPtr := &Rectangle{Width: 3, Height: 4}
    fmt.Printf("指针创建: %s\n", rectPtr.String())
    
    rectPtr.SetDimensions(6, 8)
    fmt.Printf("设置尺寸后: %s\n", rectPtr.String())
    
    // Go 可以自动处理值和指针的转换
    rect3 := Rectangle{Width: 1, Height: 1}
    rect3.Scale(5) // Go 自动取地址：(&rect3).Scale(5)
    fmt.Printf("自动转换: %s\n", rect3.String())
    
    rectPtr2 := &Rectangle{Width: 2, Height: 2}
    area := rectPtr2.Area() // Go 自动解引用：(*rectPtr2).Area()
    fmt.Printf("指针调用值方法: %.2f\n", area)
}
```
</UniversalEditor>

### 指针与性能优化

<UniversalEditor title="性能优化对比" compare={true}>
```javascript !! js
// JavaScript: 自动优化，开发者控制有限
class LargeObject {
    constructor() {
        // 模拟大对象
        this.data = new Array(1000).fill(0).map((_, i) => ({
            id: i,
            value: Math.random() * 100,
            timestamp: Date.now(),
            metadata: {
                type: 'sample',
                category: 'test',
                description: 'A sample data point'
            }
        }));
    }
    
    // 计算总和 - V8 引擎自动优化
    calculateSum() {
        return this.data.reduce((sum, item) => sum + item.value, 0);
    }
    
    // 过滤数据 - 创建新数组
    filterByValue(threshold) {
        return this.data.filter(item => item.value > threshold);
    }
    
    // 修改数据 - 就地修改
    scaleValues(factor) {
        this.data.forEach(item => {
            item.value *= factor;
        });
    }
}

// 性能测试
console.time('Large Object Creation');
let largeObj = new LargeObject();
console.timeEnd('Large Object Creation');

console.time('Sum Calculation');
let sum = largeObj.calculateSum();
console.timeEnd('Sum Calculation');

console.time('Filtering');
let filtered = largeObj.filterByValue(50);
console.timeEnd('Filtering');

console.log(`Sum: ${sum.toFixed(2)}, Filtered count: ${filtered.length}`);
```

```go !! go
// Go: 显式内存和性能控制
package main

import (
    "fmt"
    "time"
)

type DataPoint struct {
    ID        int
    Value     float64
    Timestamp int64
    Metadata  Metadata
}

type Metadata struct {
    Type        string
    Category    string
    Description string
}

type LargeObject struct {
    Data []DataPoint
}

// 值接收者 - 会拷贝整个结构体（性能较差）
func (lo LargeObject) CalculateSumByValue() float64 {
    var sum float64
    for _, item := range lo.Data { // lo.Data 是副本
        sum += item.Value
    }
    return sum
}

// 指针接收者 - 避免拷贝（性能更好）
func (lo *LargeObject) CalculateSum() float64 {
    var sum float64
    for _, item := range lo.Data { // 直接访问原数据
        sum += item.Value
    }
    return sum
}

// 指针接收者 - 就地修改，避免重新分配
func (lo *LargeObject) ScaleValues(factor float64) {
    for i := range lo.Data {
        lo.Data[i].Value *= factor
    }
}

// 返回切片而不是拷贝整个数组
func (lo *LargeObject) FilterByValue(threshold float64) []DataPoint {
    var result []DataPoint
    for _, item := range lo.Data {
        if item.Value > threshold {
            result = append(result, item)
        }
    }
    return result
}

// 就地过滤，重用切片内存
func (lo *LargeObject) FilterInPlace(threshold float64) {
    writeIndex := 0
    for _, item := range lo.Data {
        if item.Value > threshold {
            lo.Data[writeIndex] = item
            writeIndex++
        }
    }
    lo.Data = lo.Data[:writeIndex] // 调整切片长度
}

func NewLargeObject() *LargeObject {
    data := make([]DataPoint, 1000)
    for i := range data {
        data[i] = DataPoint{
            ID:        i,
            Value:     float64(i%100) + 0.5,
            Timestamp: time.Now().UnixNano(),
            Metadata: Metadata{
                Type:        "sample",
                Category:    "test",
                Description: "A sample data point",
            },
        }
    }
    return &LargeObject{Data: data}
}

func main() {
    // 创建大对象
    start := time.Now()
    largeObj := NewLargeObject()
    fmt.Printf("对象创建耗时: %v\n", time.Since(start))
    
    // 值接收者性能测试
    start = time.Now()
    sumByValue := largeObj.CalculateSumByValue()
    fmt.Printf("值接收者计算耗时: %v\n", time.Since(start))
    
    // 指针接收者性能测试
    start = time.Now()
    sumByPointer := largeObj.CalculateSum()
    fmt.Printf("指针接收者计算耗时: %v\n", time.Since(start))
    
    fmt.Printf("结果对比 - 值接收者: %.2f, 指针接收者: %.2f\n", 
               sumByValue, sumByPointer)
    
    // 过滤性能测试
    start = time.Now()
    filtered := largeObj.FilterByValue(50)
    fmt.Printf("创建新切片过滤耗时: %v, 结果数量: %d\n", 
               time.Since(start), len(filtered))
    
    // 就地过滤性能测试
    originalLen := len(largeObj.Data)
    start = time.Now()
    largeObj.FilterInPlace(50)
    fmt.Printf("就地过滤耗时: %v, 原长度: %d, 新长度: %d\n", 
               time.Since(start), originalLen, len(largeObj.Data))
    
    // 内存使用演示
    fmt.Printf("LargeObject 指针大小: %d 字节\n", 
               8) // 64位系统上指针大小
    fmt.Printf("LargeObject 值大小估计: %d 字节\n", 
               len(largeObj.Data) * 64) // 粗略估计
}
```
</UniversalEditor>

### 常见指针陷阱和最佳实践

<UniversalEditor title="指针陷阱与最佳实践" compare={true}>
```javascript !! js
// JavaScript: 常见的引用相关问题
// 1. 意外的共享引用
let originalArray = [1, 2, 3];
let sharedArray = originalArray; // 危险：共享引用

sharedArray.push(4);
console.log(originalArray); // [1, 2, 3, 4] - 意外修改！

// 正确做法：创建副本
let safeCopy = [...originalArray]; // 浅拷贝
let deepCopy = JSON.parse(JSON.stringify(originalArray)); // 深拷贝

// 2. 闭包中的引用陷阱
let functions = [];
for (let i = 0; i < 3; i++) {
    functions.push(() => console.log(i)); // 正确：let 创建块级作用域
}

functions[0](); // 0
functions[1](); // 1
functions[2](); // 2

// 错误示例（使用 var）
let badFunctions = [];
for (var j = 0; j < 3; j++) {
    badFunctions.push(() => console.log(j)); // 陷阱：共享同一个 j
}

badFunctions[0](); // 3
badFunctions[1](); // 3  
badFunctions[2](); // 3

// 3. 回调函数中的 this 陷阱
class Counter {
    constructor() {
        this.count = 0;
    }
    
    increment() {
        this.count++;
    }
    
    setupTimer() {
        // 错误：this 丢失
        // setTimeout(this.increment, 1000);
        
        // 正确：使用箭头函数或 bind
        setTimeout(() => this.increment(), 1000);
        // 或者：setTimeout(this.increment.bind(this), 1000);
    }
}
```

```go !! go
// Go: 常见指针陷阱和最佳实践
package main

import "fmt"

type User struct {
    Name string
    Age  int
}

// 陷阱1: 返回局部变量的指针
func badCreateUser() *User {
    // 危险：返回栈上变量的指针
    user := User{Name: "John", Age: 30}
    return &user // Go 编译器会自动将其移到堆上，但这不是最佳实践
}

// 最佳实践：明确使用堆分配
func goodCreateUser() *User {
    return &User{Name: "John", Age: 30} // 直接在堆上创建
}

// 陷阱2: 空指针解引用
func badProcessUser(user *User) {
    // 危险：没有检查 nil
    fmt.Println(user.Name) // 如果 user 是 nil，程序会 panic
}

func goodProcessUser(user *User) {
    // 最佳实践：总是检查 nil
    if user == nil {
        fmt.Println("用户为空")
        return
    }
    fmt.Println(user.Name)
}

// 陷阱3: 在循环中创建指针切片
func badCreateUserPointers() []*User {
    var users []*User
    names := []string{"Alice", "Bob", "Charlie"}
    
    for _, name := range names {
        user := User{Name: name, Age: 25}
        users = append(users, &user) // 陷阱：所有指针指向同一个变量
    }
    return users
}

func goodCreateUserPointers() []*User {
    var users []*User
    names := []string{"Alice", "Bob", "Charlie"}
    
    for _, name := range names {
        // 方法1：使用局部变量副本
        userName := name
        user := User{Name: userName, Age: 25}
        users = append(users, &user)
        
        // 方法2：直接在堆上创建
        // users = append(users, &User{Name: name, Age: 25})
    }
    return users
}

// 陷阱4: 指针比较
func demonstratePointerComparison() {
    user1 := &User{Name: "John", Age: 30}
    user2 := &User{Name: "John", Age: 30}
    
    // 陷阱：指针比较比较的是地址，不是值
    fmt.Printf("指针相等: %t\n", user1 == user2) // false
    
    // 正确：比较值
    fmt.Printf("值相等: %t\n", *user1 == *user2) // true
    
    // 或者实现 Equals 方法
    fmt.Printf("自定义比较: %t\n", user1.Equals(*user2))
}

func (u User) Equals(other User) bool {
    return u.Name == other.Name && u.Age == other.Age
}

// 最佳实践：方法接收者选择
type Counter struct {
    count int
    data  []int // 大数据
}

// 不需要修改：使用值接收者（小结构体）
func (c Counter) GetCount() int {
    return c.count
}

// 需要修改：使用指针接收者
func (c *Counter) Increment() {
    c.count++
}

// 大结构体：使用指针接收者避免拷贝
func (c *Counter) ProcessData() int {
    var sum int
    for _, v := range c.data {
        sum += v
    }
    return sum
}

// 最佳实践：错误处理与指针
func findUser(id int) (*User, error) {
    if id <= 0 {
        return nil, fmt.Errorf("无效的用户ID: %d", id)
    }
    
    // 模拟数据库查询
    if id == 1 {
        return &User{Name: "Alice", Age: 25}, nil
    }
    
    return nil, fmt.Errorf("用户未找到: %d", id)
}

func main() {
    fmt.Println("=== 指针陷阱演示 ===")
    
    // 演示陷阱1
    user := badCreateUser()
    fmt.Printf("Bad create user: %+v\n", user)
    
    user = goodCreateUser()
    fmt.Printf("Good create user: %+v\n", user)
    
    // 演示陷阱2
    fmt.Println("\n=== 空指针检查 ===")
    goodProcessUser(user)
    goodProcessUser(nil)
    
    // 演示陷阱3
    fmt.Println("\n=== 循环中的指针 ===")
    badUsers := badCreateUserPointers()
    fmt.Println("错误的实现:")
    for i, u := range badUsers {
        fmt.Printf("  用户%d: %+v\n", i, *u)
    }
    
    goodUsers := goodCreateUserPointers()
    fmt.Println("正确的实现:")
    for i, u := range goodUsers {
        fmt.Printf("  用户%d: %+v\n", i, *u)
    }
    
    // 演示陷阱4
    fmt.Println("\n=== 指针比较 ===")
    demonstratePointerComparison()
    
    // 最佳实践：错误处理
    fmt.Println("\n=== 错误处理 ===")
    if user, err := findUser(1); err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("找到用户: %+v\n", user)
    }
    
    if user, err := findUser(-1); err != nil {
        fmt.Printf("错误: %v\n", err)
    } else {
        fmt.Printf("找到用户: %+v\n", user)
    }
}
```
</UniversalEditor>

### 指针最佳实践总结

| 使用场景 | JavaScript | Go 指针最佳实践 |
|----------|------------|----------------|
| **函数参数** | 对象自动引用传递 | 大结构体使用指针，小值类型传值 |
| **方法接收者** | 自动绑定 this | 需要修改或大结构体使用指针接收者 |
| **性能优化** | 引擎自动优化 | 避免不必要的拷贝，使用指针 |
| **内存管理** | 自动垃圾回收 | 检查 nil，避免内存泄漏 |
| **错误处理** | try-catch 或 Promise | 返回指针和错误，检查 nil |
| **比较操作** | == 比较值或引用 | 指针比较地址，需要解引用比较值 |

**关键原则：**
1. **小对象传值，大对象传指针**
2. **需要修改时使用指针**
3. **总是检查 nil 指针**
4. **在循环中小心指针的生命周期**
5. **使用指针提高性能，但要注意内存安全**

## 类型嵌入和组合

Go 使用组合而不是继承，通过结构体嵌入实现。

<UniversalEditor title="类型嵌入对比" compare={true}>
```javascript !! js
// JavaScript: 类继承和组合
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
}

class Dog extends Animal {
    constructor(name) {
        super(name);
    }
    
    speak() {
        return `${this.name} barks`;
    }
    
    fetch() {
        return `${this.name} fetches the ball`;
    }
}

// 组合
class Walker {
    walk() {
        return "Walking...";
    }
}

class Swimmer {
    swim() {
        return "Swimming...";
    }
}

class Duck {
    constructor(name) {
        this.name = name;
        this.walker = new Walker();
        this.swimmer = new Swimmer();
    }
    
    walk() {
        return this.walker.walk();
    }
    
    swim() {
        return this.swimmer.swim();
    }
}

let dog = new Dog("Rex");
let duck = new Duck("Donald");
console.log(dog.speak()); // "Rex barks"
console.log(duck.walk()); // "Walking..."
```

```go !! go
// Go: 结构体嵌入 (组合)
package main

import "fmt"

// 基础结构体
type Animal struct {
    Name string
}

func (a Animal) Speak() string {
    return fmt.Sprintf("%s makes a sound", a.Name)
}

// 在 Dog 中嵌入 Animal
type Dog struct {
    Animal // 嵌入结构体
}

func (d Dog) Speak() string {
    return fmt.Sprintf("%s barks", d.Name)
}

func (d Dog) Fetch() string {
    return fmt.Sprintf("%s fetches the ball", d.Name)
}

// 多嵌入类型的组合
type Walker struct{}

func (w Walker) Walk() string {
    return "Walking..."
}

type Swimmer struct{}

func (s Swimmer) Swim() string {
    return "Swimming..."
}

type Duck struct {
    Animal
    Walker
    Swimmer
}

func main() {
    dog := Dog{Animal{Name: "Rex"}}
    duck := Duck{
        Animal: Animal{Name: "Donald"},
        Walker: Walker{},
        Swimmer: Swimmer{},
    }
    
    fmt.Println(dog.Speak()) // "Rex barks"
    fmt.Println(dog.Fetch()) // "Rex fetches the ball"
    fmt.Println(duck.Walk()) // "Walking..."
    fmt.Println(duck.Swim()) // "Swimming..."
    
    // 通过嵌入实现接口满足
    type Speaker interface {
        Speak() string
    }
    
    var speakers []Speaker = []Speaker{dog, duck}
    for _, speaker := range speakers {
        fmt.Println(speaker.Speak())
    }
}
```
</UniversalEditor>

---

### 练习题：
1. 解释 Go 的静态类型与 JavaScript 动态类型的区别。每种方法的优缺点是什么？
2. Go 接口与 JavaScript 的鸭子类型有何不同？提供每种方法有益的场景示例。
3. 描述 Go 的结构体嵌入以及它与 JavaScript 类继承的比较。何时使用每种方法？
4. 创建一个 Go 程序，演示接口组合、类型断言和类型开关的实际示例。
5. **指针练习**：比较 JavaScript 的引用传递和 Go 的指针传递。什么时候应该使用值接收者，什么时候使用指针接收者？
6. **内存管理练习**：编写一个 Go 程序，演示指针如何影响性能。比较值传递和指针传递在大结构体上的性能差异。
7. **指针陷阱练习**：识别并修复以下常见的指针陷阱：空指针解引用、循环中的指针问题、指针比较错误。

### 项目想法：
* **形状计算器**：在 Go 中构建一个简单的形状计算器，使用接口处理不同的几何形状（圆形、矩形、三角形）。实现面积和周长计算，并使用类型开关处理不同的形状类型。与使用类和继承的 JavaScript 实现进行比较。
* **内存管理系统**：创建一个简单的内存池管理系统，演示指针的使用。包括对象创建、回收和重用，比较指针和值类型在内存效率上的差异。
* **链表数据结构**：实现一个双向链表，充分利用 Go 的指针特性。包含插入、删除、遍历等操作，并与 JavaScript 的对象引用实现进行性能对比。

### 下一步：
* 学习 Go 的并发特性：goroutines 和 channels
* 探索 Go 的错误处理模式和最佳实践
* 理解 Go 的包管理和模块系统
