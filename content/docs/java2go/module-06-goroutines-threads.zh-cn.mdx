---
title: "模块 06：Goroutine vs 线程 - 轻量级并发"
description: "掌握 Go 的 goroutine 并与 Java 线程进行比较。了解轻量级并发、goroutine 生命周期、WaitGroup 和性能特性。"
---

# 模块 06：Goroutine vs 线程 - 轻量级并发

在本模块中，你将学习 Go 如何通过 **goroutine 处理并发**，并将其与 Java 的线程模型进行比较。Go 的 goroutine 是轻量级的，创建成本极低，使并发编程更加简单和高效。

## 学习目标

完成本模块后，你将能够：
- 创建和管理 goroutine
- 比较 goroutine 和 Java 线程
- 使用 WaitGroup 进行同步
- 理解 goroutine 调度和生命周期
- 分析内存占用的差异
- 实现常见的 goroutine 模式
- 高效构建并发程序

## 背景：Java 线程 vs Go Goroutine

### 根本区别

**Java 线程：**
- 重量级 - 每个线程映射到一个操作系统线程
- 创建成本高（每个线程约 1MB 栈空间）
- 受操作系统资源限制（最多数千个）
- 上下文切换成本高（内核级）
- 复杂的同步机制（synchronized、Lock、Condition）

**Go Goroutine：**
- 轻量级 - 由 Go 运行时管理
- 创建极其廉价（初始栈约 2KB）
- 可以创建数百万个 goroutine
- 上下文切换成本低（用户级）
- 通过 channel 实现简单的同步

<UniversalEditor title="并发入门：Java vs Go">
```java !! java
// Java：创建线程是重量级的
public class ThreadExample {
    public static void main(String[] args) {
        // 创建并启动线程
        Thread thread = new Thread(() -> {
            System.out.println("Hello from thread!");
        });
        thread.start();

        // 等待线程完成
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread done");
    }
}
```

```go !! go
// Go：Goroutine 是轻量级的
package main

import (
	"fmt"
)

func main() {
	// 启动 goroutine
	go func() {
		fmt.Println("Hello from goroutine!")
	}()

	// 等待一下（不是理想方式 - 我们会学习更好的方法）
	fmt.Println("Main goroutine done")
}
```
</UniversalEditor>

## 创建 Goroutine

### 基本 Goroutine 创建

<UniversalEditor title="创建并发任务">
```java !! java
// Java：使用线程池进行并发任务
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThread {
    public static void main(String[] args) {
        // 使用线程池（比直接创建线程更好）
        ExecutorService executor = Executors.newFixedThreadPool(5);

        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId +
                    " running on " + Thread.currentThread().getName());
            });
        }

        executor.shutdown();
    }
}
```

```go !! go
// Go：启动 goroutine
package main

import (
	"fmt"
	"time"
)

func task(id int) {
	fmt.Printf("Task %d running\n", id)
}

func main() {
	// 启动 5 个 goroutine
	for i := 0; i < 5; i++ {
		go task(i)
	}

	// 等待 goroutine 完成
	time.Sleep(time.Millisecond)
}
```
</UniversalEditor>

### 匿名 Goroutine

<UniversalEditor title="匿名函数 vs 闭包">
```java !! java
// Java：匿名 Runnable 和 lambda
public class AnonymousThread {
    public static void main(String[] args) {
        // 匿名类
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous class");
            }
        });

        // Lambda（首选）
        Thread t2 = new Thread(() -> {
            System.out.println("Lambda expression");
        });

        t1.start();
        t2.start();
    }
}
```

```go !! go
// Go：带闭包的匿名 goroutine
package main

import (
	"fmt"
)

func main() {
	// 匿名 goroutine
	go func() {
		fmt.Println("Anonymous goroutine")
	}()

	// 带参数的 goroutine
	go func(msg string) {
		fmt.Printf("Message: %s\n", msg)
	}("Hello from closure")

	// 等待 goroutine
	time.Sleep(100 * time.Millisecond)
}
```
</UniversalEditor>

## WaitGroup vs CountDownLatch

### 同步原语

<UniversalEditor title="等待多个任务">
```java !! java
// Java：使用 CountDownLatch 等待多个线程
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class LatchExample {
    public static void main(String[] args) throws InterruptedException {
        final int TASK_COUNT = 3;
        CountDownLatch latch = new CountDownLatch(TASK_COUNT);
        ExecutorService executor = Executors.newFixedThreadPool(TASK_COUNT);

        for (int i = 0; i < TASK_COUNT; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    Thread.sleep(1000);
                    System.out.println("Task " + taskId + " completed");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown(); // 发出完成信号
                }
            });
        }

        latch.await(); // 等待所有任务
        System.out.println("All tasks completed");
        executor.shutdown();
    }
}
```

```go !! go
// Go：使用 WaitGroup 同步
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker(id int, wg *sync.WaitGroup) {
	defer wg.Done() // 完成时发出信号

	fmt.Printf("Worker %d starting\n", id)
	time.Sleep(time.Second)
	fmt.Printf("Worker %d done\n", id)
}

func main() {
	var wg sync.WaitGroup

	// 启动 3 个 worker
	for i := 1; i <= 3; i++ {
		wg.Add(1) // 增加计数器
		go worker(i, &wg)
	}

	wg.Wait() // 等待所有 worker
	fmt.Println("All workers completed")
}
```
</UniversalEditor>

### WaitGroup 最佳实践

<UniversalEditor title="WaitGroup 模式">
```java !! java
// Java：更复杂的同步场景
import java.util.concurrent.*;
import java.util.*;

public class ComplexSync {
    static class Result {
        List<String> results = new ArrayList<>();
    }

    public static void main(String[] args) throws Exception {
        int taskCount = 5;
        CountDownLatch latch = new CountDownLatch(taskCount);
        Result result = new Result();

        ExecutorService executor = Executors.newFixedThreadPool(10);

        for (int i = 0; i < taskCount; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    String data = "Result " + taskId;
                    synchronized (result.results) {
                        result.results.add(data);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        System.out.println("Collected: " + result.results);
        executor.shutdown();
    }
}
```

```go !! go
// Go：更简洁的 WaitGroup 模式
package main

import (
	"fmt"
	"sync"
)

func collectResults(id int, wg *sync.WaitGroup, results *[]string) {
	defer wg.Done()

	data := fmt.Sprintf("Result %d", id)
	*results = append(*results, data)
}

func main() {
	var wg sync.WaitGroup
	var results []string
	var mu sync.Mutex // 保护共享的 slice

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()

			data := fmt.Sprintf("Result %d", id)

			mu.Lock()
			results = append(results, data)
			mu.Unlock()
		}(i)
	}

	wg.Wait()
	fmt.Println("Collected:", results)
}
```
</UniversalEditor>

## Goroutine 生命周期和调度

### 理解 Goroutine 状态

<UniversalEditor title="线程 vs Goroutine 生命周期">
```java !! java
// Java：线程状态（NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED）
public class ThreadStates {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(() -> {
            try {
                // RUNNABLE
                System.out.println("Thread running");

                // TIMED_WAITING
                Thread.sleep(1000);

                // WAITING
                synchronized (ThreadStates.class) {
                    ThreadStates.class.wait();
                }
            } catch (InterruptedException e) {
                // TERMINATED
            }
        });

        // NEW 状态
        System.out.println("State: " + thread.getState());

        thread.start(); // RUNNABLE

        Thread.sleep(100);
        System.out.println("State: " + thread.getState());
    }
}
```

```go !! go
// Go：Goroutine 状态（更简单的模型）
package main

import (
	"fmt"
	"runtime"
	"time"
)

func goroutineStates() {
	// Goroutine 正在执行
	fmt.Println("Goroutine running")

	// Goroutine 被阻塞（等待）
	time.Sleep(time.Second)

	// Goroutine 完成并被垃圾回收
	fmt.Println("Goroutine done")
}

func main() {
	// goroutine 创建前：还没有 goroutine
	fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())

	go goroutineStates()

	time.Sleep(100 * time.Millisecond)
	fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())

	time.Sleep(2 * time.Second)
	fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
}
```
</UniversalEditor>

### Goroutine 调度器（M:N 调度器）

<UniversalEditor title="调度器比较">
```java !! java
// Java：1:1 线程模型（一个 Java 线程 = 一个 OS 线程）
// 由 OS 调度器管理
public class JavaScheduler {
    public static void main(String[] args) {
        // 每个线程创建一个 OS 线程
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                // 这是 1:1 映射到 OS 线程
                Thread.currentThread().setName("Worker");
                System.out.println(Thread.currentThread().getName());
            }).start();
        }
    }
}

/* OS 管理调度 - 昂贵的上下文切换 */
```

```go !! go
// Go：M:N 调度器（M 个 goroutine : N 个 OS 线程）
// Go 运行时管理调度
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	// 设置 OS 线程数（GOMAXPROCS）
	fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))

	// 可以启动数千个 goroutine
	for i := 0; i < 1000; i++ {
		go func(id int) {
			time.Sleep(100 * time.Millisecond)
			fmt.Printf("Goroutine %d\n", id)
		}(i)
	}

	// Go 运行时将 goroutine 多路复用到更少的 OS 线程上
	time.Sleep(time.Second)
	fmt.Printf("Total goroutines created: 1000\n")
}
```
</UniversalEditor>

## 内存占用比较

### 栈大小和内存使用

<UniversalEditor title="内存占用分析">
```java !! java
// Java：线程有很大的栈空间
public class ThreadMemory {
    public static void main(String[] args) {
        // 默认栈大小：每个线程约 1MB
        // 1000 个线程 = 约 1GB 内存！

        Runtime runtime = Runtime.getRuntime();
        long before = runtime.totalMemory() - runtime.freeMemory();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                try {
                    Thread.sleep(60000); // 保持活动
                } catch (InterruptedException e) {}
            }).start();
        }

        long after = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used: " + (after - before) / 1024 / 1024 + " MB");
        System.out.println("100 threads created");
    }
}
```

```go !! go
// Go：Goroutine 开始时栈很小（2KB）
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	before := m.Alloc

	// 创建 100,000 个 goroutine！
	for i := 0; i < 100000; i++ {
		go func() {
			time.Sleep(time.Minute)
		}()
	}

	runtime.ReadMemStats(&m)
	after := m.Alloc

	fmt.Printf("Memory used: %d MB\n", (after-before)/1024/1024)
	fmt.Printf("100,000 goroutines created\n")
}
```
</UniversalEditor>

### 实际性能比较

<UniversalEditor title="并发任务性能">
```java !! java
// Java：线程池性能
import java.util.concurrent.*;
import java.util.*;

public class ThreadPerformance {
    public static void main(String[] args) throws Exception {
        int tasks = 10000;

        ExecutorService executor = Executors.newFixedThreadPool(100);
        long start = System.currentTimeMillis();

        List<Future<Integer>> futures = new ArrayList<>();

        for (int i = 0; i < tasks; i++) {
            final int taskId = i;
            futures.add(executor.submit(() -> {
                int sum = 0;
                for (int j = 0; j < 100; j++) {
                    sum += j;
                }
                return sum;
            }));
        }

        int total = 0;
        for (Future<Integer> future : futures) {
            total += future.get();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time: " + (end - start) + "ms");
        System.out.println("Total: " + total);

        executor.shutdown();
    }
}
```

```go !! go
// Go：Goroutine 性能
package main

import (
	"fmt"
	"sync"
	"time"
)

func task() int {
	sum := 0
	for i := 0; i < 100; i++ {
		sum += i
	}
	return sum
}

func main() {
	tasks := 10000

	start := time.Now()
	var wg sync.WaitGroup
	results := make(chan int, tasks)

	for i := 0; i < tasks; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			results <- task()
		}()
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	total := 0
	for result := range results {
		total += result
	}

	elapsed := time.Since(start)
	fmt.Printf("Time: %dms\n", elapsed.Milliseconds())
	fmt.Printf("Total: %d\n", total)
}
```
</UniversalEditor>

## 常见 Goroutine 模式

### Worker Pool 模式

<UniversalEditor title="Worker Pool 实现">
```java !! java
// Java：使用 ExecutorService 的 worker pool
import java.util.concurrent.*;
import java.util.*;

public class WorkerPool {
    static class Job {
        int id;
        String data;

        Job(int id, String data) {
            this.id = id;
            this.data = data;
        }
    }

    public static void main(String[] args) throws Exception {
        int numWorkers = 5;
        ExecutorService executor = Executors.newFixedThreadPool(numWorkers);

        List<Job> jobs = new ArrayList<>();
        for (int i = 0; i < 20; i++) {
            jobs.add(new Job(i, "Task " + i));
        }

        for (Job job : jobs) {
            executor.submit(() -> {
                System.out.println("Processing " + job.id);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {}
                System.out.println("Completed " + job.id);
            });
        }

        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);
    }
}
```

```go !! go
// Go：使用缓冲 channel 的 worker pool
package main

import (
	"fmt"
	"sync"
	"time"
)

type Job struct {
	ID   int
	Data string
}

func worker(id int, jobs <-chan Job, wg *sync.WaitGroup) {
	defer wg.Done()

	for job := range jobs {
		fmt.Printf("Worker %d processing job %d\n", id, job.ID)
		time.Sleep(100 * time.Millisecond)
		fmt.Printf("Worker %d completed job %d\n", id, job.ID)
	}
}

func main() {
	numWorkers := 5
	numJobs := 20

	jobs := make(chan Job, numJobs)
	var wg sync.WaitGroup

	// 启动 workers
	for i := 1; i <= numWorkers; i++ {
		wg.Add(1)
		go worker(i, jobs, &wg)
	}

	// 发送任务
	for i := 0; i < numJobs; i++ {
		jobs <- Job{ID: i, Data: fmt.Sprintf("Task %d", i)}
	}
	close(jobs)

	// 等待所有 worker
	wg.Wait()
	fmt.Println("All jobs completed")
}
```
</UniversalEditor>

### Fan-Out / Fan-In 模式

<UniversalEditor title="Fan-Out Fan-In 模式">
```java !! java
// Java：使用多个消费者的 fan-out
import java.util.concurrent.*;
import java.util.*;

public class FanOutFanIn {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(10);

        List<Future<Integer>> futures = new ArrayList<>();

        // Fan-out：分发工作
        for (int i = 0; i < 10; i++) {
            final int input = i;
            futures.add(executor.submit(() -> {
                return process(input);
            }));
        }

        // Fan-in：收集结果
        int sum = 0;
        for (Future<Integer> future : futures) {
            sum += future.get();
        }

        System.out.println("Sum: " + sum);
        executor.shutdown();
    }

    private static int process(int n) {
        return n * n;
    }
}
```

```go !! go
// Go：使用 channel 的优雅 fan-out/fan-in
package main

import (
	"fmt"
	"sync"
)

func process(n int) int {
	return n * n
}

func fanOut(inputs <-chan int) <-chan int {
	results := make(chan int)

	var wg sync.WaitGroup
	for i := 0; i < 3; i++ { // 3 个 worker
		wg.Add(1)
		go func() {
			defer wg.Done()
			for n := range inputs {
				results <- process(n)
			}
		}()
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	return results
}

func main() {
	inputs := make(chan int)

	// Fan-out
	results := fanOut(inputs)

	// 发送输入
	go func() {
		for i := 0; i < 10; i++ {
			inputs <- i
		}
		close(inputs)
	}()

	// Fan-in：收集结果
	sum := 0
	for result := range results {
		sum += result
	}

	fmt.Println("Sum:", sum)
}
```
</UniversalEditor>

### Pipeline 模式

<UniversalEditor title="Pipeline 处理">
```java !! java
// Java：使用 CompletableFuture 的 pipeline
import java.util.concurrent.*;
import java.util.stream.*;

public class Pipeline {
    public static void main(String[] args) throws Exception {
        CompletableFuture.supplyAsync(() -> {
            // 阶段 1：生成数据
            return IntStream.range(0, 10).boxed().collect(Collectors.toList());
        }).thenComposeAsync(data -> {
            // 阶段 2：转换数据
            List<CompletableFuture<Integer>> futures = data.stream()
                .map(n -> CompletableFuture.supplyAsync(() -> n * 2))
                .collect(Collectors.toList());

            return CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
            ).thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList())
            );
        }).thenAcceptAsync(results -> {
            // 阶段 3：消费结果
            results.forEach(System.out::println);
        }).get();
    }
}
```

```go !! go
// Go：使用 channel 的 pipeline
package main

import (
	"fmt"
)

func generate(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		for _, n := range nums {
			out <- n
		}
		close(out)
	}()
	return out
}

func square(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		for n := range in {
			out <- n * n
		}
		close(out)
	}()
	return out
}

func main() {
	// 设置 pipeline
	numbers := generate(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
	squares := square(numbers)

	// 消费结果
	for result := range squares {
		fmt.Println(result)
	}
}
```
</UniversalEditor>

## Goroutine 常见陷阱和最佳实践

### 常见陷阱

<UniversalEditor title="Goroutine 陷阱">
```java !! java
// Java：常见线程陷阱
public class Pitfalls {
    // 陷阱 1：不在线程中处理异常
    public static void pitfall1() {
        new Thread(() -> {
            throw new RuntimeException("Unhandled!"); // 线程静默死亡
        }).start();
    }

    // 陷阱 2：没有同步的共享可变状态
    static int counter = 0;
    public static void pitfall2() throws Exception {
        for (int i = 0; i < 1000; i++) {
            new Thread(() -> counter++).start(); // 竞态条件！
        }
        Thread.sleep(1000);
        System.out.println("Counter: " + counter); // 不可预测！
    }

    // 陷阱 3：线程泄漏
    public static void pitfall3() {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i < 100000; i++) {
            executor.submit(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {}
            });
        }
        // 忘记 shutdown - 线程永不终止！
    }
}
```

```go !! go
// Go：常见 goroutine 陷阱
package main

import (
	"fmt"
	"sync"
	"time"
)

// 陷阱 1：不等待 goroutine
func pitfall1() {
	go func() {
		fmt.Println("Goroutine running")
	}()
	// 主程序立即退出，goroutine 永不完成
}

// 陷阱 2：没有同步的共享可变状态
func pitfall2() {
	var counter int
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			counter++ // 竞态条件！
		}()
	}

	wg.Wait()
	fmt.Println("Counter:", counter) // 不可预测！
}

// 陷阱 3：Goroutine 泄漏
func pitfall3() {
	for i := 0; i < 100000; i++ {
		go func() {
			time.Sleep(time.Hour) // Goroutine 永不退出
		}()
	}
	// Goroutine 堆积，内存泄漏！
}

func main() {
	fmt.Println("Demonstrating pitfall 2:")
	pitfall2()
}
```
</UniversalEditor>

### 最佳实践

<UniversalEditor title="Goroutine 最佳实践">
```java !! java
// Java：线程最佳实践
import java.util.concurrent.*;

public class BestPractices {

    // 好：使用线程池
    public static void good1() {
        ExecutorService executor = Executors.newFixedThreadPool(10);

        for (int i = 0; i < 100; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId);
            });
        }

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // 好：正确的同步
    static class SafeCounter {
        private int count = 0;

        public synchronized void increment() {
            count++;
        }

        public synchronized int get() {
            return count;
        }
    }

    // 好：处理异常
    public static void good3() {
        Thread thread = new Thread(() -> {
            try {
                // 可能抛出的工作
            } catch (Exception e) {
                e.printStackTrace(); // 处理异常
            }
        });
        thread.setUncaughtExceptionHandler((t, e) -> {
            System.err.println("Exception in thread " + t.getName());
        });
        thread.start();
    }
}
```

```go !! go
// Go：Goroutine 最佳实践
package main

import (
	"fmt"
	"sync"
	"time"
)

// 好：总是管理 goroutine 生命周期
func good1() {
	var wg sync.WaitGroup

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			fmt.Printf("Worker %d\n", id)
		}(i)
	}

	wg.Wait()
}

// 好：正确的同步
type SafeCounter struct {
	mu    sync.Mutex
	count int
}

func (c *SafeCounter) Increment() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.count++
}

func (c *SafeCounter) Get() int {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.count
}

// 好：在 goroutine 中处理 panic
func good3() {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				fmt.Printf("Recovered: %v\n", r)
			}
		}()

		// 可能 panic 的工作
		panic("Oops!")
	}()

	time.Sleep(time.Second)
}

func main() {
	fmt.Println("Example 1: Proper lifecycle management")
	good1()

	fmt.Println("\nExample 2: Safe counter")
	counter := &SafeCounter{}
	var wg sync.WaitGroup

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			counter.Increment()
		}()
	}

	wg.Wait()
	fmt.Printf("Counter: %d\n", counter.Get())
}
```
</UniversalEditor>

## 性能基准测试

<UniversalEditor title="基准测试：线程 vs Goroutine 创建">
```java !! java
// Java：基准测试线程创建
public class ThreadBenchmark {
    public static void main(String[] args) throws Exception {
        int iterations = 10000;

        long start = System.currentTimeMillis();

        for (int i = 0; i < iterations; i++) {
            Thread t = new Thread(() -> {});
            t.start();
            t.join();
        }

        long end = System.currentTimeMillis();
        System.out.println("Created and joined " + iterations +
            " threads in " + (end - start) + "ms");
    }
}
```

```go !! go
// Go：基准测试 goroutine 创建
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	iterations := 10000

	start := time.Now()

	var wg sync.WaitGroup
	for i := 0; i < iterations; i++ {
		wg.Add(1)
		go func() {
			wg.Done()
		}()
	}

	wg.Wait()

	elapsed := time.Since(start)
	fmt.Printf("Created and waited for %d goroutines in %dms\n",
		iterations, elapsed.Milliseconds())
}
```
</UniversalEditor>

## 练习题

1. **内存效率**：为什么 Go 可以创建数百万个 goroutine，而 Java 只能创建数千个线程？

2. **同步**：`sync.WaitGroup` 与 `CountDownLatch` 相比如何？你会何时使用它们？

3. **调度**：解释 Go 中的 M:N 调度器以及它与 Java 的 1:1 线程模型的区别。

4. **最佳实践**：使用 goroutine 时的常见陷阱是什么，如何避免它们？

5. **性能**：在什么场景下 goroutine 会显著优于 Java 线程？

## 项目想法

1. **并发网页爬虫**：构建一个使用 goroutine 并发获取多个 URL 的网页爬虫

2. **并行数据处理**：创建一个程序，并行分块处理大型 CSV 文件

3. **Worker Pool 系统**：实现一个健壮的 worker pool，包含作业队列、结果收集和错误处理

4. **实时数据 Pipeline**：构建一个使用 pipeline 模式摄取、转换和输出数据的 pipeline

5. **并发缓存**：实现一个带有过期和并发访问的线程安全内存缓存

## 下一步

现在你已经理解了 goroutine 和并发：

- **下一模块**：学习 **Channel 和 Select** 用于 goroutine 之间的通信
- **深入**：研究 Go 的内存模型和同步模式
- **练习**：构建并发应用以熟悉 goroutine
- **比较**：分析 goroutine 如何与其他并发模型（async/await、actors）比较

## 总结

**Goroutine vs Java 线程：**
- Goroutine 是轻量级的（~2KB）vs 线程（~1MB）
- Go 使用 M:N 调度以提高效率
- `sync.WaitGroup` 简化同步
- Goroutine 支持大规模并发
- Channel（下一模块）提供安全通信

**关键要点**：Go 的 goroutine 使并发编程比 Java 的线程模型更加高效和易于理解。你可以用最小的开销创建数百万个 goroutine，实现使用 Java 线程无法实现的并发编程新模式。
