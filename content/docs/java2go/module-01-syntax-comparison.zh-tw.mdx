---
title: "模組 01：語法對比 - Java 到 Go"
---

本模組探討 Java 和 Go 之間的基本語法差異，幫助你有效地將 Java 知識遷移到 Go。

## 變數聲明

### 哲學差異

**Java：** 顯式類型，冗長的聲明
```java
String name = "Alice";
int age = 25;
double salary = 50000.50;
boolean isActive = true;
```

**Go：** 類型推斷，簡潔語法
```go
name := "Alice"           // 推斷為 string
age := 25                 // 推斷為 int
salary := 50000.50        // 推斷為 float64
isActive := true          // 推斷為 bool
```

### 聲明方法對比

| Java | Go | 描述 |
|------|-----|-------------|
| `String name = "Alice";` | `name := "Alice"` | 類型推斷的簡短聲明 |
| `final String NAME = "Bob";` | `const NAME = "Bob"` | 常量聲明 |
| `String name;` | `var name string` | 零值變數 |
| `int x = 10;` | `x := 10` 或 `var x int = 10` | 顯式 vs 推斷類型 |

<UniversalEditor title="變數聲明對比">
```java !! java
// Java: 變數聲明
public class Variables {
    public static void main(String[] args) {
        // 顯式類型聲明
        String name = "Alice";
        int age = 30;
        double salary = 75000.50;
        boolean isActive = true;

        // Final 常量
        final int MAX_COUNT = 100;

        // 聲明但不初始化（物件為 null）
        String uninitialized;
        uninitialized = "現在已初始化";

        // 多個聲明
        int x = 10, y = 20, z = 30;

        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("Salary: " + salary);
        System.out.println("Active: " + isActive);
    }
}
```

```go !! go
// Go: 變數聲明
package main

import "fmt"

func main() {
    // 簡短聲明（類型推斷）- 最常用
    name := "Alice"
    age := 30
    salary := 75000.50
    isActive := true

    // 常量聲明
    const MAX_COUNT = 100

    // 零值變數（Go 中沒有未初始化的變數）
    var uninitialized string
    uninitialized = "現在已初始化"

    // 多個聲明
    x, y, z := 10, 20, 30

    // 顯式類型聲明
    var employeeId int = 12345

    fmt.Printf("Name: %s\n", name)
    fmt.Printf("Age: %d\n", age)
    fmt.Printf("Salary: %.2f\n", salary)
    fmt.Printf("Active: %t\n", isActive)
    fmt.Printf("Employee ID: %d\n", employeeId)
}
```
</UniversalEditor>

### Go 中的零值

與 Java 中未初始化的物件為 `null` 不同，Go 總是將變數初始化為零值：

| Go 類型 | 零值 | Java 等價物 |
|---------|------------|-----------------|
| `int`, `int64` 等 | `0` | `0` |
| `float64`, `float32` | `0.0` | `0.0` |
| `bool` | `false` | `false` |
| `string` | `""`（空字串）| `null` |
| 指標類型 | `nil` | `null` |
| `slice` | `nil` | `null` |

<UniversalEditor title="零值初始化">
```java !! java
// Java: Null vs 預設值
public class ZeroValues {
    static int primitiveInt;      // 0
    static double primitiveDouble; // 0.0
    static boolean primitiveBool;  // false
    static String objectString;    // null

    public static void main(String[] args) {
        System.out.println(primitiveInt);    // 0
        System.out.println(primitiveDouble); // 0.0
        System.out.println(primitiveBool);   // false
        System.out.println(objectString);    // null

        // 需要 null 檢查
        if (objectString != null) {
            System.out.println(objectString.length());
        }
    }
}
```

```go !! go
// Go: 零值（基本類型沒有 Null）
package main

import "fmt"

var primitiveInt int
var primitiveDouble float64
var primitiveBool bool
var objectString string

func main() {
    fmt.Println(primitiveInt)    // 0
    fmt.Println(primitiveDouble) // 0
    fmt.Println(primitiveBool)   // false
    fmt.Println(objectString)    // ""（空字串，不是 nil！）

    // 不需要 null 檢查
    fmt.Println(len(objectString)) // 0

    // 指標示例（可以為 nil）
    var pointer *int
    fmt.Println(pointer) // <nil>

    if pointer != nil {
        fmt.Println(*pointer)
    }
}
```
</UniversalEditor>

## 資料類型對比

### 基本類型

| Java | Go | 說明 |
|------|-----|-------|
| `byte` | `byte` | 相同（8位）|
| `short` | `int16` | 16位整數 |
| `int` | `int` | 平台相關（32或64位）|
| `long` | `int64` | 64位整數 |
| `float` | `float32` | 32位浮點 |
| `double` | `float64` | 64位浮點 |
| `char` | `rune` | Go 的 rune 是 Unicode 碼點 |
| `boolean` | `bool` | 相同概念 |
| `String` | `string` | 都不可變，UTF-8 |

### Go 特有類型

Go 提供了更精確的整數類型：

```go
// 有符號整數
int8    // 8位 (-128 到 127)
int16   // 16位
int32   // 32位
int64   // 64位
int     // 平台相關（32或64位）

// 無符號整數
uint8   // 8位 (0 到 255) - 也叫 byte
uint16  // 16位
uint32  // 32位
uint64  // 64位
uint    // 平台相關
uintptr // 用於指標的無符號整數

// 浮點數
float32 // 32位 IEEE 754
float64 // 64位 IEEE 754

// 複數（Java 沒有！）
complex64  // complex64 带 float32 實部和虛部
complex128 // complex128 带 float64 實部和虛部
```

<UniversalEditor title="類型系統對比">
```java !! java
// Java: 類型系統
public class Types {
    public static void main(String[] args) {
        // 基本類型
        byte b = 100;
        short s = 1000;
        int i = 100000;
        long l = 1000000L;
        float f = 3.14f;
        double d = 3.14159;
        char c = 'A';
        boolean bool = true;

        // String（引用類型）
        String name = "Alice";

        // 陣列（固定大小）
        int[] numbers = new int[5];
        numbers[0] = 10;

        // ArrayList（動態）
        java.util.List<String> list = new java.util.ArrayList<>();
        list.add("Hello");

        System.out.println("Int: " + i);
        System.out.println("Double: " + d);
        System.out.println("String: " + name);
    }
}
```

```go !! go
// Go: 類型系統
package main

import "fmt"

func main() {
    // 基本類型
    var b byte = 100        // uint8
    var s int16 = 1000
    var i int = 100000
    var l int64 = 1000000
    var f float32 = 3.14
    var d float64 = 3.14159
    var c rune = 'A'        // rune 是 int32 的別名
    var boolVal bool = true

    // String（內建類型，不是類別）
    var name string = "Alice"

    // 陣列（固定大小）
    var numbers [5]int
    numbers[0] = 10

    // 切片（動態陣列）- 內建，無需匯入
    var slice []int = []int{1, 2, 3}
    slice = append(slice, 4) // 新增元素

    // Map（內建）
    var person map[string]int = map[string]int{
        "age": 30,
    }

    fmt.Printf("Int: %d\n", i)
    fmt.Printf("Double: %f\n", d)
    fmt.Printf("String: %s\n", name)
    fmt.Printf("Slice: %v\n", slice)
    fmt.Printf("Map: %v\n", person)
}
```
</UniversalEditor>

## 控制流

### If/Else 陳述式

Go 的 if/else 與 Java 類似，但有重要區別：
- 條件周圍不需要括號
- 左大括號必須在 if 同一行
- Go 中沒有三元運算子

<UniversalEditor title="If/Else 對比">
```java !! java
// Java: If/Else
public class Conditionals {
    public static void main(String[] args) {
        int score = 85;

        // 帶括號
        if (score >= 90) {
            System.out.println("A");
        } else if (score >= 80) {
            System.out.println("B");
        } else {
            System.out.println("C");
        }

        // 三元運算子
        String result = (score >= 60) ? "Pass" : "Fail";
        System.out.println(result);

        // Null 檢查
        String name = null;
        if (name != null && name.length() > 0) {
            System.out.println(name);
        }
    }
}
```

```go !! go
// Go: If/Else
package main

import "fmt"

func main() {
    score := 85

    // 不需要括號
    if score >= 90 {
        fmt.Println("A")
    } else if score >= 80 {
        fmt.Println("B")
    } else {
        fmt.Println("C")
    }

    // Go 中沒有三元運算子！
    // 使用常規 if/else 代替
    var result string
    if score >= 60 {
        result = "Pass"
    } else {
        result = "Fail"
    }
    fmt.Println(result)

    // 帶初始化陳述式的 if
    if name := getName(); name != "" {
        fmt.Printf("Name: %s\n", name)
    }
}

func getName() string {
    return "Alice"
}
```
</UniversalEditor>

### Switch 陳述式

Go 的 switch 比 Java 更強大：
- 不需要 break（預設不穿透）
- 可以對任何類型切換，不只是整數
- 一個 case 中可以有多個值
- 不需要 default

<UniversalEditor title="Switch 陳述式對比">
```java !! java
// Java: Switch 陳述式
public class SwitchCase {
    public static void main(String[] args) {
        int dayOfWeek = 3;

        // 傳統 switch
        switch (dayOfWeek) {
            case 1:
                System.out.println("Monday");
                break; // 需要防止穿透
            case 2:
                System.out.println("Tuesday");
                break;
            case 3:
                System.out.println("Wednesday");
                break;
            default:
                System.out.println("Other day");
        }

        // Java 14+ 增強型 switch
        String dayType = switch (dayOfWeek) {
            case 1, 2, 3, 4, 5 -> "Weekday";
            case 6, 7 -> "Weekend";
            default -> "Invalid";
        };
        System.out.println(dayType);
    }
}
```

```go !! go
// Go: Switch 陳述式
package main

import "fmt"

func main() {
    dayOfWeek := 3

    // 不需要 break！預設不穿透
    switch dayOfWeek {
    case 1:
        fmt.Println("Monday")
    case 2:
        fmt.Println("Tuesday")
    case 3:
        fmt.Println("Wednesday")
    default:
        fmt.Println("Other day")
    }

    // 一個 case 中的多個值
    switch dayOfWeek {
    case 1, 2, 3, 4, 5:
        fmt.Println("Weekday")
    case 6, 7:
        fmt.Println("Weekend")
    default:
        fmt.Println("Invalid")
    }

    // 帶條件的 switch（不需要表達式）
    score := 85
    switch {
    case score >= 90:
        fmt.Println("A")
    case score >= 80:
        fmt.Println("B")
    case score >= 70:
        fmt.Println("C")
    default:
        fmt.Println("D")
    }

    // 字串 switch（以及任何類型！）
    OS := "linux"
    switch OS {
    case "darwin":
        fmt.Println("macOS")
    case "linux":
        fmt.Println("Linux")
    case "windows":
        fmt.Println("Windows")
    }
}
```
</UniversalEditor>

## 迴圈

### For 迴圈 - Go 中唯一的迴圈

Go 只有 `for` 迴圈（沒有 `while`，沒有 `do-while`），但非常靈活：

<UniversalEditor title="迴圈對比">
```java !! java
// Java: 多種迴圈類型
public class Loops {
    public static void main(String[] args) {
        // 傳統 for 迴圈
        for (int i = 0; i < 5; i++) {
            System.out.println("Count: " + i);
        }

        // 增強型 for 迴圈（for-each）
        int[] numbers = {1, 2, 3, 4, 5};
        for (int num : numbers) {
            System.out.println(num);
        }

        // While 迴圈
        int count = 0;
        while (count < 5) {
            System.out.println("While: " + count);
            count++;
        }

        // Do-while 迴圈
        do {
            System.out.println("Do-while: " + count);
            count--;
        } while (count > 0);
    }
}
```

```go !! go
// Go: 只有 for 迴圈，但非常靈活
package main

import "fmt"

func main() {
    // 傳統 for 迴圈
    for i := 0; i < 5; i++ {
        fmt.Printf("Count: %d\n", i)
    }

    // 基於 range 的 for（類似增強型 for）
    numbers := []int{1, 2, 3, 4, 5}
    for i, num := range numbers {
        fmt.Printf("Index %d: %d\n", i, num)
    }

    // 只有值的 range
    for _, num := range numbers {
        fmt.Printf("Value: %d\n", num)
    }

    // 只有索引的 range
    for i := range numbers {
        fmt.Printf("Index: %d\n", i)
    }

    // While 風格迴圈（省略所有三個元件）
    count := 0
    for count < 5 {
        fmt.Printf("While: %d\n", count)
        count++
    }

    // 無限迴圈
    sum := 0
    for {
        sum++
        if sum > 10 {
            break
        }
    }
    fmt.Printf("Sum: %d\n", sum)

    // Range 遍歷 map
    person := map[string]int{
        "age":  30,
        "score": 85,
    }
    for key, value := range person {
        fmt.Printf("%s: %d\n", key, value)
    }

    // Range 遍歷字串（按 rune）
    for i, char := range "Hello" {
        fmt.Printf("Index %d: %c\n", i, char)
    }
}
```
</UniversalEditor>

## 函式

### 函式聲明

<UniversalEditor title="函式聲明對比">
```java !! java
// Java: 函式方法
public class Functions {
    // 靜態方法（類似 Go 函式）
    public static int add(int a, int b) {
        return a + b;
    }

    // 帶返回類型的方法
    public String greet(String name) {
        return "Hello, " + name;
    }

    // Void 方法
    public void printMessage(String message) {
        System.out.println(message);
    }

    // 多返回值？無法直接實現！
    // 需要使用類別或陣列

    // 可變參數
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(add(5, 3));

        Functions f = new Functions();
        System.out.println(f.greet("Alice"));
        f.printMessage("Hello");

        System.out.println(sum(1, 2, 3, 4, 5));
    }
}
```

```go !! go
// Go: 多返回值函式！
package main

import "fmt"

// 簡單函式
func add(a int, b int) int {
    return a + b
}

// 簡寫參數類型
func subtract(a, b int) int {
    return a - b
}

// 多返回值（非常有用！）
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("除以零")
    }
    return a / b, nil
}

// 命名返回值
func getDimensions() (width, height int) {
    width = 100
    height = 200
    return // 裸返回（返回 width, height）
}

// 可變函式（可變參數）
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// 函式作為類型（一等公民）
var operation func(int, int) int = func(a, b int) int {
    return a * b
}

func main() {
    fmt.Println(add(5, 3))
    fmt.Println(subtract(10, 3))

    // 多返回值
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Result:", result)
    }

    // 命名返回值
    w, h := getDimensions()
    fmt.Printf("Dimensions: %d x %d\n", w, h)

    // 可變函式
    fmt.Println(sum(1, 2, 3, 4, 5))

    // 函式作為變數
    fmt.Println(operation(5, 6))
}
```
</UniversalEditor>

### Go 中的方法

與 Java 不同，方法在結構體外部定義：

<UniversalEditor title="方法對比">
```java !! java
// Java: 類別內部的方法
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 實例方法
    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String introduce() {
        return "Hi, I'm " + name;
    }

    public static void main(String[] args) {
        Person p = new Person("Alice", 30);
        System.out.println(p.introduce());
    }
}
```

```go !! go
// Go: 結構體外部定義的方法
package main

import "fmt"

// 結構體定義
type Person struct {
    Name string
    Age  int
}

// 建構函式（地道的 Go）
func NewPerson(name string, age int) *Person {
    return &Person{
        Name: name,
        Age:  age,
    }
}

// 值接收者方法
func (p Person) GetName() string {
    return p.Name
}

// 指標接收者方法（可修改）
func (p *Person) SetAge(age int) {
    p.Age = age
}

// 方法
func (p Person) Introduce() string {
    return fmt.Sprintf("Hi, I'm %s", p.Name)
}

func main() {
    // 建構函式
    p := NewPerson("Alice", 30)
    fmt.Println(p.Introduce())

    p.SetAge(31)
    fmt.Printf("Age: %d\n", p.Age)
}
```
</UniversalEditor>

## 陣列和切片

<UniversalEditor title="陣列和切片對比">
```java !! java
// Java: 陣列和 ArrayList
import java.util.ArrayList;
import java.util.List;

public class Arrays {
    public static void main(String[] args) {
        // 陣列（固定大小）
        int[] fixedArray = new int[5];
        fixedArray[0] = 10;

        // 陣列字面量
        int[] numbers = {1, 2, 3, 4, 5};
        System.out.println("Length: " + numbers.length);

        // ArrayList（動態）
        List<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        list.add("Java");

        System.out.println("List size: " + list.size());
        System.out.println("Element: " + list.get(0));

        // 迭代
        for (String item : list) {
            System.out.println(item);
        }

        // 子列表
        List<String> subList = list.subList(0, 2);
        System.out.println("Sublist: " + subList);
    }
}
```

```go !! go
// Go: 陣列和切片
package main

import "fmt"

func main() {
    // 陣列（固定大小）- 很少直接使用
    var fixedArray [5]int
    fixedArray[0] = 10

    // 陣列字面量
    numbers := [5]int{1, 2, 3, 4, 5}
    fmt.Printf("Array length: %d\n", len(numbers))

    // 切片（陣列的動態視圖）- 最常用
    var slice []int
    slice = append(slice, 1)
    slice = append(slice, 2)
    slice = append(slice, 3)

    // 切片字面量
    fruits := []string{"Apple", "Banana", "Cherry"}
    fmt.Printf("Slice length: %d\n", len(fruits))
    fmt.Printf("Element: %s\n", fruits[0])

    // 使用 range 迭代
    for i, fruit := range fruits {
        fmt.Printf("Index %d: %s\n", i, fruit)
    }

    // 切片切片（子切片）
    subSlice := fruits[0:2] // 元素 0 和 1
    fmt.Printf("Sub-slice: %v\n", subSlice)

    // 追加到切片
    fruits = append(fruits, "Date")
    fmt.Printf("After append: %v\n", fruits)

    // 複製切片
    copySlice := make([]string, len(fruits))
    copy(copySlice, fruits)
    fmt.Printf("Copy: %v\n", copySlice)

    // 預分配帶容量的切片
    bigSlice := make([]int, 0, 100) // 長度 0，容量 100
    fmt.Printf("Length: %d, Capacity: %d\n", len(bigSlice), cap(bigSlice))
}
```
</UniversalEditor>

## 關鍵語法差異總結

| 特性 | Java | Go |
|---------|------|-----|
| **分號** | 必需 | 可選（推斷）|
| **if/for 中的括號** | 必需 | 可選 |
| **大括號位置** | 靈活 | 必須在同一行 |
| **三元運算子** | `condition ? true : false` | 無三元，使用 if/else |
| **While 迴圈** | `while (condition)` | `for condition` |
| **Do-while** | `do {} while (condition)` | 無直接等價物 |
| **For-each** | `for (item : collection)` | `for item := range collection` |
| **Break/Continue** | `break label` | `break label`（類似）|
| **Switch 穿透** | 預設（需要 break）| 使用 `fallthrough` 關鍵字選擇加入 |
| **多返回值** | 需要類別/物件 | 內建 `(type1, type2)` |
| **Null 檢查** | `if (obj != null)` | `if obj != nil` |
| **字串串接** | `+` 運算子 | `+` 或 `fmt.Sprintf` |

---

### 練習題：
1. Go 的類型推斷與 Java 的類型聲明有何不同？
2. 為什麼 Go 沒有三元運算子？你如何實現相同的效果？
3. 解釋 Go 的陣列和切片的區別，並將它們與 Java 的陣列和 ArrayList 進行比較。
4. 編寫一個返回多個值的 Go 函式，並展示如何處理每個返回值。

### 專案想法：
- 建立一個簡單的成績計算器程式，它：
  - 接受學生成績作為輸入
  - 計算平均分和字母等級
  - 使用多返回值作為結果
  - 演示 if/else 和 switch 陳述式

### 下一步：
- 學習 Go 的物件導向程式設計方法
- 理解 Go 的套件系統
- 探索 Go 強大的並發模型
