---
title: "模組 06：Goroutine vs 執行緒 - 輕量級並行"
description: "掌握 Go 的 goroutine 並與 Java 執行緒進行比較。了解輕量級並行、goroutine 生命週期、WaitGroup 和效能特性。"
---

# 模組 06：Goroutine vs 執行緒 - 輕量級並行

在本模組中，你將學習 Go 如何透過 **goroutine 處理並行**，並將其與 Java 的執行緒模型進行比較。Go 的 goroutine 是輕量級的，建立成本極低，使並行程式設計更加簡單和高效。

## 學習目標

完成本模組後，你將能夠：
- 建立和管理 goroutine
- 比較 goroutine 和 Java 執行緒
- 使用 WaitGroup 進行同步
- 理解 goroutine 調度和生命週期
- 分析記憶體佔用的差異
- 實作常見的 goroutine 模式
- 高效建構並行程式

## 背景：Java 執行緒 vs Go Goroutine

### 根本差異

**Java 執行緒：**
- 重量級 - 每個執行緒映射到一個作業系統執行緒
- 建立成本高（每個執行緒約 1MB 堆疊空間）
- 受作業系統資源限制（最多數千個）
- 上下文切換成本高（核心層級）
- 複雜的同步機制（synchronized、Lock、Condition）

**Go Goroutine：**
- 輕量級 - 由 Go 執行時管理
- 建立極其廉價（初始堆疊約 2KB）
- 可以建立數百萬個 goroutine
- 上下文切換成本低（使用者層級）
- 透過 channel 實作簡單的同步

<UniversalEditor title="並行入門：Java vs Go">
```java !! java
// Java：建立執行緒是重量級的
public class ThreadExample {
    public static void main(String[] args) {
        // 建立並啟動執行緒
        Thread thread = new Thread(() -> {
            System.out.println("Hello from thread!");
        });
        thread.start();

        // 等待執行緒完成
        try {
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread done");
    }
}
```

```go !! go
// Go：Goroutine 是輕量級的
package main

import (
	"fmt"
)

func main() {
	// 啟動 goroutine
	go func() {
		fmt.Println("Hello from goroutine!")
	}()

	// 等待一下（不是理想方式 - 我們會學習更好的方法）
	fmt.Println("Main goroutine done")
}
```
</UniversalEditor>

## 建立 Goroutine

### 基本 Goroutine 建立

<UniversalEditor title="建立並行任務">
```java !! java
// Java：使用執行緒池進行並行任務
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThread {
    public static void main(String[] args) {
        // 使用執行緒池（比直接建立執行緒更好）
        ExecutorService executor = Executors.newFixedThreadPool(5);

        for (int i = 0; i < 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId +
                    " running on " + Thread.currentThread().getName());
            });
        }

        executor.shutdown();
    }
}
```

```go !! go
// Go：啟動 goroutine
package main

import (
	"fmt"
	"time"
)

func task(id int) {
	fmt.Printf("Task %d running\n", id)
}

func main() {
	// 啟動 5 個 goroutine
	for i := 0; i < 5; i++ {
		go task(i)
	}

	// 等待 goroutine 完成
	time.Sleep(time.Millisecond)
}
```
</UniversalEditor>

### 匿名 Goroutine

<UniversalEditor title="匿名函式 vs 閉包">
```java !! java
// Java：匿名 Runnable 和 lambda
public class AnonymousThread {
    public static void main(String[] args) {
        // 匿名類別
        Thread t1 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Anonymous class");
            }
        });

        // Lambda（首選）
        Thread t2 = new Thread(() -> {
            System.out.println("Lambda expression");
        });

        t1.start();
        t2.start();
    }
}
```

```go !! go
// Go：帶閉包的匿名 goroutine
package main

import (
	"fmt"
)

func main() {
	// 匿名 goroutine
	go func() {
		fmt.Println("Anonymous goroutine")
	}()

	// 帶參數的 goroutine
	go func(msg string) {
		fmt.Printf("Message: %s\n", msg)
	}("Hello from closure")

	// 等待 goroutine
	time.Sleep(100 * time.Millisecond)
}
```
</UniversalEditor>

## WaitGroup vs CountDownLatch

### 同步原語

<UniversalEditor title="等待多個任務">
```java !! java
// Java：使用 CountDownLatch 等待多個執行緒
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class LatchExample {
    public static void main(String[] args) throws InterruptedException {
        final int TASK_COUNT = 3;
        CountDownLatch latch = new CountDownLatch(TASK_COUNT);
        ExecutorService executor = Executors.newFixedThreadPool(TASK_COUNT);

        for (int i = 0; i < TASK_COUNT; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    Thread.sleep(1000);
                    System.out.println("Task " + taskId + " completed");
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    latch.countDown(); // 發出完成信號
                }
            });
        }

        latch.await(); // 等待所有任務
        System.out.println("All tasks completed");
        executor.shutdown();
    }
}
```

```go !! go
// Go：使用 WaitGroup 同步
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker(id int, wg *sync.WaitGroup) {
	defer wg.Done() // 完成時發出信號

	fmt.Printf("Worker %d starting\n", id)
	time.Sleep(time.Second)
	fmt.Printf("Worker %d done\n", id)
}

func main() {
	var wg sync.WaitGroup

	// 啟動 3 個 worker
	for i := 1; i <= 3; i++ {
		wg.Add(1) // 增加計數器
		go worker(i, &wg)
	}

	wg.Wait() // 等待所有 worker
	fmt.Println("All workers completed")
}
```
</UniversalEditor>

### WaitGroup 最佳實踐

<UniversalEditor title="WaitGroup 模式">
```java !! java
// Java：更複雜的同步場景
import java.util.concurrent.*;
import java.util.*;

public class ComplexSync {
    static class Result {
        List<String> results = new ArrayList<>();
    }

    public static void main(String[] args) throws Exception {
        int taskCount = 5;
        CountDownLatch latch = new CountDownLatch(taskCount);
        Result result = new Result();

        ExecutorService executor = Executors.newFixedThreadPool(10);

        for (int i = 0; i < taskCount; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    String data = "Result " + taskId;
                    synchronized (result.results) {
                        result.results.add(data);
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await();
        System.out.println("Collected: " + result.results);
        executor.shutdown();
    }
}
```

```go !! go
// Go：更簡潔的 WaitGroup 模式
package main

import (
	"fmt"
	"sync"
)

func collectResults(id int, wg *sync.WaitGroup, results *[]string) {
	defer wg.Done()

	data := fmt.Sprintf("Result %d", id)
	*results = append(*results, data)
}

func main() {
	var wg sync.WaitGroup
	var results []string
	var mu sync.Mutex // 保護共享的 slice

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()

			data := fmt.Sprintf("Result %d", id)

			mu.Lock()
			results = append(results, data)
			mu.Unlock()
		}(i)
	}

	wg.Wait()
	fmt.Println("Collected:", results)
}
```
</UniversalEditor>

## Goroutine 生命週期和調度

### 理解 Goroutine 狀態

<UniversalEditor title="執行緒 vs Goroutine 生命週期">
```java !! java
// Java：執行緒狀態（NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED）
public class ThreadStates {
    public static void main(String[] args) throws Exception {
        Thread thread = new Thread(() -> {
            try {
                // RUNNABLE
                System.out.println("Thread running");

                // TIMED_WAITING
                Thread.sleep(1000);

                // WAITING
                synchronized (ThreadStates.class) {
                    ThreadStates.class.wait();
                }
            } catch (InterruptedException e) {
                // TERMINATED
            }
        });

        // NEW 狀態
        System.out.println("State: " + thread.getState());

        thread.start(); // RUNNABLE

        Thread.sleep(100);
        System.out.println("State: " + thread.getState());
    }
}
```

```go !! go
// Go：Goroutine 狀態（更簡單的模型）
package main

import (
	"fmt"
	"runtime"
	"time"
)

func goroutineStates() {
	// Goroutine 正在執行
	fmt.Println("Goroutine running")

	// Goroutine 被阻塞（等待）
	time.Sleep(time.Second)

	// Goroutine 完成並被垃圾回收
	fmt.Println("Goroutine done")
}

func main() {
	// goroutine 建立前：還沒有 goroutine
	fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())

	go goroutineStates()

	time.Sleep(100 * time.Millisecond)
	fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())

	time.Sleep(2 * time.Second)
	fmt.Printf("Goroutines: %d\n", runtime.NumGoroutine())
}
```
</UniversalEditor>

### Goroutine 調度器（M:N 調度器）

<UniversalEditor title="調度器比較">
```java !! java
// Java：1:1 執行緒模型（一個 Java 執行緒 = 一個 OS 執行緒）
// 由 OS 調度器管理
public class JavaScheduler {
    public static void main(String[] args) {
        // 每個執行緒建立一個 OS 執行緒
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                // 這是 1:1 映射到 OS 執行緒
                Thread.currentThread().setName("Worker");
                System.out.println(Thread.currentThread().getName());
            }).start();
        }
    }
}

/* OS 管理調度 - 昂貴的上下文切換 */
```

```go !! go
// Go：M:N 調度器（M 個 goroutine : N 個 OS 執行緒）
// Go 執行時管理調度
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	// 設定 OS 執行緒數（GOMAXPROCS）
	fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))

	// 可以啟動數千個 goroutine
	for i := 0; i < 1000; i++ {
		go func(id int) {
			time.Sleep(100 * time.Millisecond)
			fmt.Printf("Goroutine %d\n", id)
		}(i)
	}

	// Go 執行時將 goroutine 多路復用到更少的 OS 執行緒上
	time.Sleep(time.Second)
	fmt.Printf("Total goroutines created: 1000\n")
}
```
</UniversalEditor>

## 記憶體佔用比較

### 堆疊大小和記憶體使用

<UniversalEditor title="記憶體佔用分析">
```java !! java
// Java：執行緒有很大的堆疊空間
public class ThreadMemory {
    public static void main(String[] args) {
        // 預設堆疊大小：每個執行緒約 1MB
        // 1000 個執行緒 = 約 1GB 記憶體！

        Runtime runtime = Runtime.getRuntime();
        long before = runtime.totalMemory() - runtime.freeMemory();

        for (int i = 0; i < 100; i++) {
            new Thread(() -> {
                try {
                    Thread.sleep(60000); // 保持活動
                } catch (InterruptedException e) {}
            }).start();
        }

        long after = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("Memory used: " + (after - before) / 1024 / 1024 + " MB");
        System.out.println("100 threads created");
    }
}
```

```go !! go
// Go：Goroutine 開始時堆疊很小（2KB）
package main

import (
	"fmt"
	"runtime"
	"time"
)

func main() {
	var m runtime.MemStats
	runtime.ReadMemStats(&m)
	before := m.Alloc

	// 建立 100,000 個 goroutine！
	for i := 0; i < 100000; i++ {
		go func() {
			time.Sleep(time.Minute)
		}()
	}

	runtime.ReadMemStats(&m)
	after := m.Alloc

	fmt.Printf("Memory used: %d MB\n", (after-before)/1024/1024)
	fmt.Printf("100,000 goroutines created\n")
}
```
</UniversalEditor>

### 實際效能比較

<UniversalEditor title="並行任務效能">
```java !! java
// Java：執行緒池效能
import java.util.concurrent.*;
import java.util.*;

public class ThreadPerformance {
    public static void main(String[] args) throws Exception {
        int tasks = 10000;

        ExecutorService executor = Executors.newFixedThreadPool(100);
        long start = System.currentTimeMillis();

        List<Future<Integer>> futures = new ArrayList<>();

        for (int i = 0; i < tasks; i++) {
            final int taskId = i;
            futures.add(executor.submit(() -> {
                int sum = 0;
                for (int j = 0; j < 100; j++) {
                    sum += j;
                }
                return sum;
            }));
        }

        int total = 0;
        for (Future<Integer> future : futures) {
            total += future.get();
        }

        long end = System.currentTimeMillis();
        System.out.println("Time: " + (end - start) + "ms");
        System.out.println("Total: " + total);

        executor.shutdown();
    }
}
```

```go !! go
// Go：Goroutine 效能
package main

import (
	"fmt"
	"sync"
	"time"
)

func task() int {
	sum := 0
	for i := 0; i < 100; i++ {
		sum += i
	}
	return sum
}

func main() {
	tasks := 10000

	start := time.Now()
	var wg sync.WaitGroup
	results := make(chan int, tasks)

	for i := 0; i < tasks; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			results <- task()
		}()
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	total := 0
	for result := range results {
		total += result
	}

	elapsed := time.Since(start)
	fmt.Printf("Time: %dms\n", elapsed.Milliseconds())
	fmt.Printf("Total: %d\n", total)
}
```
</UniversalEditor>

## 常見 Goroutine 模式

### Worker Pool 模式

<UniversalEditor title="Worker Pool 實作">
```java !! java
// Java：使用 ExecutorService 的 worker pool
import java.util.concurrent.*;
import java.util.*;

public class WorkerPool {
    static class Job {
        int id;
        String data;

        Job(int id, String data) {
            this.id = id;
            this.data = data;
        }
    }

    public static void main(String[] args) throws Exception {
        int numWorkers = 5;
        ExecutorService executor = Executors.newFixedThreadPool(numWorkers);

        List<Job> jobs = new ArrayList<>();
        for (int i = 0; i < 20; i++) {
            jobs.add(new Job(i, "Task " + i));
        }

        for (Job job : jobs) {
            executor.submit(() -> {
                System.out.println("Processing " + job.id);
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {}
                System.out.println("Completed " + job.id);
            });
        }

        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);
    }
}
```

```go !! go
// Go：使用緩衝 channel 的 worker pool
package main

import (
	"fmt"
	"sync"
	"time"
)

type Job struct {
	ID   int
	Data string
}

func worker(id int, jobs <-chan Job, wg *sync.WaitGroup) {
	defer wg.Done()

	for job := range jobs {
		fmt.Printf("Worker %d processing job %d\n", id, job.ID)
		time.Sleep(100 * time.Millisecond)
		fmt.Printf("Worker %d completed job %d\n", id, job.ID)
	}
}

func main() {
	numWorkers := 5
	numJobs := 20

	jobs := make(chan Job, numJobs)
	var wg sync.WaitGroup

	// 啟動 workers
	for i := 1; i <= numWorkers; i++ {
		wg.Add(1)
		go worker(i, jobs, &wg)
	}

	// 發送任務
	for i := 0; i < numJobs; i++ {
		jobs <- Job{ID: i, Data: fmt.Sprintf("Task %d", i)}
	}
	close(jobs)

	// 等待所有 worker
	wg.Wait()
	fmt.Println("All jobs completed")
}
```
</UniversalEditor>

### Fan-Out / Fan-In 模式

<UniversalEditor title="Fan-Out Fan-In 模式">
```java !! java
// Java：使用多個消費者的 fan-out
import java.util.concurrent.*;
import java.util.*;

public class FanOutFanIn {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newFixedThreadPool(10);

        List<Future<Integer>> futures = new ArrayList<>();

        // Fan-out：分發工作
        for (int i = 0; i < 10; i++) {
            final int input = i;
            futures.add(executor.submit(() -> {
                return process(input);
            }));
        }

        // Fan-in：收集結果
        int sum = 0;
        for (Future<Integer> future : futures) {
            sum += future.get();
        }

        System.out.println("Sum: " + sum);
        executor.shutdown();
    }

    private static int process(int n) {
        return n * n;
    }
}
```

```go !! go
// Go：使用 channel 的優雅 fan-out/fan-in
package main

import (
	"fmt"
	"sync"
)

func process(n int) int {
	return n * n
}

func fanOut(inputs <-chan int) <-chan int {
	results := make(chan int)

	var wg sync.WaitGroup
	for i := 0; i < 3; i++ { // 3 個 worker
		wg.Add(1)
		go func() {
			defer wg.Done()
			for n := range inputs {
				results <- process(n)
			}
		}()
	}

	go func() {
		wg.Wait()
		close(results)
	}()

	return results
}

func main() {
	inputs := make(chan int)

	// Fan-out
	results := fanOut(inputs)

	// 發送輸入
	go func() {
		for i := 0; i < 10; i++ {
			inputs <- i
		}
		close(inputs)
	}()

	// Fan-in：收集結果
	sum := 0
	for result := range results {
		sum += result
	}

	fmt.Println("Sum:", sum)
}
```
</UniversalEditor>

### Pipeline 模式

<UniversalEditor title="Pipeline 處理">
```java !! java
// Java：使用 CompletableFuture 的 pipeline
import java.util.concurrent.*;
import java.util.stream.*;

public class Pipeline {
    public static void main(String[] args) throws Exception {
        CompletableFuture.supplyAsync(() -> {
            // 階段 1：生成資料
            return IntStream.range(0, 10).boxed().collect(Collectors.toList());
        }).thenComposeAsync(data -> {
            // 階段 2：轉換資料
            List<CompletableFuture<Integer>> futures = data.stream()
                .map(n -> CompletableFuture.supplyAsync(() -> n * 2))
                .collect(Collectors.toList());

            return CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0])
            ).thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList())
            );
        }).thenAcceptAsync(results -> {
            // 階段 3：消費結果
            results.forEach(System.out::println);
        }).get();
    }
}
```

```go !! go
// Go：使用 channel 的 pipeline
package main

import (
	"fmt"
)

func generate(nums ...int) <-chan int {
	out := make(chan int)
	go func() {
		for _, n := range nums {
			out <- n
		}
		close(out)
	}()
	return out
}

func square(in <-chan int) <-chan int {
	out := make(chan int)
	go func() {
		for n := range in {
			out <- n * n
		}
		close(out)
	}()
	return out
}

func main() {
	// 設定 pipeline
	numbers := generate(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
	squares := square(numbers)

	// 消費結果
	for result := range squares {
		fmt.Println(result)
	}
}
```
</UniversalEditor>

## Goroutine 常見陷阱和最佳實踐

### 常見陷阱

<UniversalEditor title="Goroutine 陷阱">
```java !! java
// Java：常見執行緒陷阱
public class Pitfalls {
    // 陷阱 1：不在執行緒中處理異常
    public static void pitfall1() {
        new Thread(() -> {
            throw new RuntimeException("Unhandled!"); // 執行緒靜默死亡
        }).start();
    }

    // 陷阱 2：沒有同步的共享可變狀態
    static int counter = 0;
    public static void pitfall2() throws Exception {
        for (int i = 0; i < 1000; i++) {
            new Thread(() -> counter++).start(); // 競態條件！
        }
        Thread.sleep(1000);
        System.out.println("Counter: " + counter); // 不可預測！
    }

    // 陷阱 3：執行緒泄漏
    public static void pitfall3() {
        ExecutorService executor = Executors.newCachedThreadPool();
        for (int i = 0; i < 100000; i++) {
            executor.submit(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {}
            });
        }
        // 忘記 shutdown - 執行緒永不終止！
    }
}
```

```go !! go
// Go：常見 goroutine 陷阱
package main

import (
	"fmt"
	"sync"
	"time"
)

// 陷阱 1：不等待 goroutine
func pitfall1() {
	go func() {
		fmt.Println("Goroutine running")
	}()
	// 主程式立即退出，goroutine 永不完成
}

// 陷阱 2：沒有同步的共享可變狀態
func pitfall2() {
	var counter int
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			counter++ // 競態條件！
		}()
	}

	wg.Wait()
	fmt.Println("Counter:", counter) // 不可預測！
}

// 陷阱 3：Goroutine 泄漏
func pitfall3() {
	for i := 0; i < 100000; i++ {
		go func() {
			time.Sleep(time.Hour) // Goroutine 永不退出
		}()
	}
	// Goroutine 堆積，記憶體泄漏！
}

func main() {
	fmt.Println("Demonstrating pitfall 2:")
	pitfall2()
}
```
</UniversalEditor>

### 最佳實踐

<UniversalEditor title="Goroutine 最佳實踐">
```java !! java
// Java：執行緒最佳實踐
import java.util.concurrent.*;

public class BestPractices {

    // 好：使用執行緒池
    public static void good1() {
        ExecutorService executor = Executors.newFixedThreadPool(10);

        for (int i = 0; i < 100; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId);
            });
        }

        executor.shutdown();
        try {
            executor.awaitTermination(1, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    // 好：正確的同步
    static class SafeCounter {
        private int count = 0;

        public synchronized void increment() {
            count++;
        }

        public synchronized int get() {
            return count;
        }
    }

    // 好：處理異常
    public static void good3() {
        Thread thread = new Thread(() -> {
            try {
                // 可能拋出的工作
            } catch (Exception e) {
                e.printStackTrace(); // 處理異常
            }
        });
        thread.setUncaughtExceptionHandler((t, e) -> {
            System.err.println("Exception in thread " + t.getName());
        });
        thread.start();
    }
}
```

```go !! go
// Go：Goroutine 最佳實踐
package main

import (
	"fmt"
	"sync"
	"time"
)

// 好：總是管理 goroutine 生命週期
func good1() {
	var wg sync.WaitGroup

	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			fmt.Printf("Worker %d\n", id)
		}(i)
	}

	wg.Wait()
}

// 好：正確的同步
type SafeCounter struct {
	mu    sync.Mutex
	count int
}

func (c *SafeCounter) Increment() {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.count++
}

func (c *SafeCounter) Get() int {
	c.mu.Lock()
	defer c.mu.Unlock()
	return c.count
}

// 好：在 goroutine 中處理 panic
func good3() {
	go func() {
		defer func() {
			if r := recover(); r != nil {
				fmt.Printf("Recovered: %v\n", r)
			}
		}()

		// 可能 panic 的工作
		panic("Oops!")
	}()

	time.Sleep(time.Second)
}

func main() {
	fmt.Println("Example 1: Proper lifecycle management")
	good1()

	fmt.Println("\nExample 2: Safe counter")
	counter := &SafeCounter{}
	var wg sync.WaitGroup

	for i := 0; i < 100; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			counter.Increment()
		}()
	}

	wg.Wait()
	fmt.Printf("Counter: %d\n", counter.Get())
}
```
</UniversalEditor>

## 效能基準測試

<UniversalEditor title="基準測試：執行緒 vs Goroutine 建立">
```java !! java
// Java：基準測試執行緒建立
public class ThreadBenchmark {
    public static void main(String[] args) throws Exception {
        int iterations = 10000;

        long start = System.currentTimeMillis();

        for (int i = 0; i < iterations; i++) {
            Thread t = new Thread(() -> {});
            t.start();
            t.join();
        }

        long end = System.currentTimeMillis();
        System.out.println("Created and joined " + iterations +
            " threads in " + (end - start) + "ms");
    }
}
```

```go !! go
// Go：基準測試 goroutine 建立
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	iterations := 10000

	start := time.Now()

	var wg sync.WaitGroup
	for i := 0; i < iterations; i++ {
		wg.Add(1)
		go func() {
			wg.Done()
		}()
	}

	wg.Wait()

	elapsed := time.Since(start)
	fmt.Printf("Created and waited for %d goroutines in %dms\n",
		iterations, elapsed.Milliseconds())
}
```
</UniversalEditor>

## 練習題

1. **記憶體效率**：為什麼 Go 可以建立數百萬個 goroutine，而 Java 只能建立數千個執行緒？

2. **同步**：`sync.WaitGroup` 與 `CountDownLatch` 相比如何？你會何時使用它們？

3. **調度**：解釋 Go 中的 M:N 調度器以及它與 Java 的 1:1 執行緒模型的區別。

4. **最佳實踐**：使用 goroutine 時的常見陷阱是什麼，如何避免它們？

5. **效能**：在什麼場景下 goroutine 會顯著優於 Java 執行緒？

## 專案想法

1. **並行網頁爬蟲**：建構一個使用 goroutine 並行獲取多個 URL 的網頁爬蟲

2. **平行資料處理**：建立一個程式，平行分塊處理大型 CSV 檔案

3. **Worker Pool 系統**：實作一個健壯的 worker pool，包含作業佇列、結果收集和錯誤處理

4. **即時資料 Pipeline**：建構一個使用 pipeline 模式攝取、轉換和輸出資料的 pipeline

5. **並行快取**：實作一個帶有過期和並行存取的執行緒安全記憶體快取

## 下一步

現在你已經理解了 goroutine 和並行：

- **下一模組**：學習 **Channel 和 Select** 用於 goroutine 之間的通訊
- **深入**：研究 Go 的記憶體模型和同步模式
- **練習**：建構並行應用以熟悉 goroutine
- **比較**：分析 goroutine 如何與其他並行模型（async/await、actors）比較

## 總結

**Goroutine vs Java 執行緒：**
- Goroutine 是輕量級的（~2KB）vs 執行緒（~1MB）
- Go 使用 M:N 調度以提高效率
- `sync.WaitGroup` 簡化同步
- Goroutine 支援大規模並行
- Channel（下一模組）提供安全通訊

**關鍵要點**：Go 的 goroutine 使並行程式設計比 Java 的執行緒模型更加高效和易於理解。你可以用最小的開銷建立數百萬個 goroutine，實作使用 Java 執行緒無法實現的並行程式設計新模式。
