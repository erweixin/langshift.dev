---
title: "模块 08：Web 开发 - 构建 HTTP 服务器"
description: "使用 net/http 掌握 Go Web 开发。与 Java/Spring Boot 比较，学习路由、JSON 处理、中间件和流行的 Go 框架。"
---

# 模块 08：Web 开发 - 构建 HTTP 服务器

在本模块中，你将学习如何使用 **net/http** 包构建 Go Web 应用程序。你将看到 Go 的 Web 开发方法与 Java 的 Spring Boot 有何不同，通常需要更少的样板代码和依赖。

## 学习目标

完成本模块后，你将能够：
- 使用 net/http 创建 HTTP 服务器
- 实现路由和处理程序
- 处理 JSON 请求和响应
- 创建中间件
- 将 Go 的方法与 Spring Boot 进行比较
- 使用流行的 Go Web 框架（Gin、Echo）
- 构建 RESTful API
- 实现 WebSocket 支持
- 使用模板渲染

## 背景：Go vs Spring Boot

### 哲学差异

**Java/Spring Boot:**
- 具有许多抽象的重量级框架
- 注解驱动的配置
- 依赖注入容器
- 自动配置和魔法
- 大内存占用
- 较长的启动时间

**Go/net/http:**
- 最小标准库方法
- 显式代码优于配置
- 没有内置依赖注入
- 简单且可预测
- 小内存占用
- 快速启动和执行

<UniversalEditor title="Hello Web 服务器：Java vs Go">
```java !! java
// Java: Spring Boot REST 控制器
import org.springframework.boot.*;
import org.springframework.web.bind.annotation.*;

@RestController
@SpringBootApplication
public class HelloApplication {
    @GetMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }

    public static void main(String[] args) {
        SpringApplication.run(HelloApplication.class, args);
    }
}
```

```go !! go
// Go: 标准库 HTTP 服务器
package main

import (
	"fmt"
	"net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "Hello, World!")
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /hello", helloHandler)

	fmt.Println("Server starting on :8080")
	http.ListenAndServe(":8080", mux)
}
```
</UniversalEditor>

## 基本 HTTP 服务器

<UniversalEditor title="基本 HTTP 服务器">
```java !! java
// Java: 基本 Spring Boot 应用
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class BasicController {
    @GetMapping("/ping")
    public String ping() {
        return "pong";
    }

    @GetMapping("/health")
    public Map<String, String> health() {
        Map<String, String> status = new HashMap<>();
        status.put("status", "UP");
        return status;
    }
}
```

```go !! go
// Go: 基本 HTTP 服务器
package main

import (
	"encoding/json"
	"net/http"
)

func pingHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprint(w, "pong")
}

func healthHandler(w http.ResponseWriter, r *http.Request) {
	response := map[string]string{"status": "UP"}
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /api/ping", pingHandler)
	mux.HandleFunc("GET /api/health", healthHandler)

	http.ListenAndServe(":8080", mux)
}
```
</UniversalEditor>

## 路由和处理程序

<UniversalEditor title="路由模式">
```java !! java
// Java: Spring Boot 路由
@RestController
@RequestMapping("/users")
public class UserController {
    @GetMapping
    public List<User> getUsers() {
        return userService.getUsers();
    }

    @GetMapping("/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.getById(id);
    }

    @PostMapping
    public User createUser(@RequestBody User user) {
        return userService.save(user);
    }
}
```

```go !! go
// Go: HTTP 路由
package main

import (
	"encoding/json"
	"net/http"
)

type User struct {
	ID    int    `json:"id"`
	Name  string `json:"name"`
	Email string `json:"email"`
}

func getUsersHandler(w http.ResponseWriter, r *http.Request) {
	users := []User{
		{ID: 1, Name: "Alice", Email: "alice@example.com"},
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(users)
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /users", getUsersHandler)
	http.ListenAndServe(":8080", mux)
}
```
</UniversalEditor>

## JSON 处理

<UniversalEditor title="JSON 处理">
```java !! java
// Java: JSON with Spring Boot
@PostMapping("/users")
public ResponseEntity<User> createUser(@RequestBody CreateUserRequest request) {
    User user = new User();
    user.setName(request.getName());
    user.setEmail(request.getEmail());

    return ResponseEntity.status(HttpStatus.CREATED).body(user);
}
```

```go !! go
// Go: JSON 处理
func createUserHandler(w http.ResponseWriter, r *http.Request) {
	var req CreateUserRequest

	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	user := User{ID: 1, Name: req.Name, Email: req.Email}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(user)
}
```
</UniversalEditor>

## 中间件

<UniversalEditor title="中间件实现">
```go !! go
// Go: 中间件函数
package main

import (
	"log"
	"net/http"
	"time"
)

// 日志中间件
func loggingMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()
		log.Printf("%s %s", r.Method, r.URL.Path)

		next.ServeHTTP(w, r)

		duration := time.Since(start)
		w.Header().Set("X-Response-Time", duration.String())
	})
}

// CORS 中间件
func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Access-Control-Allow-Origin", "*")
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE")

		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("GET /public", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "Public endpoint")
	})

	handler := loggingMiddleware(corsMiddleware(mux))
	http.ListenAndServe(":8080", handler)
}
```
</UniversalEditor>

## Go Web 框架

### 使用 Gin 框架

<UniversalEditor title="Spring Boot vs Gin">
```go !! go
// Go: Gin 框架
package main

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

type Product struct {
	ID    int     `json:"id"`
	Name  string  `json:"name"`
	Price float64 `json:"price"`
}

func getAllProducts(c *gin.Context) {
	products := []Product{
		{ID: 1, Name: "Laptop", Price: 999.99},
	}
	c.JSON(http.StatusOK, products)
}

func main() {
	r := gin.Default()

	api := r.Group("/api/products")
	{
		api.GET("", getAllProducts)
		api.POST "", createProduct)
	}

	r.Run(":8080")
}
```
</UniversalEditor>

## 练习题

1. **简洁性**：是什么让 Go 的 Web 开发方法比 Spring Boot 更简单？

2. **依赖**：为什么你可能选择 Go 的标准库而不是像 Gin 这样的框架？

3. **性能**：Go 的并发模型如何使 Web 应用受益？

## 项目想法

1. **RESTful Blog API**：构建完整的博客 API
2. **任务管理系统**：创建任务管理器
3. **实时聊天**：实现 WebSocket 聊天服务器

## 下一步

现在你已经理解了 Go 的 Web 开发：

- **下一模块**：学习 Go 中的 **测试**
- **练习**：使用 net/http 和框架构建 RESTful API

## 总结

**Go vs Spring Boot 用于 Web 开发：**
- Go 需要更少的样板代码和配置
- 标准库 (net/http) 是生产就绪的
- 更简单的部署（单个二进制文件）
- 更好的性能和更低的内存使用
- 并发内置于语言中

**关键要点**：Go 的 Web 开发方法优先考虑简单性和性能，而不是框架魔法。
