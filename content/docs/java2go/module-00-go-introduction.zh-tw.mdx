---
title: "模組 00：面向 Java 開發者的 Go 語言介紹"
---

## 為什麼選擇 Go？Java 開發者的視角

作為一名 Java 開發者，你可能熟悉 JVM 生態系統、Spring 框架、物件導向程式設計以及管理複雜的類別層次結構。Go（Golang）提供了一個令人耳目一新的替代方案，它強調簡潔性、效能和現代開發實踐。

### Go 與 Java 的高層對比

| 方面 | Java | Go |
|------|------|-----|
| **程式設計範式** | 物件導向（類別、繼承） | 多範式（無類別，使用結構和介面） |
| **執行方式** | JVM（編譯為位元組碼） | 原生二進位編譯 |
| **啟動時間** | 慢（JVM 預熱） | 即時（原生二進位） |
| **記憶體佔用** | 高（JVM 開銷） | 低（單一二進位） |
| **並發模型** | 執行緒（重量級） | Goroutines（輕量級） |
| **類型系統** | 泛型（Java 5 起） | 類型推斷，早期無泛型 |
| **錯誤處理** | 例外（try-catch） | 顯式錯誤返回 |
| **依賴管理** | Maven, Gradle | Go Modules |
| **學習曲線** | 陡峭（複雜生態系統） | 平緩（極簡語言） |
| **編譯速度** | 慢 | 極快 |
| **典型應用** | 企業應用、Android、大數據 | 微服務、雲原生、CLI 工具 |

## Go 語言歷史和設計哲學

Go 於 2007 年在 Google 由 Robert Griesemer、Rob Pike 和 Ken Thompson（Unix 之父）創建。它的設計旨在解決 C++、Java 和 Python 在大規模軟體開發中遇到的挫折。

### 核心設計原則

1. **簡潔優於複雜**
   - 僅 25 個關鍵字（Java 有 50+ 個）
   - 無類別、無繼承、無建構函式
   - 最小化語法，幾天即可學會

2. **並發是一等公民**
   - 內建 goroutines（輕量級執行緒）
   - 通道通訊
   - 無回調地獄或複雜的異步模式

3. **快速編譯**
   - 秒級編譯，而非分鐘級
   - 支援快速開發迭代
   - 開發期間無需單獨建構步驟

4. **效能與安全兼顧**
   - 靜態類型配合類型推斷
   - 記憶體安全（垃圾回收）
   - 接近 C 的效能

5. **實用優於教條**
   - "不要透過共享記憶體來通訊；透過通訊來共享記憶體"
   - 顯式優於隱式
   - 少即是多（指數級）

## 何時選擇 Go 而非 Java

### Go 的完美使用場景：

✅ **微服務和 API**
- 輕量級服務
- 快速啟動和擴展
- 簡單部署（單一二進位）

✅ **雲原生應用**
- Kubernetes（Go 編寫）
- Docker（Go 編寫）
- 基礎設施工具

✅ **高效能網路服務**
- 代理伺服器
- 負載均衡器
- 即時資料處理

✅ **DevOps 和工具**
- CLI 應用
- 自動化腳本
- 開發工具

✅ **系統程式設計**
- 檔案系統
- 資料庫引擎
- 網路協定

### Java 可能更合適的場景：

✅ **大型企業應用**
- 複雜業務邏輯
- 成熟生態系統（Spring、Hibernate）
- 企業級支援和工具

✅ **Android 開發**
- 原生 Android 應用
- Kotlin 互操作性

✅ **大數據處理**
- Hadoop、Spark 生態系統
- 成熟的資料處理框架

## 真實成功案例

許多公司已成功從 Java 遷移到 Go：

**Google**
- 為內部使用開發了 Go
- 將許多服務從 Java/C++ 遷移到 Go
- 更好的效能和更簡單的程式碼

**Uber**
- 將許多微服務從 Java 遷移到 Go
- 記憶體佔用減少 10 倍
- 啟動時間從秒級改善到毫秒級

**Twitch**
- 用 Go 替換 Java 服務
- 處理數百萬並發連線
- 更簡單的部署和管理

**Dropbox**
- 從 Python/Java 遷移到 Go
- 效能顯著提升
- 降低基礎設施成本

**字節跳動（TikTok）**
- 大量採用 Go
- 構建了自己的 Go 框架（CloudWeGo）
- 處理數十億用戶

## Java 到 Go 的學習之旅

### 你會感到熟悉的部分：
✅ 靜態類型
✅ 垃圾回收
✅ 類似的控制流結構（if、for、switch）
✅ 套件匯入
✅ 基於介面的多型
✅ 編譯型語言

### 不同的部分：
❌ 無類別（使用結構體）
❌ 無繼承（使用組合）
❌ 無建構函式（使用工廠函式）
❌ 無例外（使用錯誤返回）
❌ 舊版本無泛型（Go 1.18+ 支援泛型）
❌ 無 while 迴圈（只有 for）
❌ 無隱式類型轉換

### 你將獲得：
✅ 更簡單的語法（寫更少的程式碼）
✅ 更快的編譯
✅ 更好的並發模型
✅ 更簡單的部署（單一二進位）
✅ 更小的記憶體佔用
✅ 更快的啟動時間

## 開發環境搭建

### 安裝 Go

**macOS（Homebrew）：**
```bash
brew install go
```

**Ubuntu/Debian：**
```bash
sudo apt update
sudo apt install golang-go
```

**Windows：**
從 [golang.org/dl/](https://golang.org/dl/) 下載

### 驗證安裝

```bash
go version
# 輸出：go version go1.21.x darwin/amd64（或類似）
```

### 設置工作空間

```bash
# 建立專案目錄
mkdir ~/go-projects
cd ~/go-projects

# 初始化新模組
go mod init github.com/yourusername/yourproject

# 這會建立一個 go.mod 檔案
```

### 推薦工具

**VS Code 擴充功能：**
- Go（Google 官方擴充功能）
- Code runner
- Error lens

**替代 IDE：**
- GoLand（JetBrains，付費）
- Vim/Neovim 配合 vim-go
- IntelliJ IDEA 的 Go 外掛程式

## 你的第一個 Go 程式

讓我們對比 Java 和 Go 中的簡單 "Hello, World!" 程式：

<UniversalEditor title="Hello World: Java vs Go">
```java !! java
// Java: Hello World
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World from Java!");
    }
}

// 編譯：javac HelloWorld.java
// 執行：java HelloWorld
```

```go !! go
// Go: Hello World
package main

import "fmt"

func main() {
    fmt.Println("Hello, World from Go!")
}

// 執行：go run main.go
// 或建構：go build main.go && ./main
```
</UniversalEditor>

### 關鍵觀察：

1. **無需類別**：Go 不需要類別包裝器
2. **更簡單的入口**：只需 `func main()`，而不是 `public static void main`
3. **分號可選**：Go 會推斷（但你可以使用）
4. **套件宣告**：每個檔案以 `package` 宣告開始
5. **單檔案**：無需將檔案名與類別名匹配

## 理解 Go 的建構過程

### Java 建構過程：
```
原始碼 (.java) → 編譯器 → 位元組碼 (.class) → JVM → 機器碼
              ↓
        編譯慢，但位元組碼可移植
```

### Go 建構過程：
```
原始碼 (.go) → 編譯器 → 機器碼（二進位）
            ↓
      編譯快，平台特定二進位
```

### 執行 Go 程式碼

**開發（快速迭代）：**
```bash
go run main.go
```

**生產（建立可執行檔）：**
```bash
go build -o myapp main.go
./myapp  # Windows 上是 myapp.exe
```

**為不同平台建構：**
```bash
# 為 Linux 建構
GOOS=linux go build -o myapp-linux main.go

# 為 Windows 建構
GOOS=windows go build -o myapp.exe main.go

# 為 macOS ARM（Apple Silicon）建構
GOOS=darwin GOARCH=arm64 go build -o myapp-mac-arm main.go
```

## Go 模組系統

Go 1.11+ 引入了 Go Modules 進行依賴管理：

```bash
# 初始化新模組
go mod init github.com/user/project

# 新增依賴（go build/go test 時自動）
go get github.com/gin-gonic/gin

# 整理依賴
go mod tidy

# 下載依賴
go mod download

# 驗證依賴
go mod verify
```

**go.mod 檔案範例：**
```go
module github.com/user/project

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/go-redis/redis/v8 v8.11.5
)
```

## 常用 Go 指令

```bash
# 執行程式碼
go run main.go

# 建構可執行檔
go build

# 執行測試
go test ./...

# 格式化程式碼
go fmt ./...

# 程式碼檢查
go vet ./...

# 下載依賴
go mod download

# 更新依賴
go get -u ./...

# 查看套件文件
go doc fmt.Println

# 安裝工具
go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
```

## 下一步：你將學到什麼

在本課程中，你將學習：

**模組 1-2：語言基礎**
- 從 Java 角角看 Go 語法
- 變數、類型和控制流
- 函式和錯誤處理

**模組 3-4：物件導向的 Go**
- Go 如何在沒有類別的情況下做 OOP
- 介面 vs 抽象類別
- 組合優於繼承

**模組 5-6：並發**
- Goroutines vs Java 執行緒
- 通道 vs 共享記憶體
- Select 陳述式和逾時

**模組 7-9：實戰開發**
- 沒有 Spring 的 Web 開發
- 微服務架構
- 測試和最佳實踐

**模組 10-14：進階主題**
- 效能優化
- 生產部署
- 常見陷阱
- 地道的 Go 模式

## Java 開發者的轉型策略

### 第一階段：忘掉 Java 模式（第 1-2 週）
- 忘掉類別和繼承
- 擁抱組合
- 習慣顯式錯誤處理

### 第二階段：學習 Go 基礎（第 3-4 週）
- 掌握基本語法
- 理解 Go 的類型系統
- 學習套件結構

### 第三階段：掌握 Go 並發（第 5-6 週）
- Goroutines 和通道
- 並發模式
- 效能考慮

### 第四階段：生產級 Go（第 7-8 週）
- 測試框架
- 錯誤處理模式
- 部署策略

---

### 練習題：
1. Java 的 JVM 執行和 Go 的原生編譯之間有哪些主要區別？
2. 為什麼公司可能在微服務中選擇 Go 而非 Java？給出三個理由。
3. 切換到 Go 時，你需要"忘掉"哪些 Java 概念？
4. 描述從零開始設置 Go 開發環境的過程。

### 專案想法：
- 在 Go 中建立一個簡單的 HTTP 伺服器回應 "Hello, World!"，並與 Java Spring Boot 版本比較。測量啟動時間、記憶體使用和二進位大小。

### 下一步：
- 深入了解 Go 語法，看看它與 Java 有何不同
- 學習 Go 的物件導向程式設計方法
- 探索 Go 強大的並發模型
