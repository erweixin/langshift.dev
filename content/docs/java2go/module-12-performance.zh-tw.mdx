---
title: "模組 12：Go 效能優化"
---

本模組介紹 Go 中的效能優化技術，並與 Java 的效能調優方法進行比較。

## 效能哲學：Go vs Java

**Java 效能哲學：**
- JVM 優化（JIT 編譯、GC 調優）
- 使用 VisualVM、JProfiler 進行效能分析
- 垃圾回收調優
- 記憶體池管理
- 執行緒池配置

**Go 效能哲學：**
- 簡單、可預測的效能
- 內建效能分析工具（pprof）
- 高效的記憶體分配模式
- 最小的執行時開銷
- 直接編譯為機器碼

<UniversalEditor title="效能哲學比較">
```java !! java
// Java: 效能考慮
public class Performance {
    // 需要預熱才能達到最佳效能
    // JIT 編譯在執行時進行
    // 可能發生垃圾回收暫停

    private List<Integer> numbers = new ArrayList<>();

    public void addNumber(int num) {
        numbers.add(num); // 可能觸發 GC 和陣列擴容
    }

    // 物件分配開銷
    public String processData(String input) {
        StringBuilder sb = new StringBuilder();
        // 字串操作建立中間物件
        return sb.toString();
    }
}
```

```go !! go
// Go: 可預測的效能
package main

// 無需預熱
// 直接編譯
// 簡單的 GC，暫停時間短

type Performance struct {
    numbers []int
}

func (p *Performance) AddNumber(num int) {
    p.numbers = append(p.numbers, num) // 高效增長
}

// 最小分配開銷
func (p *Performance) ProcessData(input string) string {
    var builder strings.Builder
    // 高效的字串構建
    return builder.String()
}
```
</UniversalEditor>

## 內建效能分析工具

Go 提供了優秀的內建效能分析工具，比 Java 的部分析器更容易使用。

### CPU 效能分析

<UniversalEditor title="CPU 效能分析比較">
```java !! java
// Java: 使用 VisualVM/JProfiler 進行 CPU 效能分析
/*
1. 使用效能分析代理啟動應用程式：
   java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 MyApp

2. 使用 VisualVM 或 JProfiler 連線

3. 獲取 CPU 快照

4. 分析熱點

範例：使用 Java Flight Recorder
*/
import jdk.jfr.Category;
import jdk.jfr.Event;
import jdk.jfr.Label;

@Label("Processing Event")
@Category("Processing")
public class ProcessingEvent extends Event {
    @Label "Items Processed"
    public int items;
}

public class ProfilerDemo {
    public void processItems(int count) {
        ProcessingEvent event = new ProcessingEvent();
        event.begin();
        event.items = count;

        // 處理邏輯
        for (int i = 0; i < count; i++) {
            // 執行工作
        }

        event.end();
        event.commit();
    }
}
```

```go !! go
// Go: 內建 CPU 效能分析
package main

import (
    "fmt"
    "os"
    "runtime/pprof"
    "time"
)

func main() {
    // 開始 CPU 效能分析
    f, _ := os.Create("cpu.prof")
    pprof.StartCPUProfile(f)
    defer pprof.StopCPUProfile()

    // 執行要分析的程式碼
    processItems(1000000)

    f.Close()
    fmt.Println("效能分析已儲存到 cpu.prof")
    // 使用以下指令分析: go tool pprof cpu.prof
}

func processItems(count int) {
    for i := 0; i < count; i++ {
        // 執行工作
        calculate(i)
    }
}

func calculate(n int) int {
    result := 0
    for i := 0; i < n; i++ {
        result += i
    }
    return result
}
```
</UniversalEditor>

### 記憶體效能分析

<UniversalEditor title="記憶體效能分析比較">
```java !! java
// Java: 堆分析
import java.util.ArrayList;
import java.util.List;

public class MemoryProfiler {
    private List<byte[]> allocations = new ArrayList<>();

    public void allocateMemory() {
        // Runtime.getRuntime().gc() 強制 GC
        // MemoryMXBean 取得堆使用情況

        for (int i = 0; i < 1000; i++) {
            allocations.add(new byte[1024]); // 每 1KB
        }

        // 分析堆轉儲
        Runtime runtime = Runtime.getRuntime();
        long usedMemory = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("已用記憶體: " + usedMemory + " 位元組");
    }

    // 使用 VisualVM 分析堆轉儲
    // jmap -dump:format=b,file=heap.hprof <pid>
}
```

```go !! go
// Go: 記憶體效能分析
package main

import (
    "fmt"
    "os"
    "runtime/pprof"
)

func main() {
    // 記憶體效能分析
    f, _ := os.Create("mem.prof")
    defer f.Close()

    // 取得記憶體快照
    pprof.WriteHeapProfile(f)
    fmt.Println("記憶體效能分析已儲存到 mem.prof")
    // 使用以下指令分析: go tool pprof mem.prof
}

func allocateMemory() {
    allocations := make([][]byte, 0)

    for i := 0; i < 1000; i++ {
        allocations = append(allocations, make([]byte, 1024))
    }

    // 取得記憶體統計
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("已分配記憶體: %d 位元組\n", m.Alloc)
    fmt.Printf("總分配次數: %d\n", m.TotalAlloc)
    fmt.Printf("堆物件數: %d\n", m.HeapObjects)
}
```
</UniversalEditor>

## 記憶體分配模式

### 避免不必要的分配

<UniversalEditor title="記憶體效率比較">
```java !! java
// Java: 常見分配模式
public class Allocations {
    // 迴圈中的字串拼接 - 不好
    public String buildStringBad(String[] items) {
        String result = "";
        for (String item : items) {
            result += item; // 每次迭代建立新字串
        }
        return result;
    }

    // 使用 StringBuilder - 好
    public String buildStringGood(String[] items) {
        StringBuilder sb = new StringBuilder();
        for (String item : items) {
            sb.append(item); // 高效
        }
        return sb.toString();
    }

    // 物件池範例
    private static final ObjectPool<Buffer> bufferPool =
        new ObjectPool<>(() -> new Buffer());

    public Buffer getBuffer() {
        return bufferPool.borrow();
    }

    public void returnBuffer(Buffer buffer) {
        bufferPool.release(buffer);
    }
}
```

```go !! go
// Go: 高效分配模式
package main

import (
    "strings"
)

// 不好：迴圈中的字串拼接
func buildStringBad(items []string) string {
    result := ""
    for _, item := range items {
        result += item // 每次迭代建立新字串
    }
    return result
}

// 好：使用 strings.Builder
func buildStringGood(items []string) string {
    var builder strings.Builder
    builder.Grow(len(items) * 10) // 預分配容量

    for _, item := range items {
        builder.WriteString(item) // 高效
    }
    return builder.String()
}

// 好：使用 buffer pool
var bufferPool = sync.Pool{
    New: func() interface{} {
        return new(bytes.Buffer)
    },
}

func getBuffer() *bytes.Buffer {
    return bufferPool.Get().(*bytes.Buffer)
}

func returnBuffer(buf *bytes.Buffer) {
    buf.Reset()
    bufferPool.Put(buf)
}

// 好：預分配切片
func preAllocateSlice(count int) []int {
    // 使用容量避免重新分配
    slice := make([]int, 0, count)
    for i := 0; i < count; i++ {
        slice = append(slice, i) // 無需重新分配
    }
    return slice
}
```
</UniversalEditor>

## 基準測試

<UniversalEditor title="基準測試比較">
```java !! java
// Java: JMH 基準測試
import org.openjdk.jmh.annotations.*;
import java.util.concurrent.TimeUnit;

@BenchmarkMode(Mode.AverageTime)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@State(Scope.Benchmark)
public class Benchmarks {
    private int[] data;

    @Setup
    public void setup() {
        data = new int[1000];
        for (int i = 0; i < data.length; i++) {
            data[i] = i;
        }
    }

    @Benchmark
    public int sumWithLoop() {
        int sum = 0;
        for (int num : data) {
            sum += num;
        }
        return sum;
    }

    @Benchmark
    public int sumWithStream() {
        return java.util.Arrays.stream(data).sum();
    }
}

// 執行指令: java -jar benchmarks.jar
```

```go !! go
// Go: 內建基準測試
package main

import (
    "testing"
)

var data []int

func setup() {
    data = make([]int, 1000)
    for i := 0; i < len(data); i++ {
        data[i] = i
    }
}

func BenchmarkSumWithLoop(b *testing.B) {
    setup()
    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        sum := 0
        for _, num := range data {
            sum += num
        }
    }
}

func BenchmarkSumWithRange(b *testing.B) {
    setup()
    b.ResetTimer()

    for i := 0; i < b.N; i++ {
        sum := 0
        for i := range data {
            sum += data[i]
        }
    }
}

// 執行指令: go test -bench=. -benchmem
```
</UniversalEditor>

## Goroutine 效能

<UniversalEditor title="Goroutine vs 執行緒效能">
```java !! java
// Java: 執行緒開銷
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class ThreadPerformance {
    private static final int TASK_COUNT = 100000;

    public void runWithThreads() throws InterruptedException {
        long start = System.currentTimeMillis();

        ExecutorService executor = Executors.newFixedThreadPool(100);

        for (int i = 0; i < TASK_COUNT; i++) {
            final int taskNum = i;
            executor.submit(() -> {
                // 模擬工作
                int result = taskNum * 2;
            });
        }

        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.MINUTES);

        long duration = System.currentTimeMillis() - start;
        System.out.println("執行緒: " + duration + "ms");
        // 輸出: 執行緒: ~2000-5000ms
        // 記憶體: 10 萬執行緒約 ~500MB-1GB
    }
}
```

```go !! go
// Go: Goroutine 效率
package main

import (
    "fmt"
    "sync"
    "time"
)

const taskCount = 100000

func runWithGoroutines() {
    start := time.Now()

    var wg sync.WaitGroup

    for i := 0; i < taskCount; i++ {
        wg.Add(1)
        go func(taskNum int) {
            defer wg.Done()
            // 模擬工作
            result := taskNum * 2
            _ = result
        }(i)
    }

    wg.Wait()

    duration := time.Since(start)
    fmt.Printf("Goroutine: %v\n", duration)
    // 輸出: Goroutine: ~200-500ms
    // 記憶體: 10 萬 goroutine 約 ~50-100MB
}

func main() {
    runWithGoroutines()
}
```
</UniversalEditor>

## Channel 效能

<UniversalEditor title="Channel 優化">
```java !! java
// Java: BlockingQueue
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;

public class QueuePerformance {
    private BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(100);

    public void producer() throws InterruptedException {
        for (int i = 0; i < 1000000; i++) {
            queue.put(i); // 佇列滿時阻塞
        }
    }

    public void consumer() throws InterruptedException {
        while (true) {
            Integer value = queue.take(); // 佇列空時阻塞
            // 處理值
        }
    }
}
```

```go !! go
// Go: 緩衝 channel
package main

import "sync"

// 無緩衝 channel（同步）
func unbufferedChannel() {
    ch := make(chan int)
    go func() {
        for i := 0; i < 1000000; i++ {
            ch <- i // 阻塞直到接收者準備就緒
        }
        close(ch)
    }()

    for value := range ch {
        _ = value
    }
}

// 緩衝 channel（非同步）
func bufferedChannel() {
    ch := make(chan int, 100) // 緩衝大小 100
    go func() {
        for i := 0; i < 1000000; i++ {
            ch <- i // 緩衝滿時才阻塞
        }
        close(ch)
    }()

    for value := range ch {
        _ = value
    }
}

// 最佳實踐：根據工作負載選擇緩衝大小
func optimizedChannel() {
    // 對於生產者-消費者不同速率的場景
    ch := make(chan int, 1000) // 較大緩衝給更快生產者

    var wg sync.WaitGroup

    // 多個生產者
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for j := 0; j < 10000; j++ {
                ch <- id*10000 + j
            }
        }(i)
    }

    // 單一消費者
    go func() {
        for value := range ch {
            _ = value
        }
    }()

    wg.Wait()
    close(ch)
}
```
</UniversalEditor>

## 字串優化

<UniversalEditor title="字串效能">
```java !! java
// Java: 字串優化
public class StringOptimization {
    // 不好：迴圈中字串拼接
    public String concatenateBad(List<String> items) {
        String result = "";
        for (String item : items) {
            result += item; // 建立新物件
        }
        return result;
    }

    // 好：使用 StringBuilder
    public String concatenateGood(List<String> items) {
        StringBuilder sb = new StringBuilder(items.size() * 16);
        for (String item : items) {
            sb.append(item);
        }
        return sb.toString();
    }

    // 字串比較
    public boolean compareStrings(String a, String b) {
        return a.equals(b); // 正確方式
        // return a == b; // 錯誤！比較引用
    }

    // 字串駐留提高記憶體效率
    public void stringInterning() {
        String s1 = "hello".intern(); // 駐留
        String s2 = "hello".intern(); // 相同引用
        boolean same = (s1 == s2); // true
    }
}
```

```go !! go
// Go: 字串優化
package main

import (
    "strings"
)

// 不好：迴圈中字串拼接
func concatenateBad(items []string) string {
    result := ""
    for _, item := range items {
        result += item // 低效
    }
    return result
}

// 好：使用 strings.Builder
func concatenateGood(items []string) string {
    var builder strings.Builder
    // 預分配容量
    builder.Grow(len(items) * 16)

    for _, item := range items {
        builder.WriteString(item)
    }
    return builder.String()
}

// 字串比較（Go 中直接 == 即可！）
func compareStrings(a, b string) bool {
    return a == b // 高效且正確
}

// 字串駐留（手動）
var internPool = sync.Pool{
    New: func() interface{} {
        return make(map[string]string)
    },
}

// 字串重用模式
func stringReuse() {
    // 常見模式：使用位元組切片構建
    // 只在最後轉換為字串
    data := []byte("hello")
    str := string(data) // 一次分配
    _ = str
}

// 高效的字串連接
func joinStrings(items []string) string {
    return strings.Join(items, ",") // 高效
}
```
</UniversalEditor>

## 切片效能

<UniversalEditor title="切片 vs 陣列效能">
```java !! java
// Java: ArrayList vs Array
public class CollectionPerformance {
    // ArrayList（動態）
    public void arrayListTest() {
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < 100000; i++) {
            list.add(i); // 可能需要擴容
        }
    }

    // Array（固定大小，更快）
    public void arrayTest() {
        int[] array = new int[100000];
        for (int i = 0; i < 100000; i++) {
            array[i] = i; // 直接存取
        }
    }

    // 預設大小的 ArrayList
    public void preSizedList() {
        List<Integer> list = new ArrayList<>(100000);
        for (int i = 0; i < 100000; i++) {
            list.add(i); // 無需擴容
        }
    }
}
```

```go !! go
// Go: 切片 vs 陣列
package main

// 切片（動態）
func sliceTest() {
    slice := make([]int, 0)
    for i := 0; i < 100000; i++ {
        slice = append(slice, i) // 可能增長並複製
    }
}

// 預分配切片（更快）
func preAllocatedSlice() {
    slice := make([]int, 0, 100000) // 容量預分配
    for i := 0; i < 100000; i++ {
        slice = append(slice, i) // 無需複製
    }
}

// 陣列（固定大小，最快）
func arrayTest() {
    var array [100000]int
    for i := 0; i < 100000; i++ {
        array[i] = i // 直接存取，無邊界檢查開銷
    }
}

// 切片效能技巧
func sliceTricks() {
    // 重用切片底層陣列
    buffer := make([]int, 100)

    // 多次使用相同緩衝區
    work1 := buffer[:50]  // 前 50 個元素
    work2 := buffer[50:]  // 剩餘 50 個元素

    _ = work1
    _ = work2
}

// 高效清空切片
func clearSlice(slice []int) {
    // 好：重用底層陣列
    for i := range slice {
        slice[i] = 0
    }

    // 替代方案：建立新切片（可能分配）
    // slice = make([]int, len(slice))
}
```
</UniversalEditor>

## 效能最佳實踐

### 1. 盡可能預分配

```go
// 不好：重複分配
func badGrowth() {
    data := []int{}
    for i := 0; i < 1000000; i++ {
        data = append(data, i) // 多次重新分配
    }
}

// 好：預分配容量
func goodGrowth() {
    data := make([]int, 0, 1000000)
    for i := 0; i < 1000000; i++ {
        data = append(data, i) // 無重新分配
    }
}
```

### 2. 適當使用值型別

```go
// 小結構體優先使用值型別
type Point struct {
    X, Y int
}

// 按值傳遞（小結構體高效）
func distance(p1, p2 Point) int {
    dx := p1.X - p2.X
    dy := p1.Y - p2.Y
    return dx*dx + dy*dy
}

// 大結構體使用指標
type LargeStruct struct {
    data [1024]int
}

func process(l *LargeStruct) {
    // 使用指標避免複製
}
```

### 3. 避免過早優化

```go
// 先編寫清晰的程式碼
func processData(items []string) string {
    var result strings.Builder
    for _, item := range items {
        result.WriteString(item)
        result.WriteString(",")
    }
    return result.String()
}

// 先進行效能分析，只優化熱點
// 使用: go test -bench=. -cpuprofile=cpu.prof
```

## 常見效能陷阱

### 1. 子字串分配

<UniversalEditor title="字串切片">
```java !! java
// Java: substring() 複製資料（Java 7u6 之前）
public class Substrings {
    public void processString(String text) {
        // 建立新字串物件
        String sub = text.substring(0, 10);
        System.out.println(sub);
    }
}
```

```go !! go
// Go: 字串切片不複製
package main

func processString(text string) {
    // 無分配！只是切片字串
    sub := text[:10]
    println(sub)
}

// 但要注意：保持原字串在記憶體中
func memoryLeakExample() {
    // 讀取 1GB 檔案
    data := readFile("largefile.txt") // 1GB

    // 提取小部分
    firstLine := getFirstLine(data) // 前 100 個字元

    // firstLine 仍然引用整個 1GB 資料！
    useString(firstLine)

    // 修復：轉換為 []byte 再轉回
}

func getFirstLine(data string) string {
    // 這會保持整個 data 在記憶體中
    return data[:100]

    // 更好：複製到新字串
    // return strings.Clone(data[:100])
}
```
</UniversalEditor>

### 2. Range 迴圈變數捕獲

```go
// 錯誤：所有 goroutine 捕獲同一變數
func wrongRange() {
    items := []int{1, 2, 3, 4, 5}
    for _, item := range items {
        go func() {
            println(item) // 總是打印 5
        }()
    }
}

// 正確：將變數作為參數傳遞
func correctRange() {
    items := []int{1, 2, 3, 4, 5}
    for _, item := range items {
        go func(val int) {
            println(val) // 打印正確的值
        }(item)
    }
}
```

---

### 練習問題：
1. 什麼時候應該預分配切片容量而不是使用 append？
2. Go 的垃圾回收與 Java 有什麼不同？
3. 緩衝 channel 和無緩衝 channel 有什麼權衡？
4. 為什麼 Go 中的字串切片比 Java 的 substring() 更高效？

### 專案想法：
- 建立一個效能比較工具，對等價的 Java 和 Go 程式碼進行基準測試
- 建構一個 Web 服務，展示 goroutine 相比 Java 執行緒的效率
- 實作一個 Go 應用程式的記憶體效能分析儀表板

### 下一步：
- 學習 Go 應用程式的部署策略
- 了解生產環境監控和可觀察性
- 探索真實專案架構
