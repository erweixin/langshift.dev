---
title: "Module 01: Syntax Comparison - Java to Go"
---

This module explores the fundamental syntax differences between Java and Go, helping you transition your Java knowledge to Go effectively.

## Variable Declarations

### The Philosophy Difference

**Java:** Explicit types, verbose declaration
```java
String name = "Alice";
int age = 25;
double salary = 50000.50;
boolean isActive = true;
```

**Go:** Type inference, concise syntax
```go
name := "Alice"           // string inferred
age := 25                 // int inferred
salary := 50000.50        // float64 inferred
isActive := true          // bool inferred
```

### Declaration Methods Comparison

| Java | Go | Description |
|------|-----|-------------|
| `String name = "Alice";` | `name := "Alice"` | Short declaration with type inference |
| `final String NAME = "Bob";` | `const NAME = "Bob"` | Constant declaration |
| `String name;` | `var name string` | Variable with zero value |
| `int x = 10;` | `x := 10` or `var x int = 10` | Explicit vs inferred type |

<UniversalEditor title="Variable Declaration Comparison">
```java !! java
// Java: Variable Declarations
public class Variables {
    public static void main(String[] args) {
        // Explicit type declaration
        String name = "Alice";
        int age = 30;
        double salary = 75000.50;
        boolean isActive = true;

        // Final constant
        final int MAX_COUNT = 100;

        // Declaration without initialization (null for objects)
        String uninitialized;
        uninitialized = "Now initialized";

        // Multiple declarations
        int x = 10, y = 20, z = 30;

        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
        System.out.println("Salary: " + salary);
        System.out.println("Active: " + isActive);
    }
}
```

```go !! go
// Go: Variable Declarations
package main

import "fmt"

func main() {
    // Short declaration (type inferred) - MOST COMMON
    name := "Alice"
    age := 30
    salary := 75000.50
    isActive := true

    // Constant declaration
    const MAX_COUNT = 100

    // Variable with zero value (no uninitialized variables in Go)
    var uninitialized string
    uninitialized = "Now initialized"

    // Multiple declarations
    x, y, z := 10, 20, 30

    // Explicit type declaration
    var employeeId int = 12345

    fmt.Printf("Name: %s\n", name)
    fmt.Printf("Age: %d\n", age)
    fmt.Printf("Salary: %.2f\n", salary)
    fmt.Printf("Active: %t\n", isActive)
    fmt.Printf("Employee ID: %d\n", employeeId)
}
```
</UniversalEditor>

### Zero Values in Go

Unlike Java where uninitialized objects are `null`, Go always initializes variables to their zero value:

| Go Type | Zero Value | Java Equivalent |
|---------|------------|-----------------|
| `int`, `int64`, etc. | `0` | `0` |
| `float64`, `float32` | `0.0` | `0.0` |
| `bool` | `false` | `false` |
| `string` | `""` (empty string) | `null` |
| pointer types | `nil` | `null` |
| `slice` | `nil` | `null` |

<UniversalEditor title="Zero Value Initialization">
```java !! java
// Java: Null vs Default Values
public class ZeroValues {
    static int primitiveInt;      // 0
    static double primitiveDouble; // 0.0
    static boolean primitiveBool;  // false
    static String objectString;    // null

    public static void main(String[] args) {
        System.out.println(primitiveInt);    // 0
        System.out.println(primitiveDouble); // 0.0
        System.out.println(primitiveBool);   // false
        System.out.println(objectString);    // null

        // Null check required
        if (objectString != null) {
            System.out.println(objectString.length());
        }
    }
}
```

```go !! go
// Go: Zero Values (No Null for Primitives)
package main

import "fmt"

var primitiveInt int
var primitiveDouble float64
var primitiveBool bool
var objectString string

func main() {
    fmt.Println(primitiveInt)    // 0
    fmt.Println(primitiveDouble) // 0
    fmt.Println(primitiveBool)   // false
    fmt.Println(objectString)    // "" (empty string, not nil!)

    // No null check needed for string
    fmt.Println(len(objectString)) // 0

    // Pointer example (can be nil)
    var pointer *int
    fmt.Println(pointer) // <nil>

    if pointer != nil {
        fmt.Println(*pointer)
    }
}
```
</UniversalEditor>

## Data Types Comparison

### Primitive Types

| Java | Go | Notes |
|------|-----|-------|
| `byte` | `byte` | Same (8-bit) |
| `short` | `int16` | 16-bit integer |
| `int` | `int` | Platform-dependent (32 or 64-bit) |
| `long` | `int64` | 64-bit integer |
| `float` | `float32` | 32-bit float |
| `double` | `float64` | 64-bit float |
| `char` | `rune` | Go's rune is Unicode code point |
| `boolean` | `bool` | Same concept |
| `String` | `string` | Both immutable, UTF-8 |

### Go-Specific Types

Go provides more precise integer types:

```go
// Signed integers
int8    // 8-bit (-128 to 127)
int16   // 16-bit
int32   // 32-bit
int64   // 64-bit
int     // Platform-dependent (32 or 64-bit)

// Unsigned integers
uint8   // 8-bit (0 to 255) - aka byte
uint16  // 16-bit
uint32  // 32-bit
uint64  // 64-bit
uint    // Platform-dependent
uintptr // Unsigned integer for pointer

// Floating-point
float32 // 32-bit IEEE 754
float64 // 64-bit IEEE 754

// Complex numbers (Java doesn't have these!)
complex64  // Complex with float32 real and imaginary
complex128 // Complex with float64 real and imaginary
```

<UniversalEditor title="Type System Comparison">
```java !! java
// Java: Type System
public class Types {
    public static void main(String[] args) {
        // Primitive types
        byte b = 100;
        short s = 1000;
        int i = 100000;
        long l = 1000000L;
        float f = 3.14f;
        double d = 3.14159;
        char c = 'A';
        boolean bool = true;

        // String (reference type)
        String name = "Alice";

        // Arrays (fixed size)
        int[] numbers = new int[5];
        numbers[0] = 10;

        // ArrayList (dynamic)
        java.util.List<String> list = new java.util.ArrayList<>();
        list.add("Hello");

        System.out.println("Int: " + i);
        System.out.println("Double: " + d);
        System.out.println("String: " + name);
    }
}
```

```go !! go
// Go: Type System
package main

import "fmt"

func main() {
    // Basic types
    var b byte = 100        // uint8
    var s int16 = 1000
    var i int = 100000
    var l int64 = 1000000
    var f float32 = 3.14
    var d float64 = 3.14159
    var c rune = 'A'        // rune is alias for int32
    var boolVal bool = true

    // String (built-in type, not a class)
    var name string = "Alice"

    // Arrays (fixed size)
    var numbers [5]int
    numbers[0] = 10

    // Slices (dynamic arrays) - BUILT-IN, no import needed
    var slice []int = []int{1, 2, 3}
    slice = append(slice, 4) // Add element

    // Maps (built-in)
    var person map[string]int = map[string]int{
        "age": 30,
    }

    fmt.Printf("Int: %d\n", i)
    fmt.Printf("Double: %f\n", d)
    fmt.Printf("String: %s\n", name)
    fmt.Printf("Slice: %v\n", slice)
    fmt.Printf("Map: %v\n", person)
}
```
</UniversalEditor>

## Control Flow

### If/Else Statements

Go's if/else is similar to Java but with important differences:
- No parentheses required around condition
- Opening brace must be on same line as if
- No ternary operator in Go

<UniversalEditor title="If/Else Comparison">
```java !! java
// Java: If/Else
public class Conditionals {
    public static void main(String[] args) {
        int score = 85;

        // With parentheses
        if (score >= 90) {
            System.out.println("A");
        } else if (score >= 80) {
            System.out.println("B");
        } else {
            System.out.println("C");
        }

        // Ternary operator
        String result = (score >= 60) ? "Pass" : "Fail";
        System.out.println(result);

        // Null check
        String name = null;
        if (name != null && name.length() > 0) {
            System.out.println(name);
        }
    }
}
```

```go !! go
// Go: If/Else
package main

import "fmt"

func main() {
    score := 85

    // No parentheses required
    if score >= 90 {
        fmt.Println("A")
    } else if score >= 80 {
        fmt.Println("B")
    } else {
        fmt.Println("C")
    }

    // No ternary operator in Go!
    // Use regular if/else instead
    var result string
    if score >= 60 {
        result = "Pass"
    } else {
        result = "Fail"
    }
    fmt.Println(result)

    // If with initialization statement
    if name := getName(); name != "" {
        fmt.Printf("Name: %s\n", name)
    }

    // Multiple conditions in one if
    if x := 10; x < 0 {
        fmt.Println("Negative")
    } else if x < 10 {
        fmt.Println("Single digit")
    } else {
        fmt.Println("Double digit")
    }
}

func getName() string {
    return "Alice"
}
```
</UniversalEditor>

### Switch Statements

Go's switch is more powerful than Java's:
- No break needed (no fall-through by default)
- Can switch on any type, not just integers
- Multiple values in one case
- No default required

<UniversalEditor title="Switch Statement Comparison">
```java !! java
// Java: Switch Statement
public class SwitchCase {
    public static void main(String[] args) {
        int dayOfWeek = 3;

        // Traditional switch
        switch (dayOfWeek) {
            case 1:
                System.out.println("Monday");
                break; // Required to prevent fall-through
            case 2:
                System.out.println("Tuesday");
                break;
            case 3:
                System.out.println("Wednesday");
                break;
            default:
                System.out.println("Other day");
        }

        // Java 14+ enhanced switch
        String dayType = switch (dayOfWeek) {
            case 1, 2, 3, 4, 5 -> "Weekday";
            case 6, 7 -> "Weekend";
            default -> "Invalid";
        };
        System.out.println(dayType);
    }
}
```

```go !! go
// Go: Switch Statement
package main

import "fmt"

func main() {
    dayOfWeek := 3

    // No break needed! No fall-through by default
    switch dayOfWeek {
    case 1:
        fmt.Println("Monday")
    case 2:
        fmt.Println("Tuesday")
    case 3:
        fmt.Println("Wednesday")
    default:
        fmt.Println("Other day")
    }

    // Multiple values in one case
    switch dayOfWeek {
    case 1, 2, 3, 4, 5:
        fmt.Println("Weekday")
    case 6, 7:
        fmt.Println("Weekend")
    default:
        fmt.Println("Invalid")
    }

    // Switch with condition (no expression needed)
    score := 85
    switch {
    case score >= 90:
        fmt.Println("A")
    case score >= 80:
        fmt.Println("B")
    case score >= 70:
        fmt.Println("C")
    default:
        fmt.Println("D")
    }

    // Switch on strings (and any type!)
    OS := "linux"
    switch OS {
    case "darwin":
        fmt.Println("macOS")
    case "linux":
        fmt.Println("Linux")
    case "windows":
        fmt.Println("Windows")
    }
}
```
</UniversalEditor>

## Loops

### For Loops - The Only Loop in Go

Go only has `for` loops (no `while`, no `do-while`), but it's very flexible:

<UniversalEditor title="Loop Comparison">
```java !! java
// Java: Multiple Loop Types
public class Loops {
    public static void main(String[] args) {
        // Traditional for loop
        for (int i = 0; i < 5; i++) {
            System.out.println("Count: " + i);
        }

        // Enhanced for loop (for-each)
        int[] numbers = {1, 2, 3, 4, 5};
        for (int num : numbers) {
            System.out.println(num);
        }

        // While loop
        int count = 0;
        while (count < 5) {
            System.out.println("While: " + count);
            count++;
        }

        // Do-while loop
        do {
            System.out.println("Do-while: " + count);
            count--;
        } while (count > 0);
    }
}
```

```go !! go
// Go: Only for Loop, But Very Flexible
package main

import "fmt"

func main() {
    // Traditional for loop
    for i := 0; i < 5; i++ {
        fmt.Printf("Count: %d\n", i)
    }

    // Range-based for (like enhanced for)
    numbers := []int{1, 2, 3, 4, 5}
    for i, num := range numbers {
        fmt.Printf("Index %d: %d\n", i, num)
    }

    // Range with only value
    for _, num := range numbers {
        fmt.Printf("Value: %d\n", num)
    }

    // Range with only index
    for i := range numbers {
        fmt.Printf("Index: %d\n", i)
    }

    // While-style loop (just omit all three components)
    count := 0
    for count < 5 {
        fmt.Printf("While: %d\n", count)
        count++
    }

    // Infinite loop
    sum := 0
    for {
        sum++
        if sum > 10 {
            break
        }
    }
    fmt.Printf("Sum: %d\n", sum)

    // Range over map
    person := map[string]int{
        "age":  30,
        "score": 85,
    }
    for key, value := range person {
        fmt.Printf("%s: %d\n", key, value)
    }

    // Range over string (by rune)
    for i, char := range "Hello" {
        fmt.Printf("Index %d: %c\n", i, char)
    }
}
```
</UniversalEditor>

## Functions

### Function Declaration

<UniversalEditor title="Function Declaration Comparison">
```java !! java
// Java: Function Methods
public class Functions {
    // Static method (like Go function)
    public static int add(int a, int b) {
        return a + b;
    }

    // Method with return type
    public String greet(String name) {
        return "Hello, " + name;
    }

    // Void method
    public void printMessage(String message) {
        System.out.println(message);
    }

    // Method with multiple return values? Not possible directly!
    // Need to use a class or array

    // Varargs
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    public static void main(String[] args) {
        System.out.println(add(5, 3));

        Functions f = new Functions();
        System.out.println(f.greet("Alice"));
        f.printMessage("Hello");

        System.out.println(sum(1, 2, 3, 4, 5));
    }
}
```

```go !! go
// Go: Functions with Multiple Return Values!
package main

import "fmt"

// Simple function
func add(a int, b int) int {
    return a + b
}

// Shorthand parameter types
func subtract(a, b int) int {
    return a - b
}

// Multiple return values (VERY USEFUL!)
func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, fmt.Errorf("division by zero")
    }
    return a / b, nil
}

// Named return values
func getDimensions() (width, height int) {
    width = 100
    height = 200
    return // naked return (returns width, height)
}

// Variadic function (varargs)
func sum(numbers ...int) int {
    total := 0
    for _, num := range numbers {
        total += num
    }
    return total
}

// Function as a type (first-class citizen)
var operation func(int, int) int = func(a, b int) int {
    return a * b
}

func main() {
    fmt.Println(add(5, 3))
    fmt.Println(subtract(10, 3))

    // Multiple return values
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Result:", result)
    }

    // Named return values
    w, h := getDimensions()
    fmt.Printf("Dimensions: %d x %d\n", w, h)

    // Variadic function
    fmt.Println(sum(1, 2, 3, 4, 5))

    // Function as variable
    fmt.Println(operation(5, 6))
}
```
</UniversalEditor>

### Methods in Go

Unlike Java, methods are defined outside structs:

<UniversalEditor title="Methods Comparison">
```java !! java
// Java: Methods inside Class
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Instance method
    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String introduce() {
        return "Hi, I'm " + name;
    }

    public static void main(String[] args) {
        Person p = new Person("Alice", 30);
        System.out.println(p.introduce());
    }
}
```

```go !! go
// Go: Methods defined outside Struct
package main

import "fmt"

// Struct definition
type Person struct {
    Name string
    Age  int
}

// Constructor function (idiomatic Go)
func NewPerson(name string, age int) *Person {
    return &Person{
        Name: name,
        Age:  age,
    }
}

// Method with value receiver
func (p Person) GetName() string {
    return p.Name
}

// Method with pointer receiver (can modify)
func (p *Person) SetAge(age int) {
    p.Age = age
}

// Method
func (p Person) Introduce() string {
    return fmt.Sprintf("Hi, I'm %s", p.Name)
}

func main() {
    // Constructor
    p := NewPerson("Alice", 30)
    fmt.Println(p.Introduce())

    p.SetAge(31)
    fmt.Printf("Age: %d\n", p.Age)
}
```
</UniversalEditor>

## Arrays and Slices

<UniversalEditor title="Arrays and Slices Comparison">
```java !! java
// Java: Arrays and ArrayList
import java.util.ArrayList;
import java.util.List;

public class Arrays {
    public static void main(String[] args) {
        // Array (fixed size)
        int[] fixedArray = new int[5];
        fixedArray[0] = 10;

        // Array literal
        int[] numbers = {1, 2, 3, 4, 5};
        System.out.println("Length: " + numbers.length);

        // ArrayList (dynamic)
        List<String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");
        list.add("Java");

        System.out.println("List size: " + list.size());
        System.out.println("Element: " + list.get(0));

        // Iterate
        for (String item : list) {
            System.out.println(item);
        }

        // Sublist
        List<String> subList = list.subList(0, 2);
        System.out.println("Sublist: " + subList);
    }
}
```

```go !! go
// Go: Arrays and Slices
package main

import "fmt"

func main() {
    // Array (fixed size) - rarely used directly
    var fixedArray [5]int
    fixedArray[0] = 10

    // Array literal
    numbers := [5]int{1, 2, 3, 4, 5}
    fmt.Printf("Array length: %d\n", len(numbers))

    // Slice (dynamic view of array) - MOST COMMON
    var slice []int
    slice = append(slice, 1)
    slice = append(slice, 2)
    slice = append(slice, 3)

    // Slice literal
    fruits := []string{"Apple", "Banana", "Cherry"}
    fmt.Printf("Slice length: %d\n", len(fruits))
    fmt.Printf("Element: %s\n", fruits[0])

    // Iterate with range
    for i, fruit := range fruits {
        fmt.Printf("Index %d: %s\n", i, fruit)
    }

    // Slicing (sub-slice)
    subSlice := fruits[0:2] // elements 0 and 1
    fmt.Printf("Sub-slice: %v\n", subSlice)

    // Append to slice
    fruits = append(fruits, "Date")
    fmt.Printf("After append: %v\n", fruits)

    // Copy slice
    copySlice := make([]string, len(fruits))
    copy(copySlice, fruits)
    fmt.Printf("Copy: %v\n", copySlice)

    // Pre-allocate slice with capacity
    bigSlice := make([]int, 0, 100) // length 0, capacity 100
    fmt.Printf("Length: %d, Capacity: %d\n", len(bigSlice), cap(bigSlice))
}
```
</UniversalEditor>

## Key Syntax Differences Summary

| Feature | Java | Go |
|---------|------|-----|
| **Semicolons** | Required | Optional (inferred) |
| **Parentheses in if/for** | Required | Optional |
| **Brace position** | Flexible | Must be on same line |
| **Ternary operator** | `condition ? true : false` | No ternary, use if/else |
| **While loop** | `while (condition)` | `for condition` |
| **Do-while** | `do {} while (condition)` | No direct equivalent |
| **For-each** | `for (item : collection)` | `for item := range collection` |
| **Break/Continue** | `break label` | `break label` (similar) |
| **Switch fall-through** | Default (need break) | Opt-in with `fallthrough` keyword |
| **Multiple returns** | Need class/object | Built-in `(type1, type2)` |
| **Null check** | `if (obj != null)` | `if obj != nil` |
| **String concatenation** | `+` operator | `+` or `fmt.Sprintf` |

---

### Practice Questions:
1. How does Go's type inference differ from Java's type declarations?
2. Why doesn't Go have a ternary operator? How would you achieve the same effect?
3. Explain the difference between Go's arrays and slices, and compare them to Java's arrays and ArrayList.
4. Write a Go function that returns multiple values, and show how to handle each returned value.

### Project Idea:
- Create a simple grade calculator program that:
  - Takes student scores as input
  - Calculates average and letter grade
  - Uses multiple return values for the result
  - Demonstrates if/else and switch statements

### Next Steps:
- Learn about Go's approach to object-oriented programming
- Understand Go's package system
- Explore Go's powerful concurrency model
