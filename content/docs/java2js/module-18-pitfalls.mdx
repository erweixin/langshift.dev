---
title: "Module 18: Common Pitfalls"
description: "Avoid common JavaScript mistakes and anti-patterns"
---

## Module 18: Common Pitfalls

This module covers common mistakes Java developers make when transitioning to JavaScript.

## Learning Objectives

By the end of this module, you will:
✅ Know common JavaScript pitfalls
✅ Understand type coercion issues
✅ Learn async/await mistakes
✅ Know DOM manipulation issues
✅ Understand this-related problems
✅ Master debugging strategies

## Type Coercion

<UniversalEditor title="Coercion Pitfalls">
```javascript !! js
// ❌ BAD: Using == instead of ===
if (value == "0") { }  // Matches 0, "0", false

// ✅ GOOD: Use ===
if (value === "0") { }

// ❌ BAD: Forgetting typeof null
typeof null  // "object" (historical bug)

// ✅ GOOD: Check for null properly
if (value === null) { }

// ❌ BAD: NaN comparison
if (NaN === NaN) { }  // Never true!

// ✅ GOOD: Use isNaN
if (Number.isNaN(value)) { }
```
</UniversalEditor>

## Async Pitfalls

<UniversalEditor title="Async Mistakes">
```javascript !! js
// ❌ BAD: Not awaiting promises
async function getData() {
  const result = fetch("/api/data");  // Returns promise, not data!
  console.log(result);  // Promise {<pending>}
}

// ✅ GOOD: Await the promise
async function getData() {
  const result = await fetch("/api/data");
  const data = await result.json();
  console.log(data);
}

// ❌ BAD: Forgetting try-catch
async function risky() {
  const data = await fetchData();  // Unhandled rejection!
}

// ✅ GOOD: Always handle errors
async function risky() {
  try {
    const data = await fetchData();
    return data;
  } catch (error) {
    console.error(error);
    throw error;
  }
}
```
</UniversalEditor>

## This Context

<UniversalEditor title="This Pitfalls">
```javascript !! js
// ❌ BAD: Losing this in callbacks
class Component {
  constructor() {
    this.data = null;
    
    button.addEventListener("click", this.handleClick);
  }
  
  handleClick() {
    console.log(this.data);  // undefined!
  }
}

// ✅ GOOD: Bind or use arrow
class Component {
  constructor() {
    this.data = null;
    
    // Bind
    this.handleClick = this.handleClick.bind(this);
    button.addEventListener("click", this.handleClick);
    
    // Or arrow
    button.addEventListener("click", () => this.handleClick());
  }
}
```
</UniversalEditor>

## Loop Closures

<UniversalEditor title="Loop Closure Issues">
```javascript !! js
// ❌ BAD: Closure in loop with var
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 3, 3, 3

// ✅ GOOD: Use let
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// Output: 0, 1, 2
```
</UniversalEditor>

## Array Methods

<UniversalEditor title="Array Method Pitfalls">
```javascript !! js
// ❌ BAD: forEach when need to break
numbers.forEach(num => {
  if (num === 5) break;  // Error!
});

// ✅ GOOD: Use for...of
for (const num of numbers) {
  if (num === 5) break;
}

// ❌ BAD: Forgetting return in map
const doubled = numbers.map(n => {
  n * 2;  // No return!
});

// ✅ GOOD: Always return
const doubled = numbers.map(n => n * 2);
```
</UniversalEditor>

## Best Practices Summary

<UniversalEditor title="Avoid These Mistakes">
```javascript !! js
// 1. Always use === and !==
// 2. Use let/const, never var
// 3. Handle async errors
// 4. Understand this binding
// 5. Use for...of to break loops
// 6. Return in map/filter/reduce
// 7. Check for null/undefined
// 8. Don't modify while iterating
```
</UniversalEditor>

## Summary

### Key Takeaways

1. **Equality**: Use ===, not ==
2. **Async**: Always await and catch
3. **This**: Bind or use arrows
4. **Loops**: Use let, not var
5. **Arrays**: Return in callbacks
6. **Null**: Check explicitly

## What's Next?

Next: **Module 19: Real Projects** - Build practical applications!
