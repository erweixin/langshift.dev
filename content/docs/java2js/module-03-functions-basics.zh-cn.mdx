---
title: "模块 3: 函数基础"
description: "学习 JavaScript 函数声明、表达式、箭头函数和核心概念"
---

## 模块 3: 函数基础

欢迎来到最重要的模块之一!JavaScript 中的函数比 Java 中的方法更强大、更灵活。深入理解函数对于成为高效的 JavaScript 开发者至关重要。

## 学习目标

完成本模块后,你将:
✅ 理解函数声明 vs 表达式
✅ 掌握箭头函数(ES6+)
✅ 学习默认参数
✅ 理解 rest 和 spread 参数
✅ 了解参数和实参的区别
✅ 学习函数提升

## 函数基础: Java vs JavaScript

在 Java 中,方法总是附加到类。在 JavaScript 中,函数是一等公民 - 它们可以独立存在,被赋值给变量,作为参数传递,并从其他函数返回。

<UniversalEditor title="函数声明比较">
```java !! java
// Java - Methods are class members
public class Calculator {

    // Method declaration
    public int add(int a, int b) {
        return a + b;
    }

    // Method overloading
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Main method
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int result = calc.add(5, 3);
        System.out.println(result);  // 8
    }
}
```

```javascript !! js
// JavaScript - Functions can exist independently
// Function declaration
function add(a, b) {
    return a + b;
}

// Call the function
const result = add(5, 3);
console.log(result);  // 8

// Can be assigned to variable
const multiply = function(a, b) {
    return a * b;
};

// Arrow function (ES6+)
const subtract = (a, b) => a - b;

// All of these are valid
console.log(add(2, 3));        // 5
console.log(multiply(2, 3));   // 6
console.log(subtract(5, 2));   // 3
```
</UniversalEditor>

## 函数声明

函数声明类似于 Java 方法,但不需要类:

<UniversalEditor title="函数声明语法">
```java !! java
// Java - Method inside class
public class Utils {
    public static int calculate(int x, int y) {
        return x + y;
    }

    // Instance method
    public String format(String text) {
        return text.toUpperCase();
    }
}

// Calling
Utils.calculate(5, 3);
Utils utils = new Utils();
utils.format("hello");
```

```javascript !! js
// JavaScript - Standalone functions
function calculate(x, y) {
    return x + y;
}

// Can be called before declaration (hoisting)
console.log(add(5, 3));  // 8 - Works!

function add(a, b) {
    return a + b;
}

// No public/private modifiers (yet - ES2022 has #)
function privateFunction() {
    return "private";
}

// Naming convention: camelCase
function getUserById(id) {
    // ... implementation
}

function calculateTotalPrice(items, taxRate) {
    // ... implementation
}
```
</UniversalEditor>

### 函数提升

函数声明被"提升" - 它们可以在定义之前被调用:

<UniversalEditor title="函数提升">
```java !! java
// Java - No hoisting
public class Example {
    public static void main(String[] args) {
        greet();  // Compilation error! Method not defined yet
    }

    public static void greet() {
        System.out.println("Hello!");
    }
}
```

```javascript !! js
// JavaScript - Hoisting works for declarations
greet();  // "Hello!" - Works because of hoisting

function greet() {
    console.log("Hello!");
}

// Hoisting doesn't work for expressions
greet2();  // TypeError: greet2 is not a function

const greet2 = function() {
    console.log("Hello 2!");
};

// What actually happens:
// 1. Declaration is hoisted
function greet() {
    console.log("Hello!");
}
// 2. Assignment stays in place
// (greet2 is undefined until the assignment)
```
</UniversalEditor>

## 函数表达式

JavaScript 允许将函数赋值给变量:

<UniversalEditor title="函数表达式">
```java !! java
// Java - Lambda expressions (Java 8+)
interface Operation {
    int apply(int a, int b);
}

public class Calculator {
    public static void main(String[] args) {
        Operation add = (a, b) -> a + b;
        Operation multiply = (a, b) -> a * b;

        System.out.println(add.apply(5, 3));       // 8
        System.out.println(multiply.apply(5, 3));  // 15
    }
}
```

```javascript !! js
// JavaScript - Function expressions
const add = function(a, b) {
    return a + b;
};

const multiply = function(a, b) {
    return a * b;
};

console.log(add(5, 3));       // 8
console.log(multiply(5, 3));  // 15

// Anonymous function (no name)
setTimeout(function() {
    console.log("Delayed execution");
}, 1000);

// Named function expression (better for debugging)
const divide = function divideNumbers(a, b) {
    if (b === 0) {
        throw new Error("Cannot divide by zero");
    }
    return a / b;
};

// The name is only visible inside the function
console.log(divide(10, 2));  // 5
// console.log(divideNumbers(10, 2));  // ReferenceError
```
</UniversalEditor>

## 箭头函数

箭头函数(ES6 引入)是一种编写函数的简洁方式:

<UniversalEditor title="箭头函数">
```java !! java
// Java - Lambda expressions
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Single expression
numbers.stream()
    .map(n -> n * 2)
    .forEach(System.out::println);

// Multiple statements (need braces)
numbers.stream()
    .map(n -> {
        int doubled = n * 2;
        return doubled + 1;
    })
    .forEach(System.out::println);
```

```javascript !! js
// JavaScript - Arrow functions
const numbers = [1, 2, 3, 4, 5];

// Single expression (implicit return)
const doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

// Multiple parameters (need parentheses)
const sum = numbers.reduce((a, b) => a + b, 0);

// No parameters (need parentheses)
const getRandom = () => Math.random();

// Multiple statements (need braces and explicit return)
const processed = numbers.map(n => {
    const doubled = n * 2;
    return doubled + 1;
});

// Returning object literals (need parentheses)
const createUser = name => ({ name, id: Date.now() });
const user = createUser("John");
console.log(user);  // { name: "John", id: 1234567890 }

// Arrow functions are anonymous
// Use variable name for identification
const add = (a, b) => a + b;
```
</UniversalEditor>

### 箭头函数的局限性

箭头函数并不总是合适的。它们在重要方面与普通函数不同:

<UniversalEditor title="箭头函数的局限性">
```java !! java
// Java - 'this' refers to the object
public class Counter {
    private int count = 0;

    public Runnable getIncrementer() {
        return () -> {
            this.count++;  // 'this' refers to Counter instance
            System.out.println(this.count);
        };
    }
}
```

```javascript !! js
// JavaScript - Arrow functions lexically bind 'this'
const counter = {
    count: 0,
    increment: function() {
        console.log(this.count);  // 'this' refers to counter
    },

    // Arrow function as method (NOT recommended)
    incrementBad: () => {
        console.log(this.count);  // 'this' is not counter!
        // 'this' is lexically bound from surrounding scope
    }
};

counter.increment();      // 0 (correct)
counter.incrementBad();   // undefined (wrong!)

// Correct usage: callback functions
const timer = {
    seconds: 0,
    start: function() {
        // Regular function would lose 'this'
        // setInterval(function() {
        //     this.seconds++;  // Error: 'this' is not timer
        // }, 1000);

        // Arrow function preserves 'this'
        setInterval(() => {
            this.seconds++;
            console.log(this.seconds);
        }, 1000);
    }
};

timer.start();  // Works correctly!
```
</UniversalEditor>

## 默认参数

JavaScript 支持默认参数值:

<UniversalEditor title="默认参数">
```java !! java
// Java - Method overloading
public class Greeter {
    public void greet(String name) {
        greet(name, "Hello");
    }

    public void greet(String name, String greeting) {
        System.out.println(greeting + ", " + name);
    }

    // Or use null checks
    public void greet2(String name, String greeting) {
        if (greeting == null) {
            greeting = "Hello";
        }
        System.out.println(greeting + ", " + name);
    }
}
```

```javascript !! js
// JavaScript - Default parameters
function greet(name, greeting = "Hello") {
    console.log(`${greeting}, ${name}`);
}

greet("John");           // "Hello, John"
greet("Jane", "Hi");     // "Hi, Jane"

// Default with undefined
greet("Bob", undefined); // "Hello, Bob" (uses default)
greet("Alice", null);    // "null, Alice" (null is a value!)

// Expressions as defaults
function createUser(name, role = "user", createdAt = Date.now()) {
    return { name, role, createdAt };
}

const user1 = createUser("John");
console.log(user1);  // { name: "John", role: "user", createdAt: 1234567890 }

const user2 = createUser("Jane", "admin");
console.log(user2);  // { name: "Jane", role: "admin", createdAt: 1234567890 }

// Default can reference previous parameters
function createArray(size, defaultValue = 0) {
    return Array(size).fill(defaultValue);
}

console.log(createArray(5));         // [0, 0, 0, 0, 0]
console.log(createArray(3, "x"));    // ["x", "x", "x"]
```
</UniversalEditor>

## Rest 参数

Rest 参数允许函数接受无限数量的参数:

<UniversalEditor title="Rest 参数">
```java !! java
// Java - Varargs
public class Sum {
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    public static void main(String[] args) {
        Sum s = new Sum();
        System.out.println(s.sum(1, 2, 3));        // 6
        System.out.println(s.sum(1, 2, 3, 4, 5));  // 15
    }
}
```

```javascript !! js
// JavaScript - Rest parameters
function sum(...numbers) {
    return numbers.reduce((total, n) => total + n, 0);
}

console.log(sum(1, 2, 3));        // 6
console.log(sum(1, 2, 3, 4, 5));  // 15
console.log(sum());               // 0

// Rest parameter must be last
function log(message, ...args) {
    console.log(message, args);
}

log("Values:", 1, 2, 3);  // "Values:" [1, 2, 3]

// Destructuring with rest
function getUserInfo(firstName, lastName, ...details) {
    return {
        name: `${firstName} ${lastName}`,
        details
    };
}

const info = getUserInfo("John", "Doe", "Engineer", "NYC", 30);
console.log(info);
// {
//   name: "John Doe",
//   details: ["Engineer", "NYC", 30]
// }

// Arrow functions with rest
const multiply = (multiplier, ...numbers) => {
    return numbers.map(n => n * multiplier);
};

console.log(multiply(2, 1, 2, 3));  // [2, 4, 6]
```
</UniversalEditor>

## Spread 运算符

spread 运算符将数组/对象展开为单个元素:

<UniversalEditor title="Spread 运算符">
```java !! java
// Java - Arrays can't be easily spread
int[] arr1 = {1, 2, 3};
int[] arr2 = {4, 5, 6};
// Need manual copying or System.arraycopy

// Java varargs for method calls
public void printAll(String... messages) {
    for (String msg : messages) {
        System.out.println(msg);
    }
}

printAll("Hello", "World");  // Works
// Can't easily spread an existing array
```

```javascript !! js
// JavaScript - Spread operator
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Combine arrays
const combined = [...arr1, ...arr2];
console.log(combined);  // [1, 2, 3, 4, 5, 6]

// Add elements
const withExtra = [0, ...arr1, 4, ...arr2, 7];
console.log(withExtra);  // [0, 1, 2, 3, 4, 4, 5, 6, 7]

// Copy array
const copy = [...arr1];

// Spread in function calls
const numbers = [1, 2, 3, 4, 5];
console.log(Math.max(...numbers));  // 5
console.log(Math.min(...numbers));  // 1

// Spread with strings
const chars = [..."hello"];
console.log(chars);  // ["h", "e", "l", "l", "o"]

// Spread objects
const user = { name: "John", age: 25 };
const enhanced = { ...user, role: "admin" };
console.log(enhanced);  // { name: "John", age: 25, role: "admin" }

// Override properties
const updated = { ...user, age: 26 };
console.log(updated);  // { name: "John", age: 26 }

// Merge objects
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 };
console.log(merged);  // { a: 1, b: 2, c: 3, d: 4 }
```
</UniversalEditor>

## 参数 vs 实参

<UniversalEditor title="参数 vs 实参">
```java !! java
// Java - Parameters (in declaration)
public int add(int a, int b) {  // a and b are parameters
    return a + b;
}

// Arguments (in call)
int result = add(5, 3);  // 5 and 3 are arguments
```

```javascript !! js
// JavaScript - Same concept, but more flexible
function add(a, b) {  // a and b are parameters
    console.log(a);  // undefined if argument not provided
    console.log(b);  // undefined if argument not provided
    return a + b;
}

add(5, 3);  // 5 and 3 are arguments
add(5);     // Only 5 is provided, b is undefined
add(5, 3, 7);  // 7 is ignored (no error!)

// Access all arguments (old way)
function sumAll() {
    // arguments is array-like object
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}

console.log(sumAll(1, 2, 3, 4, 5));  // 15

// Modern way: rest parameters
function sumAllModern(...numbers) {
    return numbers.reduce((sum, n) => sum + n, 0);
}

console.log(sumAllModern(1, 2, 3, 4, 5));  // 15
```
</UniversalEditor>

## 返回值

<UniversalEditor title="返回值">
```java !! java
// Java - Must declare return type
public int add(int a, int b) {
    return a + b;
}

// Void return type
public void print(String message) {
    System.out.println(message);
    // No return needed
}

// All paths must return value
public int max(int a, int b) {
    if (a > b) {
        return a;
    }
    // Error: Missing return statement
}
```

```javascript !! js
// JavaScript - No return type declaration
function add(a, b) {
    return a + b;
}

// No return = undefined
function print(message) {
    console.log(message);
    // Returns undefined implicitly
}

const result = print("Hello");
console.log(result);  // undefined

// Early returns
function max(a, b) {
    if (a > b) {
        return a;
    }
    return b;
}

// Conditional return
function getDiscount(amount) {
    if (amount > 1000) {
        return 0.2;  // 20% discount
    }
    if (amount > 500) {
        return 0.1;  // 10% discount
    }
    return 0;  // No discount
}

// Multiple return values (via array or object)
function getMinMax(numbers) {
    return {
        min: Math.min(...numbers),
        max: Math.max(...numbers)
    };
}

const { min, max } = getMinMax([1, 5, 3, 9, 2]);
console.log(min, max);  // 1 9
```
</UniversalEditor>

## 一等函数

函数是一等公民 - 它们可以:

1. 赋值给变量
2. 作为参数传递
3. 从其他函数返回
4. 存储在数据结构中

<UniversalEditor title="一等函数">
```java !! java
// Java - Limited support
interface Operation {
    int apply(int a, int b);
}

public class Calculator {
    public int calculate(Operation op, int a, int b) {
        return op.apply(a, b);
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // Pass lambda as argument
        int result = calc.calculate((x, y) -> x + y, 5, 3);
        System.out.println(result);  // 8
    }
}
```

```javascript !! js
// JavaScript - Full first-class function support

// 1. Assigned to variables
const greet = function(name) {
    return `Hello, ${name}`;
};

// 2. Passed as arguments
function applyOperation(a, b, operation) {
    return operation(a, b);
}

const sum = (x, y) => x + y;
const difference = (x, y) => x - y;

console.log(applyOperation(10, 5, sum));         // 15
console.log(applyOperation(10, 5, difference));  // 5

// 3. Returned from functions
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15

// 4. Stored in data structures
const operations = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => a / b
};

console.log(operations.add(5, 3));        // 8
console.log(operations.multiply(4, 3));   // 12

// Array of functions
const transformers = [
    x => x * 2,
    x => x + 10,
    x => x * x
];

const value = 5;
const results = transformers.map(fn => fn(value));
console.log(results);  // [10, 15, 25]
```
</UniversalEditor>

## 常见模式

### 模式 1: 函数工厂

<UniversalEditor title="函数工厂模式">
```java !! java
// Java - Not easily possible
// Would need classes and interfaces
```

```javascript !! js
// JavaScript - Function factory
function createValidator(regex) {
    return function(value) {
        return regex.test(value);
    };
}

const isEmail = createValidator(/^[^\s@]+@[^\s@]+\.[^\s@]+$/);
const isPhone = createValidator(/^\d{3}-\d{3}-\d{4}$/);

console.log(isEmail("test@example.com"));  // true
console.log(isPhone("123-456-7890"));      // true

// Practical example: API client creator
function createApiClient(baseUrl) {
    return async function(endpoint, options = {}) {
        const response = await fetch(`${baseUrl}${endpoint}`, options);
        return response.json();
    };
}

const api = createApiClient("https://api.example.com");
const users = await api("/users");
const posts = await api("/posts");
```
</UniversalEditor>

### 模式 2: 配置对象

<UniversalEditor title="配置对象模式">
```java !! java
// Java - Builder pattern
public class Request {
    private String url;
    private String method = "GET";
    private Map<String, String> headers = new HashMap<>();

    public static class Builder {
        // Builder implementation
    }
}

Request request = new Request.Builder()
    .url("https://api.example.com")
    .method("POST")
    .build();
```

```javascript !! js
// JavaScript - Configuration object with defaults
function makeRequest(url, options = {}) {
    const defaults = {
        method: "GET",
        headers: {
            "Content-Type": "application/json"
        },
        body: null
    };

    const config = { ...defaults, ...options };

    return fetch(url, config);
}

// Usage
makeRequest("https://api.example.com/users", {
    method: "POST",
    body: JSON.stringify({ name: "John" })
});

// Destructured parameters
function createUser({ name, email, role = "user", active = true }) {
    return { name, email, role, active };
}

const user = createUser({
    name: "John",
    email: "john@example.com"
    // role and active use defaults
});
```
</UniversalEditor>

## 最佳实践

<UniversalEditor title="函数最佳实践">
```java !! java
// Java: Clear method signatures
public class UserService {
    private UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public Optional<User> findById(Long id) {
        return repository.findById(id);
    }

    public List<User> findActiveUsers() {
        return repository.findAll()
                        .stream()
                        .filter(User::isActive)
                        .collect(Collectors.toList());
    }
}
```

```javascript !! js
// JavaScript: Similar principles

// 1. Use descriptive names
function calculateMonthlyPayment(principal, rate, months) {
    // Good
}

function calc(p, r, m) {
    // Bad - not descriptive
}

// 2. Keep functions small and focused
function validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

function validatePassword(password) {
    return password.length >= 8;
}

// Instead of one big function
function validateCredentials(email, password) {
    // Validates everything
}

// 3. Use default parameters for optional arguments
function fetchUsers(options = {}) {
    const {
        limit = 10,
        offset = 0,
        active = true
    } = options;

    // Implementation
}

// 4. Prefer arrow functions for callbacks
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);

// 5. Use regular functions for methods
const calculator = {
    add: function(a, b) {
        return a + b;
    },

    // Or use shorthand (still has correct 'this')
    subtract(a, b) {
        return a - b;
    }
};

// 6. Return early to reduce nesting
function processUser(user) {
    if (!user) {
        return null;
    }

    if (!user.isActive) {
        return null;
    }

    if (!user.email) {
        return null;
    }

    // Main logic
    return transformUser(user);
}
```
</UniversalEditor>

## 常见陷阱

### 陷阱 1: 在箭头函数中忘记返回

<UniversalEditor title="缺少返回值">
```javascript !! js
// ❌ BAD: Implicit return with curly braces
const doubled = [1, 2, 3].map(n => {
    n * 2;
});
// Result: [undefined, undefined, undefined]

// ✅ GOOD: Either use explicit return
const doubled2 = [1, 2, 3].map(n => {
    return n * 2;
});

// ✅ GOOD: Or remove curly braces for implicit return
const doubled3 = [1, 2, 3].map(n => n * 2);

// ⚠️ Need parentheses for object literals
const users = ["alice", "bob"].map(name => ({ name }));
// Correct: ({ name }) creates object

// Without parentheses:
const bad = ["alice"].map(name => { name });
// Result: [undefined] - { name } is a code block, not object
```
</UniversalEditor>

### 陷阱 2: 将箭头函数用于方法

<UniversalEditor title="箭头函数作为方法">
```javascript !! js
// ❌ BAD: Arrow function doesn't have own 'this'
const counter = {
    count: 0,
    increment: () => {
        this.count++;  // 'this' is not counter!
    }
};

// ✅ GOOD: Use regular function or shorthand
const counter2 = {
    count: 0,
    increment: function() {
        this.count++;  // 'this' is counter2
    },

    // Or shorthand (same as function)
    decrement() {
        this.count--;  // 'this' is counter2
    }
};
```
</UniversalEditor>

### 陷阱 3: 可变默认参数

<UniversalEditor title="可变默认参数">
```javascript !! js
// ❌ BAD: Mutable default is shared across calls
function addItem(item, list = []) {
    list.push(item);
    return list;
}

const list1 = addItem("a");  // ["a"]
const list2 = addItem("b");  // ["a", "b"] - Not a new array!

// ✅ GOOD: Create new array in function body
function addItemSafe(item, list) {
    const items = list ? [...list] : [];
    items.push(item);
    return items;
}

// Or use null check
function addItemSafe2(item, list) {
    if (!list) list = [];
    return [...list, item];
}
```
</UniversalEditor>

## 练习

### 练习 1: 转换为箭头函数
将这些函数转换为箭头函数:
```javascript
function add(a, b) {
    return a + b;
}

function square(x) {
    return x * x;
}

function greet(name) {
    return "Hello, " + name;
}
```

### 练习 2: 默认参数
添加默认参数:
```javascript
function createUser(name, email, role) {
    return { name, email, role };
}

// role should default to "user"
// email should default to empty string
```

### 练习 3: Rest 参数
创建一个计算平均值的函数:
```javascript
function average(/* numbers */) {
    // Accept any number of arguments
    // Return the average
}

average(1, 2, 3, 4, 5);  // 3
average(10, 20);        // 15
```

### 练习 4: 函数工厂
创建一个返回函数的函数:
```javascript
function createGreeter(greeting) {
    // Return a function that greets with the specified greeting
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

sayHello("John");  // "Hello, John"
sayHi("Jane");     // "Hi, Jane"
```

## 总结

### 关键要点

1. **函数声明:**
   - 被提升(可以在定义之前调用)
   - 传统函数语法
   - 适合独立函数

2. **函数表达式:**
   - 不被提升
   - 赋值给变量
   - 适合回调和闭包

3. **箭头函数:**
   - 简洁的语法
   - 词法 `this` 绑定
   - 非常适合回调
   - 不适合方法

4. **默认参数:**
   - 提供默认值
   - 可以是表达式
   - 仅由 `undefined` 触发,而不是 `null`

5. **Rest/Spread:**
   - Rest: 将参数收集到数组中
   - Spread: 将数组/对象展开为元素
   - 便于操作

6. **一等函数:**
   - 可以被赋值、传递、返回
   - 支持高阶函数
   - 支持函数式编程

### 比较表: Java vs JavaScript

| 特性 | Java | JavaScript |
|------|------|-----------|
| **声明** | 仅在类中 | 可以独立 |
| **提升** | 否 | 是(仅声明) |
| **重载** | 是(多个签名) | 否(使用默认参数或 rest) |
| **返回类型** | 必须声明 | 不需要声明 |
| **默认参数** | 通过重载 | 内置支持 |
| **可变参数** | `Type...` | `...args` (rest) |
| **Lambda** | `() -> expression` | `() => expression` |
| **This 绑定** | 始终是实例 | 取决于调用位置(箭头函数: 词法) |

## 下一步是什么?

你已经学习了 JavaScript 函数的基础!在**模块 4: 函数高级**中,我们将探索:

- 闭包和词法作用域
- 高阶函数
- 柯里化和部分应用
- 记忆化
- JavaScript 中的递归
- `arguments` 对象
- 函数属性和方法

准备好提升你的函数技能了吗?让我们继续!
