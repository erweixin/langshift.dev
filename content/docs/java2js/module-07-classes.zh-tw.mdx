---
title: "Module 7: Classes"
description: "掌握 JavaScript ES6 類別、繼承和物件導向程式設計"
---

## Module 7: Classes

雖然 JavaScript 基於原型，但 ES6 引入了類別語法，為 Java 開發者提供熟悉的物件導向程式設計體驗。讓我們學習 JavaScript 類別。

## Learning Objectives

完成本模組後，你將：
✅ 理解 ES6 類別語法
✅ 掌握建構函數和方法
✅ 學習繼承和 extends
✅ 理解 static 方法
✅ 掌握 getters 和 setters
✅ 了解類別與原型的關係

## Classes Comparison

<UniversalEditor title="類別比較">
```java !! java
// Java - Traditional class
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void greet() {
        System.out.println("Hello, I'm " + name);
    }
}

User user = new User("Alice", 25);
user.greet();
```

```javascript !! js
// JavaScript - ES6 class
class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    getName() {
        return this.name;
    }

    setName(name) {
        this.name = name;
    }

    greet() {
        console.log(`Hello, I'm ${this.name}`);
    }
}

const user = new User("Alice", 25);
user.greet();  // "Hello, I'm Alice"

// Classes are syntactic sugar over prototypes
// Under the hood, they still use prototype-based inheritance
```
</UniversalEditor>

## Class Declarations vs Expressions

<UniversalEditor title="類別聲明與表達式">
```java !! java
// Java - Only declarations
public class MyClass {
    // ...
}

// Anonymous classes
Runnable r = new Runnable() {
    public void run() {
        System.out.println("Running");
    }
};
```

```javascript !! js
// JavaScript - Declarations
class User {
    constructor(name) {
        this.name = name;
    }
}

// Hoisted? No（unlike function declarations）
// const user = new User();  // ReferenceError

class User2 {
    // ...
}

// Expressions
const UserClass = class {
    constructor(name) {
        this.name = name;
    }
};

const user = new UserClass("Alice");

// Named class expression（useful for recursion）
const Factory = class User {
    constructor(name) {
        this.name = name;
    }

    static create(name) {
        return new User(name);
    }
};
```
</UniversalEditor>

## Inheritance

<UniversalEditor title="繼承">
```java !! java
// Java - extends
public class Animal {
    public void speak() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}

Dog dog = new Dog();
dog.speak();  // "Woof!"
```

```javascript !! js
// JavaScript - extends
class Animal {
    speak() {
        console.log("Some sound");
    }
}

class Dog extends Animal {
    speak() {
        console.log("Woof!");
    }
}

const dog = new Dog();
dog.speak();  // "Woof!"

// super keyword
class Dog2 extends Animal {
    speak() {
        super.speak();  // Call parent method
        console.log("Woof!");
    }
}

// Calling super constructor
class Animal2 {
    constructor(name) {
        this.name = name;
    }
}

class Dog3 extends Animal2 {
    constructor(name, breed) {
        super(name);  // Must call super before using this
        this.breed = breed;
    }
}

// instanceof check
console.log(dog instanceof Dog);    // true
console.log(dog instanceof Animal); // true
```
</UniversalEditor>

## Static Members

<UniversalEditor title="Static 成員">
```java !! java
// Java - static members
public class MathUtil {
    public static final double PI = 3.14159;

    public static int add(int a, int b) {
        return a + b;
    }
}

int sum = MathUtil.add(5, 3);
double pi = MathUtil.PI;
```

```javascript !! js
// JavaScript - static members
class MathUtil {
    static PI = 3.14159;

    static add(a, b) {
        return a + b;
    }
}

const sum = MathUtil.add(5, 3);
const pi = MathUtil.PI;

// Static methods cannot access instance members
class Example {
    static count = 0;

    constructor() {
        Example.count++;  // Access static via class name
    }

    static getCount() {
        return Example.count;  // Cannot use this.count
    }
}

const e1 = new Example();
const e2 = new Example();
console.log(Example.getCount());  // 2
```
</UniversalEditor>

## Getters and Setters

<UniversalEditor title="Getters 和 Setters">
```java !! java
// Java - Getters and setters
public class User {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```javascript !! js
// JavaScript - Getters and setters
class User {
    constructor() {
        this._name = "";
    }

    get name() {
        return this._name.toUpperCase();
    }

    set name(value) {
        if (value.length > 0) {
            this._name = value;
        }
    }
}

const user = new User();
user.name = "alice";
console.log(user.name);  // "ALICE"

// Computed properties
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }

    get area() {
        return this.width * this.height;
    }
}

const rect = new Rectangle(10, 20);
console.log(rect.area);  // 200
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="類別最佳實踐">
```javascript !! js
// 1. Use classes for objects with behavior
class UserService {
    constructor(apiUrl) {
        this.apiUrl = apiUrl;
    }

    async getUser(id) {
        const response = await fetch(`${this.apiUrl}/users/${id}`);
        return response.json();
    }
}

// 2. Use factory methods for complex construction
class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    static fromJSON(json) {
        return new User(json.name, json.age);
    }
}

// 3. Prefer composition over deep inheritance
class Logger {
    log(message) {
        console.log(message);
    }
}

class UserService {
    constructor(logger) {
        this.logger = logger;
    }
}
```
</UniversalEditor>

## Summary

### Key Takeaways

1. **Classes:** 原型的語法糖
2. **Inheritance:** extends 和 super
3. **Static:** 類別層級成員
4. **Getters/Setters:** 計算屬性

## What's Next?

接下來是 **Module 8: Prototypes** - 深入了解原型系統！
