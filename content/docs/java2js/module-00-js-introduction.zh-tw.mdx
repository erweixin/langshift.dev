---
title: "Module 0: JavaScript 語言簡介"
description: "了解 JavaScript 的歷史、設計理念，以及為 Java 開發者設定開發環境"
---

## JavaScript 語言歷史與設計理念

JavaScript 由 Brendan Eich 於 1995 年在 Netscape 公司創造（僅用了 10 天！）。最初命名為 Mocha，後來改名為 LiveScript，最終改名為 JavaScript 是為了利用當時 Java 的知名度。儘管名稱相似，JavaScript 和 Java 是完全不同的語言，有著不同的設計目標。

### 為何創建 JavaScript

JavaScript 的出現是因為需要一種可在瀏覽器中運行的輕量級腳本語言：

- **Java 太重**，無法處理簡單的網頁互動
- **HTML 是靜態的**，缺乏互動性
- **沒有客戶端邏輯**存在於網頁瀏覽器中
- **網頁需要**無需伺服器往返的動態行為

JavaScript 的創造者希望有一種語言：
- 可以直接嵌入 HTML
- 對初學者來說容易學習
- 為網頁提供動態行為
- 跨不同瀏覽器運作

### JavaScript 的設計理念

JavaScript 的設計由以下核心原則指導：

#### 1. 動態型別
- **無需型別宣告**：變數可以保存任何型別
- **執行時期型別檢查**：型別在執行過程中確定
- **靈活轉換**：自動型別強制轉換
- **快速原型設計**：更少的樣板程式碼

<UniversalEditor title="動態 vs 靜態型別">
```java !! java
// Java - 靜態型別
String name = "John";
int age = 25;
boolean isActive = true;

// age = "twenty five";  // 編譯錯誤！
// 必須明確宣告型別
```

```javascript !! js
// JavaScript - 動態型別
let name = "John";
let age = 25;
let isActive = true;

age = "twenty five";  // 有效！型別可以改變
// 無需型別宣告
```
</UniversalEditor>

#### 2. 一等公民函數
- **函數是值**：可賦值給變數
- **高階函數**：可接受並返回函數
- **閉包**：函數保留對其作用域的訪問
- **函數式程設**：支援 map、filter、reduce

<UniversalEditor title="函數：Java vs JavaScript">
```java !! java
// Java - 函數是類別方法
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    // 無法將方法作為參數傳遞
    // 需要介面或 Lambda 運算式 (Java 8+)
}
```

```javascript !! js
// JavaScript - 函數是一等公民
const add = function(a, b) {
    return a + b;
};

// 箭頭函數 (ES6+)
const multiply = (a, b) => a * b;

// 函數可作為參數傳遞
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);

// 高階函數
function withLogging(fn) {
    return function(...args) {
        console.log('Calling', fn.name);
        return fn(...args);
    };
}
```
</UniversalEditor>

#### 3. 原型基礎繼承
- **無類別（傳統上）**：物件從其他物件繼承
- **原型**：每個物件都有一個原型鏈
- **動態行為**：可在執行時修改物件
- **ES6 類別**：原型的語法糖

<UniversalEditor title="繼承模型">
```java !! java
// Java - 基於類別的繼承
public class Animal {
    public void speak() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}

// 使用
Animal dog = new Dog();
dog.speak();  // "Woof!"
```

```javascript !! js
// JavaScript - 基於原型的繼承
const animal = {
    speak() {
        console.log("Some sound");
    }
};

const dog = Object.create(animal);
dog.speak = function() {
    console.log("Woof!");
};

dog.speak();  // "Woof!"

// ES6 類別語法（語法糖）
class Animal {
    speak() {
        console.log("Some sound");
    }
}

class Dog extends Animal {
    speak() {
        console.log("Woof!");
    }
}

const dog2 = new Dog();
dog2.speak();  // "Woof!"
```
</UniversalEditor>

#### 4. 事件驅動架構
- **事件迴圈**：帶事件佇列的單執行緒
- **非同步**：非阻塞 I/O 操作
- **回呼函數**：事件完成時呼叫的函數
- **Promise/async-await**：現代非同步處理

<UniversalEditor title="並發模型">
```java !! java
// Java - 多執行緒
public class DataLoader {
    public String loadData() {
        // 阻塞執行緒直到資料載入完成
        String data = fetchDataFromDatabase();
        return data;
    }

    public static void main(String[] args) {
        // 每個執行緒獨立運行
        Thread thread1 = new Thread(() -> {
            new DataLoader().loadData();
        });
        thread1.start();
    }
}
```

```javascript !! js
// JavaScript - 事件驅動，單執行緒
function loadData() {
    return new Promise((resolve) => {
        // 非阻塞，繼續執行
        setTimeout(() => {
            resolve("Data loaded!");
        }, 1000);
    });
}

// Async/await（現代方法）
async function main() {
    console.log("Loading...");
    const data = await loadData();
    console.log(data);
    // 全部在單執行緒上配合事件迴圈運行
}

main();
```
</UniversalEditor>

## 與 Java 的比較

| 特性 | Java | JavaScript |
|---------|------|------------|
| **範式** | 物件導向（基於類別） | 多範式（基於原型、函數式） |
| **型別** | 靜態（必須宣告型別） | 動態（執行時確定型別） |
| **執行** | 編譯為位元組碼，在 JVM 上運行 | 在瀏覽器或 Node.js 中解譯/JIT 編譯 |
| **環境** | JVM（伺服器、桌面、Android） | 瀏覽器、Node.js（伺服器）、各種嵌入 |
| **並發** | 多執行緒與共享記憶體 | 單執行緒與事件迴圈 |
| **繼承** | 類別繼承（extends、implements） | 原型鏈（類別語法是糖） |
| **函數** | 方法（附加到類別） | 一等公民（可隨意傳遞） |
| **記憶體** | 手動物件生命週期、GC | GC、自動記憶體管理 |
| **部署** | JAR/WAR 檔案，需要 JVM | 嵌入 HTML、npm 套件、獨立 |
| **套件管理** | Maven、Gradle | npm、yarn、pnpm |
| **標準函式庫** | 豐富、企業級 | 較小、網頁導向 |

## 編譯 vs 解譯

### Java（編譯為位元組碼）

Java 程式碼經歷編譯過程：

1. **原始碼**（`.java` 檔案）被編譯為位元組碼
2. **位元組碼**（`.class` 檔案）在 JVM 上運行
3. **JIT 編譯器**優化熱程式碼路徑
4. **靜態型別**在編譯時捕捉錯誤

**優點：**
- JIT 編譯後執行快速
- 編譯時期錯誤檢查
- 強型別安全
- 優化的效能

**缺點：**
- 需要編譯步驟
- 冗長的語法
- 較重的記憶體佔用
- 啟動時間較慢

### JavaScript（解譯/JIT）

JavaScript 執行因環境而異：

**在瀏覽器中：**
1. **原始碼**立即被解析和執行
2. **JIT 編譯**優化經常使用的程式碼
3. **動態型別**提供靈活性
4. **事件迴圈**處理非同步操作

**在 Node.js 中：**
1. **V8 引擎**編譯為機器碼
2. **即時**優化
3. **無瀏覽器 DOM** - 伺服器端 API

<UniversalEditor title="執行模型比較">
```java !! java
// Java - 先編譯後執行
// 檔案：HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}

// 編譯
$ javac HelloWorld.java

// 執行
$ java HelloWorld
Hello, World!
```

```javascript !! js
// JavaScript - 直接執行（無需編譯）
// 檔案：hello.js
console.log("Hello, World!");

// 在瀏覽器中
<script src="hello.js"></script>

// 在 Node.js 中
$ node hello.js
Hello, World!
```
</UniversalEditor>

## JavaScript 的使用案例與優勢

### 主要使用案例

#### 1. 網頁前端開發
JavaScript 對於網頁開發至關重要：

- **DOM 操作**：互動式網頁
- **事件處理**：使用者互動
- **AJAX/Fetch**：動態資料載入
- **單頁應用**：React、Vue、Angular
- **漸進式網頁應用**：離線功能

<UniversalEditor title="網頁互動性">
```java !! java
// Java - 需要完整頁面重新載入以更新
@WebServlet("/users")
public class UserServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        // 伺服器渲染整個 HTML 頁面
        req.setAttribute("users", getUsers());
        req.getRequestDispatcher("/users.jsp").forward(req, resp);
    }
}
```

```javascript !! js
// JavaScript - 無需重新載入的動態更新
// 非同步獲取使用者資料
async function loadUsers() {
    const response = await fetch('/api/users');
    const users = await response.json();

    // 動態更新 DOM
    const userList = document.getElementById('user-list');
    userList.innerHTML = users.map(user =>
        `<li>${user.name}</li>`
    ).join('');
}

// 呼叫無需頁面重新載入
loadUsers();
```
</UniversalEditor>

#### 2. 後端開發（Node.js）
- **REST API**：Express、Fastify、Koa
- **即時應用**：WebSockets、Socket.io
- **微服務**：輕量級服務
- **無伺服器**：AWS Lambda、Cloud Functions

<UniversalEditor title="後端開發">
```java !! java
// Java - Spring Boot REST API
@RestController
@RequestMapping("/api")
public class UserController {

    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
}
```

```javascript !! js
// JavaScript - Node.js REST API (Express)
const express = require('express');
const app = express();

app.get('/api/users/:id', (req, res) => {
    const user = userService.findById(req.params.id);
    res.json(user);
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```
</UniversalEditor>

#### 3. 行動裝置開發
- **React Native**：iOS 和 Android 應用
- **Ionic**：混合行動應用
- **Electron**：桌面應用程式

#### 4. 開發者工具
- **建置工具**：Webpack、Vite、esbuild
- **測試**：Jest、Cypress、Playwright
- **Linting**：ESLint、Prettier
- **套件管理**：npm、yarn

### 主要優勢

#### 1. 快速開發
- **無需編譯**：立即回饋
- **動態型別**：更少的樣板程式碼
- **熱重載**：即時更新
- **龐大的生態系**：npm 套件

<UniversalEditor title="開發速度">
```java !! java
// Java - 更多樣板程式碼
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}
```

```javascript !! js
// JavaScript - 簡潔
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    toString() {
        return `Person{name='${this.name}', age=${this.age}}`;
    }
}

// 或使用物件字面量更簡單
const person = { name: "John", age: 30 };
console.log(JSON.stringify(person));
```
</UniversalEditor>

#### 2. 通用語言
- **前端和後端**：到處使用相同的語言
- **程式碼共享**：在平台間共享程式碼
- **全端開發**：一個開發者，完整技術堆疊
- **社群**：最大的開發者社群

#### 3. 靈活性
- **多種範式**：OOP、函數式、程序式
- **動態功能**：元程設計、反射
- **快速原型設計**：快速實驗
- **適應性強**：在任何地方運作

#### 4. 現代功能
- **ES6+ 語法**：類別、模組、箭頭函數
- **Async/await**：簡潔的非同步程式碼
- **解構賦值**：方便的資料提取
- **展開運算子**：簡單的物件/陣列操作

<UniversalEditor title="現代 JavaScript 功能">
```java !! java
// Java - 傳統方法
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> filtered = new ArrayList<>();

for (String name : names) {
    if (name.startsWith("A")) {
        filtered.add(name);
    }
}

Map<String, Integer> nameLengths = new HashMap<>();
for (String name : filtered) {
    nameLengths.put(name, name.length());
}
```

```javascript !! js
// JavaScript - 現代函數式方法
const names = ["Alice", "Bob", "Charlie"];

const result = names
    .filter(name => name.startsWith("A"))
    .reduce((acc, name) => ({
        ...acc,
        [name]: name.length
    }), {});

console.log(result);  // { Alice: 5 }
```
</UniversalEditor>

## 開發環境設定

### 前置需求

無需特殊前置需求 - JavaScript 可運作於：
- **任何現代瀏覽器**：Chrome、Firefox、Safari、Edge
- **Node.js**：用於伺服器端開發
- **作業系統**：Windows、macOS、Linux

### 安裝方法

#### 方法 1：瀏覽器主控台（最快開始）

無需安裝 - 只需打開瀏覽器：

1. 開啟 Chrome/Firefox/Safari
2. 按 `F12` 或 `Cmd+Option+I`（Mac）/ `Ctrl+Shift+I`（Windows）
3. 前往「主控台」分頁
4. 開始編寫程式碼！

```javascript
// 在瀏覽器主控台中嘗試這些
console.log("Hello, JavaScript!");
alert("Welcome to JS!");
document.body.style.backgroundColor = "lightblue";
```

#### 方法 2：Node.js（用於開發）

**macOS/Linux:**
```bash
# 使用 Homebrew (macOS)
brew install node

# 或使用 apt (Ubuntu/Debian)
sudo apt update
sudo apt install nodejs npm
```

**Windows:**
1. 從 https://nodejs.org/ 下載
2. 執行安裝程式
3. 重新啟動終端機

**驗證安裝：**
```bash
node --version   # 應該是 v18.x 或更高
npm --version    # 應該是 9.x 或更高
```

#### 方法 3：線上遊樂場（用於學習）

- **CodePen**：https://codepen.io/pen/
- **JSFiddle**：https://jsfiddle.net/
- **Replit**：https://replit.com/
- **StackBlitz**：https://stackblitz.com/

### 推薦工具

#### 程式碼編輯器

**Visual Studio Code（推薦）：**
```bash
# 從 https://code.visualstudio.com/ 下載
# 安裝這些擴充功能：
- ESLint
- Prettier
- JavaScript (ES6) code snippets
- Node.js modules intellisense
```

**WebStorm（JetBrains）：**
- 功能完整的 JavaScript IDE
- 內建除錯器
- 重構工具
- 智慧程式碼補全

#### 瀏覽器開發者工具

**Chrome DevTools:**
- Elements：DOM 檢查
- Console：JavaScript 執行
- Sources：除錯
- Network：HTTP 監控
- Performance：效能分析

#### 套件管理器

**npm（Node 套件管理器）：**
```bash
# 隨 Node.js 一起提供
npm init -y              # 初始化專案
npm install lodash       # 安裝套件
npm install --save-dev jest  # 開發相依性
```

**yarn（替代方案）：**
```bash
npm install -g yarn      # 全局安裝
yarn init               # 初始化專案
yarn add lodash         # 安裝套件
```

#### 建置工具

**Vite（現代、快速）：**
```bash
npm create vite@latest my-app
cd my-app
npm install
npm run dev
```

**Webpack（靈活）：**
```bash
npm init -y
npm install webpack webpack-cli --save-dev
```

### 你的第一個 JavaScript 程式

<UniversalEditor title="Hello World：Java vs JavaScript">
```java !! java
// Java - 傳統方法
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");

        // 使用變數
        String name = "Java Developer";
        int years = 5;

        System.out.println("I'm a " + name + " with " + years + " years experience");
    }
}

// 儲存為 HelloWorld.java
// 編譯：javac HelloWorld.java
// 執行：java HelloWorld
```

```javascript !! js
// JavaScript - 簡單直接
console.log("Hello, World!");

// 使用變數（無需型別宣告）
const name = "Java Developer";
const years = 5;

// 模板字面量
console.log(`I'm a ${name} with ${years} years experience`);

// 在瀏覽器中，你也可以：
// alert("Hello, World!");
// document.write("Hello, World!");
```
</UniversalEditor>

### 設定專案

**初始化 Node.js 專案：**
```bash
# 建立專案目錄
mkdir my-js-project
cd my-js-project

# 初始化 package.json
npm init -y

# 建立 index.js
touch index.js

# 新增至 index.js
console.log("Hello from Node.js!");

# 執行
node index.js
```

**package.json:**
```json
{
  "name": "my-js-project",
  "version": "1.0.0",
  "description": "My JavaScript project",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "node --watch index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

## JavaScript 版本（ES6+）

本課程聚焦於**現代 JavaScript（ES6+）**：

### ES2015 (ES6) - 重大版本
- `let` 和 `const` 區塊作用域變數
- 箭頭函數
- 類別
- 模板字面量
- 解構賦值
- 展開運算子
- Promise
- 模組

### ES2016-ES2020 - 漸進更新
- Array.includes (ES2016)
- Async/await (ES2017)
- 物件 rest/spread (ES2018)
- 選擇鏈 (ES2020)
- 空值合併 (ES2020)

### ES2021+ - 最新功能
- 邏輯指派運算子
- 數字分隔符
- String.replaceAll
- Promise.any
- 頂層 await

<UniversalEditor title="ES5 vs ES6+ 語法">
```javascript !! js
// ES5（舊 JavaScript - 我們不會重點講解）
var name = "John";
var age = 25;

function greet(name) {
    return "Hello, " + name;
}

var numbers = [1, 2, 3];
var doubled = numbers.map(function(n) {
    return n * 2;
});

// 建構函式
function Person(name) {
    this.name = name;
}

Person.prototype.greet = function() {
    console.log("Hello, " + this.name);
};
```

```javascript !! js
// ES6+（現代 JavaScript - 我們將學習的）
const name = "John";
const age = 25;

const greet = (name) => `Hello, ${name}`;

const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);

// 類別語法
class Person {
    constructor(name) {
        this.name = name;
    }

    greet() {
        console.log(`Hello, ${this.name}`);
    }
}
```
</UniversalEditor>

## 瀏覽器環境 vs Node.js

### 瀏覽器 JavaScript
- **DOM API**：`document`、`window`、`querySelector`
- **Web API**：`fetch`、`localStorage`、`Canvas`、`WebGL`
- **無檔案系統訪問**（安全性）
- **單頁面上下文**

### Node.js JavaScript
- **無 DOM**：無 `document` 或 `window`
- **檔案系統訪問**：`fs` 模組
- **HTTP 伺服器**：`http`、`https` 模組
- **CommonJS 模組**：`require()`（也支援 ES 模組）

<UniversalEditor title="環境差異">
```javascript !! js
// 瀏覽器 JavaScript
// 從 API 獲取資料並更新 DOM
async function loadUser(userId) {
    const response = await fetch(`/api/users/${userId}`);
    const user = await response.json();

    // 更新 DOM
    document.getElementById('user-name').textContent = user.name;
    document.getElementById('user-email').textContent = user.email;
}

loadUser(123);
```

```javascript !! js
// Node.js（伺服器端）
const fs = require('fs');
const http = require('http');

// 建立 HTTP 伺服器
const server = http.createServer((req, res) => {
    if (req.url === '/api/user') {
        // 從檔案系統讀取
        fs.readFile('user.json', (err, data) => {
            if (err) {
                res.writeHead(500);
                res.end('Error loading user');
                return;
            }

            res.writeHead(200, { 'Content-Type': 'application/json' });
            res.end(data);
        });
    }
});

server.listen(3000);
```
</UniversalEditor>

## Java 開發者的思維模型調整

### 關鍵思維轉變

#### 1. 從編譯時期錯誤到執行時期錯誤

**Java:**
```java
String name = "John";
// name = 42;  // 編譯器立即捕捉此錯誤
```

**JavaScript:**
```javascript
let name = "John";
name = 42;  // 有效！但可能稍後導致問題
console.log(name.toUpperCase());  // 執行時期錯誤：name.toUpperCase 不是一個函數
```

#### 2. 從類別到原型

**Java:**
```java
// 一切必須在類別中
public class Utils {
    public static int add(int a, int b) {
        return a + b;
    }
}
```

**JavaScript:**
```javascript
// 函數可以獨立存在
function add(a, b) {
    return a + b;
}

// 或作為箭頭函數
const add = (a, b) => a + b;
```

#### 3. 從基於執行緒到基於事件的並發

**Java:**
```java
// 建立執行緒，並發執行
new Thread(() -> {
    doWork();
}).start();
```

**JavaScript:**
```javascript
// 使用事件迴圈、回呼、promise
setTimeout(() => {
    doWork();
}, 1000);

// 或更好的方式，使用 async/await
await new Promise(resolve => {
    setTimeout(resolve, 1000);
});
doWork();
```

#### 4. 從明確型別到型別推斷

**Java:**
```java
Map<String, List<Integer>> data = new HashMap<>();
List<String> names = data.get("key");
```

**JavaScript:**
```javascript
const data = {};  // 無型別註解
const names = data.key;  // 使用點號訪問
// 或：const names = data["key"];
```

## 常見 JavaScript 術語

對於 Java 開發者，以下是關鍵的 JavaScript 術語：

| 術語 | Java 等效 | 說明 |
|------|----------------|-------------|
| **變數** | Variable | 值的儲存（無型別宣告） |
| **函數** | Method | 可重複使用的程式碼區塊（不綁定到類別） |
| **物件** | Instance/Map | 鍵值對，動態屬性 |
| **陣列** | List/ArrayList | 有序列表（可包含混合型別） |
| **Promise** | Future/CompletableFuture | 非同步操作結果 |
| **回呼** | Listener/Observer | 作為參數傳遞的函數 |
| **閉包** | Lambda 與捕獲變數 | 保留作用域的函數 |
| **模組** | Package/Import | 程式碼組織（ES6） |
| **npm** | Maven/Gradle | 套件管理器 |
| **事件迴圈** | Executor/Dispatcher | 非同步執行模型 |
| **DOM** | - | 文件物件模型（僅瀏覽器） |
| **JSON** | - | JavaScript 物件表示法（資料格式） |

## 學習路徑概覽

本課程結構化以幫助 Java 開發者掌握 JavaScript：

### 模組結構

**模組 1-5：基本語法**
- 變數宣告（let、const、var）
- 資料型別和型別強制轉換
- 控制流程（if/else、switch、迴圈）
- 函數（宣告、運算式、箭頭）
- 陣列和陣列方法

**模組 6-9：物件與類別**
- 物件字面量和屬性
- ES6 類別和繼承
- 原型和原型鏈
- `this` 上下文和綁定

**模組 10-11：非同步程設**
- 回呼和事件迴圈
- Promise 和 async/await
- 錯誤處理模式

**模組 12-15：前端開發**
- DOM 操作和 querySelector
- 事件處理和傳播
- ES6 模組和匯入
- 建置工具（webpack、Vite）

**模組 16-19：工具與最佳實踐**
- 測試框架（Jest、Cypress）
- 框架基礎（React、Vue）
- 常見陷阱和反模式
- 真實專案範例

## 練習

### 練習 1：瀏覽器主控台
1. 開啟瀏覽器的開發者主控台（F12）
2. 嘗試這些指令：
   ```javascript
   console.log("Hello from console!");
   const name = "Java Developer";
   console.log(`Welcome, ${name}!`);
   alert("You can do this!");
   ```

### 練習 2：Node.js 設定
1. 如果尚未安裝 Node.js，請先安裝
2. 建立一個檔案 `hello.js`：
   ```javascript
   console.log("Hello from Node.js!");
   ```
3. 執行它：`node hello.js`

### 練習 3：現代 JavaScript
透過執行以下程式碼來比較 ES5 vs ES6 語法：
```javascript
// ES5
var add = function(a, b) {
    return a + b;
};

// ES6
const addES6 = (a, b) => a + b;

console.log(add(1, 2));
console.log(addES6(1, 2));
```

### 練習 4：思維模型轉變
反思這些差異：
1. 動態型別與靜態型別的感覺有何不同？
2. 一等公民函數提供什麼優勢？
3. 事件迴圈模型與 Java 執行緒有何不同？

## 總結

JavaScript 為 Java 開發者提供了一種完全不同的程設範式：

**關鍵差異：**
- **動態型別**：無型別宣告，執行時期靈活性
- **基於原型**：物件從物件繼承，而非類別
- **事件驅動**：單執行緒與事件迴圈，而非多執行緒
- **一等公民函數**：函數是值，可隨意傳遞
- **無所不在**：在瀏覽器、伺服器、行動裝置、桌面任何地方運行

**JavaScript 的強大之處：**
- 快速開發並立即回饋
- 全端開發的通用語言
- 龐大的生態系（npm 套件）
- 現代語法（ES6+）使程式碼簡潔易讀
- 可擴展應用的非同步程設模型

**你將學到：**
- 現代 JavaScript（ES6+）語法和功能
- 函數式和物件導向程式設計模式
- Promise 和 async/await 的非同步程設
- DOM 操作的前端開發
- Node.js 的後端開發
- 最佳實踐和常見模式

在接下來的模組中，我們將深入探討 JavaScript 語法，從與 Java 的基本比較開始。準備好看 JavaScript 的靈活性和簡單性如何提高你的生產力！

準備好開始學習 JavaScript 了嗎？讓我們從**模組 1：基本語法比較**開始吧！
