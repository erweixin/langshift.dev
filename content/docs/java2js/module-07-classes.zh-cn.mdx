---
title: "模块 7:类与继承"
description: "学习 ES6 类、继承和 JavaScript 中的面向对象模式"
---

## 模块 7:类与继承

JavaScript 在 ES6 (2015) 中引入了类语法,使面向对象编程对 Java 开发者来说更加熟悉。然而,JavaScript 类是原型之上的语法糖,与 Java 类的工作方式不同。

## 学习目标

完成本模块后,你将:
✅ 理解 ES6 类语法
✅ 掌握构造函数和方法
✅ 学习使用 `extends` 进行继承
✅ 理解 `super` 关键字
✅ 了解静态方法和属性
✅ 学习私有字段 (ES2022)

## 类语法

<UniversalEditor title="类定义比较">
```java !! java
// Java - 传统类
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void greet() {
        System.out.println("Hello, I'm " + name);
    }
}

// 使用
User user = new User("John", 25);
user.greet();
```

```javascript !! js
// JavaScript - ES6 类语法
class User {
    // 字段声明 (ES2022+)
    name;
    age;

    // 构造函数
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    // 实例方法
    greet() {
        console.log(`Hello, I'm ${this.name}`);
    }

    // Getter
    get info() {
        return `${this.name} (${this.age})`;
    }

    // Setter
    set setName(name) {
        this.name = name;
    }
}

// 使用
const user = new User("John", 25);
user.greet();  // "Hello, I'm John"
console.log(user.info);  // "John (25)"

// 类是一等公民
const UserClass = User;
const user2 = new UserClass("Jane", 30);
```
</UniversalEditor>

### 提升

<UniversalEditor title="类提升">
```java !! java
// Java - 没有提升
User user = new User();  // 如果 User 未定义则编译错误

public class User {
    // ...
}
```

```javascript !! js
// JavaScript - 类不会被提升
// ❌ 错误:在声明前使用类
const user = new User();  // ReferenceError

class User {
    constructor(name) {
        this.name = name;
    }
}

// ✅ 正确:先声明类
class User2 {
    constructor(name) {
        this.name = name;
    }
}

const user2 = new User2("John");  // 可以工作

// 函数声明会被提升
const user3 = createUser("Bob");  // 可以工作!

function createUser(name) {
    return { name };
}
```
</UniversalEditor>

### 类表达式

<UniversalEditor title="类表达式">
```java !! java
// Java - 匿名类
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Running");
    }
};

// Lambda (Java 8+)
Runnable r2 = () -> System.out.println("Running");
```

```javascript !! js
// JavaScript - 类表达式
const User = class {
    constructor(name) {
        this.name = name;
    }

    greet() {
        console.log(`Hi, ${this.name}`);
    }
};

const user = new User("John");
user.greet();

// 命名类表达式(更适合调试)
const User2 = class UserClass {
    constructor(name) {
        this.name = name;
    }
};

// 可以立即导出
export default class {
    constructor() {
        // ...
    }
}
```
</UniversalEditor>

## 继承

<UniversalEditor title="继承比较">
```java !! java
// Java - Extends 关键字
public class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    public void speak() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    private String breed;

    public Dog(String name, String breed) {
        super(name);  // 调用父类构造函数
        this.breed = breed;
    }

    @Override
    public void speak() {
        System.out.println("Woof!");
    }

    public void fetch() {
        System.out.println("Fetching!");
    }
}
```

```javascript !! js
// JavaScript - Extends 关键字(类似语法)
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log("Some sound");
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);  // 必须在使用 'this' 之前调用 super
        this.breed = breed;
    }

    speak() {
        console.log("Woof!");
    }

    fetch() {
        console.log("Fetching!");
    }
}

const dog = new Dog("Buddy", "Labrador");
dog.speak();  // "Woof!"
dog.fetch();  // "Fetching!"
console.log(dog instanceof Dog);     // true
console.log(dog instanceof Animal);  // true
```
</UniversalEditor>

### Super 关键字

<UniversalEditor title="Super 关键字使用">
```java !! java
// Java - Super 用于调用父类方法
public class Dog extends Animal {
    @Override
    public void speak() {
        super.speak();  // 调用父类方法
        System.out.println("Woof!");
    }

    public void displayInfo() {
        System.out.println(super.name);  // 访问父类字段
    }
}
```

```javascript !! js
// JavaScript - Super 关键字

class Parent {
    constructor(name) {
        this.name = name;
    }

    greet() {
        return `Hello, I'm ${this.name}`;
    }

    static getType() {
        return "Parent";
    }
}

class Child extends Parent {
    constructor(name, age) {
        super(name);  // 调用父类构造函数(必需!)
        this.age = age;
    }

    greet() {
        // 调用父类方法
        const parentGreeting = super.greet();
        return `${parentGreeting} and I'm ${this.age}`;
    }

    // 重写静态方法
    static getType() {
        return `${super.getType()} -> Child`;
    }
}

const child = new Child("John", 25);
console.log(child.greet());  // "Hello, I'm John and I'm 25"
console.log(Child.getType());  // "Parent -> Child"

// 对象字面量中的 super
const parent = {
    greet() {
        return "Hello from parent";
    }
};

const child2 = {
    __proto__: parent,
    greet() {
        return super.greet() + " and child";
    }
};

console.log(child2.greet());  // "Hello from parent and child"
```
</UniversalEditor>

## 静态成员

<UniversalEditor title="静态方法和属性">
```java !! java
// Java - 静态成员
public class MathUtil {
    private static final double PI = 3.14159;

    public static double circleArea(double radius) {
        return PI * radius * radius;
    }

    public static class Constants {
        public static final String APP_NAME = "MyApp";
    }
}

// 使用
double area = MathUtil.circleArea(5.0);
String name = MathUtil.Constants.APP_NAME;
```

```javascript !! js
// JavaScript - 静态方法和属性

class MathUtil {
    // 静态属性 (ES2022+)
    static PI = 3.14159;

    // 静态方法
    static circleArea(radius) {
        return this.PI * radius * radius;
    }

    // 静态方法不能访问实例属性
    static notValid() {
        // console.log(this.name);  // 错误:undefined
    }
}

// 使用(无需实例化)
console.log(MathUtil.PI);  // 3.14159
console.log(MathUtil.circleArea(5));  // 78.53975

// 静态代码块 (ES2022+)
class AppConfig {
    static config = {};

    static {
        // 在类定义时运行一次
        this.config = {
            apiUrl: "https://api.example.com",
            timeout: 5000
        };
        console.log("Config initialized");
    }

    static get(key) {
        return this.config[key];
    }
}

console.log(AppConfig.get("apiUrl"));  // "https://api.example.com"

// 静态方法与继承
class Parent {
    static staticMethod() {
        return "Parent";
    }
}

class Child extends Parent {
    static staticMethod() {
        // 调用父类静态方法
        return `${super.staticMethod()} -> Child`;
    }
}

console.log(Child.staticMethod());  // "Parent -> Child"
```
</UniversalEditor>

## 私有字段

<UniversalEditor title="私有字段">
```java !! java
// Java - 私有字段
public class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            this.balance += amount;
        }
    }

    public double getBalance() {
        return this.balance;
    }
}
```

```javascript !! js
// JavaScript - 私有字段 (ES2022+)
class BankAccount {
    // 私有字段(用 # 声明)
    #balance;

    constructor(initialBalance) {
        this.#balance = initialBalance;
    }

    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
        }
    }

    getBalance() {
        return this.#balance;
    }

    // 私有方法 (ES2022+)
    #validateAmount(amount) {
        return amount > 0 && !isNaN(amount);
    }

    withdraw(amount) {
        if (this.#validateAmount(amount)) {
            this.#balance -= amount;
        }
    }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account.#balance);      // 语法错误!(真正私有)

// 私有字段不会被继承
class SavingsAccount extends BankAccount {
    #interestRate;

    constructor(initialBalance, interestRate) {
        super(initialBalance);
        this.#interestRate = interestRate;
    }

    addInterest() {
        const balance = this.getBalance();
        const interest = balance * this.#interestRate;
        this.deposit(interest);
    }
}

// 在私有字段之前:使用 _ 约定
class User {
    constructor(name) {
        this._name = name;  // 仅通过约定实现私有
    }

    getName() {
        return this._name;
    }
}
```
</UniversalEditor>

## Getter 和 Setter

<UniversalEditor title="属性 Getter 和 Setter">
```java !! java
// Java - Getter 和 setter
public class User {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        }
    }
}
```

```javascript !! js
// JavaScript - Getter 和 setter
class User {
    constructor(name, age) {
        this._name = name;  // 支持属性的约定
        this._age = age;
    }

    // Getter
    get name() {
        return this._name;
    }

    // Setter
    set name(value) {
        if (value && value.trim().length > 0) {
            this._name = value;
        }
    }

    get age() {
        return this._age;
    }

    set age(value) {
        if (value >= 0) {
            this._age = value;
        }
    }

    // 计算属性
    get info() {
        return `${this._name} is ${this._age} years old`;
    }
}

const user = new User("John", 25);

// 像属性一样访问(不是方法!)
console.log(user.name);  // "John" (调用 getter)
user.name = "Jane";       // 调用 setter
console.log(user.name);  // "Jane"
user.name = "";          // 验证失败
console.log(user.name);  // "Jane" (未改变)

console.log(user.info);  // "Jane is 25 years old"

// 对象字面量也支持 getter/setter
const person = {
    _firstName: "John",
    _lastName: "Doe",

    get fullName() {
        return `${this._firstName} ${this._lastName}`;
    },

    set fullName(value) {
        [this._firstName, this._lastName] = value.split(" ");
    }
};

console.log(person.fullName);  // "John Doe"
person.fullName = "Jane Smith";
console.log(person.fullName);  // "Jane Smith"
```
</UniversalEditor>

## 实例 vs 静态 vs 私有

<UniversalEditor title="成员类型总结">
```java !! java
// Java - 成员类型
public class Example {
    private int instanceField;        // 实例
    private static int staticField;   // 静态

    public void instanceMethod() { }

    public static void staticMethod() { }
}
```

```javascript !! js
// JavaScript - 所有成员类型

class Example {
    // 公共实例字段
    instanceField = 1;

    // 静态字段
    static staticField = 2;

    // 私有实例字段
    #privateField = 3;

    // 静态私有字段
    static #staticPrivate = 4;

    // 实例方法
    instanceMethod() {
        console.log(this.instanceField);  // ✓ 可访问
        console.log(this.#privateField);  // ✓ 可访问
        console.log(Example.staticField); // ✓ 可访问
        // console.log(Example.#staticPrivate);  // ✗ 不能访问私有静态
    }

    // 静态方法
    static staticMethod() {
        console.log(this.staticField);   // ✓ 可访问
        console.log(this.#staticPrivate); // ✓ 可访问
        // console.log(this.instanceField); // ✗ 不能访问实例
    }
}

const ex = new Example();
ex.instanceMethod();
Example.staticMethod();

// 访问成员
console.log(ex.instanceField);  // 1
console.log(Example.staticField);  // 2
// console.log(ex.#privateField);  // 语法错误!
```
</UniversalEditor>

## 方法重写和多态

<UniversalEditor title="方法重写">
```java !! java
// Java - 方法重写
public class Animal {
    public void speak() {
        System.out.println("Animal sound");
    }

    public void perform() {
        speak();  // 调用子类中的重写版本
    }
}

public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}

Dog dog = new Dog();
dog.perform();  // "Woof!" (多态调用)
```

```javascript !! js
// JavaScript - 方法重写(工作方式类似)

class Animal {
    speak() {
        console.log("Animal sound");
    }

    perform() {
        this.speak();  // 多态 - 调用子类版本
    }
}

class Dog extends Animal {
    speak() {
        console.log("Woof!");
    }
}

const dog = new Dog();
dog.perform();  // "Woof!"

// 显式调用父类方法
class Dog2 extends Animal {
    speak() {
        super.speak();  // "Animal sound"
        console.log("Woof!");
    }
}

const dog2 = new Dog2();
dog2.speak();  // "Animal sound" 然后 "Woof!"
```
</UniversalEditor>

## 常见模式

### 模式 1: 单例

<UniversalEditor title="单例模式">
```java !! java
// Java - 单例
public class Database {
    private static Database instance;

    private Database() {
        // 私有构造函数
    }

    public static synchronized Database getInstance() {
        if (instance == null) {
            instance = new Database();
        }
        return instance;
    }
}
```

```javascript !! js
// JavaScript - 使用类的单例

class Database {
    constructor() {
        if (Database.instance) {
            return Database.instance;
        }
        this.connection = "connected";
        Database.instance = this;
    }

    static getInstance() {
        if (!Database.instance) {
            Database.instance = new Database();
        }
        return Database.instance;
    }
}

const db1 = Database.getInstance();
const db2 = Database.getInstance();
console.log(db1 === db2);  // true

// 更简单:使用对象字面量
const config = Object.freeze({
    apiUrl: "https://api.example.com",
    timeout: 5000
});
```
</UniversalEditor>

### 模式 2: Mixin 模式

<UniversalEditor title="Mixin 模式">
```java !! java
// Java - 不支持多重继承
// 使用接口实现类似行为
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    public void fly() { /* ... */ }
    public void swim() { /* ... */ }
}
```

```javascript !! js
// JavaScript - Mixin 模式

const Flyable = {
    fly() {
        console.log("Flying!");
    }
};

const Swimmable = {
    swim() {
        console.log("Swimming!");
    }
};

class Duck {}
Object.assign(Duck.prototype, Flyable, Swimmable);

const duck = new Duck();
duck.fly();   // "Flying!"
duck.swim();  // "Swimming!"

// Mixin 工厂函数
function mix(...mixins) {
    return function(targetClass) {
        Object.assign(targetClass.prototype, ...mixins);
        return targetClass;
    };
}

class Bird {}
const MixedBird = mix(Flyable)(Bird);

const bird = new MixedBird();
bird.fly();  // "Flying!"
```
</UniversalEditor>

### 模式 3: 类的工厂模式

<UniversalEditor title="使用类的工厂模式">
```javascript !! js
// 抽象基类
class Vehicle {
    constructor(make, model) {
        if (this.constructor === Vehicle) {
            throw new Error("Abstract class cannot be instantiated");
        }
        this.make = make;
        this.model = model;
    }

    // 抽象方法
    start() {
        throw new Error("Must implement start()");
    }
}

class Car extends Vehicle {
    start() {
        console.log(`${this.make} ${this.model} is starting`);
    }
}

class Motorcycle extends Vehicle {
    start() {
        console.log(`${this.make} ${this.model} vroom!`);
    }
}

// 工厂函数
function createVehicle(type, make, model) {
    switch (type) {
        case "car":
            return new Car(make, model);
        case "motorcycle":
            return new Motorcycle(make, model);
        default:
            throw new Error("Unknown vehicle type");
    }
}

const car = createVehicle("car", "Toyota", "Camry");
car.start();  // "Toyota Camry is starting"
```
</UniversalEditor>

## 最佳实践

<UniversalEditor title="类最佳实践">
```java !! java
// Java: 清晰的封装
public class User {
    private final String name;  // 不可变
    private int age;

    public User(String name, int age) {
        this.name = Objects.requireNonNull(name);
        this.age = age;
    }

    public String getName() {
        return name;
    }

    // setter 中的验证
    public void setAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        this.age = age;
    }
}
```

```javascript !! js
// JavaScript: 类似原则

// 1. 为具有行为的对象使用类
class User {
    // 使用私有字段 (ES2022+)
    #name;
    #age;

    constructor(name, age) {
        this.#name = name;
        this.#age = age;
    }

    get name() {
        return this.#name;
    }

    get age() {
        return this.#age;
    }

    set age(value) {
        if (value >= 0) {
            this.#age = value;
        }
    }
}

// 2. 简单数据使用对象字面量
const config = { apiUrl: "https://api.example.com" };

// 3. 优先使用组合而非继承
// 好
class TodoApp {
    constructor(storage, logger) {
        this.storage = storage;
        this.logger = logger;
    }
}

// 避免:深层继承链
// 不好
class Animal {}
class Mammal extends Animal {}
class Dog extends Mammal {}
class Labrador extends Dog {}

// 4. 静态方法用于工具函数
class MathUtils {
    static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
}

// 5. getter/setter 用于计算或验证属性
class Temperature {
    #celsius;

    get celsius() {
        return this.#celsius;
    }

    set celsius(value) {
        this.#celsius = value;
    }

    get fahrenheit() {
        return (this.#celsius * 9/5) + 32;
    }

    set fahrenheit(value) {
        this.#celsius = (value - 32) * 5/9;
    }
}

// 6. 总是在子类构造函数中调用 super()
class Child extends Parent {
    constructor(name) {
        super(name);  // 必须是第一行
        // ...
    }
}
```
</UniversalEditor>

## 练习

### 练习 1: 创建类
```javascript
// 创建一个 Rectangle 类,包含:
// - width, height 属性
// - area() 方法
// - perimeter() 方法
// - get isSquare() getter
```

### 练习 2: 继承
```javascript
// 创建 Shape 基类
// 创建 Circle 和 Rectangle 子类
// 每个类都应该有 area() 方法
```

### 练习 3: 私有字段
```javascript
// 创建 BankAccount 类,包含:
// - 私有 #balance 字段
// - deposit() 和 withdraw() 方法
// - 对负数的验证
```

### 练习 4: 静态方法
```javascript
// 创建 MathUtility 类,包含:
// - 静态方法: clamp(), lerp(), randomInRange()
// - 无需实例化即可使用
```

## 总结

### 关键要点

1. **类语法:**
   - 原型之上的语法糖
   - 不会被提升(不像函数)
   - 可以命名或匿名

2. **继承:**
   - `extends` 用于继承
   - `super` 调用父类
   - 必须在 `this` 之前调用 `super()`

3. **静态成员:**
   - `static` 关键字
   - 通过类名访问
   - 不需要实例化

4. **私有字段:**
   - `#` 前缀 (ES2022+)
   - 真正封装
   - 不能在类外访问

5. **Getter/Setter:**
   - 计算属性
   - 验证
   - 封装

6. **最佳实践:**
   - 类用于行为,对象用于数据
   - 优先使用组合而非深层继承
   - 使用私有字段实现真正封装
   - 静态方法用于工具函数

### 比较表: Java vs JavaScript

| 特性 | Java | JavaScript |
|---------|------|------------|
| **语法** | `class Name { }` | 相同 (ES6+) |
| **继承** | `extends` (单一) | `extends` (单一) |
| **接口** | 支持 | 不支持 (使用协议) |
| **抽象** | `abstract` 关键字 | 手动强制 |
| **私有** | `private` 关键字 | `#` 前缀 (ES2022+) |
| **受保护** | `protected` 关键字 | 约定 (`_name`) |
| **静态** | `static` 关键字 | 相同 |
| **最终** | `final` 关键字 | 不支持 (使用 Object.freeze) |
| **Super** | `super.method()` | 相同 |
| **构造函数** | 与类同名 | `constructor()` |

## 下一步?

你已经掌握了 JavaScript 类!接下来是 **模块 8: 原型和原型链**,我们将探索:

- 原型如何在底层工作
- 原型链查找
- Object.create() 和原型继承
- 构造函数
- 类和原型之间的关系
- 何时使用原型 vs 类

准备理解 JavaScript 的原型系统了吗?让我们继续!
