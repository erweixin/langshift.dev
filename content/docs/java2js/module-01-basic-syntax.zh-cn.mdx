---
title: "模块 1：基本语法比较"
description: "学习 JavaScript 变量、数据类型、运算符和与 Java 相比的基本语法"
---

## 模块 1：基本语法比较

欢迎首次深入了解 JavaScript 语法！作为 Java 开发者，你会发现许多熟悉的概念，但 JavaScript 有一些重要的差异使其独一无二。

## 学习目标

完成本模块后，你将：
✅ 理解 JavaScript 变量声明（var、let、const）
✅ 了解 Java 的静态类型和 JavaScript 的动态类型之间的差异
✅ 掌握 JavaScript 的原始类型和引用类型
✅ 理解类型强制转换以及如何避免常见陷阱
✅ 学习 JavaScript 运算符及其特性

## 变量声明

### Java 变量

在 Java 中，变量是显式类型的：

<UniversalEditor title="变量声明：Java vs JavaScript">
```java !! java
// Java - 显式类型声明
String name = "John";
int age = 25;
double salary = 50000.50;
boolean isActive = true;
char grade = 'A';

// Final 变量（不能重新赋值）
final String CITY = "New York";
// CITY = "Boston";  // 编译错误！

// Null 值
String middleName = null;

// 使用 var 的类型推断（Java 10+）
var username = "johndoe";  // 类型推断为 String
// username = 42;  // 编译错误！
```

```javascript !! js
// JavaScript - 无类型声明
let name = "John";
let age = 25;
let salary = 50000.50;
let isActive = true;

// 常量（不能重新赋值）
const CITY = "New York";
// CITY = "Boston";  // TypeError: Assignment to constant variable

// 无需显式 null 声明
let middleName = null;
let middleName2 = undefined;

// 类型是动态的
let username = "johndoe";
username = 42;  // 有效！类型变为 number
username = true;  // 现在是 boolean
```
</UniversalEditor>

### JavaScript 变量关键字

JavaScript 有三种声明变量的方式：

#### 1. `var`（旧方式 - 在现代代码中避免使用）

<UniversalEditor title="var 的行为和问题">
```javascript !! js
// var - 函数作用域（非块作用域）
function example() {
    if (true) {
        var x = 10;
    }
    console.log(x);  // 10 - 在 if 块外可访问！
}

// var 可以重新声明
var name = "John";
var name = "Jane";  // 没有错误！

// var 变量提升
console.log(y);  // undefined（不是错误！）
var y = 5;

// 这等价于：
var y;  // 声明提升到顶部
console.log(y);
y = 5;  // 赋值留在这里

// 不要在现代代码中使用 var！
// 改用 let 和 const
```
</UniversalEditor>

#### 2. `let`（现代方式，用于可变变量）

<UniversalEditor title="let 的使用">
```javascript !! js
// let - 块作用域（类似 Java）
function example() {
    if (true) {
        let x = 10;
        console.log(x);  // 10
    }
    console.log(x);  // ReferenceError: x is not defined
}

// let 不能在同一作用域重新声明
let name = "John";
// let name = "Jane";  // SyntaxError!

// 但可以重新赋值
let age = 25;
age = 26;  // 有效

// let 用于 for 循环（块作用域）
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// 输出：0、1、2（每次迭代都有自己的 i）

// 与 var 比较（函数作用域）
for (var j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 100);
}
// 输出：3、3、3（共享 j 引用）
```
</UniversalEditor>

#### 3. `const`（现代方式，用于常量）

<UniversalEditor title="const 的使用">
```javascript !! js
// const - 块作用域，不能重新赋值
const PI = 3.14159;
// PI = 3.14;  // TypeError: Assignment to constant variable

// 必须初始化
const name;  // SyntaxError: Missing initializer

// 对象和数组仍然可以修改（不能重新赋值）
const person = { name: "John", age: 25 };
person.name = "Jane";  // 有效！对象被修改
person.age = 26;  // 有效！

// person = {};  // TypeError: Cannot reassign const

const numbers = [1, 2, 3];
numbers.push(4);  // 有效！数组被修改
// numbers = [];  // TypeError: Cannot reassign const

// 防止修改，使用 Object.freeze()
const frozenPerson = Object.freeze({ name: "John", age: 25 });
frozenPerson.name = "Jane";  // 静默失败（严格模式：错误）
console.log(frozenPerson.name);  // "John"
```
</UniversalEditor>

### 最佳实践：何时使用什么

<UniversalEditor title="变量声明最佳实践">
```java !! java
// Java - 尽可能使用 final
public class User {
    private final String name;  // 对常量使用 final
    private int age;            // 可变字段使用常规方式

    public User(String name) {
        this.name = name;  // 一次赋值
    }

    public void setAge(int age) {
        this.age = age;  // 可以改变
    }
}
```

```javascript !! js
// JavaScript - 优先使用 const，需要时使用 let
// 1. 默认使用 const（大多数变量不需要改变）
const API_URL = "https://api.example.com";
const MAX_RETRIES = 3;

// 2. 需要重新赋值时使用 let
let counter = 0;
counter++;

let userData = null;
userData = fetchUserData();

// 3. 完全避免 var（它是函数作用域且令人困惑）
// ❌ 不要这样做：
var i = 0;

// ✅ 改为这样做：
let i = 0;
```
</UniversalEditor>

## 数据类型

### 原始类型

JavaScript 有 7 种原始类型（Java 有 8 种）：

<UniversalEditor title="原始类型比较">
```java !! java
// Java 原始类型
byte b = 127;                // 8 位整数
short s = 32767;             // 16 位整数
int i = 2147483647;          // 32 位整数
long l = 9223372036854775807L;  // 64 位整数
float f = 3.14f;             // 32 位浮点数
double d = 3.14159265359;    // 64 位浮点数
char c = 'A';                // 16 位 Unicode 字符
boolean bool = true;         // true 或 false

// Java 也有 void（无值）
```

```javascript !! js
// JavaScript 原始类型（更简单！）
let num = 42;                // Number（所有数字都是 64 位浮点数）
let pi = 3.14159265359;      // Number（没有 int/float 区别）
let bigInt = 9007199254740991n;  // BigInt（用于大整数）

let str = "Hello";           // String（可以使用 " 或 ' 或 `）
let char = 'A';              // 仍然是 String（单个字符也是字符串）

let bool = true;             // Boolean（true 或 false）

let nothing = null;          // Null（有意为空）
let undefinedVar = undefined; // Undefined（无意为空）

let symbol = Symbol('id');   // Symbol（唯一标识符，ES6+）
```
</UniversalEditor>

### Number 类型

JavaScript 只有一种数字类型（与 Java 不同）：

<UniversalEditor title="Number 类型差异">
```java !! java
// Java - 多种数字类型
int integer = 42;
double decimal = 3.14;
long bigNumber = 9007199254740991L;

// 类型提升
int a = 5;
int b = 2;
int result = a / b;  // result = 2（整数除法）

// 显式转换
double x = 3.7;
int y = (int) x;  // y = 3（截断）
```

```javascript !! js
// JavaScript - 单一 Number 类型（IEEE 754 64 位浮点数）
let integer = 42;
let decimal = 3.14;
let scientific = 1.5e-4;  // 0.00015
let hex = 0xFF;           // 255
let binary = 0b1010;      // 10
let octal = 0o755;        // 493

// 除法总是产生浮点数
let a = 5;
let b = 2;
let result = a / b;  // result = 2.5（不是 2！）

// Number 方法
let num = 42.123;
console.log(num.toFixed(2));  // "42.12"
console.log(Math.round(num)); // 42
console.log(Math.floor(num)); // 42

// 特殊数值
let infinity = Infinity;
let negInfinity = -Infinity;
let notANumber = NaN;  // Not-a-Number

console.log(0 / 0);           // NaN
console.log(1 / 0);           // Infinity
console.log(Math.sqrt(-1));   // NaN

// 检查 NaN（重要！）
console.log(NaN === NaN);  // false（NaN 不等于自身！）
console.log(Number.isNaN(NaN));  // true
console.log(Number.isFinite(42));  // true
console.log(Number.isFinite(Infinity));  // false
```
</UniversalEditor>

### String 类型

JavaScript 字符串与 Java 字符串类似，但更加灵活：

<UniversalEditor title="String 比较">
```java !! java
// Java 字符串是不可变的
String name = "John";
name.toUpperCase();  // 返回 "JOHN" 但 name 仍是 "John"
name = name.toUpperCase();  // 现在 name 是 "JOHN"

// 字符串连接
String greeting = "Hello, " + name;

// 多行字符串（Java 15+）
String multiline = """
    This is a
    multiline string
    """;

// 字符串方法
String text = "JavaScript";
System.out.println(text.length());           // 10
System.out.println(text.substring(0, 4));    // "Java"
System.out.println(text.contains("Script")); // true
```

```javascript !! js
// JavaScript 字符串是不可变的（与 Java 相同）
let name = "John";
name.toUpperCase();  // 返回 "JOHN" 但 name 仍是 "John"
name = name.toUpperCase();  // 现在 name 是 "JOHN"

// 字符串连接（多种方式）
let greeting = "Hello, " + name;
let greeting2 = `Hello, ${name}`;  // 模板字面量（推荐）

// 多行字符串（模板字面量）
const multiline = `This is a
multiline string`;

// 字符串方法
const text = "JavaScript";
console.log(text.length);              // 10
console.log(text.substring(0, 4));     // "Java"
console.log(text.includes("Script"));  // true
console.log(text.startsWith("Java"));  // true
console.log(text.endsWith("Script"));  // true
console.log(text.split('a'));          // ["J", "v", "Script"]

// 返回修改后字符串的字符串方法
console.log(text.toUpperCase());       // "JAVASCRIPT"
console.log(text.toLowerCase());       // "javascript"
console.log(text.trim());              // 删除空格
console.log(text.replace("Java", "ECMA"));  // "ECMAScript"

// 带表达式的模板字面量
const x = 10;
const y = 20;
console.log(`${x} + ${y} = ${x + y}`);  // "10 + 20 = 30"
```
</UniversalEditor>

### Boolean 类型和真值/假值

这是与 Java 的一个主要差异！

<UniversalEditor title="Boolean 和真值/假值">
```java !! java
// Java - 严格的 boolean 检查
boolean isActive = true;
boolean isInactive = false;

// 只有 boolean 表达式可以在条件中使用
String name = "John";
if (name != null && !name.isEmpty()) {  // 必须显式检查
    System.out.println("Name exists");
}

// 没有真值/假值 - 必须明确
int count = 0;
if (count > 0) {  // 不能仅使用 "if (count)"
    System.out.println("Count is positive");
}
```

```javascript !! js
// JavaScript - Boolean 加上真值/假值
let isActive = true;
let isInactive = false;

// 假值（在 boolean 上下文中评估为 false）：
false, 0, -0, 0n, "", null, undefined, NaN

// 真值（其他所有值）：
true, 42, "hello", {}, [], function() {}

// 短路求值
const name = "John";
if (name) {  // name 是真值（非空字符串）
    console.log("Name exists");
}

const count = 0;
if (count) {  // count 是假值（零）
    console.log("Count is positive");
} else {
    console.log("Count is zero or negative");
}

// 常见模式：默认值
function greet(name) {
    // 如果 name 是假值，使用 "Guest"
    const displayName = name || "Guest";
    console.log(`Hello, ${displayName}`);
}

greet("John");  // "Hello, John"
greet("");      // "Hello, Guest"
greet(null);    // "Hello, Guest"

// 空值合并运算符（ES2020）
// 仅检查 null/undefined（不包括 0 或 ""）
function greet2(name) {
    const displayName = name ?? "Guest";
    console.log(`Hello, ${displayName}`);
}

greet2("");  // "Hello, "（空字符串不是 null/undefined）
greet2(null);  // "Hello, Guest"

// Boolean 转换
console.log(Boolean("hello"));  // true
console.log(Boolean(""));       // false
console.log(Boolean(42));       // true
console.log(Boolean(0));        // false
console.log(Boolean({}));  // true（空对象是真值！）
console.log(Boolean([]));       // true（空数组是真值！）
```
</UniversalEditor>

### Null vs Undefined

两种表示"无值"的方式：

<UniversalEditor title="Null vs Undefined">
```java !! java
// Java - 只有 null
String name = null;
int[] numbers = null;

// 不能有 undefined - 一切都被初始化
// int x;  // 使用前必须初始化
int x = 0;  // 原始类型的默认值

// Optional 类型（Java 8+）
Optional<String> optionalName = Optional.of("John");
Optional<String> emptyOptional = Optional.empty();
```

```javascript !! js
// JavaScript - 既有 null 又有 undefined

// undefined：变量已声明但未赋值
let x;
console.log(x);  // undefined

// null：有意设置为无值
let y = null;
console.log(y);  // null

// 关键差异：
console.log(typeof undefined);  // "undefined"
console.log(typeof null);       // "object"（历史 bug！）

// 转换为数字
console.log(Number(undefined));  // NaN
console.log(Number(null));       // 0

// 宽松相等（避免使用！）
console.log(null == undefined);   // true
console.log(null === undefined);  // false（使用严格相等）

// 最佳实践：
// 使用 null 表示"有意为空"
function getUser(id) {
    const user = database.find(id);
    return user !== undefined ? user : null;
}

// 使用 undefined 表示"未设置"
function process(options) {
    // 如果 options.timeout 未提供
    if (options.timeout === undefined) {
        options.timeout = 5000;  // 使用默认值
    }
}

// 检查 null/undefined
function safeGet(obj) {
    // 旧方法
    if (obj !== null && obj !== undefined) {
        return obj.value;
    }

    // 现代方法（检查 null 和 undefined）
    if (obj != null) {  // 宽松相等在这里可行
        return obj.value;
    }

    // 或使用空值合并
    return obj?.value;
}
```
</UniversalEditor>

## 类型强制转换

JavaScript 在某些上下文中自动转换类型 - 这是 bug 的主要来源！

<UniversalEditor title="类型强制转换示例">
```java !! java
// Java - 几乎没有类型强制转换
String result = "10" + 5;  // "105"（字符串连接）
// int result = "10" + 5;   // 编译错误！

// 必须显式转换
int num = Integer.parseInt("10");
String str = String.valueOf(42);

// Boolean 是严格的
boolean b = (1 == 2);  // false
// boolean b2 = 1;  // 编译错误！
```

```javascript !! js
// JavaScript - 自动类型强制转换
console.log("10" + 5);    // "105"（字符串连接）
console.log("10" - 5);    // 5（减法转换为数字）
console.log("10" * 5);    // 50（乘法转换为数字）
console.log("10" / 5);    // 2（除法转换为数字）

// 字符串连接技巧
console.log(1 + "2");      // "12"
console.log(1 + 2 + "3");  // "33" (1+2=3, then "3"+"3"="33")
console.log("1" + 2 + 3);  // "123"

// 宽松相等（==）带有强制转换
console.log(5 == "5");     // true（字符串转换为数字）
console.log(0 == "");      // true（空字符串转换为 0）
console.log(0 == "0");     // true
console.log(false == 0);   // true
console.log(null == undefined);  // true

// 严格相等（===）- 无强制转换
console.log(5 === "5");    // false（不同类型）
console.log(0 === "");     // false
console.log(false === 0);  // false
console.log(null === undefined);  // false

// 始终使用严格相等（=== 和 !==）
function compare(a, b) {
    // ❌ 不好：宽松相等
    if (a == b) {  // 可能有意外行为
        // ...
    }

    // ✅ 好：严格相等
    if (a === b) {  // 清晰的类型检查
        // ...
    }
}

// 显式类型转换
let str = "42";
let num = Number(str);        // 42（如果无效则 NaN）
let num2 = parseInt(str);     // 42（仅整数）
let num3 = parseFloat("3.14"); // 3.14

let numToStr = String(42);     // "42"
let numToStr2 = 42.toString();  // "42"
let numToStr3 = (42).toString(); // "42"（字面量需要括号）

let toBool = Boolean("hello");  // true
let toBool2 = !!"hello";        // true（双重否定技巧）
```
</UniversalEditor>

## 运算符

大多数运算符与 Java 类似，但 JavaScript 有一些独特的：

<UniversalEditor title="运算符比较">
```java !! java
// Java 运算符
int a = 10, b = 3;

// 算术
int sum = a + b;        // 13
int diff = a - b;       // 7
int prod = a * b;       // 30
int quot = a / b;       // 3（整数除法）
int rem = a % b;        // 1

// 比较
boolean equal = (a == b);     // false
boolean notEqual = (a != b);  // true
boolean greater = (a > b);    // true
boolean lessOrEqual = (a <= b);  // false

// 逻辑
boolean and = (true && false);  // false
boolean or = (true || false);   // true
boolean not = !true;            // false

// 位运算
int bitwiseAnd = a & b;    // 2
int bitwiseOr = a | b;     // 11
int bitwiseXor = a ^ b;    // 9
int bitwiseNot = ~a;       // -11
int leftShift = a << 1;    // 20
int rightShift = a >> 1;   // 5

// 三元
int max = (a > b) ? a : b;  // 10

// 自增/自减
a++;  // a = a + 1
b--;  // b = b - 1
```

```javascript !! js
// JavaScript 运算符（类似但有差异）
let a = 10, b = 3;

// 算术（与 Java 相同，但除法产生浮点数）
let sum = a + b;        // 13
let diff = a - b;       // 7
let prod = a * b;       // 30
let quot = a / b;       // 3.333...（非整数除法！）
let rem = a % b;        // 1

// 整数除法（ES2020）
let intQuot = Math.trunc(a / b);  // 3

// 比较（使用严格版本！）
let equal = (a === b);     // false（严格）
let notEqual = (a !== b);  // true（严格）
let greater = (a > b);     // true
let lessOrEqual = (a <= b); // false

// 宽松相等（避免！）
console.log(10 == "10");   // true（强制转换）
console.log(10 === "10");  // false（严格）

// 逻辑运算符（返回实际值，不仅仅是 boolean）
let logicalAnd = true && false;   // false
let logicalAnd2 = 10 && 20;       // 20（返回最后的真值）
let logicalOr = true || false;    // true
let logicalOr2 = 0 || 42;         // 42（返回第一个真值）
let logicalNot = !true;           // false

// 空值合并（ES2020）
let value = null ?? "default";  // "default"（仅用于 null/undefined）
let value2 = 0 ?? "default";    // 0（0 不是 null/undefined）

// 可选链（ES2020）
const user = { name: "John", address: { city: "NYC" } };
console.log(user?.address?.city);  // "NYC"
console.log(user?.phone?.number);  // undefined（无错误）

// 位运算（与 Java 相同）
let bitwiseAnd = a & b;    // 2
let bitwiseOr = a | b;     // 11
let bitwiseXor = a ^ b;    // 9
let bitwiseNot = ~a;       // -11
let leftShift = a << 1;    // 20
let rightShift = a >> 1;   // 5
let unsignedRightShift = a >>> 1;  // 5（仅 JavaScript）

// 幂运算（ES2016）
let power = 2 ** 3;  // 8（2 的 3 次方）
// 等价于：Math.pow(2, 3)

// 三元（与 Java 相同）
let max = (a > b) ? a : b;  // 10

// 自增/自减（与 Java 相同）
a++;  // a = a + 1
b--;  // b = b - 1
++a;  // 前置自增
--b;  // 前置自减

// 一元运算符
let positive = +10;        // 10
let negative = -10;        // -10
let toNumber = +"42";      // 42（将字符串转换为数字）
```
</UniversalEditor>

## typeof 运算符

JavaScript 有一个 `typeof` 运算符来检查类型：

<UniversalEditor title="typeof 运算符">
```java !! java
// Java - 没有 typeof 运算符
// 使用 instanceof 或 getClass()
String str = "hello";
if (str instanceof String) {
    System.out.println("It's a String");
}

// 反射
Class<?> type = str.getClass();
System.out.println(type.getName());  // "java.lang.String"
```

```javascript !! js
// JavaScript - typeof 运算符
let num = 42;
let str = "hello";
let bool = true;
let obj = { name: "John" };
let arr = [1, 2, 3];
let func = function() {};
let nothing = null;
let undef = undefined;

console.log(typeof num);    // "number"
console.log(typeof str);    // "string"
console.log(typeof bool);   // "boolean"
console.log(typeof obj);    // "object"
console.log(typeof arr);    // "object"（数组是对象！）
console.log(typeof func);   // "function"
console.log(typeof nothing); // "object"（历史 bug！）
console.log(typeof undef);   // "undefined"

// 检查 null（需要特殊处理）
function isNull(value) {
    return value === null;
}

// 检查数组
function isArray(value) {
    return Array.isArray(value);
}

// 检查 NaN
function isNaNCheck(value) {
    return Number.isNaN(value);
}

// 模式：类型检查
function process(value) {
    if (typeof value === "string") {
        console.log("Processing string:", value.toUpperCase());
    } else if (typeof value === "number") {
        console.log("Processing number:", value * 2);
    } else if (Array.isArray(value)) {
        console.log("Processing array:", value.length);
    } else if (value === null) {
        console.log("Processing null value");
    } else {
        console.log("Unknown type");
    }
}

process("hello");  // "Processing string: HELLO"
process(42);       // "Processing number: 84"
process([1, 2, 3]); // "Processing array: 3"
process(null);     // "Processing null value"
```
</UniversalEditor>

## 常见陷阱

### 陷阱 1：使用 == 而不是 ===

<UniversalEditor title="相等陷阱">
```javascript !! js
// ❌ 不好：宽松相等
console.log(0 == false);       // true
console.log("" == false);      // true
console.log("0" == false);     // true
console.log(null == undefined); // true
console.log([] == false);      // true
console.log([1] == "1");       // true

// ✅ 好：严格相等
console.log(0 === false);       // false
console.log("" === false);      // false
console.log("0" === false);     // false
console.log(null === undefined); // false
console.log([] === false);      // false
console.log([1] === "1");       // false
```
</UniversalEditor>

### 陷阱 2：忘记 const/let

<UniversalEditor title="变量声明陷阱">
```javascript !! js
// ❌ 不好：使用 var
var name = "John";
if (true) {
    var name = "Jane";  // 在同一作用域重新声明！
}
console.log(name);  // "Jane"（意外！）

// ❌ 不好：忘记 const/let
message = "Hello";  // 创建全局变量（不好）

// ✅ 好：使用 let/const
let name = "John";
if (true) {
    let name = "Jane";  // 块作用域
}
console.log(name);  // "John"（符合预期）

// ✅ 好：始终声明变量
const message = "Hello";  // 正确声明
```
</UniversalEditor>

### 陷阱 3：类型强制转换惊喜

<UniversalEditor title="类型强制转换陷阱">
```javascript !! js
// 陷阱：String + Number
console.log("10" + 20);   // "1020"（字符串连接）
console.log(10 + "20");   // "1020"
console.log(10 + 20 + "30"); // "3030" (10+20=30, then "30"+"30")

// 解决方案：显式转换
console.log(Number("10") + 20);  // 30
console.log("10" + String(20));  // "1020"

// 陷阱：减法转换为数字
console.log("10" - 5);    // 5
console.log("10px" - 5);  // NaN（无法转换 "10px"）
console.log("10" - "5");  // 5

// 解决方案：显式解析
console.log(parseInt("10px") - 5);  // 5
```
</UniversalEditor>

## 最佳实践总结

<UniversalEditor title="最佳实践：变量声明和类型">
```java !! java
// Java：清晰、显式的类型
public class User {
    private final String name;  // 对常量使用 final
    private int age;            // 可变使用常规方式

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public boolean isAdult() {
        return age >= 18;  // 清晰的 boolean 检查
    }
}
```

```javascript !! js
// JavaScript：现代、简洁的语法
class User {
    constructor(name, age) {
        this.name = name;  // 使用 _ 表示私有约定（ES2022 有 #）
        this._age = age;
    }

    isAdult() {
        return this._age >= 18;  // 相同的检查
    }
}

// 变量声明规则
const API_URL = "https://api.example.com";  // 对常量使用 const
let currentUser = null;                      // 对可变变量使用 let
let counter = 0;                             // 对计数器使用 let

// 始终使用严格相等
if (counter === 0) {  // ✅
    // ...
}

// 避免类型强制转换 - 明确一点
const num = Number(str);      // ✅ 显式转换
const sum = a + b;            // ✅ 清晰的操作
const result = `${a}${b}`;    // ✅ 显式字符串连接

// 使用模板字面量
const greeting = `Hello, ${name}!`;  // ✅ 现代语法

// 正确检查 null/undefined
if (user != null) {  // 检查 null 和 undefined（宽松相等可以）
    // 安全访问 user
}

// 或使用可选链
const city = user?.address?.city;  // 安全属性访问
```
</UniversalEditor>

## 练习

### 练习 1：变量声明
将此 Java 代码转换为地道的 JavaScript：
```java
String name = "John";
int age = 25;
final String CITY = "New York";
boolean isActive = true;
```

### 练习 2：类型转换
修复类型强制转换问题：
```javascript
function add(a, b) {
    return a + b;  // 应该相加数字，而不是连接字符串
}

console.log(add(5, "10"));  // 应该输出 15，而不是 "510"
```

### 练习 3：Null/Undefined 处理
编写一个处理 null/undefined 值的函数：
```javascript
function getDisplayName(user) {
    // 如果 user 存在且有 name，返回 user.name
    // 否则返回 "Guest"
}
```

### 练习 4：类型检查
编写一个处理不同类型的函数：
```javascript
function processValue(value) {
    // 如果是 string：返回大写
    // 如果是 number：返回双倍
    // 如果是 boolean：返回取反
    // 如果是 array：返回长度
    // 否则：返回 "unknown"
}
```

## 总结

### 关键要点

1. **变量声明：**
   - 默认使用 `const`（不能重新赋值）
   - 需要重新赋值时使用 `let`
   - 避免 `var`（它是函数作用域且令人困惑）

2. **类型系统：**
   - JavaScript 是动态类型的（无需类型声明）
   - 原始类型：number、string、boolean、null、undefined、symbol、bigint
   - 其他一切都是对象（包括数组和函数）

3. **类型强制转换：**
   - JavaScript 在许多上下文中自动转换类型
   - 始终使用严格相等（`===` 和 `!==`）
   - 明确类型转换

4. **真值/假值：**
   - 假值：`false`、`0`、`""`、`null`、`undefined`、`NaN`
   - 真值：其他所有值（包括 `{}` 和 `[]`）
   - 使用 `??` 进行空值合并，`||` 用于逻辑或

5. **最佳实践：**
   - 优先使用 `const` 而不是 `let`
   - 始终使用严格相等
   - 明确类型转换
   - 使用模板字面量进行字符串插值
   - 使用可选链（`?.`）检查 null/undefined

### 比较表：Java vs JavaScript

| 方面 | Java | JavaScript |
|--------|------|------------|
| **变量声明** | `String name = "John";` | `let name = "John";` 或 `const NAME = "John";` |
| **常量** | `final int MAX = 100;` | `const MAX = 100;` |
| **原始类型数量** | 8 种原始类型 | 7 种原始类型（number、string、boolean、null、undefined、symbol、bigint） |
| **数字类型** | byte、short、int、long、float、double | 只有 `number`（64 位浮点数）+ `bigint` |
| **相等** | `==`（没有宽松相等） | `===`（严格）和 `==`（宽松 - 避免） |
| **类型检查** | `instanceof`、`getClass()` | `typeof`、`Array.isArray()` |
| **类型转换** | 显式：`Integer.parseInt()` | 隐式（强制转换）或显式：`Number()`、`String()` |
| **字符串连接** | `"Hello " + name` | `` `Hello ${name}` ``（模板字面量推荐） |
| **Null 处理** | 只有 `null` | 既有 `null` 又有 `undefined` |

## 下一步？

现在你已经了解了 JavaScript 的基本语法和类型系统，让我们继续学习**模块 2：控制流和循环**，我们将学习 JavaScript 的控制结构与 Java 的比较！

你将发现：
- `if/else` 如何不同（以及如何相同！）
- `switch` 语句的差异
- 循环变体（for、for...of、for...in）
- 数组方法的力量（map、filter、reduce）
- Break 和 continue 行为

让我们继续你的 JavaScript 之旅！
