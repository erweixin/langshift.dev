---
title: "Module 5: Arrays and Collections"
description: "掌握 JavaScript 陣列、Set、Map 和集合方法"
---

## Module 5: Arrays and Collections

JavaScript 的集合類型與 Java 有很大不同。陣列更加靈活，且 JavaScript 提供了 Set 和 Map 等額外的集合類型。讓我們探索這些強大的資料結構。

## Learning Objectives

完成本模組後，你將：
✅ 掌握 JavaScript 陣列的創建和操作
✅ 理解陣列方法（變異 vs 非變異）
✅ 學習 Set 和 Map 資料結構
✅ 知道何時使用 WeakSet 和 WeakMap
✅ 理解陣列解構
✅ 學習效能考量

## Array Basics

JavaScript 陣列更像動態列表，而不是 Java 的固定大小陣列：

<UniversalEditor title="陣列創建和基礎">
```java !! java
// Java - 固定大小陣列
int[] numbers = new int[5];
numbers[0] = 1;
numbers[1] = 2;
// numbers[5] = 3;  // ArrayIndexOutOfBoundsException

// 陣列初始化器
int[] moreNumbers = {1, 2, 3, 4, 5};

// 大小是固定的
System.out.println(numbers.length);  // 5

// 不能改變大小
// 要添加元素需要使用 ArrayList
```

```javascript !! js
// JavaScript - 動態陣列
const numbers = [1, 2, 3, 4, 5];

// 可以添加元素
numbers.push(6);       // 添加到末尾
numbers.unshift(0);    // 添加到開頭

// 可以移除元素
numbers.pop();         // 從末尾移除
numbers.shift();       // 從開頭移除

// 動態長度
console.log(numbers.length);  // 5 (push/pop 之後)

// 混合類型（不推薦但可能）
const mixed = [1, "hello", true, { id: 1 }, [1, 2, 3]];

// 稀疏陣列
const sparse = [1, , , 4];  // 陣列中有空隙
console.log(sparse.length); // 4
console.log(sparse[1]);     // undefined

// 陣列建構函數（避免 - 使用字面語法）
const arr = new Array(5);   // 創建有 5 個空槽的陣列
const arr2 = new Array(1, 2, 3);  // 創建 [1, 2, 3]
// 更好：const arr = [1, 2, 3];
```
</UniversalEditor>

## Array Methods - Mutating vs Non-Mutating

JavaScript 區分修改陣列的方法和創建新陣列的方法：

### Mutating Methods

<UniversalEditor title="變異陣列方法">
```java !! java
// Java - 陣列沒有方法
// 使用 ArrayList 或工具類
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
list.add("d");           // 添加到末尾
list.add(0, "start");    // 在索引處添加
list.remove(0);          // 移除索引處的元素
list.set(0, "x");        // 替換索引處的元素
```

```javascript !! js
// JavaScript - 變異方法

const arr = [1, 2, 3, 4, 5];

// push: 添加到末尾
arr.push(6);
console.log(arr);  // [1, 2, 3, 4, 5, 6]

// pop: 從末尾移除
arr.pop();
console.log(arr);  // [1, 2, 3, 4, 5]

// unshift: 添加到開頭
arr.unshift(0);
console.log(arr);  // [0, 1, 2, 3, 4, 5]

// shift: 從開頭移除
arr.shift();
console.log(arr);  // [1, 2, 3, 4, 5]

// splice: 在任何位置移除/添加
arr.splice(2, 1);  // 在索引 2 處移除 1 個元素
console.log(arr);  // [1, 2, 4, 5]

arr.splice(2, 0, 3);  // 在索引 2 處插入 3
console.log(arr);  // [1, 2, 3, 4, 5]

// sort: 原地排序
arr.sort((a, b) => a - b);
console.log(arr);  // [1, 2, 3, 4, 5]

// reverse: 原地反轉
arr.reverse();
console.log(arr);  // [5, 4, 3, 2, 1]

// fill: 用值填充
arr.fill(0);
console.log(arr);  // [0, 0, 0, 0, 0]
```
</UniversalEditor>

### Non-Mutating Methods

<UniversalEditor title="非變異陣列方法">
```java !! java
// Java - Streams 創建新集合
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

// 原始列表未改變
```

```javascript !! js
// JavaScript - 非變異方法
const numbers = [1, 2, 3, 4, 5];

// map: 轉換為新陣列
const doubled = numbers.map(n => n * 2);
console.log(doubled);    // [2, 4, 6, 8, 10]
console.log(numbers);    // [1, 2, 3, 4, 5] (未改變)

// filter: 選擇元素
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);      // [2, 4]
console.log(numbers);    // [1, 2, 3, 4, 5] (未改變)

// slice: 提取部分
const slice = numbers.slice(1, 4);
console.log(slice);      // [2, 3, 4]

// concat: 合併陣列
const more = [6, 7, 8];
const combined = numbers.concat(more);
console.log(combined);   // [1, 2, 3, 4, 5, 6, 7, 8]

// join: 轉換為字串
const str = numbers.join("-");
console.log(str);        // "1-2-3-4-5"

// flat: 展平嵌套陣列
const nested = [1, [2, [3, [4]]]];
const flat = nested.flat(2);
console.log(flat);       // [1, 2, 3, [4]]
```
</UniversalEditor>

## Set and Map

ES2015 引入了 Set 和 Map 集合類型：

<UniversalEditor title="Set 和 Map">
```java !! java
// Java - HashSet 和 HashMap
Set<String> set = new HashSet<>();
set.add("apple");
set.add("banana");
set.add("apple");  // Duplicate ignored

Map<String, Integer> map = new HashMap<>();
map.put("Alice", 25);
map.put("Bob", 30);
int age = map.get("Alice");  // 25
```

```javascript !! js
// JavaScript - Set
const set = new Set();
set.add("apple");
set.add("banana");
set.add("apple");  // 重複被忽略

console.log(set);  // Set { "apple", "banana" }
console.log(set.has("apple"));  // true
console.log(set.size);  // 2

// 從陣列創建 Set
const numbers = [1, 2, 2, 3, 3, 3];
const unique = new Set(numbers);
console.log(unique);  // Set { 1, 2, 3 }

// Map
const map = new Map();
map.set("Alice", 25);
map.set("Bob", 30);

console.log(map.get("Alice"));  // 25
console.log(map.has("Bob"));    // true
console.log(map.size);          // 2

// Map 可以使用任何類型的鍵
const key1 = { id: 1 };
const key2 = { id: 2 };
map.set(key1, "Value 1");
map.set(key2, "Value 2");

// 物件 vs Map
const obj = {};
const keyObj = { id: 1 };
obj[keyObj] = "value";  // 鍵變為 "[object Object]"
console.log(obj["[object Object]"]);  // "value"

// Map 保留鍵的類型
const map2 = new Map();
map2.set(keyObj, "value");
console.log(map2.get(keyObj));  // "value"
```
</UniversalEditor>

## Array Destructuring

<UniversalEditor title="陣列解構">
```java !! java
// Java - Manual extraction
int[] arr = {1, 2, 3, 4, 5};
int first = arr[0];
int second = arr[1];
int third = arr[2];

// Java 21+ has pattern matching（limited）
Object obj = arr;
if (obj instanceof int[] arr2) {
    System.out.println(arr2[0]);
}
```

```javascript !! js
// JavaScript - Destructuring
const arr = [1, 2, 3, 4, 5];

// Basic destructuring
const [first, second, third] = arr;
console.log(first, second, third);  // 1 2 3

// Skip elements
const [a, , b] = arr;  // Skip second element
console.log(a, b);  // 1 3

// Rest operator
const [head, ...tail] = arr;
console.log(head);  // 1
console.log(tail);  // [2, 3, 4, 5]

// Default values
const [x, y, z = 30] = [10, 20];
console.log(x, y, z);  // 10 20 30

// Swap variables（without temp）
let m = 1, n = 2;
[m, n] = [n, m];
console.log(m, n);  // 2 1

// Destructuring function return
function getStats() {
    return [10, 20, 30];
}

const [min, avg, max] = getStats();
console.log(min, avg, max);  // 10 20 30

// Ignore some values
const [, , , fourth] = arr;
console.log(fourth);  // 4
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="集合最佳實踐">
```javascript !! js
// 1. Use non-mutating methods for immutability
const original = [1, 2, 3];
const modified = [...original, 4];  // Add without mutation
const filtered = original.filter(n => n > 1);  // Filter without mutation

// 2. Use Set for unique values
function unique(array) {
    return [...new Set(array)];
}

// 3. Use Map when keys are not strings
const cache = new Map();
cache.set(objKey, value);  // Works with object keys

// 4. Use spread operator for copying
const copy = [...original];

// 5. Avoid mutating arrays in loops
// Bad
for (const item of arr) {
    arr.push(transform(item));  // Infinite loop!
}

// Good
const result = [];
for (const item of arr) {
    result.push(transform(item));
}

// Or better
const result = arr.map(transform);
```
</UniversalEditor>

## Summary

### Key Takeaways

1. **Arrays:** 動態大小，混合類型
2. **Methods:** 區分變異和非變異
3. **Set/Map:** 現代集合類型
4. **Destructuring:** 簡潔的提取語法

## What's Next?

接下來是 **Module 6: Objects** - 深入了解 JavaScript 物件！
