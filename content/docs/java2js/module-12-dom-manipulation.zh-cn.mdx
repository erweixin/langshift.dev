---
title: "模块 12:DOM 操作"
description: "掌握 DOM 遍历、操作和最佳实践"
---

## 模块 12:DOM 操作

文档对象模型(DOM)是 JavaScript 与 HTML 文档的接口。本模块教你如何动态地与网页交互。

## 学习目标

完成本模块后,你将:
✅ 理解 DOM 结构和遍历
✅ 掌握元素选择方法
✅ 学习修改 DOM 元素
✅ 理解创建和删除元素
✅ 了解性能最佳实践
✅ 掌握 DOM 操作模式

## DOM vs Java GUI

<UniversalEditor title="DOM vs Java Swing/JavaFX">
```java !! java
// Java - Swing
JFrame frame = new JFrame("My App");
JButton button = new JButton("Click me");
frame.add(button);
frame.setVisible(true);

// JavaFX
Button btn = new Button("Click me");
Scene scene = new Scene(new StackPane(btn), 300, 250);
stage.setScene(scene);
stage.show();
```

```javascript !! js
// JavaScript - DOM
const button = document.createElement("button");
button.textContent = "Click me";
document.body.appendChild(button);
```
</UniversalEditor>

## 选择元素

<UniversalEditor title="元素选择">
```javascript !! js
// 现代方法(推荐)
const byId = document.getElementById("myId");
const byClass = document.getElementsByClassName("myClass");
const byTag = document.getElementsByTagName("div");

// 查询选择器(最灵活)
const element = document.querySelector("#myId");
const allElements = document.querySelectorAll(".myClass");

// CSS 选择器
const element1 = document.querySelector("#container .item");
const element2 = document.querySelector("button[data-action='submit']");
const element3 = document.querySelector("ul > li:first-child");

// 上下文选择
const container = document.querySelector("#container");
const items = container.querySelectorAll(".item");  // 仅在容器内

// 性能考虑
// getElementById 对于 ID 查找最快
// querySelector 较慢但更灵活

// 最佳实践:缓存选择器
const button = document.getElementById("submit");
button.addEventListener("click", handleClick);
```
</UniversalEditor>

## 遍历 DOM

<UniversalEditor title="DOM 遍历">
```javascript !! js
const parent = document.getElementById("parent");

// 子元素
const children = parent.children;  // HTMLCollection (实时)
const childNodes = parent.childNodes;  // NodeList (实时)
const firstChild = parent.firstElementChild;
const lastChild = parent.lastElementChild;

// 兄弟元素
const nextSibling = element.nextElementSibling;
const prevSibling = element.previousElementSibling;

// 父元素
const parent = element.parentElement;

// 遍历 DOM 树
function walkDOM(node, callback) {
    callback(node);
    node = node.firstChild;
    while (node) {
        walkDOM(node, callback);
        node = node.nextSibling;
    }
}

// 查找元素
const closestParent = element.closest(".container");
const matches = element.matches(".active");
```
</UniversalEditor>

## 修改元素

<UniversalEditor title="修改元素">
```javascript !! js
const element = document.querySelector("#myElement");

// 内容
element.textContent = "New text";  // 纯文本
element.innerHTML = "<strong>New HTML</strong>";  // HTML (安全风险!)

// 属性
element.setAttribute("class", "active");
element.getAttribute("class");
element.hasAttribute("class");
element.removeAttribute("class");

// 属性(推荐)
element.id = "myId";
element.className = "my-class";
element.href = "https://example.com";
element.disabled = true;

// 类
element.classList.add("active");
element.classList.remove("inactive");
element.classList.toggle("active");
element.classList.contains("active");

// 多个类
element.classList.add("class1", "class2");
element.classList.remove("class1", "class2");

// 替换类
element.classList.replace("old", "new");

// 样式
element.style.color = "red";
element.style.backgroundColor = "blue";

// CSS 自定义属性
element.style.setProperty("--main-color", "#00ff00");
const color = element.style.getPropertyValue("--main-color");

// 数据集(data-* 属性)
element.dataset.userId = "123";
console.log(element.dataset.userId);  // "123"
```
</UniversalEditor>

## 创建和删除元素

<UniversalEditor title="创建和删除">
```javascript !! js
// 创建元素
const div = document.createElement("div");
div.textContent = "Hello";
div.className = "greeting";

// 添加到 DOM
document.body.appendChild(div);
container.insertBefore(div, container.firstChild);

// 替换元素
parent.replaceChild(newElement, oldElement);

// 克隆元素
const clone = element.cloneNode(true);  // 深克隆
const shallow = element.cloneNode(false);  // 浅克隆

// 删除元素
parent.removeChild(child);
child.remove();  // 现代

// 插入 HTML(安全风险!)
element.insertAdjacentHTML("beforeend", "<span>New</span>");

// 插入位置:
// "beforebegin" - 元素之前
// "afterbegin" - 内部,开始处
// "beforeend" - 内部,结束处
// "afterend" - 元素之后

// 插入元素
const span = document.createElement("span");
element.insertAdjacentElement("beforeend", span);
```
</UniversalEditor>

## 最佳实践

<UniversalEditor title="DOM 最佳实践">
```javascript !! js
// 1. 最小化回流和重绘
// 不好:多次回流
element.style.width = "100px";
element.style.height = "100px";
element.style.margin = "10px";

// 好:单次回流
element.style.cssText = "width: 100px; height: 100px; margin: 10px;";

// 更好:使用类
element.className = "optimized-style";

// 2. 批处理 DOM 更新
// 不好:多次 DOM 插入
items.forEach(item => {
    document.body.appendChild(createElement(item));
});

// 好:文档片段
const fragment = document.createDocumentFragment();
items.forEach(item => {
    fragment.appendChild(createElement(item));
});
document.body.appendChild(fragment);  // 单次回流

// 3. 缓存 DOM 查询
// 不好
function update() {
    document.getElementById("result").textContent = "Done";
}

// 好
const result = document.getElementById("result");
function update() {
    result.textContent = "Done";
}

// 4. 使用事件委托
// 不好(许多监听器)
items.forEach(item => {
    item.addEventListener("click", handleClick);
});

// 好(单个监听器)
container.addEventListener("click", (e) => {
    if (e.target.matches(".item")) {
        handleClick(e);
    }
});
```
</UniversalEditor>

## 练习

### 练习 1:动态列表
创建一个从数组构建列表的函数:
```javascript
function buildList(items) {
    // 创建 <ul> ,每个项目一个 <li>
}
```

### 练习 2:切换类
```javascript
// 点击时添加 "active" 类,从其他类中删除
function setupTabs(tabs) {
    // 实现
}
```

### 练习 3:表单验证
```javascript
// 提交时验证表单
function validateForm(form) {
    // 检查必填字段
    // 显示错误
}
```

## 总结

### 关键要点

1. **选择:**使用 querySelector/querySelectorAll
2. **遍历:**parentElement、children、nextElementSibling
3. **修改:**textContent、classList、style
4. **性能:**最小化回流、批处理更新、缓存查询

### 对比:Java vs JavaScript

| 特性 | Java | JavaScript |
|------|------|-----------|
| **DOM 访问** | 无 DOM | document 方法 |
| **事件处理** | 监听器 | addEventListener |
| **样式** | CSS 文件 | 内联 + 类 |
| **更新** | 重绘 | 回流/重绘 |

## 接下来是什么?

接下来:**模块 13:事件处理** - 掌握事件、传播和委托!
