---
title: "Module 6: Objects"
description: "掌握 JavaScript 物件、屬性、方法和物件操作"
---

## Module 6: Objects

物件是 JavaScript 的核心。與 Java 不同，JavaScript 的物件是動態的鍵值對集合，不基於類別。讓我們掌握 JavaScript 物件。

## Learning Objectives

完成本模組後，你將：
✅ 理解 JavaScript 物件本質
✅ 掌握物件創建語法
✅ 學習屬性訪問和操作
✅ 理解物件方法
✅ 掌握物件解構
✅ 學習物件比較和複製

## Objects Comparison

<UniversalEditor title="物件比較">
```java !! java
// Java - 類別基礎物件
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public int getAge() { return age; }
}

User user = new User("Alice", 25);
System.out.println(user.getName());
```

```javascript !! js
// JavaScript - 動態物件
const user = {
    name: "Alice",
    age: 25,
    greet: function() {
        console.log(`Hello, I'm ${this.name}`);
    }
};

// Property access
console.log(user.name);      // "Alice"
console.log(user["name"]);   // "Alice"

// Dynamic access
const key = "age";
console.log(user[key]);      // 25

// Add properties
user.email = "alice@example.com";
user["isAdmin"] = false;

// Remove properties
delete user.email;

// Call method
user.greet();  // "Hello, I'm Alice"
```
</UniversalEditor>

## Object Creation

<UniversalEditor title="物件創建">
```java !! java
// Java - 類別實例化
public class Point {
    public int x;
    public int y;

    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

Point p = new Point(10, 20);
```

```javascript !! js
// JavaScript - 多種創建方式

// 1. Object literal（最常用）
const obj1 = {
    name: "Alice",
    age: 25
};

// 2. Object.create()
const proto = { greet: function() { console.log("Hi!"); } };
const obj2 = Object.create(proto);

// 3. new Object（避免使用）
const obj3 = new Object();
obj3.name = "Bob";

// 4. Constructor function
function User(name) {
    this.name = name;
}
const user = new User("Charlie");

// 5. Class（ES6+）
class Person {
    constructor(name) {
        this.name = name;
    }
}
const person = new Person("David");

// Computed property names
const key = "dynamic";
const obj4 = {
    [key]: "value",
    [`prop_${Date.now()}`]: "timestamp"
};

// Shorthand
const name = "Alice";
const age = 25;
const obj5 = { name, age };  // Same as { name: name, age: age }

// Method shorthand
const obj6 = {
    greet() {
        console.log("Hello!");
    }
};
```
</UniversalEditor>

## Property Descriptors

<UniversalEditor title="屬性描述符">
```java !! java
// Java - Private fields with getters/setters
public class User {
    private String name;

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
}
```

```javascript !! js
// JavaScript - Property descriptors
const obj = {};

// Data property
Object.defineProperty(obj, "name", {
    value: "Alice",
    writable: true,      // Can be changed
    enumerable: true,    // Shows in for...in
    configurable: true   // Can be deleted or modified
});

// Read-only property
Object.defineProperty(obj, "ID", {
    value: 12345,
    writable: false
});

obj.ID = 99999;  // Silently fails in non-strict mode

// Getter/setter
const user = {
    _name: "Alice",

    get name() {
        return this._name.toUpperCase();
    },

    set name(value) {
        if (value.length > 0) {
            this._name = value;
        }
    }
};

console.log(user.name);  // "ALICE"
user.name = "Bob";
console.log(user.name);  // "BOB"

// Check property
console.log(obj.hasOwnProperty("name"));  // true
console.log("name" in obj);               // true

// Get all keys
console.log(Object.keys(obj));           // Own enumerable keys
console.log(Object.getOwnPropertyNames(obj));  // All own keys
```
</UniversalEditor>

## Object Destructuring

<UniversalEditor title="物件解構">
```java !! java
// Java - Manual field access
User user = new User("Alice", 25);
String name = user.getName();
int age = user.getAge();
```

```javascript !! js
// JavaScript - Destructuring
const user = {
    name: "Alice",
    age: 25,
    email: "alice@example.com"
};

// Basic destructuring
const { name, age } = user;
console.log(name, age);  // "Alice" 25

// Rename
const { name: userName, age: userAge } = user;

// Default values
const { name: n = "Anonymous", country = "USA" } = user;

// Nested destructuring
const data = {
    user: {
        name: "Alice",
        address: {
            city: "Taipei"
        }
    }
};

const { user: { name, address: { city } } } = data;
console.log(name, city);  // "Alice" "Taipei"

// Function parameter destructuring
function greet({ name, age = 18 }) {
    console.log(`${name} is ${age} years old`);
}

greet({ name: "Bob" });  // "Bob is 18 years old"

// Destructuring with rest
const { name, ...rest } = user;
console.log(rest);  // { age: 25, email: "alice@example.com" }
```
</UniversalEditor>

## Object Methods

<UniversalEditor title="物件方法">
```javascript !! js
const obj = {
    name: "Alice",

    // Method shorthand
    greet() {
        return `Hello, I'm ${this.name}`;
    },

    // Arrow function（no this binding）
    greetArrow: () => {
        return `Hello`;  // this.name is undefined
    }
};

console.log(obj.greet());     // "Hello, I'm Alice"
console.log(obj.greetArrow()); // "Hello"

// Dynamic methods
const methodName = "sayHello";
const obj2 = {
    [methodName]() {
        console.log("Hello!");
    }
};

obj2.sayHello();  // "Hello!"

// Computed method names
const prefix = "get";
const obj3 = {
    [`${prefix}Name`() {
        return "Alice";
    }
};

console.log(obj3.getName());  // "Alice"
```
</UniversalEditor>

## Object Comparison

<UniversalEditor title="物件比較">
```java !! java
// Java - equals() for content comparison
String s1 = new String("hello");
String s2 = new String("hello");

System.out.println(s1 == s2);           // false（different references）
System.out.println(s1.equals(s2));      // true（same content）
```

```javascript !! js
// JavaScript - Reference comparison
const obj1 = { name: "Alice" };
const obj2 = { name: "Alice" };
const obj3 = obj1;

console.log(obj1 === obj2);  // false（different references）
console.log(obj1 === obj3);  // true（same reference）

// Shallow equality check
function shallowEqual(obj1, obj2) {
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);

    if (keys1.length !== keys2.length) return false;

    for (const key of keys1) {
        if (obj1[key] !== obj2[key]) return false;
    }

    return true;
}

console.log(shallowEqual(obj1, obj2));  // true

// Deep equality（simplified）
function deepEqual(obj1, obj2) {
    if (obj1 === obj2) return true;

    if (typeof obj1 !== "object" || obj1 === null ||
        typeof obj2 !== "object" || obj2 === null) {
        return false;
    }

    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);

    if (keys1.length !== keys2.length) return false;

    for (const key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) {
            return false;
        }
    }

    return true;
}
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="物件最佳實踐">
```javascript !! js
// 1. Use object literals for simple objects
const config = { apiUrl: "https://api.example.com", timeout: 5000 };

// 2. Use destructuring for cleaner code
const { name, age } = user;

// 3. Use spread for shallow copy
const copy = { ...original };

// 4. Use Object.freeze for immutability
const constants = Object.freeze({ API_KEY: "xxx", VERSION: 1 });

// 5. Use optional chaining
const city = user?.address?.city;

// 6. Use nullish coalescing
const timeout = config.timeout ?? 3000;
```
</UniversalEditor>

## Summary

### Key Takeaways

1. **Objects:** 動態鍵值對
2. **Creation:** 字面語法最常用
3. **Destructuring:** 簡潔的屬性提取
4. **Comparison:** 參考比較

## What's Next?

接下來是 **Module 7: Classes** - 了解 ES6 類別！
