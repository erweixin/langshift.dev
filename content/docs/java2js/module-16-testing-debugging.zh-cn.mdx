---
title: "Module 16: Testing and Debugging"
description: "Master JavaScript testing frameworks and debugging techniques"
---

## Module 16: Testing and Debugging

Testing and debugging are essential skills for writing reliable JavaScript code.

## Learning Objectives

By the end of this module, you will:
✅ Master Jest testing framework
✅ Learn testing patterns (unit, integration, E2E)
✅ Understand debugging techniques
✅ Know browser DevTools
✅ Learn error handling strategies
✅ Master testing best practices

## Testing: Java vs JavaScript

<UniversalEditor title="Testing Comparison">
```java !! java
// Java - JUnit
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class CalculatorTest {
    @Test
    public void testAdd() {
        Calculator calc = new Calculator();
        assertEquals(5, calc.add(2, 3));
    }
}
```

```javascript !! js
// JavaScript - Jest
test("add returns sum", () => {
    const calc = new Calculator();
    expect(calc.add(2, 3)).toBe(5);
});
```
</UniversalEditor>

## Jest Testing

<UniversalEditor title="Jest Basics">
```javascript !! js
// math.test.js
const { add, subtract } = require("./math");

describe("Math operations", () => {
  test("add adds numbers", () => {
    expect(add(2, 3)).toBe(5);
  });

  test("subtract subtracts numbers", () => {
    expect(subtract(5, 3)).toBe(2);
  });

  // Matchers
  test("matchers", () => {
    expect(42).toBe(42);
    expect({ name: "John" }).toEqual({ name: "John" });
    expect("hello").toContain("ell");
    expect([1, 2, 3]).toHaveLength(3);
    expect(null).toBeNull();
    expect(undefined).toBeUndefined();
    expect(true).toBeTruthy();
    expect(false).toBeFalsy();
  });
});

// Async testing
test("async fetch", async () => {
  const data = await fetchData();
  expect(data).toBeDefined();
});

// Mocking
test("mock function", () => {
  const mock = jest.fn();
  mock("arg1", "arg2");

  expect(mock).toHaveBeenCalledWith("arg1", "arg2");
  expect(mock).toHaveBeenCalledTimes(1);
});
```
</UniversalEditor>

## Debugging

<UniversalEditor title="Debugging Techniques">
```javascript !! js
// 1. console.log (simplest)
console.log("Value:", value);
console.table(data);  // Tabular data
console.group("Group");
console.log("Inside group");
console.groupEnd();

// 2. debugger statement
function buggyFunction() {
  const x = 1;
  debugger;  // Pauses execution
  const y = 2;
  return x + y;
}

// 3. Chrome DevTools
// - Sources panel
// - Set breakpoints
// - Step through code
// - Inspect variables

// 4. Error handling
try {
  riskyOperation();
} catch (error) {
  console.error("Caught:", error);
  console.trace();  // Stack trace
}

// 5. Performance profiling
console.time("operation");
// ... code ...
console.timeEnd("operation");
```
</UniversalEditor>

## Browser DevTools

<UniversalEditor title="DevTools">
```html
<!-- Open DevTools: F12 or Cmd+Option+I -->

<!-- Elements: Inspect DOM -->
<!-- Console: Execute JS -->
<!-- Sources: Debug code -->
<!-- Network: Monitor requests -->
<!-- Performance: Profile -->
```
</UniversalEditor>

## Testing Patterns

<UniversalEditor title="Testing Patterns">
```javascript !! js
// Unit test
describe("UserService", () => {
  test("creates user", () => {
    const user = new User("John");
    expect(user.name).toBe("John");
  });
});

// Integration test
describe("API", () => {
  test("fetches user", async () => {
    const response = await fetch("/api/users/1");
    const user = await response.json();
    expect(user.id).toBe(1);
  });
});

// Mock external dependencies
jest.mock("./api");
import { fetchUser } from "./api";

test("displays user", async () => {
  fetchUser.mockResolvedValue({ id: 1, name: "John" });

  const user = await getUser(1);
  expect(user.name).toBe("John");
});
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Testing Best Practices">
```javascript !! js
// 1. Test behavior, not implementation
// Bad
test("uses array.push", () => {
  arr.push(1);
  expect(arr.push).toHaveBeenCalled();
});

// Good
test("adds item to array", () => {
  addItem(arr, 1);
  expect(arr).toContain(1);
});

// 2. Arrange-Act-Assert
test("user can login", () => {
  // Arrange
  const user = { email: "test@test.com", password: "pass" };

  // Act
  const result = authService.login(user);

  // Assert
  expect(result.success).toBe(true);
});

// 3. One assertion per test (mostly)
test("returns user data", () => {
  const user = getUser(1);
  expect(user.id).toBe(1);
  // Don't test everything in one test
});

// 4. Use descriptive test names
test("returns 404 when user not found", () => {
  // Clear what it tests
});
```
</UniversalEditor>

## Summary

### Key Takeaways

1. **Jest**: Testing framework
2. **Matchers**: toBe, toEqual, toContain
3. **Async**: await async tests
4. **Mocking**: jest.fn(), jest.mock()
5. **Debug**: console.log, debugger, DevTools

### Comparison: Java vs JavaScript

| Feature | Java | JavaScript |
|---------|------|------------|
| **Testing** | JUnit | Jest |
| **Mocking** | Mockito | jest.fn() |
| **Debugging** | IDE debugger | Browser DevTools |
| **Profiling** | JProfiler | Chrome DevTools |

## What's Next?

Next: **Module 17: Popular Frameworks** - Learn React and Vue basics!
