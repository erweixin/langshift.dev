---
title: "Module 2: Control Flow and Loops"
description: "Master JavaScript's control flow statements, loops, and iteration patterns"
---

## Module 2: Control Flow and Loops

在這個模組中，我們將探討 JavaScript 如何處理控制流程和迭代。你會發現它與 Java 有許多相似之處，但 JavaScript 提供了一些強大的功能，使迭代更具表達力。

## Learning Objectives

完成本模組後，你將：
✅ 掌握條件語句（if/else、switch、三元運算符）
✅ 理解所有迴圈類型（for、while、do-while、for...of、for...in）
✅ 學習函數式迭代方法（map、filter、reduce）
✅ 發現短路求值（short-circuit evaluation）
✅ 知道何時使用每種迭代模式

## Conditional Statements

### if/else Statements

JavaScript 的 if/else 與 Java 幾乎完全相同：

<UniversalEditor title="if/else Comparison">
```java !! java
// Java - if/else
int age = 18;

if (age >= 18) {
    System.out.println("Adult");
} else if (age >= 13) {
    System.out.println("Teenager");
} else {
    System.out.println("Child");
}

// Ternary operator
String status = (age >= 18) ? "Adult" : "Minor";

// With null check
String name = null;
String displayName = (name != null) ? name : "Guest";
```

```javascript !! js
// JavaScript - if/else（相同語法）
let age = 18;

if (age >= 18) {
    console.log("Adult");
} else if (age >= 13) {
    console.log("Teenager");
} else {
    console.log("Child");
}

// Ternary operator（相同）
let status = (age >= 18) ? "Adult" : "Minor";

// With null/undefined check
let name = null;
let displayName = (name !== null && name !== undefined) ? name : "Guest";

// Or simpler with nullish coalescing
let displayName2 = name ?? "Guest";
```
</UniversalEditor>

### Short-Circuit Evaluation

JavaScript 對邏輯運算符使用短路求值：

<UniversalEditor title="Short-Circuit Evaluation">
```java !! java
// Java - 邏輯運算符總是返回布林值
boolean isValid = true;
String name = "John";

// 兩個條件總是被求值為布林值
if (isValid && name != null && name.length() > 0) {
    // ...
}

// Cannot use logical operators for default values
// This doesn't work in Java:
// String displayName = name || "Guest";  // Compilation error!
```

```javascript !! js
// JavaScript - 短路求值
let isValid = true;
let name = "John";

// && 返回第一個假值或最後一個真值
let result1 = isValid && name;  // "John"（兩者都是真值）
let result2 = isValid && null;  // null（在 null 處停止）
let result3 = false && name;   // false（在 false 處停止）

// || 返回第一個真值或最後一個假值
let displayName = name || "Guest";  // "John"（name 是真值）
let displayName2 = null || "Guest"; // "Guest"（null 是假值）

// 實用模式：預設值
function greet(name) {
    name = name || "Guest";  // 如果 name 是假值則使用 "Guest"
    console.log(`Hello, ${name}`);
}

greet("John");  // "Hello, John"
greet("");      // "Hello, Guest"（空字串是假值）
greet(null);    // "Hello, Guest"

// Nullish coalescing（ES2020）- 僅用於 null/undefined
function greet2(name) {
    let displayName = name ?? "Guest";
    console.log(`Hello, ${displayName}`);
}

greet2("");      // "Hello, "（空字串不是 null/undefined）
greet2(null);    // "Hello, Guest"

// Optional chaining for safe property access
const user = { profile: { name: "John" } };
const username = user?.profile?.name ?? "Guest";  // "John"
const username2 = user?.settings?.theme ?? "dark";  // "dark"（settings 不存在）
```
</UniversalEditor>

### switch Statements

JavaScript 的 switch 與 Java 有一些重要差異：

<UniversalEditor title="switch Statement Comparison">
```java !! java
// Java - switch with strict type matching
int dayOfWeek = 1;
String dayName;

switch (dayOfWeek) {
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case 3:
        dayName = "Wednesday";
        break;
    default:
        dayName = "Unknown";
}

// Java - switch expressions（Java 14+）
String dayType = switch (dayOfWeek) {
    case 1, 2, 3, 4, 5 -> "Weekday";
    case 6, 7 -> "Weekend";
    default -> "Invalid";
};
```

```javascript !! js
// JavaScript - switch with loose equality（小心！）
let dayOfWeek = 1;
let dayName;

switch (dayOfWeek) {
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case "1":  // ⚠️ 這也匹配！（寬鬆相等）
        dayName = "Monday (string)";
        break;
    default:
        dayName = "Unknown";
}

// Pitfall: Loose equality
let x = "1";
switch (x) {
    case 1:  // 這匹配！（"1" == 1 是 true）
        console.log("Equal");
        break;
}

// Solution: Use strict equality checks
function strictSwitch(value) {
    if (value === 1) {
        return "One";
    } else if (value === 2) {
        return "Two";
    } else {
        return "Unknown";
    }
}

// Or use object lookup（更好的模式）
const dayMap = {
    1: "Monday",
    2: "Tuesday",
    3: "Wednesday",
    4: "Thursday",
    5: "Friday",
    6: "Saturday",
    7: "Sunday"
};

const dayName2 = dayMap[dayOfWeek] ?? "Unknown";
```
</UniversalEditor>

## Traditional Loops

### for Loop

JavaScript 的傳統 for loop 與 Java 類似：

<UniversalEditor title="for Loop Comparison">
```java !! java
// Java - for loop
for (int i = 0; i < 5; i++) {
    System.out.println("Iteration " + i);
}

// Enhanced for loop（for-each）
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// With index
for (int i = 0; i < numbers.length; i++) {
    System.out.println("Index " + i + ": " + numbers[i]);
}
```

```javascript !! js
// JavaScript - for loop（相同語法）
for (let i = 0; i < 5; i++) {
    console.log("Iteration " + i);
}

// for...of loop（現代 for-each）
const numbers = [1, 2, 3, 4, 5];
for (const num of numbers) {
    console.log(num);
}

// With index using entries()
for (const [index, num] of numbers.entries()) {
    console.log(`Index ${index}: ${num}`);
}

// for...in loop（iterate over indices/keys）
for (const index in numbers) {
    console.log(`Index ${index}: ${numbers[index]}`);
}

// ⚠️ 小心：for...in 是用於物件，不是陣列
const user = { name: "John", age: 25 };
for (const key in user) {
    console.log(`${key}: ${user[key]}`);
}
```
</UniversalEditor>

### while and do-while Loops

這些與 Java 完全相同：

<UniversalEditor title="while and do-while">
```java !! java
// Java - while loop
int count = 0;
while (count < 5) {
    System.out.println("Count: " + count);
    count++;
}

// do-while loop
int i = 0;
do {
    System.out.println("At least once: " + i);
    i++;
} while (i < 5);
```

```javascript !! js
// JavaScript - while loop（相同）
let count = 0;
while (count < 5) {
    console.log("Count: " + count);
    count++;
}

// do-while loop（相同）
let i = 0;
do {
    console.log("At least once: " + i);
    i++;
} while (i < 5);

// Practical example: Input validation
function guessNumber() {
    let guess;
    let target = 42;

    do {
        guess = parseInt(prompt("Guess a number:"));
        if (guess < target) {
            console.log("Too low!");
        } else if (guess > target) {
            console.log("Too high!");
        }
    } while (guess !== target);

    console.log("Correct!");
}
```
</UniversalEditor>

### break and continue

JavaScript 支援 break 和 continue，就像 Java 一樣：

<UniversalEditor title="break and continue">
```java !! java
// Java - break and continue
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // Exit loop
    }
    if (i % 2 == 0) {
        continue;  // Skip to next iteration
    }
    System.out.println("Odd number: " + i);
}

// Labeled breaks（for nested loops）
outer:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break outer;  // Exit outer loop
        }
        System.out.println(i + ", " + j);
    }
}
```

```javascript !! js
// JavaScript - break and continue（相同）
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break;  // Exit loop
    }
    if (i % 2 === 0) {
        continue;  // Skip to next iteration
    }
    console.log("Odd number: " + i);
}

// Labeled breaks（與 Java 相同）
outer:
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outer;  // Exit outer loop
        }
        console.log(`${i}, ${j}`);
    }
}

// Practical example: Search
function findUser(users, targetId) {
    for (const user of users) {
        if (user.id === targetId) {
            return user;  // Found it, exit early
        }
    }
    return null;  // Not found
}
```
</UniversalEditor>

## Modern Iteration Methods

JavaScript 提供了強大的陣列方法，Java 開發者會從 streams 中認識它們：

### Array.prototype.forEach

<UniversalEditor title="forEach vs for-each">
```java !! java
// Java - for-each loop
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}

// Java 8+ forEach with lambda
names.forEach(name -> System.out.println(name));

// With index（need IntStream）
IntStream.range(0, names.size())
         .forEach(i -> System.out.println(i + ": " + names.get(i)));
```

```javascript !! js
// JavaScript - forEach method
const names = ["Alice", "Bob", "Charlie"];
names.forEach(name => {
    console.log(name);
});

// With index
names.forEach((name, index) => {
    console.log(`${index}: ${name}`);
});

// Note: Cannot break out of forEach!
// Use a for...of loop if you need to break
for (const name of names) {
    if (name === "Bob") break;  // This works
    console.log(name);
}

// forEach doesn't return anything
const result = names.forEach(name => name.toUpperCase());
console.log(result);  // undefined
```
</UniversalEditor>

### Array.prototype.map

透過轉換每個元素來建立新陣列：

<UniversalEditor title="map Comparison">
```java !! java
// Java - Stream.map()
List<String> names = Arrays.asList("alice", "bob", "charlie");
List<String> upperNames = names.stream()
                               .map(String::toUpperCase)
                               .collect(Collectors.toList());

// Or with lambda
List<Integer> lengths = names.stream()
                            .map(name -> name.length())
                            .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array.map()
const names = ["alice", "bob", "charlie"];
const upperNames = names.map(name => name.toUpperCase());
console.log(upperNames);  // ["ALICE", "BOB", "CHARLIE"]

// Get lengths
const lengths = names.map(name => name.length());
console.log(lengths);  // [5, 3, 7]

// Transform objects
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

const userIds = users.map(user => user.id);
console.log(userIds);  // [1, 2]

// With index
const numbered = names.map((name, i) => `${i + 1}. ${name}`);
console.log(numbered);  // ["1. Alice", "2. Bob", "3. Charlie"]
```
</UniversalEditor>

### Array.prototype.filter

建立包含通過測試的元素的新陣列：

<UniversalEditor title="filter Comparison">
```java !! java
// Java - Stream.filter()
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> evens = numbers.stream()
                              .filter(n -> n % 2 == 0)
                              .collect(Collectors.toList());

// Chain multiple operations
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .filter(n -> n > 5)
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array.filter()
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);  // [2, 4, 6, 8, 10]

// Chain methods
const result = numbers
    .filter(n => n % 2 === 0)
    .filter(n => n > 5);
console.log(result);  // [6, 8, 10]

// Filter objects
const users = [
    { id: 1, name: "Alice", age: 25 },
    { id: 2, name: "Bob", age: 17 },
    { id: 3, name: "Charlie", age: 30 }
];

const adults = users.filter(user => user.age >= 18);
console.log(adults);  // [{ id: 1, ... }, { id: 3, ... }]

// Remove null/undefined values
const values = [1, null, 2, undefined, 3, null, 4];
const clean = values.filter(v => v != null);
console.log(clean);  // [1, 2, 3, 4]
```
</UniversalEditor>

### Array.prototype.reduce

將陣列減少為單一值：

<UniversalEditor title="reduce Comparison">
```java !! java
// Java - Stream.reduce()
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);

int product = numbers.stream()
                     .reduce(1, (a, b) -> a * b);

// With Optional
Optional<Integer> max = numbers.stream()
                               .reduce(Integer::max);
```

```javascript !! js
// JavaScript - Array.reduce()
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum);  // 15

const product = numbers.reduce((acc, n) => acc * n, 1);
console.log(product);  // 120

// Find max
const max = numbers.reduce((acc, n) => Math.max(acc, n), -Infinity);
console.log(max);  // 5

// Group by
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

const byRole = users.reduce((acc, user) => {
    if (!acc[user.role]) {
        acc[user.role] = [];
    }
    acc[user.role].push(user);
    return acc;
}, {});

console.log(byRole);
// {
//   admin: [{ name: "Alice", ... }, { name: "Charlie", ... }],
//   user: [{ name: "Bob", ... }]
// }
```
</UniversalEditor>

### Other Array Methods

<UniversalEditor title="More Array Methods">
```java !! java
// Java - Various stream operations
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Find first
Optional<String> first = names.stream().findFirst();

// Any match
boolean hasAlice = names.stream().anyMatch(n -> n.equals("Alice"));

// All match
boolean allLong = names.stream().allMatch(n -> n.length() > 3);

// Count
long count = names.stream().count();

// Limit
List<String> firstTwo = names.stream().limit(2).collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array methods
const names = ["Alice", "Bob", "Charlie"];

// Find first（returns element, not Optional）
const first = names[0];  // "Alice"
const firstFind = names.find(name => name.startsWith("A"));  // "Alice"

// Find index
const indexOfBob = names.indexOf("Bob");  // 1
const findIndex = names.findIndex(name => name.startsWith("B"));  // 1

// Check if exists
const hasAlice = names.includes("Alice");  // true
const hasLongName = names.some(name => name.length > 3);  // true
const allLong = names.every(name => name.length > 3);  // false

// Count
const count = names.length;  // 3

// Slice（first two）
const firstTwo = names.slice(0, 2);  // ["Alice", "Bob"]

// Flat map（ES2019）
const matrix = [[1, 2], [3, 4], [5, 6]];
const flattened = matrix.flat();  // [1, 2, 3, 4, 5, 6]

// Sort（modifies in place!）
const nums = [3, 1, 4, 1, 5];
nums.sort((a, b) => a - b);  // [1, 1, 3, 4, 5]
```
</UniversalEditor>

## Method Chaining

JavaScript 陣列方法可以鏈結，就像 Java streams 一樣：

<UniversalEditor title="Method Chaining">
```java !! java
// Java - Stream chaining
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .limit(5)
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array method chaining
const result = numbers
    .filter(n => n % 2 === 0)
    .map(n => n * 2)
    .slice(0, 5);

// Real-world example
const users = [
    { name: "Alice", age: 25, score: 85 },
    { name: "Bob", age: 17, score: 92 },
    { name: "Charlie", age: 30, score: 78 },
    { name: "David", age: 22, score: 88 }
];

// Get names of adult users with high scores, sorted
const topAdults = users
    .filter(user => user.age >= 18)           // Filter adults
    .filter(user => user.score >= 80)         // Filter high scores
    .sort((a, b) => b.score - a.score)        // Sort by score desc
    .map(user => user.name);                  // Get names

console.log(topAdults);  // ["Bob", "David", "Alice"]

// Calculate average score
const averageScore = users
    .map(user => user.score)
    .reduce((sum, score, _, arr) => sum + score / arr.length, 0);

console.log(averageScore);  // 85.75
```
</UniversalEditor>

## Iteration Patterns

### Pattern 1: Transform and Filter

<UniversalEditor title="Transform and Filter Pattern">
```java !! java
// Java
List<String> words = Arrays.asList("hello", "world", "java", "stream");

List<String> result = words.stream()
    .filter(w -> w.length() > 4)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript
const words = ["hello", "world", "java", "javascript"];

const result = words
    .filter(w => w.length > 4)
    .map(w => w.toUpperCase())
    .sort();

console.log(result);  // ["HELLO", "JAVASCRIPT", "WORLD"]
```
</UniversalEditor>

### Pattern 2: Find and Update

<UniversalEditor title="Find and Update Pattern">
```java !! java
// Java - Immutable approach
List<User> users = getUsers();
User updatedUser = users.stream()
    .filter(u -> u.getId() == targetId)
    .findFirst()
    .map(u -> new User(u.getId(), u.getName(), true))
    .orElse(null);
```

```javascript !! js
// JavaScript - Find and update
const users = [
    { id: 1, name: "Alice", active: false },
    { id: 2, name: "Bob", active: false }
];

const targetId = 1;
const updatedUsers = users.map(user => {
    if (user.id === targetId) {
        return { ...user, active: true };
    }
    return user;
});

console.log(updatedUsers);
// [
//   { id: 1, name: "Alice", active: true },
//   { id: 2, name: "Bob", active: false }
// ]
```
</UniversalEditor>

### Pattern 3: Reduce to Object

<UniversalEditor title="Reduce to Object Pattern">
```java !! java
// Java - Group by with Collectors.groupingBy
List<User> users = getUsers();
Map<String, List<User>> byRole = users.stream()
    .collect(Collectors.groupingBy(User::getRole));
```

```javascript !! js
// JavaScript - Group by with reduce
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

const byRole = users.reduce((acc, user) => ({
    ...acc,
    [user.role]: [...(acc[user.role] || []), user]
}), {});

console.log(byRole);
// {
//   admin: [
//     { name: "Alice", role: "admin" },
//     { name: "Charlie", role: "admin" }
//   ],
//   user: [{ name: "Bob", role: "user" }]
// }
```
</UniversalEditor>

## Performance Considerations

<UniversalEditor title="Performance: Loops vs Array Methods">
```java !! java
// Java - Streams have overhead
// For simple operations, traditional loops can be faster
List<Integer> numbers = /* large list */;

// Stream（cleaner but some overhead）
List<Integer> result = numbers.stream()
    .filter(n -> n > 0)
    .collect(Collectors.toList());

// Traditional loop（faster for simple cases）
List<Integer> result2 = new ArrayList<>();
for (Integer n : numbers) {
    if (n > 0) {
        result2.add(n);
    }
}
```

```javascript !! js
// JavaScript - Similar trade-offs
const numbers = /* large array */;

// Array methods（cleaner, similar performance）
const result = numbers.filter(n => n > 0);

// Traditional for loop（often faster）
const result2 = [];
for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 0) {
        result2.push(numbers[i]);
    }
}

// for...of（clean, good middle ground）
const result3 = [];
for (const n of numbers) {
    if (n > 0) {
        result3.push(n);
    }
}

// General rule:
// - Use array methods for readability（usually fast enough）
// - Use traditional loops for performance-critical code
// - Avoid forEach when you might need to break（use for...of）
```
</UniversalEditor>

## Common Pitfalls

### Pitfall 1: Using for...in on Arrays

<UniversalEditor title="for...in Pitfall">
```javascript !! js
// ❌ BAD: for...in iterates over keys, not values
const arr = [10, 20, 30];
for (const i in arr) {
    console.log(i);  // "0", "1", "2"（字串，不是數字！）
    console.log(arr[i]);  // 10, 20, 30
}

// Also iterates over inherited properties
Array.prototype.customProp = "inherited";
for (const i in arr) {
    console.log(i);  // "0", "1", "2", "customProp"
}

// ✅ GOOD: Use for...of for arrays
for (const value of arr) {
    console.log(value);  // 10, 20, 30
}

// ✅ GOOD: Use forEach for index and value
arr.forEach((value, index) => {
    console.log(`${index}: ${value}`);
});
```
</UniversalEditor>

### Pitfall 2: Modifying Array While Iterating

<UniversalEditor title="Modification During Iteration">
```javascript !! js
// ❌ BAD: Removing elements during iteration
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 === 0) {
        numbers.splice(i, 1);  // Removes element
    }
}
// Result: [1, 3, 5] but skips some elements!

// ✅ GOOD: Filter instead
const filtered = numbers.filter(n => n % 2 !== 0);
// Result: [1, 3, 5]

// ✅ GOOD: Iterate backwards if you must modify
for (let i = numbers.length - 1; i >= 0; i--) {
    if (numbers[i] % 2 === 0) {
        numbers.splice(i, 1);
    }
}
```
</UniversalEditor>

### Pitfall 3: Forgetting Return in Array Methods

<UniversalEditor title="Missing Return">
```javascript !! js
// ❌ BAD: Forgetting return
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => {
    n * 2;  // No return! Results in [undefined, undefined, ...]
});

// ✅ GOOD: Explicit return
const doubled2 = numbers.map(n => {
    return n * 2;
});

// ✅ GOOD: Implicit return（one-liner）
const doubled3 = numbers.map(n => n * 2);

// ⚠️ Watch out with curly braces
const doubled4 = numbers.map(n => { n * 2 });  // Wrong!
const doubled5 = numbers.map(n => ({ value: n * 2 }));  // Need parentheses for object
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Best Practices Summary">
```java !! java
// Java: Use streams for readability
List<String> names = Arrays.asList("alice", "bob", "charlie");

List<String> result = names.stream()
    .filter(n -> n.length() > 3)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());

// Use traditional loops for performance or when need to break
for (String name : names) {
    if (name.equals("bob")) break;
    System.out.println(name);
}
```

```javascript !! js
// JavaScript: Use array methods for readability
const names = ["alice", "bob", "charlie"];

const result = names
    .filter(n => n.length > 3)
    .map(n => n.toUpperCase())
    .sort();

// Use for...of when you need to break
for (const name of names) {
    if (name === "bob") break;
    console.log(name);
}

// Use reduce for complex aggregations
const summary = names.reduce((acc, name) => ({
    count: acc.count + 1,
    totalLength: acc.totalLength + name.length,
    avgLength: (acc.totalLength + name.length) / (acc.count + 1)
}), { count: 0, totalLength: 0, avgLength: 0 });

// Avoid forEach when you could use map/filter
// ❌ BAD
const results = [];
items.forEach(item => {
    if (item.isValid) {
        results.push(transform(item));
    }
});

// ✅ GOOD
const results = items
    .filter(item => item.isValid)
    .map(transform);
```
</UniversalEditor>

## Exercises

### Exercise 1: Array Transformation
將此 Java 程式碼轉換為 JavaScript：
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squares = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .collect(Collectors.toList());
```

### Exercise 2: Find User
撰寫一個函數來透過 ID 查找使用者：
```javascript
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
];

function findUser(users, targetId) {
    // Return the user with matching ID, or null
}
```

### Exercise 3: Reduce to Object
按角色群組使用者：
```javascript
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

// Create object: { admin: [...], user: [...] }
```

### Exercise 4: Conditional Logic
修正程式碼以使用嚴格相等：
```javascript
function processValue(value) {
    if (value == "0") {  // Bug: uses loose equality
        return "zero";
    }
    return value;
}
```

## Summary

### Key Takeaways

1. **Conditionals:**
   - if/else 與 Java 運作方式相同
   - Switch 使用寬鬆相等（小心！）
   - 三元運算符相同
   - 短路求值提供預設值

2. **Loops:**
   - Traditional for/while/do-while 完全相同
   - for...of 用於陣列值（類似 Java 的 for-each）
   - for...in 用於物件鍵（不是陣列！）
   - break 和 continue 運作方式相同

3. **Array Methods:**
   - forEach: 迭代（無法中斷）
   - map: 轉換為新陣列
   - filter: 選擇元素
   - reduce: 聚合為單一值
   - find/findIndex: 搜尋元素
   - some/every: 測試條件

4. **Method Chaining:**
   - 陣列方法可以鏈結
   - 類似 Java streams
   - 比嵌套迴圈更易讀

5. **Best Practices:**
   - 使用 for...of 進行迭代（可以中斷）
   - 使用陣列方法進行轉換
   - 避免在陣列上使用 for...in
   - 不要在迭代時修改陣列

## What's Next?

你已經掌握了控制流程和迭代！接下來是 **Module 3: Functions**，我們將探討 JavaScript 強大的函數功能：

- Function declarations vs expressions
- Arrow functions
- Closures
- Higher-order functions
- Default parameters
- Rest and spread parameters
- 函數中的 `this` 關鍵字

準備好深入學習 JavaScript 函數了嗎？讓我們繼續！
