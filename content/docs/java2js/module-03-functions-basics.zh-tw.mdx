---
title: "Module 3: Functions Basics"
description: "Master JavaScript functions: declarations, expressions, arrows, and basic concepts"
---

## Module 3: Functions Basics

Functions 是 JavaScript 的「一等公民」，比 Java 的方法更靈活且更強大。在本模組中，我們將探討函數聲明、表達式、箭頭函數，以及使 JavaScript 函數獨特的基本概念。

## Learning Objectives

完成本模組後，你將：
✅ 理解函數聲明與表達式的區別
✅ 掌握箭頭函數的語法與行為
✅ 學習預設參數
✅ 理解 rest 和 spread 參數
✅ 掌握函數提升（hoisting）
✅ 知道一等函數的含義

## Functions vs Methods

在 Java 中，函數存在於類別中並被稱為方法。在 JavaScript 中，函數是獨立的值：

<UniversalEditor title="Functions Comparison">
```java !! java
// Java - Methods are part of classes
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public static int multiply(int a, int b) {
        return a * b;
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int sum = calc.add(5, 3);

        int product = Calculator.multiply(4, 3);
    }
}

// Methods must be in classes
// Cannot have standalone functions
```

```javascript !! js
// JavaScript - Functions are first-class values
function add(a, b) {
    return a + b;
}

const multiply = function(a, b) {
    return a * b;
};

// Arrow function（ES6+）
const subtract = (a, b) => a - b;

// Functions as values
const operation = add;
console.log(operation(5, 3));  // 8

// Functions in objects（methods）
const calculator = {
    add: function(a, b) {
        return a + b;
    },

    // Shorthand method syntax
    subtract(a, b) {
        return a - b;
    }
};

console.log(calculator.add(5, 3));  // 8
console.log(calculator.subtract(10, 4));  // 6
```
</UniversalEditor>

## Function Declarations vs Expressions

<UniversalEditor title="Declarations vs Expressions">
```java !! java
// Java - Only method declarations
public class Example {
    // Method declaration
    public void greet() {
        System.out.println("Hello!");
    }

    // No equivalent to function expressions
    // Methods are always bound to class
}
```

```javascript !! js
// JavaScript - Declarations
function greet1(name) {
    console.log(`Hello, ${name}!`);
}

greet1("Alice");  // "Hello, Alice!"

// Function expression（anonymous function assigned to variable）
const greet2 = function(name) {
    console.log(`Hi, ${name}!`);
};

greet2("Bob");  // "Hi, Bob!"

// Named function expression（useful for debugging）
const greet3 = function greet(name) {
    console.log(`Hey, ${name}!`);
    // Can call greet recursively here
};

greet3("Charlie");  // "Hey, Charlie!"

// Key differences:
// 1. Hoisting
console.log(declared(5));  // 10（works due to hoisting）
function declared(x) {
    return x * 2;
}

// console.log(expressed(5));  // Error: expressed is not a hoist
const expressed = function(x) {
    return x * 2;
};

// 2. Scope
{
    functionscoped() {
        console.log("Function scoped");
    }
    varscoped = function() {
        console.log("Var scoped");
    };
}

functionscoped();  // Works
varscoped();  // Error in strict mode
```
</UniversalEditor>

## Arrow Functions

箭頭函數提供了更簡潔的語法，但有一些重要的行為差異：

<UniversalEditor title="Arrow Functions">
```java !! java
// Java - Lambda expressions
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

numbers.stream()
    .filter(n -> n % 2 == 0)
    .forEach(n -> System.out.println(n));

// Multi-line lambda
numbers.stream()
    .map(n -> {
        int doubled = n * 2;
        return doubled + 1;
    });
```

```javascript !! js
// JavaScript - Arrow functions
const numbers = [1, 2, 3, 4, 5];

// No parameters
const log = () => console.log("Logging");
log();

// One parameter（parentheses optional）
const double = n => n * 2;
console.log(double(5));  // 10

// Multiple parameters（parentheses required）
const add = (a, b) => a + b;
console.log(add(3, 4));  // 7

// Function body（explicit return）
const calculate = (a, b) => {
    const sum = a + b;
    return sum * 2;
};
console.log(calculate(3, 4));  // 14

// Returning object literal（parentheses needed）
const createUser = (name, age) => ({
    name: name,
    age: age,
    adult: age >= 18
});
console.log(createUser("Alice", 25));  // { name: "Alice", age: 25, adult: true }

// Arrow functions as callbacks
numbers
    .filter(n => n % 2 === 0)
    .forEach(n => console.log(n));

// ⚠️ Key difference: No 'this' binding
const obj = {
    value: 42,
    // Regular function: 'this' is obj
    regular: function() {
        console.log(this.value);  // 42
    },
    // Arrow function: 'this' is inherited from surrounding scope
    arrow: () => {
        console.log(this.value);  // undefined（or window in browser）
    }
};

obj.regular();  // 42
obj.arrow();    // undefined

// ⚠️ Arrow functions cannot be used as constructors
const User = (name) => {
    this.name = name;
};

// const user = new User("Alice");  // TypeError: User is not a constructor
```
</UniversalEditor>

## Default Parameters

JavaScript 提供了比 Java 更靈活的預設參數：

<UniversalEditor title="Default Parameters">
```java !! java
// Java - Method overloading
public class Greeter {
    public void greet() {
        greet("World");
    }

    public void greet(String name) {
        greet(name, "Hello");
    }

    public void greet(String name, String greeting) {
        System.out.println(greeting + ", " + name + "!");
    }
}

// Usage
greeter.greet();                    // "Hello, World!"
greeter.greet("Alice");              // "Hello, Alice!"
greeter.greet("Bob", "Hi");          // "Hi, Bob!"
```

```javascript !! js
// JavaScript - Default parameters
function greet(name = "World", greeting = "Hello") {
    console.log(`${greeting}, ${name}!`);
}

greet();                    // "Hello, World!"
greet("Alice");              // "Hello, Alice!"
greet("Bob", "Hi");          // "Hi, Bob!"

// Expressions as defaults
function createUser(name, role = "user", createdAt = Date.now()) {
    return { name, role, createdAt };
}

console.log(createUser("Alice"));
// { name: "Alice", role: "user", createdAt: 1234567890 }

console.log(createUser("Bob", "admin"));
// { name: "Bob", role: "admin", createdAt: 1234567890 }

// Default parameters can use previous parameters
function createArray(size, fillValue = 0, array = new Array(size).fill(fillValue)) {
    return array;
}

console.log(createArray(5));  // [0, 0, 0, 0, 0]
console.log(createArray(3, "x"));  // ["x", "x", "x"]

// ⚠️ Default parameters are not evaluated for null
function test(value = "default") {
    console.log(value);
}

test(undefined);  // "default"
test(null);       // null（not "default"!）
test(0);          // 0
test("");         // ""

// Pattern: Provide defaults for objects
function config({ host = "localhost", port = 3000, ssl = false } = {}) {
    return { host, port, ssl };
}

console.log(config());
// { host: "localhost", port: 3000, ssl: false }

console.log(config({ host: "example.com", port: 8080 }));
// { host: "example.com", port: 8080, ssl: false }
```
</UniversalEditor>

## Rest Parameters

Rest parameters 允許你將不定數量的參數表示為陣列：

<UniversalEditor title="Rest Parameters">
```java !! java
// Java - Varargs
public class Calculator {
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    // Must be last parameter
    public void log(String message, Object... data) {
        System.out.println(message + " " + Arrays.toString(data));
    }
}

// Usage
calculator.sum(1, 2, 3, 4, 5);  // 15
calculator.log("Data:", 1, "test", true);
```

```javascript !! js
// JavaScript - Rest parameters
function sum(...numbers) {
    return numbers.reduce((total, n) => total + n, 0);
}

console.log(sum(1, 2, 3));        // 6
console.log(sum(1, 2, 3, 4, 5));  // 15

// Mixed with regular parameters
function greet(greeting, ...names) {
    names.forEach(name => {
        console.log(`${greeting}, ${name}!`);
    });
}

greet("Hello", "Alice", "Bob", "Charlie");
// "Hello, Alice!"
// "Hello, Bob!"
// "Hello, Charlie!"

// Rest parameter must be last
// function bad(...rest, last) {}  // SyntaxError

// Practical: Create flexible API
function middleware(...handlers) {
    return function(req, res, next) {
        handlers.forEach((handler, index) => {
            if (index === handlers.length - 1) {
                handler(req, res, next);
            } else {
                handler(req, res, () => {});
            }
        });
    };
}

// Destructuring with rest
function processUser({ id, name, ...details }) {
    console.log(`User ${id}: ${name}`);
    console.log("Details:", details);
}

processUser({
    id: 1,
    name: "Alice",
    age: 25,
    email: "alice@example.com",
    role: "admin"
});
// User 1: Alice
// Details: { age: 25, email: "alice@example.com", role: "admin" }
```
</UniversalEditor>

## Spread Operator

Spread 運算符允許你展開可迭代物件：

<UniversalEditor title="Spread Operator">
```java !! java
// Java - Arrays.copyOf or manual copy
int[] original = {1, 2, 3};
int[] copy = Arrays.copyOf(original, original.length);

// Or manual
int[] copy2 = new int[original.length];
for (int i = 0; i < original.length; i++) {
    copy2[i] = original[i];
}

// Java doesn't have spread operator
```

```javascript !! js
// JavaScript - Spread operator
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Spread into new array
const combined = [...arr1, ...arr2];
console.log(combined);  // [1, 2, 3, 4, 5, 6]

// Spread with other values
const withExtras = [0, ...arr1, 3.5, ...arr2, 7];
console.log(withExtras);  // [0, 1, 2, 3, 3.5, 4, 5, 6, 7]

// Copy array
const copy = [...arr1];

// Spread into function arguments
function add(a, b, c) {
    return a + b + c;
}

const numbers = [1, 2, 3];
console.log(add(...numbers));  // 6

// Spread objects（ES2018+）
const user = { name: "Alice", age: 25 };
const withRole = { ...user, role: "admin" };
console.log(withRole);
// { name: "Alice", age: 25, role: "admin" }

// Override properties
const updated = { ...user, age: 26 };
console.log(updated);
// { name: "Alice", age: 26 }

// Merge objects
const defaults = { theme: "dark", lang: "en" };
const settings = { lang: "zh-tw" };
const final = { ...defaults, ...settings };
console.log(final);  // { theme: "dark", lang: "zh-tw" }

// Practical: Immutable updates
const state = { count: 0, name: "counter" };
const newState = { ...state, count: state.count + 1 };
console.log(state, newState);
// { count: 0, name: "counter" } { count: 1, name: "counter" }
```
</UniversalEditor>

## Hoisting

函數提升是 JavaScript 中的一個重要概念：

<UniversalEditor title="Function Hoisting">
```java !! java
// Java - No hoisting
// Methods must be declared before use
public class Example {
    public void method1() {
        method2();  // Compilation error if method2 not declared
    }
}
```

```javascript !! js
// JavaScript - Hoisting

// Function declarations are hoisted
console.log(declared());  // "Declared!"（works）

function declared() {
    return "Declared!";
}

// Function expressions are NOT hoisted
// console.log(expressed());  // TypeError: expressed is not a function

const expressed = function() {
    return "Expressed!";
};

// Var declarations are hoisted（but undefined）
console.log(varVar);  // undefined（not ReferenceError）
var varVar = 5;

// Let/const are NOT hoisted to the top
// console.log(letVar);  // ReferenceError: Cannot access 'letVar' before initialization
let letVar = 10;

// Practical: Safe ordering
// 1. Declare functions first
function processData(data) {
    return data.map(transform);
}

function transform(item) {
    return item * 2;
}

// 2. Use function expressions for mutual recursion
const isEven = (n) => {
    if (n === 0) return true;
    return isOdd(n - 1);
};

const isOdd = (n) => {
    if (n === 0) return false;
    return isEven(n - 1);
};
```
</UniversalEditor>

## First-Class Functions

函數作為一等公民意味著它們可以：

<UniversalEditor title="First-Class Functions">
```java !! java
// Java - Methods are not first-class
// Need interfaces/functional interfaces for function-like behavior

@FunctionalInterface
interface Operation {
    int apply(int a, int b);
}

public class Calculator {
    public int calculate(Operation op, int a, int b) {
        return op.apply(a, b);
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // Lambda（close to first-class function）
        int result = calc.calculate((x, y) -> x + y, 5, 3);
    }
}
```

```javascript !! js
// JavaScript - Functions are first-class citizens

// 1. Assign to variables
const greet = function(name) {
    console.log(`Hello, ${name}!`);
};

// 2. Pass as arguments
function repeat(fn, times) {
    for (let i = 0; i < times; i++) {
        fn();
    }
}

repeat(() => console.log("Hello!"), 3);
// "Hello!"
// "Hello!"
// "Hello!"

// 3. Return from functions
function createGreeter(greeting) {
    return function(name) {
        console.log(`${greeting}, ${name}!`);
    };
}

const sayHi = createGreeter("Hi");
sayHi("Alice");  // "Hi, Alice!"

const sayHello = createGreeter("Hello");
sayHello("Bob");  // "Hello, Bob!"

// 4. Store in data structures
const operations = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => a / b
};

console.log(operations.add(5, 3));        // 8
console.log(operations.multiply(4, 3));   // 12

// 5. Have properties（functions are objects）
function greet(name) {
    console.log(`Hello, ${name}!`);
}

greet.version = "1.0";
greet.author = "Alice";
console.log(greet.version);  // "1.0"
```
</UniversalEditor>

## Practical Patterns

### Pattern 1: Function Composition

<UniversalEditor title="Function Composition">
```javascript !! js
// Compose multiple functions
function compose(...fns) {
    return function(value) {
        return fns.reduceRight((acc, fn) => fn(acc), value);
    };
}

const toUpper = str => str.toUpperCase();
const exclaim = str => str + "!";
const reverse = str => str.split("").reverse().join("");

const transform = compose(reverse, exclaim, toUpper);
console.log(transform("hello"));  // "!OLLEH"

// Pipe（left to right）
function pipe(...fns) {
    return function(value) {
        return fns.reduce((acc, fn) => fn(acc), value);
    };
}

const transform2 = pipe(toUpper, exclaim, reverse);
console.log(transform2("hello"));  // "ELH!"
```
</UniversalEditor>

### Pattern 2: Closures Introduction

<UniversalEditor title="Simple Closures">
```java !! java
// Java - Anonymous classes capture variables
public class Greeter {
    public Function<String, String> createGreeter(String greeting) {
        return name -> greeting + ", " + name + "!";
        // greeting is "captured"（effectively final）
    }
}
```

```javascript !! js
// JavaScript - Closures
function createGreeter(greeting) {
    return function(name) {
        console.log(`${greeting}, ${name}!`);
    };
    // greeting is "closed over" and remembered
}

const sayHi = createGreeter("Hi");
const sayHello = createGreeter("Hello");

sayHi("Alice");    // "Hi, Alice!"
sayHello("Bob");   // "Hello, Bob!"

// Practical: Function factories
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15

// Practical: Private state（covered more in Module 4）
function createCounter() {
    let count = 0;
    return {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
}

const counter = createCounter();
console.log(counter.increment());  // 1
console.log(counter.increment());  // 2
console.log(counter.getCount());   // 2
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Function Best Practices">
```javascript !! js
// 1. Use arrow functions for short callbacks
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);

// 2. Use regular functions for methods
const calculator = {
    value: 0,
    add: function(v) {
        this.value += v;
    },
    subtract(v) {
        this.value -= v;
    }
};

// 3. Use default parameters instead of checking for undefined
function greet(name = "World") {
    console.log(`Hello, ${name}!`);
}

// 4. Use rest parameters instead of arguments
function sum(...numbers) {
    return numbers.reduce((a, b) => a + b, 0);
}

// 5. Use descriptive names
// Bad
function fn(x) {
    return x * 2;
}

// Good
function double(value) {
    return value * 2;
}

// 6. Keep functions small and focused
// Bad
function process(data) {
    // 50 lines of code doing multiple things
}

// Good
function validate(data) {
    // Validation logic
}

function transform(data) {
    // Transformation logic
}

function save(data) {
    // Save logic
}

// 7. Return early（guard clauses）
function processUser(user) {
    if (!user) {
        return null;
    }

    if (!user.isActive) {
        return null;
    }

    return transformUser(user);
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Function Types
將此 Java 程式碼轉換為 JavaScript：
```java
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }
}
```

### Exercise 2: Arrow Functions
使用箭頭函數重寫：
```javascript
function add(a, b) {
    return a + b;
}

function greet(name) {
    return "Hello, " + name;
}
```

### Exercise 3: Default Parameters
創建一個帶有預設參數的函數：
```javascript
function createRequest(url, method, body, headers) {
    // Set defaults: method = "GET", body = null, headers = {}
}
```

### Exercise 4: Rest Parameters
創建一個函數來計算可變數量參數的平均值：
```javascript
function average(...numbers) {
    // Return the average of all numbers
}
```

## Summary

### Key Takeaways

1. **Declarations vs Expressions:**
   - Declarations 會被提升
   - Expressions 不會被提升
   - 選擇取決於風格和使用案例

2. **Arrow Functions:**
   - 更簡潔的語法
   - 詞法 `this`（繼承自周圍作用域）
   - 不能用作建構函數
   - 適合用於回調函數

3. **Default Parameters:**
   - 比方法多載更靈活
   - 可以是運算式
   - 僅對 undefined 使用預設值

4. **Rest & Spread:**
   - Rest: 收集參數為陣列
   - Spread: 展開陣列/物件
   - 對可變參數和不可變更新很有用

5. **First-Class Functions:**
   - 可以被指派、傳遞、返回
   - 可以有屬性
   - 是 JavaScript 的核心概念

## What's Next?

你已經掌握了函數基礎！接下來是 **Module 4: Functions Advanced**，我們將探討：

- Closures in depth
- Higher-order functions
- Currying and partial application
- Memoization
- Recursion in JavaScript
- Generator functions

準備好深入學習進階函數概念了嗎？讓我們繼續！
