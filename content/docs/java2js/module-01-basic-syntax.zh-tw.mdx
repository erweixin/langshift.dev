---
title: "Module 1: Basic Syntax Comparison"
description: "Learn JavaScript variables, data types, operators, and basic syntax compared to Java"
---

## Module 1: Basic Syntax Comparison

歡迎來到 JavaScript 語法的首次深入探討！作為 Java 開發者，你會發現許多熟悉的概念，但 JavaScript 有一些重要的差異使其獨特。

## Learning Objectives

By the end of this module, you will:
✅ Understand JavaScript variable declarations (var, let, const)
✅ Know the differences between Java's static typing and JavaScript's dynamic typing
✅ Master JavaScript's primitive and reference types
✅ Understand type coercion and how to avoid common pitfalls
✅ Learn JavaScript operators and their quirks

## Variable Declarations

### Java Variables

在 Java 中，變數是明確型別的：

<UniversalEditor title="Variable Declaration: Java vs JavaScript">
```java !! java
// Java - Explicit type declarations
String name = "John";
int age = 25;
double salary = 50000.50;
boolean isActive = true;
char grade = 'A';

// Final variable (cannot be reassigned)
final String CITY = "New York";
// CITY = "Boston";  // Compilation error!

// Null values
String middleName = null;

// Type inference with var (Java 10+)
var username = "johndoe";  // Type is inferred as String
// username = 42;  // Compilation error!
```

```javascript !! js
// JavaScript - No type declarations
let name = "John";
let age = 25;
let salary = 50000.50;
let isActive = true;

// Constants (cannot be reassigned)
const CITY = "New York";
// CITY = "Boston";  // TypeError: Assignment to constant variable

// No explicit null declaration needed
let middleName = null;
let middleName2 = undefined;

// Type is dynamic
let username = "johndoe";
username = 42;  // Valid! Type changes to number
username = true;  // Now it's a boolean
```
</UniversalEditor>

### JavaScript Variable Keywords

JavaScript 有三種宣告變數的方法：

#### 1. `var`（舊方法 - 在現代程式碼中避免使用）

<UniversalEditor title="var Behavior and Problems">
```javascript !! js
// var - function-scoped (NOT block-scoped)
function example() {
    if (true) {
        var x = 10;
    }
    console.log(x);  // 10 - accessible outside if block!
}

// var can be redeclared
var name = "John";
var name = "Jane";  // No error!

// var hoisting
console.log(y);  // undefined (not an error!)
var y = 5;

// This is equivalent to:
var y;  // Declaration hoisted to top
console.log(y);
y = 5;  // Assignment stays here

// DON'T USE var IN MODERN CODE!
// Use let and const instead
```
</UniversalEditor>

#### 2. `let`（現代方法，用於會改變的變數）

<UniversalEditor title="let Usage">
```javascript !! js
// let - block-scoped (like Java)
function example() {
    if (true) {
        let x = 10;
        console.log(x);  // 10
    }
    console.log(x);  // ReferenceError: x is not defined
}

// let cannot be redeclared in same scope
let name = "John";
// let name = "Jane";  // SyntaxError!

// But can be reassigned
let age = 25;
age = 26;  // Valid

// let with for loops (block-scoped)
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 100);
}
// Output: 0, 1, 2 (each iteration has its own i)

// Compare with var (function-scoped)
for (var j = 0; j < 3; j++) {
    setTimeout(() => console.log(j), 100);
}
// Output: 3, 3, 3 (shared j reference)
```
</UniversalEditor>

#### 3. `const`（現代方法，用於常數）

<UniversalEditor title="const Usage">
```javascript !! js
// const - block-scoped, cannot be reassigned
const PI = 3.14159;
// PI = 3.14;  // TypeError: Assignment to constant variable

// Must be initialized
const name;  // SyntaxError: Missing initializer

// Objects and arrays can still be modified (not reassigned)
const person = { name: "John", age: 25 };
person.name = "Jane";  // Valid! Object is modified
person.age = 26;  // Valid!

// person = {};  // TypeError: Cannot reassign const

const numbers = [1, 2, 3];
numbers.push(4);  // Valid! Array is modified
// numbers = [];  // TypeError: Cannot reassign const

// To prevent modifications, use Object.freeze()
const frozenPerson = Object.freeze({ name: "John", age: 25 });
frozenPerson.name = "Jane";  // Silently fails (strict mode: error)
console.log(frozenPerson.name);  // "John"
```
</UniversalEditor>

### Best Practice: When to Use What

<UniversalEditor title="Variable Declaration Best Practices">
```java !! java
// Java - Always use final when possible
public class User {
    private final String name;  // Use final for constants
    private int age;            // Use regular for mutable fields

    public User(String name) {
        this.name = name;  // Assign once
    }

    public void setAge(int age) {
        this.age = age;  // Can change
    }
}
```

```javascript !! js
// JavaScript - Prefer const, use let when needed
// 1. Use const by default (most variables don't need to change)
const API_URL = "https://api.example.com";
const MAX_RETRIES = 3;

// 2. Use let when you need to reassign
let counter = 0;
counter++;

let userData = null;
userData = fetchUserData();

// 3. Avoid var entirely (it's function-scoped and confusing)
// ❌ Don't do this:
var i = 0;

// ✅ Do this instead:
let i = 0;
```
</UniversalEditor>

## Data Types

### Primitive Types

JavaScript 有 7 種基本型別（Java 有 8 種）：

<UniversalEditor title="Primitive Types Comparison">
```java !! java
// Java primitives
byte b = 127;                // 8-bit integer
short s = 32767;             // 16-bit integer
int i = 2147483647;          // 32-bit integer
long l = 9223372036854775807L;  // 64-bit integer
float f = 3.14f;             // 32-bit floating point
double d = 3.14159265359;    // 64-bit floating point
char c = 'A';                // 16-bit Unicode character
boolean bool = true;         // true or false

// Java also has void (no value)
```

```javascript !! js
// JavaScript primitives (simpler!)
let num = 42;                // Number (all numbers are 64-bit floats)
let pi = 3.14159265359;      // Number (no int/float distinction)
let bigInt = 9007199254740991n;  // BigInt (for large integers)

let str = "Hello";           // String (can use " or ' or `)
let char = 'A';              // Still a String (single chars are strings)

let bool = true;             // Boolean (true or false)

let nothing = null;          // Null (intentional absence)
let undefinedVar = undefined; // Undefined (unintentional absence)

let symbol = Symbol('id');   // Symbol (unique identifier, ES6+)
```
</UniversalEditor>

### Number Type

JavaScript 只有一種數字型別（不像 Java）：

<UniversalEditor title="Number Differences">
```java !! java
// Java - Multiple numeric types
int integer = 42;
double decimal = 3.14;
long bigNumber = 9007199254740991L;

// Type promotion
int a = 5;
int b = 2;
int result = a / b;  // result = 2 (integer division)

// Explicit casting
double x = 3.7;
int y = (int) x;  // y = 3 (truncates)
```

```javascript !! js
// JavaScript - Single Number type (IEEE 754 64-bit float)
let integer = 42;
let decimal = 3.14;
let scientific = 1.5e-4;  // 0.00015
let hex = 0xFF;           // 255
let binary = 0b1010;      // 10
let octal = 0o755;        // 493

// Division always produces float
let a = 5;
let b = 2;
let result = a / b;  // result = 2.5 (not 2!)

// Number methods
let num = 42.123;
console.log(num.toFixed(2));  // "42.12"
console.log(Math.round(num)); // 42
console.log(Math.floor(num)); // 42

// Special numeric values
let infinity = Infinity;
let negInfinity = -Infinity;
let notANumber = NaN;  // Not-a-Number

console.log(0 / 0);           // NaN
console.log(1 / 0);           // Infinity
console.log(Math.sqrt(-1));   // NaN

// Check for NaN (important!)
console.log(NaN === NaN);  // false (NaN is not equal to itself!)
console.log(Number.isNaN(NaN));  // true
console.log(Number.isFinite(42));  // true
console.log(Number.isFinite(Infinity));  // false
```
</UniversalEditor>

### String Type

JavaScript 字串類似於 Java 字串，但更具靈活性：

<UniversalEditor title="String Comparison">
```java !! java
// Java strings are immutable
String name = "John";
name.toUpperCase();  // Returns "JOHN" but name is still "John"
name = name.toUpperCase();  // Now name is "JOHN"

// String concatenation
String greeting = "Hello, " + name;

// Multiline strings (Java 15+)
String multiline = """
    This is a
    multiline string
    """;

// String methods
String text = "JavaScript";
System.out.println(text.length());           // 10
System.out.println(text.substring(0, 4));    // "Java"
System.out.println(text.contains("Script")); // true
```

```javascript !! js
// JavaScript strings are immutable (same as Java)
let name = "John";
name.toUpperCase();  // Returns "JOHN" but name is still "John"
name = name.toUpperCase();  // Now name is "JOHN"

// String concatenation (multiple ways)
let greeting = "Hello, " + name;
let greeting2 = `Hello, ${name}`;  // Template literal (preferred)

// Multiline strings (template literals)
const multiline = `This is a
multiline string`;

// String methods
const text = "JavaScript";
console.log(text.length);              // 10
console.log(text.substring(0, 4));     // "Java"
console.log(text.includes("Script"));  // true
console.log(text.startsWith("Java"));  // true
console.log(text.endsWith("Script"));  // true
console.log(text.split('a'));          // ["J", "v", "Script"]

// String methods that return modified strings
console.log(text.toUpperCase());       // "JAVASCRIPT"
console.log(text.toLowerCase());       // "javascript"
console.log(text.trim());              // Removes whitespace
console.log(text.replace("Java", "ECMA"));  // "ECMAScript"

// Template literals with expressions
const x = 10;
const y = 20;
console.log(`${x} + ${y} = ${x + y}`);  // "10 + 20 = 30"

// Tagged template literals (advanced)
function highlight(strings, ...values) {
    return strings.reduce((result, str, i) => {
        return result + str + (values[i] || '');
    }, '');
}
const name2 = "John";
const age = 25;
console.log(highlight`Name: ${name2}, Age: ${age}`);
```
</UniversalEditor>

### Boolean Type and Truthy/Falsy Values

這與 Java 的一個主要差異！

<UniversalEditor title="Boolean and Truthy/Falsy">
```java !! java
// Java - Strict boolean checking
boolean isActive = true;
boolean isInactive = false;

// Only boolean expressions can be used in conditionals
String name = "John";
if (name != null && !name.isEmpty()) {  // Must check explicitly
    System.out.println("Name exists");
}

// No truthy/falsy - must be explicit
int count = 0;
if (count > 0) {  // Cannot just use "if (count)"
    System.out.println("Count is positive");
}
```

```javascript !! js
// JavaScript - Boolean plus truthy/falsy values
let isActive = true;
let isInactive = false;

// Falsy values (evaluate to false in boolean context):
false, 0, -0, 0n, "", null, undefined, NaN

// Truthy values (everything else):
true, 42, "hello", {}, [], [], function() {}

// Short-circuit evaluation
const name = "John";
if (name) {  // name is truthy (non-empty string)
    console.log("Name exists");
}

const count = 0;
if (count) {  // count is falsy (zero)
    console.log("Count is positive");
} else {
    console.log("Count is zero or negative");
}

// Common pattern: default values
function greet(name) {
    // If name is falsy, use "Guest"
    const displayName = name || "Guest";
    console.log(`Hello, ${displayName}`);
}

greet("John");  // "Hello, John"
greet("");      // "Hello, Guest"
greet(null);    // "Hello, Guest"

// Nullish coalescing operator (ES2020)
// Only checks for null/undefined (not 0 or "")
function greet2(name) {
    const displayName = name ?? "Guest";
    console.log(`Hello, ${displayName}`);
}

greet2("");  // "Hello, " (empty string is not null/undefined)
greet2(null);  // "Hello, Guest"

// Boolean conversion
console.log(Boolean("hello"));  // true
console.log(Boolean(""));       // false
console.log(Boolean(42));       // true
console.log(Boolean(0));        // false
console.log(Boolean({}));  // true (empty object is truthy!)
console.log(Boolean([]));       // true (empty array is truthy!)
```
</UniversalEditor>

### Null vs Undefined

兩種表示「無值」的方式：

<UniversalEditor title="Null vs Undefined">
```java !! java
// Java - Only null
String name = null;
int[] numbers = null;

// Cannot have undefined - everything is initialized
// int x;  // Must be initialized before use
int x = 0;  // Default value for primitives

// Optional type (Java 8+)
Optional<String> optionalName = Optional.of("John");
Optional<String> emptyOptional = Optional.empty();
```

```javascript !! js
// JavaScript - Both null and undefined

// undefined: Variable declared but not assigned
let x;
console.log(x);  // undefined

// null: Intentionally set to no value
let y = null;
console.log(y);  // null

// Key differences:
console.log(typeof undefined);  // "undefined"
console.log(typeof null);       // "object" (historical bug!)

// Converting to number
console.log(Number(undefined));  // NaN
console.log(Number(null));       // 0

// Loose equality (avoid this!)
console.log(null == undefined);   // true
console.log(null === undefined);  // false (use strict equality)

// Best practice:
// Use null for "intentionally empty"
function getUser(id) {
    const user = database.find(id);
    return user !== undefined ? user : null;
}

// Use undefined for "not set"
function process(options) {
    // If options.timeout is not provided
    if (options.timeout === undefined) {
        options.timeout = 5000;  // Use default
    }
}

// Checking for null/undefined
function safeGet(obj) {
    // Old way
    if (obj !== null && obj !== undefined) {
        return obj.value;
    }

    // Modern way (checks for both null and undefined)
    if (obj != null) {  // Loose equality works here
        return obj.value;
    }

    // Or using nullish coalescing
    return obj?.value;
}
```
</UniversalEditor>

## Type Coercion

JavaScript 在某些上下文中自動轉換型別 - 這是錯誤的主要來源！

<UniversalEditor title="Type Coercion Examples">
```java !! java
// Java - No type coercion (mostly)
String result = "10" + 5;  // "105" (String concatenation)
// int result = "10" + 5;   // Compilation error!

// Must explicitly convert
int num = Integer.parseInt("10");
String str = String.valueOf(42);

// Boolean is strict
boolean b = (1 == 2);  // false
// boolean b2 = 1;  // Compilation error!
```

```javascript !! js
// JavaScript - Automatic type coercion
console.log("10" + 5);    // "105" (string concatenation)
console.log("10" - 5);    // 5 (subtraction converts to number)
console.log("10" * 5);    // 50 (multiplication converts to number)
console.log("10" / 5);    // 2 (division converts to number)

// String concatenation tricks
console.log(1 + "2");      // "12"
console.log(1 + 2 + "3");  // "33" (1+2=3, then "3"+"3"="33")
console.log("1" + 2 + 3);  // "123"

// Loose equality (==) with coercion
console.log(5 == "5");     // true (string converted to number)
console.log(0 == "");      // true (empty string converted to 0)
console.log(0 == "0");     // true
console.log(false == 0);   // true
console.log(null == undefined);  // true

// Strict equality (===) - no coercion
console.log(5 === "5");    // false (different types)
console.log(0 === "");     // false
console.log(false === 0);  // false
console.log(null === undefined);  // false

// ALWAYS use strict equality (=== and !==)
function compare(a, b) {
    // ❌ Bad: loose equality
    if (a == b) {  // Might have unexpected behavior
        // ...
    }

    // ✅ Good: strict equality
    if (a === b) {  // Clear type checking
        // ...
    }
}

// Explicit type conversion
let str = "42";
let num = Number(str);        // 42 (or NaN if invalid)
let num2 = parseInt(str);     // 42 (integer only)
let num3 = parseFloat("3.14"); // 3.14

let numToStr = String(42);     // "42"
let numToStr2 = 42.toString();  // "42"
let numToStr3 = (42).toString(); // "42" (need parentheses for literals)

let toBool = Boolean("hello");  // true
let toBool2 = !!"hello";        // true (double negation trick)
```
</UniversalEditor>

## Operators

大多數運算子類似於 Java，但 JavaScript 有一些獨特的：

<UniversalEditor title="Operator Comparison">
```java !! java
// Java operators
int a = 10, b = 3;

// Arithmetic
int sum = a + b;        // 13
int diff = a - b;       // 7
int prod = a * b;       // 30
int quot = a / b;       // 3 (integer division)
int rem = a % b;        // 1

// Comparison
boolean equal = (a == b);     // false
boolean notEqual = (a != b);  // true
boolean greater = (a > b);    // true
boolean lessOrEqual = (a <= b);  // false

// Logical
boolean and = (true && false);  // false
boolean or = (true || false);   // true
boolean not = !true;            // false

// Bitwise
int bitwiseAnd = a & b;    // 2
int bitwiseOr = a | b;     // 11
int bitwiseXor = a ^ b;    // 9
int bitwiseNot = ~a;       // -11
int leftShift = a << 1;    // 20
int rightShift = a >> 1;   // 5

// Ternary
int max = (a > b) ? a : b;  // 10

// Increment/decrement
a++;  // a = a + 1
b--;  // b = b - 1
```

```javascript !! js
// JavaScript operators (similar but some differences)
let a = 10, b = 3;

// Arithmetic (same as Java, but division produces float)
let sum = a + b;        // 13
let diff = a - b;       // 7
let prod = a * b;       // 30
let quot = a / b;       // 3.333... (NOT integer division!)
let rem = a % b;        // 1

// Integer division (ES2020)
let intQuot = Math.trunc(a / b);  // 3

// Comparison (use strict versions!)
let equal = (a === b);     // false (strict)
let notEqual = (a !== b);  // true (strict)
let greater = (a > b);     // true
let lessOrEqual = (a <= b); // false

// Loose equality (avoid!)
console.log(10 == "10");   // true (coerced)
console.log(10 === "10");  // false (strict)

// Logical operators (return the actual value, not just boolean)
let logicalAnd = true && false;   // false
let logicalAnd2 = 10 && 20;       // 20 (returns last truthy value)
let logicalOr = true || false;    // true
let logicalOr2 = 0 || 42;         // 42 (returns first truthy value)
let logicalNot = !true;           // false

// Nullish coalescing (ES2020)
let value = null ?? "default";  // "default" (only for null/undefined)
let value2 = 0 ?? "default";    // 0 (0 is not null/undefined)

// Optional chaining (ES2020)
const user = { name: "John", address: { city: "NYC" } };
console.log(user?.address?.city);  // "NYC"
console.log(user?.phone?.number);  // undefined (no error)

// Bitwise (same as Java)
let bitwiseAnd = a & b;    // 2
let bitwiseOr = a | b;     // 11
let bitwiseXor = a ^ b;    // 9
let bitwiseNot = ~a;       // -11
let leftShift = a << 1;    // 20
let rightShift = a >> 1;   // 5
let unsignedRightShift = a >>> 1;  // 5 (JavaScript only)

// Exponentiation (ES2016)
let power = 2 ** 3;  // 8 (2 to the power of 3)
// Equivalent to: Math.pow(2, 3)

// Ternary (same as Java)
let max = (a > b) ? a : b;  // 10

// Increment/decrement (same as Java)
a++;  // a = a + 1
b--;  // b = b - 1
++a;  // Pre-increment
--b;  // Pre-decrement

// Unary operators
let positive = +10;        // 10
let negative = -10;        // -10
let toNumber = +"42";      // 42 (converts string to number)
```
</UniversalEditor>

## typeof Operator

JavaScript 有一個 `typeof` 運算子來檢查型別：

<UniversalEditor title="typeof Operator">
```java !! java
// Java - No typeof operator
// Use instanceof or getClass()
String str = "hello";
if (str instanceof String) {
    System.out.println("It's a String");
}

// Reflection
Class<?> type = str.getClass();
System.out.println(type.getName());  // "java.lang.String"
```

```javascript !! js
// JavaScript - typeof operator
let num = 42;
let str = "hello";
let bool = true;
let obj = { name: "John" };
let arr = [1, 2, 3];
let func = function() {};
let nothing = null;
let undef = undefined;

console.log(typeof num);    // "number"
console.log(typeof str);    // "string"
console.log(typeof bool);   // "boolean"
console.log(typeof obj);    // "object"
console.log(typeof arr);    // "object" (arrays are objects!)
console.log(typeof func);   // "function"
console.log(typeof nothing); // "object" (historical bug!)
console.log(typeof undef);   // "undefined"

// Checking for null (need special handling)
function isNull(value) {
    return value === null;
}

// Checking for array
function isArray(value) {
    return Array.isArray(value);
}

// Checking for NaN
function isNaNCheck(value) {
    return Number.isNaN(value);
}

// Pattern: type checking
function process(value) {
    if (typeof value === "string") {
        console.log("Processing string:", value.toUpperCase());
    } else if (typeof value === "number") {
        console.log("Processing number:", value * 2);
    } else if (Array.isArray(value)) {
        console.log("Processing array:", value.length);
    } else if (value === null) {
        console.log("Processing null value");
    } else {
        console.log("Unknown type");
    }
}

process("hello");  // "Processing string: HELLO"
process(42);       // "Processing number: 84"
process([1, 2, 3]); // "Processing array: 3"
process(null);     // "Processing null value"
```
</UniversalEditor>

## Common Pitfalls

### Pitfall 1: Using == Instead of ===

<UniversalEditor title="Equality Pitfalls">
```javascript !! js
// ❌ BAD: Loose equality
console.log(0 == false);       // true
console.log("" == false);      // true
console.log("0" == false);     // true
console.log(null == undefined); // true
console.log([] == false);      // true
console.log([1] == "1");       // true

// ✅ GOOD: Strict equality
console.log(0 === false);       // false
console.log("" === false);      // false
console.log("0" === false);     // false
console.log(null === undefined); // false
console.log([] === false);      // false
console.log([1] === "1");       // false

// ESLint rule to enforce this
/* eslint eqeqeq: ["error", "always"] */
```
</UniversalEditor>

### Pitfall 2: Forgetting const/let

<UniversalEditor title="Variable Declaration Pitfalls">
```javascript !! js
// ❌ BAD: Using var
var name = "John";
if (true) {
    var name = "Jane";  // Redeclares in same scope!
}
console.log(name);  // "Jane" (unexpected!)

// ❌ BAD: Forgetting const/let
message = "Hello";  // Creates global variable (bad practice)

// ✅ GOOD: Using let/const
let name = "John";
if (true) {
    let name = "Jane";  // Block-scoped
}
console.log(name);  // "John" (as expected)

// ✅ GOOD: Always declare variables
const message = "Hello";  // Properly declared
```
</UniversalEditor>

### Pitfall 3: Type Coercion Surprises

<UniversalEditor title="Type Coercion Pitfalls">
```javascript !! js
// Pitfall: String + Number
console.log("10" + 20);   // "1020" (string concatenation)
console.log(10 + "20");   // "1020"
console.log(10 + 20 + "30"); // "3030" (10+20=30, then "30"+"30")

// Solution: Explicitly convert
console.log(Number("10") + 20);  // 30
console.log("10" + String(20));  // "1020"

// Pitfall: Subtraction converts to number
console.log("10" - 5);    // 5
console.log("10px" - 5);  // NaN (can't convert "10px")
console.log("10" - "5");  // 5

// Solution: Explicit parsing
console.log(parseInt("10px") - 5);  // 5

// Pitfall: Object to primitive
console.log(1 + {});     // "1[object Object]"
console.log({} + 1);     // "[object Object]1"
console.log([] + []);    // "" (empty string)
console.log([] + {});    // "[object Object]"
console.log({} + []);    // "[object Object]"
```
</UniversalEditor>

## Best Practices Summary

<UniversalEditor title="Best Practices: Variable Declaration and Types">
```java !! java
// Java: Clear, explicit types
public class User {
    private final String name;  // Use final for constants
    private int age;            // Regular for mutable

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public boolean isAdult() {
        return age >= 18;  // Clear boolean check
    }
}
```

```javascript !! js
// JavaScript: Modern, clean syntax
class User {
    constructor(name, age) {
        this.name = name;  // Use _ for private convention (ES2022 has #)
        this._age = age;
    }

    isAdult() {
        return this._age >= 18;  // Same check
    }
}

// Variable declaration rules
const API_URL = "https://api.example.com";  // Use const for constants
let currentUser = null;                      // Use let for variables that change
let counter = 0;                             // Use let for counters

// Always use strict equality
if (counter === 0) {  // ✅
    // ...
}

// Avoid type coercion - be explicit
const num = Number(str);      // ✅ Explicit conversion
const sum = a + b;            // ✅ Clear operation
const result = `${a}${b}`;    // ✅ Explicit string concatenation

// Use template literals
const greeting = `Hello, ${name}!`;  // ✅ Modern syntax

// Check for null/undefined properly
if (user != null) {  // Checks both null and undefined (loose eq ok here)
    // Safe to access user
}

// Or use optional chaining
const city = user?.address?.city;  // Safe property access
```
</UniversalEditor>

## Exercises

### Exercise 1: Variable Declarations
Convert this Java code to idiomatic JavaScript:
```java
String name = "John";
int age = 25;
final String CITY = "New York";
boolean isActive = true;
```

### Exercise 2: Type Conversion
Fix the type coercion issues:
```javascript
function add(a, b) {
    return a + b;  // Should add numbers, not concatenate strings
}

console.log(add(5, "10"));  // Should output 15, not "510"
```

### Exercise 3: Null/Undefined Handling
Write a function that handles null/undefined values:
```javascript
function getDisplayName(user) {
    // Return user.name if user exists and has a name
    // Otherwise return "Guest"
}
```

### Exercise 4: Type Checking
Write a function that processes different types:
```javascript
function processValue(value) {
    // If string: return uppercase
    // If number: return doubled
    // If boolean: return negated
    // If array: return length
    // Otherwise: return "unknown"
}
```

## Summary

### Key Takeaways

1. **Variable Declarations:**
   - Use `const` by default (cannot be reassigned)
   - Use `let` when you need to reassign
   - Avoid `var` (it's function-scoped and confusing)

2. **Type System:**
   - JavaScript is dynamically typed (no type declarations)
   - Primitive types: number, string, boolean, null, undefined, symbol, bigint
   - Everything else is an object (including arrays and functions)

3. **Type Coercion:**
   - JavaScript automatically converts types in many contexts
   - Always use strict equality (`===` and `!==`)
   - Be explicit about type conversion

4. **Truthy/Falsy:**
   - Falsy: `false`, `0`, `""`, `null`, `undefined`, `NaN`
   - Truthy: Everything else (including `{}` and `[]`)
   - Use `??` for nullish coalescing, `||` for logical OR

5. **Best Practices:**
   - Prefer `const` over `let`
   - Always use strict equality
   - Be explicit about type conversions
   - Use template literals for string interpolation
   - Check for null/undefined with optional chaining (`?.`)

### Comparison Table: Java vs JavaScript

| Aspect | Java | JavaScript |
|--------|------|------------|
| **Variable declaration** | `String name = "John";` | `let name = "John";` or `const NAME = "John";` |
| **Constants** | `final int MAX = 100;` | `const MAX = 100;` |
| **Primitive count** | 8 primitives | 7 primitives (number, string, boolean, null, undefined, symbol, bigint) |
| **Number types** | byte, short, int, long, float, double | Just `number` (64-bit float) + `bigint` |
| **Equality** | `==` (no loose equality) | `===` (strict) and `==` (loose - avoid) |
| **Type checking** | `instanceof`, `getClass()` | `typeof`, `Array.isArray()` |
| **Type conversion** | Explicit: `Integer.parseInt()` | Implicit (coercion) or explicit: `Number()`, `String()` |
| **String concatenation** | `"Hello " + name` | `` `Hello ${name}` `` (template literal preferred) |
| **Null handling** | Only `null` | Both `null` and `undefined` |

## What's Next?

Now that you understand JavaScript's basic syntax and type system, let's move on to **Module 2: Control Flow and Loops**, where we'll learn how JavaScript's control structures compare to Java's!

You'll discover:
- How `if/else` differs (and doesn't!)
- The `switch` statement differences
- Loop variations (for, for...of, for...in)
- The power of array methods (map, filter, reduce)
- Break and continue behavior

Let's continue your JavaScript journey!
