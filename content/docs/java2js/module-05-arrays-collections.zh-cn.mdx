---
title: "模块 5:数组和集合"
description: "掌握 JavaScript 数组、Set、Map 和集合方法"
---

## 模块 5:数组和集合

JavaScript 的集合类型与 Java 有很大不同。数组更加灵活，而且 JavaScript 提供了额外的集合类型如 Set 和 Map。让我们探索这些强大的数据结构。

## 学习目标

完成本模块后,你将:
✅ 掌握 JavaScript 数组的创建和操作
✅ 理解数组方法(变异方法与非变异方法)
✅ 学习 Set 和 Map 数据结构
✅ 了解何时使用 WeakSet 和 WeakMap
✅ 理解数组解构
✅ 学习性能考虑

## 数组基础

JavaScript 数组更像动态列表,而不是 Java 的固定大小数组:

<UniversalEditor title="数组创建和基础">
```java !! java
// Java - 固定大小数组
int[] numbers = new int[5];
numbers[0] = 1;
numbers[1] = 2;
// numbers[5] = 3;  // ArrayIndexOutOfBoundsException

// 数组初始化器
int[] moreNumbers = {1, 2, 3, 4, 5};

// 大小是固定的
System.out.println(numbers.length);  // 5

// 不能改变大小
// 要添加元素,需要 ArrayList
```

```javascript !! js
// JavaScript - 动态数组
const numbers = [1, 2, 3, 4, 5];

// 可以添加元素
numbers.push(6);       // 添加到末尾
numbers.unshift(0);    // 添加到开头

// 可以删除元素
numbers.pop();         // 从末尾删除
numbers.shift();       // 从开头删除

// 动态长度
console.log(numbers.length);  // 5 (在 push/pop 之后)

// 混合类型(不推荐但可能)
const mixed = [1, "hello", true, { id: 1 }, [1, 2, 3]];

// 稀疏数组
const sparse = [1, , , 4];  // 数组中有空缺
console.log(sparse.length); // 4
console.log(sparse[1]);     // undefined

// 数组构造函数(避免 - 使用字面量语法)
const arr = new Array(5);   // 创建有 5 个空槽的数组
const arr2 = new Array(1, 2, 3);  // 创建 [1, 2, 3]
// 更好: const arr = [1, 2, 3];
```
</UniversalEditor>

### 数组长度

<UniversalEditor title="数组长度行为">
```java !! java
// Java - 长度是固定的
int[] arr = {1, 2, 3};
System.out.println(arr.length);  // 3

arr.length = 5;  // 编译错误!不能改变长度
```

```javascript !! js
// JavaScript - 长度是可写的
let arr = [1, 2, 3];
console.log(arr.length);  // 3

// 设置长度会截断或添加 undefined
arr.length = 5;
console.log(arr);  // [1, 2, 3, undefined × 2]

arr.length = 2;
console.log(arr);  // [1, 2]

// 清空数组
arr.length = 0;
console.log(arr);  // []

// 实用:快速截断
const bigArray = [1, 2, 3, 4, 5];
bigArray.length = 3;  // 只保留前 3 个元素

// 检查是否为空
if (arr.length === 0) {
    console.log("数组为空");
}

// 真值/假值
if (arr.length) {  // 有效,因为 0 是假值
    console.log("数组有元素");
}
```
</UniversalEditor>

## 数组方法 - 变异方法与非变异方法

JavaScript 区分修改数组的方法和创建新数组的方法:

### 变异方法

<UniversalEditor title="变异数组方法">
```java !! java
// Java - 数组没有方法
// 使用 ArrayList 或工具类
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
list.add("d");           // 添加到末尾
list.add(0, "start");    // 在索引处添加
list.remove(0);          // 删除索引处
list.set(0, "x");        // 替换索引处
```

```javascript !! js
// JavaScript - 变异方法

const arr = [1, 2, 3, 4, 5];

// push: 添加到末尾
arr.push(6);
console.log(arr);  // [1, 2, 3, 4, 5, 6]

// pop: 从末尾删除
arr.pop();
console.log(arr);  // [1, 2, 3, 4, 5]

// unshift: 添加到开头
arr.unshift(0);
console.log(arr);  // [0, 1, 2, 3, 4, 5]

// shift: 从开头删除
arr.shift();
console.log(arr);  // [1, 2, 3, 4, 5]

// splice: 在任何位置删除/添加
arr.splice(2, 1);  // 删除索引 2 的 1 个元素
console.log(arr);  // [1, 2, 4, 5]

arr.splice(2, 0, 3);  // 在索引 2 插入 3
console.log(arr);  // [1, 2, 3, 4, 5]

// sort: 原地排序
arr.sort((a, b) => a - b);
console.log(arr);  // [1, 2, 3, 4, 5]

// reverse: 原地反转
arr.reverse();
console.log(arr);  // [5, 4, 3, 2, 1]

// fill: 用值填充
arr.fill(0);
console.log(arr);  // [0, 0, 0, 0, 0]
```
</UniversalEditor>

### 非变异方法

<UniversalEditor title="非变异数组方法">
```java !! java
// Java - Streams 创建新集合
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

// 原列表不变
```

```javascript !! js
// JavaScript - 非变异方法
const numbers = [1, 2, 3, 4, 5];

// map: 转换为新数组
const doubled = numbers.map(n => n * 2);
console.log(doubled);    // [2, 4, 6, 8, 10]
console.log(numbers);    // [1, 2, 3, 4, 5] (未改变)

// filter: 选择元素
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);      // [2, 4]
console.log(numbers);    // [1, 2, 3, 4, 5] (未改变)

// slice: 提取部分
const first3 = numbers.slice(0, 3);
console.log(first3);     // [1, 2, 3]

// concat: 合并数组
const more = [6, 7, 8];
const combined = numbers.concat(more);
console.log(combined);   // [1, 2, 3, 4, 5, 6, 7, 8]

// join: 转换为字符串
const str = numbers.join("-");
console.log(str);        // "1-2-3-4-5"

// flat: 展平嵌套数组
const nested = [1, [2, [3, [4]]]];
const flat = nested.flat(2);
console.log(flat);       // [1, 2, 3, [4]]

// flatMap: 一步完成映射和展平
const sentences = ["Hello world", "Goodbye earth"];
const words = sentences.flatMap(s => s.split(" "));
console.log(words);      // ["Hello", "world", "Goodbye", "earth"]
```
</UniversalEditor>

## 数组解构

解构允许从数组中解包值:

<UniversalEditor title="数组解构">
```java !! java
// Java - 手动解包
int[] coordinates = {10, 20, 30};
int x = coordinates[0];
int y = coordinates[1];
int z = coordinates[2];

// 或使用对象/类
public class Point {
    public int x, y, z;
    // 构造函数、getter、setter...
}
```

```javascript !! js
// JavaScript - 解构
const coordinates = [10, 20, 30];

// 基础解构
const [x, y, z] = coordinates;
console.log(x, y, z);  // 10 20 30

// 跳过元素
const [first, , third] = coordinates;
console.log(first, third);  // 10 30

// 剩余运算符
const [head, ...tail] = coordinates;
console.log(head);  // 10
console.log(tail);  // [20, 30]

// 默认值
const [a = 1, b = 2, c = 3] = [10];
console.log(a, b, c);  // 10 2 3

// 交换变量
let m = 1, n = 2;
[m, n] = [n, m];
console.log(m, n);  // 2 1

// 解构函数返回
function getStats() {
    return [100, 50, [25, 75]];
}
const [total, min, [max1, max2]] = getStats();
console.log(total, min, max1, max2);  // 100 50 25 75

// 实用: 解析 URL
const url = "https://example.com/users/123";
const [, protocol, domain, path, id] = url.split(/\/+/);
console.log(protocol);  // "https:"
console.log(domain);    // "example.com"
console.log(path);      // "users"
console.log(id);        // "123"
```
</UniversalEditor>

## 搜索和查询

<UniversalEditor title="数组搜索方法">
```java !! java
// Java - 搜索方法
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

boolean hasAlice = names.contains("Alice");  // true
int indexOfBob = names.indexOf("Bob");       // 1

// 使用 streams
Optional<String> found = names.stream()
    .filter(n -> n.startsWith("B"))
    .findFirst();

boolean allLong = names.stream()
    .allMatch(n -> n.length() > 3);

boolean anyLong = names.stream()
    .anyMatch(n -> n.length() > 4);
```

```javascript !! js
// JavaScript - 搜索方法
const names = ["Alice", "Bob", "Charlie"];

// indexOf: 查找索引
const indexOfBob = names.indexOf("Bob");
console.log(indexOfBob);  // 1

const indexOfXYZ = names.indexOf("XYZ");
console.log(indexOfXYZ);  // -1 (未找到)

// includes: 检查存在
const hasAlice = names.includes("Alice");
console.log(hasAlice);  // true

// find: 查找匹配谓词的元素
const found = names.find(name => name.startsWith("B"));
console.log(found);  // "Bob"

// findIndex: 查找匹配元素的索引
const foundIndex = names.findIndex(name => name.startsWith("B"));
console.log(foundIndex);  // 1

// some: 检查是否有任何元素匹配
const anyLong = names.some(name => name.length > 4);
console.log(anyLong);  // true

// every: 检查是否所有元素匹配
const allLong = names.every(name => name.length > 3);
console.log(allLong);  // true

// lastIndexOf: 从末尾查找
const dupes = [1, 2, 3, 2, 1];
console.log(dupes.lastIndexOf(2));  // 3

// 实用: 按 ID 查找用户
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
];

const user = users.find(u => u.id === 2);
console.log(user);  // { id: 2, name: "Bob" }

const userIndex = users.findIndex(u => u.id === 2);
console.log(userIndex);  // 1
```
</UniversalEditor>

## 数组归约

<UniversalEditor title="数组归约方法">
```java !! java
// Java - 使用 streams 归约
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 求和
int sum = numbers.stream().reduce(0, Integer::sum);

// 求积
int product = numbers.stream().reduce(1, (a, b) -> a * b);

// 连接
String joined = names.stream().collect(Collectors.joining(", "));

// 转为 map
Map<Integer, String> map = names.stream()
    .collect(Collectors.toMap(
        String::length,
        Function.identity(),
        (a, b) -> a  // 合并函数
    ));
```

```javascript !! js
// JavaScript - 归约方法
const numbers = [1, 2, 3, 4, 5];

// reduce: 归约为单个值
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum);  // 15

const product = numbers.reduce((acc, n) => acc * n, 1);
console.log(product);  // 120

const max = numbers.reduce((acc, n) => Math.max(acc, n), -Infinity);
console.log(max);  // 5

const min = numbers.reduce((acc, n) => Math.min(acc, n), Infinity);
console.log(min);  // 1

// reduceRight: 从右到左归约
const flattened = [[1, 2], [3, 4], [5, 6]].reduce((acc, arr) => acc.concat(arr), []);
console.log(flattened);  // [1, 2, 3, 4, 5, 6]

// 实用: 分组
const words = ["apple", "banana", "avocado", "cherry", "blueberry"];
const grouped = words.reduce((acc, word) => {
    const first = word[0];
    if (!acc[first]) acc[first] = [];
    acc[first].push(word);
    return acc;
}, {});

console.log(grouped);
// { a: ["apple", "avocado"], b: ["banana", "blueberry"], c: ["cherry"] }

// 实用: 构建查找 map
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

const userMap = users.reduce((acc, user) => {
    acc[user.id] = user;
    return acc;
}, {});

console.log(userMap[1]);  // { id: 1, name: "Alice" }
```
</UniversalEditor>

## Set 和 Map

JavaScript 提供类似 Java 的 Set 和 Map 集合:

<UniversalEditor title="Set 比较">
```java !! java
// Java - HashSet
Set<String> names = new HashSet<>();
names.add("Alice");
names.add("Bob");
names.add("Alice");  // 重复被忽略

System.out.println(names.contains("Alice"));  // true
System.out.println(names.size());  // 2

names.remove("Alice");

for (String name : names) {
    System.out.println(name);
}

// LinkedHashSet (保持插入顺序)
Set<String> ordered = new LinkedHashSet<>();

// TreeSet (排序)
Set<String> sorted = new TreeSet<>();
```

```javascript !! js
// JavaScript - Set
const names = new Set();
names.add("Alice");
names.add("Bob");
names.add("Alice");  // 重复被忽略

console.log(names.has("Alice"));  // true
console.log(names.size);  // 2

names.delete("Alice");
console.log(names.has("Alice"));  // false

// 迭代
for (const name of names) {
    console.log(name);
}

// 转为数组
const nameArray = [...names];
console.log(nameArray);  // ["Bob"]

// 从数组初始化
const numbers = new Set([1, 2, 3, 2, 1]);
console.log(numbers);  // Set {1, 2, 3}

// 实用: 去重
const dupes = [1, 2, 2, 3, 3, 3, 4];
const unique = [...new Set(dupes)];
console.log(unique);  // [1, 2, 3, 4]

// Set 方法
const set = new Set([1, 2, 3]);
set.clear();  // 删除所有
console.log(set.size);  // 0

// Set 操作
const a = new Set([1, 2, 3]);
const b = new Set([3, 4, 5]);

// 并集
const union = new Set([...a, ...b]);
console.log(union);  // Set {1, 2, 3, 4, 5}

// 交集
const intersection = new Set([...a].filter(x => b.has(x)));
console.log(intersection);  // Set {3}

// 差集
const difference = new Set([...a].filter(x => !b.has(x)));
console.log(difference);  // Set {1, 2}
```
</UniversalEditor>

<UniversalEditor title="Map 比较">
```java !! java
// Java - HashMap
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 87);

System.out.println(scores.get("Alice"));  // 95
System.out.println(scores.containsKey("Bob"));  // true

scores.remove("Alice");

for (Map.Entry<String, Integer> entry : scores.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// LinkedHashMap (保持插入顺序)
// TreeMap (按键排序)
```

```javascript !! js
// JavaScript - Map
const scores = new Map();
scores.set("Alice", 95);
scores.set("Bob", 87);

console.log(scores.get("Alice"));  // 95
console.log(scores.has("Bob"));  // true

scores.delete("Alice");
console.log(scores.has("Alice"));  // false

// 迭代
for (const [name, score] of scores) {
    console.log(`${name}: ${score}`);
}

// 从对数组初始化
const data = new Map([
    ["Alice", 95],
    ["Bob", 87]
]);

// Map vs Object: Map 键可以是任何类型
const map = new Map();
const key1 = { id: 1 };
const key2 = { id: 2 };

map.set(key1, "Value 1");
map.set(key2, "Value 2");
map.set("string", "String key");
map.set(123, "Number key");

console.log(map.get(key1));  // "Value 1"

// Object 键总是字符串/符号
const obj = {};
obj[key1] = "Value";  // 键被转换为 "[object Object]"
obj[key2] = "Value";  // 覆盖前一个!

// Map 迭代顺序有保证
const orderedMap = new Map([
    ["z", 1],
    ["a", 2],
    ["m", 3]
]);

for (const [key, value] of orderedMap) {
    console.log(key, value);  // 保持插入顺序
}

// Map 方法
const map2 = new Map([["a", 1], ["b", 2]]);
console.log(map2.keys());    // MapIterator {"a", "b"}
console.log(map2.values());  // MapIterator {1, 2}
console.log(map2.entries()); // MapIterator {"a" => 1, "b" => 2}

// 将 Map 转为 Object
const map3 = new Map([["a", 1], ["b", 2]]);
const obj2 = Object.fromEntries(map3);
console.log(obj2);  // { a: 1, b: 2 }

// 将 Object 转为 Map
const obj3 = { a: 1, b: 2 };
const map4 = new Map(Object.entries(obj3));
```
</UniversalEditor>

## WeakSet 和 WeakMap

WeakSet 和 WeakMap 弱持有对象引用(允许垃圾回收):

<UniversalEditor title="WeakSet 和 WeakMap">
```java !! java
// Java - WeakHashMap
Map<String, Integer> weakMap = new WeakHashMap<>();
// 键被弱引用
// 当键不再强可达时,条目被删除

// 没有 WeakSet 的直接等价物 (直到 Java 9 使用 IdentityHashMap)
```

```javascript !! js
// JavaScript - WeakSet 和 WeakMap

// WeakSet: 只持有对象,不能迭代
const weakSet = new WeakSet();
let obj1 = { id: 1 };
let obj2 = { id: 2 };

weakSet.add(obj1);
weakSet.add(obj2);
// weakSet.add("string");  // TypeError!

console.log(weakSet.has(obj1));  // true

obj1 = null;  // 删除强引用
// obj1 将被垃圾回收,WeakSet 条目被删除

// 用例: 跟踪对象而不阻止 GC
function processObjects(objects) {
    const processed = new WeakSet();

    return objects.filter(obj => {
        if (processed.has(obj)) {
            return false;  // 已处理
        }
        processed.add(obj);
        return true;
    });
}

// WeakMap: 键必须是对象,值可以是任何东西
const weakMap = new WeakMap();
const key1 = { id: 1 };
const key2 = { id: 2 };

weakMap.set(key1, "Metadata 1");
weakMap.set(key2, "Metadata 2");

console.log(weakMap.get(key1));  // "Metadata 1"
console.log(weakMap.has(key1));  // true

weakMap.delete(key1);

// 用例: 私有数据
const privateData = new WeakMap();

class User {
    constructor(name, age) {
        privateData.set(this, { age, secret: "xyz" });
        this.name = name;
    }

    getAge() {
        return privateData.get(this).age;
    }

    getSecret() {
        return privateData.get(this).secret;
    }
}

const user = new User("Alice", 25);
console.log(user.name);    // "Alice" (公开)
console.log(user.getAge());  // 25 (通过 WeakMap 访问)
console.log(user.age);     // undefined (真正私有)

// 用例: DOM 节点元数据
const nodeData = new WeakMap();

function setupNode(node) {
    nodeData.set(node, {
        clickCount: 0,
        lastClick: null
    });

    node.addEventListener("click", () => {
        const data = nodeData.get(node);
        data.clickCount++;
        data.lastClick = Date.now();
        console.log(`点击了 ${data.clickCount} 次`);
    });
}

// 当节点从 DOM 移除时,元数据自动被 GC 回收
```
</UniversalEditor>

## 性能考虑

<UniversalEditor title="数组性能技巧">
```java !! java
// Java - ArrayList vs LinkedList
// ArrayList: O(1) 随机访问, O(n) 插入/删除
// LinkedList: O(n) 随机访问, O(1) 插入/删除

// 大多数情况使用 ArrayList
List<Integer> list = new ArrayList<>();

// 可能时预分配大小
List<Integer> sized = new ArrayList<>(1000);
```

```javascript !! js
// JavaScript - 数组性能

// 1. 知道大小时预分配(帮助 V8 优化)
const arr = new Array(1000);
// 或
const arr2 = [];
arr2.length = 1000;

// 2. 对数值使用类型化数组
const int8 = new Int8Array(1000);      // 8 位整数
const int16 = new Int16Array(1000);    // 16 位整数
const float64 = new Float64Array(1000); // 64 位浮点数

// 性能比较
const regular = [];
for (let i = 0; i < 1000000; i++) {
    regular.push(i);
}

const typed = new Int32Array(1000000);
for (let i = 0; i < typed.length; i++) {
    typed[i] = i;
}

// 3. 避免稀疏数组
const sparse = [];  // 坏
sparse[1000] = 1;   // 创建空缺

const dense = new Array(1001).fill(0);  // 好
dense[1000] = 1;

// 4. 对重操作使用 for 循环比 forEach 快
const numbers = [1, 2, 3, 4, 5];

// 较慢(函数调用开销)
numbers.forEach(n => {
    // 处理 n
});

// 更快
for (let i = 0; i < numbers.length; i++) {
    const n = numbers[i];
    // 处理 n
}

// 5. Set/Map 查找 vs Array includes
const arr = [1, 2, 3, 4, 5];
const set = new Set([1, 2, 3, 4, 5]);

// Array: O(n)
arr.includes(3);

// Set: O(1)
set.has(3);

// 对大数据集,使用 Set/Map 查找
const largeArray = Array.from({ length: 100000 }, (_, i) => i);
const largeSet = new Set(largeArray);

// 快速查找
console.time("array");
largeArray.includes(99999);
console.timeEnd("array");  // ~5ms

console.time("set");
largeSet.has(99999);
console.timeEnd("set");    // ~0ms

// 6. 数组展开 vs concat
const a = [1, 2, 3];
const b = [4, 5, 6];

// 现代: 展开(对非常大的数组较慢)
const combined = [...a, ...b];

// 传统: concat(通常更快)
const combined2 = a.concat(b);
```
</UniversalEditor>

## 常见模式

### 模式 1: 分块

<UniversalEditor title="分块数组模式">
```java !! java
// Java - 分块为子列表
public static <T> List<List<T>> chunk(List<T> list, int size) {
    List<List<T>> chunks = new ArrayList<>();
    for (int i = 0; i < list.size(); i += size) {
        chunks.add(list.subList(i, Math.min(i + size, list.size())));
    }
    return chunks;
}
```

```javascript !! js
// JavaScript - 分块数组
function chunk(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
    }
    return chunks;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(chunk(numbers, 3));
// [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

// 函数式方法
function chunkFunctional(array, size) {
    return Array.from(
        { length: Math.ceil(array.length / size) },
        (_, i) => array.slice(i * size, i * size + size)
    );
}
```
</UniversalEditor>

### 模式 2: 展平

<UniversalEditor title="展平模式">
```javascript !! js
// 展平嵌套数组
const nested = [1, [2, [3, [4, 5]]]];

// 浅展平
const flat1 = nested.flat();
console.log(flat1);  // [1, 2, [3, [4, 5]]]

// 深展平(指定深度)
const flat2 = nested.flat(2);
console.log(flat2);  // [1, 2, 3, [4, 5]]

// 无限展平
const flat3 = nested.flat(Infinity);
console.log(flat3);  // [1, 2, 3, 4, 5]

// 自定义展平函数
function flatten(arr) {
    const result = [];

    for (const item of arr) {
        if (Array.isArray(item)) {
            result.push(...flatten(item));
        } else {
            result.push(item);
        }
    }

    return result;
}
```
</UniversalEditor>

## 最佳实践

<UniversalEditor title="集合最佳实践">
```java !! java
// Java: 使用适当的集合类型
List<String> list = new ArrayList<>();  // 有序,允许重复
Set<String> set = new HashSet<>();      // 无序,唯一
Map<String, Integer> map = new HashMap<>();  // 键值对

// 根据需求选择:
// - ArrayList: 快速随机访问
// - LinkedList: 频繁插入/删除
// - HashSet: 快速查找,唯一元素
// - TreeSet: 排序元素
// - HashMap: 快速键查找
// - TreeMap: 排序键
```

```javascript !! js
// JavaScript: 明智选择

// 1. 对有序数据使用数组
const items = ["apple", "banana", "cherry"];

// 2. 对唯一性使用 Set
const uniqueItems = new Set(["apple", "banana", "apple"]);

// 3. 对非字符串键的键值使用 Map
const metadata = new Map();
const element = document.getElementById("myDiv");
metadata.set(element, { clicks: 0 });

// 4. 对简单字符串键使用对象
const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000,
    retries: 3
};

// 5. 优先使用非变异方法
const numbers = [1, 2, 3, 4, 5];

// 好: 返回新数组
const doubled = numbers.map(n => n * 2);

// 小心: 原地修改
numbers.reverse();  // 修改原数组!

// 避免变异: 先创建副本
const reversed = [...numbers].reverse();

// 6. 使用解构提高清晰度
const [first, second, ...rest] = numbers;

// 7. 使用展开进行不可变更新
const state = { count: 0, name: "app" };
const newState = { ...state, count: 1 };  // 复制并更新

const list = [1, 2, 3];
const newList = [...list, 4];  // 复制并添加

// 8. 利用 Set 去重
const dupes = [1, 2, 2, 3, 3, 3];
const unique = [...new Set(dupes)];
```
</UniversalEditor>

## 练习

### 练习 1: 数组操作
实现这些操作:
```javascript
const arr = [1, 2, 3, 4, 5];

// 1. 在开头添加 0
// 2. 在末尾添加 6
// 3. 删除第一个元素
// 4. 删除最后一个元素
// 5. 将所有元素翻倍(非变异)
// 6. 过滤掉偶数
// 7. 求所有数字的和
```

### 练习 2: Set 操作
创建 Set 工具函数:
```javascript
// 两个集合的并集
function union(setA, setB) { }

// 两个集合的交集
function intersection(setA, setB) { }

// 两个集合的差集
function difference(setA, setB) { }
```

### 练习 3: 分块数组
将数组分成大小为 n 的块:
```javascript
function chunk(array, size) {
    // 返回数组的数组
}

chunk([1, 2, 3, 4, 5, 6, 7], 3);
// [[1, 2, 3], [4, 5, 6], [7]]
```

### 练习 4: Map 操作
创建频率 map:
```javascript
function frequencyMap(array) {
    // 返回包含元素计数的 Map
}

frequencyMap(["apple", "banana", "apple", "cherry", "banana", "apple"]);
// Map {"apple" => 3, "banana" => 2, "cherry" => 1}
```

## 总结

### 关键要点

1. **数组:**
   - 动态大小(可以增长/缩小)
   - 可能混合类型
   - 丰富的方法集
   - 区分变异方法和非变异方法

2. **解构:**
   - 清晰地解包值
   - 用逗号跳过
   - 剩余运算符用于其余部分
   - 默认值

3. **Set:**
   - 只有唯一值
   - 快速查找(O(1))
   - 适合去重
   - WeakSet 用于内存管理

4. **Map:**
   - 任何键类型
   - 保持插入顺序
   - 快速查找(O(1))
   - WeakMap 用于元数据

5. **性能:**
   - 可能时预分配
   - 对数字使用类型化数组
   - 大量查找使用 Set/Map
   - 重操作使用 for 循环

### 对比表: Java vs JavaScript

| 特性 | Java | JavaScript |
|---------|------|------------|
| **数组类型** | 固定大小,单一类型 | 动态,混合类型 |
| **增长** | 需要 ArrayList | 自动 |
| **Set** | HashSet, TreeSet, LinkedHashSet | Set (插入顺序) |
| **Map** | HashMap, TreeMap, LinkedHashMap | Map (插入顺序) |
| **弱引用** | WeakHashMap | WeakSet, WeakMap |
| **类型化数组** | 无 | Int8Array, Float64Array 等 |
| **解构** | 无 | 有 (ES6+) |

## 接下来是什么?

你已经掌握了 JavaScript 集合!接下来是**模块 6: 对象**,我们将探索:

- 对象字面量和创建
- 属性 getter 和 setter
- 对象方法(keys, values, entries)
- 对象解构
- 对象的展开运算符
- Object.freeze 和 Object.seal

准备好深入探索 JavaScript 对象了吗?让我们继续!
