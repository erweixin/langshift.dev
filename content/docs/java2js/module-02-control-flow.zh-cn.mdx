---
title: "模块 2: 控制流和循环"
description: "掌握 JavaScript 的控制流语句、循环和迭代模式"
---

## 模块 2: 控制流和循环

在本模块中,我们将探索 JavaScript 如何处理控制流和迭代。你会发现它与 Java 有很多相似之处,但 JavaScript 提供了一些强大的功能,使迭代更加表达性强。

## 学习目标

完成本模块后,你将:
✅ 掌握条件语句(if/else、switch、三元运算符)
✅ 理解所有循环类型(for、while、do-while、for...of、for...in)
✅ 学习函数式迭代方法(map、filter、reduce)
✅ 了解短路求值(short-circuit evaluation)
✅ 知道何时使用每种迭代模式

## 条件语句

### if/else 语句

JavaScript 的 if/else 与 Java 几乎完全相同:

<UniversalEditor title="if/else 比较">
```java !! java
// Java - if/else
int age = 18;

if (age >= 18) {
    System.out.println("Adult");
} else if (age >= 13) {
    System.out.println("Teenager");
} else {
    System.out.println("Child");
}

// Ternary operator
String status = (age >= 18) ? "Adult" : "Minor";

// With null check
String name = null;
String displayName = (name != null) ? name : "Guest";
```

```javascript !! js
// JavaScript - if/else (same syntax)
let age = 18;

if (age >= 18) {
    console.log("Adult");
} else if (age >= 13) {
    console.log("Teenager");
} else {
    console.log("Child");
}

// Ternary operator (same)
let status = (age >= 18) ? "Adult" : "Minor";

// With null/undefined check
let name = null;
let displayName = (name !== null && name !== undefined) ? name : "Guest";

// Or simpler with nullish coalescing
let displayName2 = name ?? "Guest";
```
</UniversalEditor>

### 短路求值

JavaScript 对逻辑运算符使用短路求值:

<UniversalEditor title="短路求值">
```java !! java
// Java - 逻辑运算符总是返回布尔值
boolean isValid = true;
String name = "John";

// 两个条件总是被求值为布尔值
if (isValid && name != null && name.length() > 0) {
    // ...
}

// 不能使用逻辑运算符来设置默认值
// 这在 Java 中不起作用:
// String displayName = name || "Guest";  // Compilation error!
```

```javascript !! js
// JavaScript - 短路求值
let isValid = true;
let name = "John";

// && 返回第一个假值或最后一个真值
let result1 = isValid && name;  // "John" (both truthy)
let result2 = isValid && null;  // null (stops at null)
let result3 = false && name;   // false (stops at false)

// || 返回第一个真值或最后一个假值
let displayName = name || "Guest";  // "John" (name is truthy)
let displayName2 = null || "Guest"; // "Guest" (null is falsy)

// Practical pattern: Default values
function greet(name) {
    name = name || "Guest";  // Use "Guest" if name is falsy
    console.log(`Hello, ${name}`);
}

greet("John");  // "Hello, John"
greet("");      // "Hello, Guest" (empty string is falsy)
greet(null);    // "Hello, Guest"

// Nullish coalescing (ES2020) - only for null/undefined
function greet2(name) {
    let displayName = name ?? "Guest";
    console.log(`Hello, ${displayName}`);
}

greet2("");      // "Hello, " (empty string is NOT null/undefined)
greet2(null);    // "Hello, Guest"

// Optional chaining for safe property access
const user = { profile: { name: "John" } };
const username = user?.profile?.name ?? "Guest";  // "John"
const username2 = user?.settings?.theme ?? "dark";  // "dark" (settings doesn't exist)
```
</UniversalEditor>

### switch 语句

JavaScript 的 switch 与 Java 有一些重要区别:

<UniversalEditor title="switch 语句比较">
```java !! java
// Java - switch with strict type matching
int dayOfWeek = 1;
String dayName;

switch (dayOfWeek) {
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case 3:
        dayName = "Wednesday";
        break;
    default:
        dayName = "Unknown";
}

// Java - switch expressions (Java 14+)
String dayType = switch (dayOfWeek) {
    case 1, 2, 3, 4, 5 -> "Weekday";
    case 6, 7 -> "Weekend";
    default -> "Invalid";
};
```

```javascript !! js
// JavaScript - switch with loose equality (be careful!)
let dayOfWeek = 1;
let dayName;

switch (dayOfWeek) {
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case "1":  // ⚠️ This matches too! (loose equality)
        dayName = "Monday (string)";
        break;
    default:
        dayName = "Unknown";
}

// Pitfall: Loose equality
let x = "1";
switch (x) {
    case 1:  // This matches! ("1" == 1 is true)
        console.log("Equal");
        break;
}

// Solution: Use strict equality checks
function strictSwitch(value) {
    if (value === 1) {
        return "One";
    } else if (value === 2) {
        return "Two";
    } else {
        return "Unknown";
    }
}

// Or use object lookup (better pattern)
const dayMap = {
    1: "Monday",
    2: "Tuesday",
    3: "Wednesday",
    4: "Thursday",
    5: "Friday",
    6: "Saturday",
    7: "Sunday"
};

const dayName2 = dayMap[dayOfWeek] ?? "Unknown";
```
</UniversalEditor>

## 传统循环

### for 循环

JavaScript 的传统 for 循环与 Java 类似:

<UniversalEditor title="for 循环比较">
```java !! java
// Java - for loop
for (int i = 0; i < 5; i++) {
    System.out.println("Iteration " + i);
}

// Enhanced for loop (for-each)
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// With index
for (int i = 0; i < numbers.length; i++) {
    System.out.println("Index " + i + ": " + numbers[i]);
}
```

```javascript !! js
// JavaScript - for loop (same syntax)
for (let i = 0; i < 5; i++) {
    console.log("Iteration " + i);
}

// for...of loop (modern for-each)
const numbers = [1, 2, 3, 4, 5];
for (const num of numbers) {
    console.log(num);
}

// With index using entries()
for (const [index, num] of numbers.entries()) {
    console.log(`Index ${index}: ${num}`);
}

// for...in loop (iterate over indices/keys)
for (const index in numbers) {
    console.log(`Index ${index}: ${numbers[index]}`);
}

// ⚠️ Be careful: for...in is for objects, not arrays
const user = { name: "John", age: 25 };
for (const key in user) {
    console.log(`${key}: ${user[key]}`);
}
```
</UniversalEditor>

### while 和 do-while 循环

这些与 Java 完全相同:

<UniversalEditor title="while 和 do-while">
```java !! java
// Java - while loop
int count = 0;
while (count < 5) {
    System.out.println("Count: " + count);
    count++;
}

// do-while loop
int i = 0;
do {
    System.out.println("At least once: " + i);
    i++;
} while (i < 5);
```

```javascript !! js
// JavaScript - while loop (same)
let count = 0;
while (count < 5) {
    console.log("Count: " + count);
    count++;
}

// do-while loop (same)
let i = 0;
do {
    console.log("At least once: " + i);
    i++;
} while (i < 5);

// Practical example: Input validation
function guessNumber() {
    let guess;
    let target = 42;

    do {
        guess = parseInt(prompt("Guess a number:"));
        if (guess < target) {
            console.log("Too low!");
        } else if (guess > target) {
            console.log("Too high!");
        }
    } while (guess !== target);

    console.log("Correct!");
}
```
</UniversalEditor>

### break 和 continue

JavaScript 像 Java 一样支持 break 和 continue:

<UniversalEditor title="break 和 continue">
```java !! java
// Java - break and continue
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // Exit loop
    }
    if (i % 2 == 0) {
        continue;  // Skip to next iteration
    }
    System.out.println("Odd number: " + i);
}

// Labeled breaks (for nested loops)
outer:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break outer;  // Exit outer loop
        }
        System.out.println(i + ", " + j);
    }
}
```

```javascript !! js
// JavaScript - break and continue (same)
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break;  // Exit loop
    }
    if (i % 2 === 0) {
        continue;  // Skip to next iteration
    }
    console.log("Odd number: " + i);
}

// Labeled breaks (same as Java)
outer:
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outer;  // Exit outer loop
        }
        console.log(`${i}, ${j}`);
    }
}

// Practical example: Search
function findUser(users, targetId) {
    for (const user of users) {
        if (user.id === targetId) {
            return user;  // Found it, exit early
        }
    }
    return null;  // Not found
}
```
</UniversalEditor>

## 现代迭代方法

JavaScript 提供了强大的数组方法,Java 开发者会从 streams 中认出它们:

### Array.prototype.forEach

<UniversalEditor title="forEach vs for-each">
```java !! java
// Java - for-each loop
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}

// Java 8+ forEach with lambda
names.forEach(name -> System.out.println(name));

// With index (need IntStream)
IntStream.range(0, names.size())
         .forEach(i -> System.out.println(i + ": " + names.get(i)));
```

```javascript !! js
// JavaScript - forEach method
const names = ["Alice", "Bob", "Charlie"];
names.forEach(name => {
    console.log(name);
});

// With index
names.forEach((name, index) => {
    console.log(`${index}: ${name}`);
});

// Note: Cannot break out of forEach!
// Use a for...of loop if you need to break
for (const name of names) {
    if (name === "Bob") break;  // This works
    console.log(name);
}

// forEach doesn't return anything
const result = names.forEach(name => name.toUpperCase());
console.log(result);  // undefined
```
</UniversalEditor>

### Array.prototype.map

通过转换每个元素来创建新数组:

<UniversalEditor title="map 比较">
```java !! java
// Java - Stream.map()
List<String> names = Arrays.asList("alice", "bob", "charlie");
List<String> upperNames = names.stream()
                               .map(String::toUpperCase)
                               .collect(Collectors.toList());

// Or with lambda
List<Integer> lengths = names.stream()
                            .map(name -> name.length())
                            .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array.map()
const names = ["alice", "bob", "charlie"];
const upperNames = names.map(name => name.toUpperCase());
console.log(upperNames);  // ["ALICE", "BOB", "CHARLIE"]

// Get lengths
const lengths = names.map(name => name.length());
console.log(lengths);  // [5, 3, 7]

// Transform objects
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

const userIds = users.map(user => user.id);
console.log(userIds);  // [1, 2]

// With index
const numbered = names.map((name, i) => `${i + 1}. ${name}`);
console.log(numbered);  // ["1. Alice", "2. Bob", "3. Charlie"]
```
</UniversalEditor>

### Array.prototype.filter

创建一个包含通过测试的元素的新数组:

<UniversalEditor title="filter 比较">
```java !! java
// Java - Stream.filter()
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> evens = numbers.stream()
                              .filter(n -> n % 2 == 0)
                              .collect(Collectors.toList());

// Chain multiple operations
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .filter(n -> n > 5)
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array.filter()
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);  // [2, 4, 6, 8, 10]

// Chain methods
const result = numbers
    .filter(n => n % 2 === 0)
    .filter(n => n > 5);
console.log(result);  // [6, 8, 10]

// Filter objects
const users = [
    { id: 1, name: "Alice", age: 25 },
    { id: 2, name: "Bob", age: 17 },
    { id: 3, name: "Charlie", age: 30 }
];

const adults = users.filter(user => user.age >= 18);
console.log(adults);  // [{ id: 1, ... }, { id: 3, ... }]

// Remove null/undefined values
const values = [1, null, 2, undefined, 3, null, 4];
const clean = values.filter(v => v != null);
console.log(clean);  // [1, 2, 3, 4]
```
</UniversalEditor>

### Array.prototype.reduce

将数组归约为单个值:

<UniversalEditor title="reduce 比较">
```java !! java
// Java - Stream.reduce()
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);

int product = numbers.stream()
                     .reduce(1, (a, b) -> a * b);

// With Optional
Optional<Integer> max = numbers.stream()
                               .reduce(Integer::max);
```

```javascript !! js
// JavaScript - Array.reduce()
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum);  // 15

const product = numbers.reduce((acc, n) => acc * n, 1);
console.log(product);  // 120

// Find max
const max = numbers.reduce((acc, n) => Math.max(acc, n), -Infinity);
console.log(max);  // 5

// Group by
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

const byRole = users.reduce((acc, user) => {
    if (!acc[user.role]) {
        acc[user.role] = [];
    }
    acc[user.role].push(user);
    return acc;
}, {});

console.log(byRole);
// {
//   admin: [{ name: "Alice", ... }, { name: "Charlie", ... }],
//   user: [{ name: "Bob", ... }]
// }
```
</UniversalEditor>

### 其他数组方法

<UniversalEditor title="更多数组方法">
```java !! java
// Java - Various stream operations
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Find first
Optional<String> first = names.stream().findFirst();

// Any match
boolean hasAlice = names.stream().anyMatch(n -> n.equals("Alice"));

// All match
boolean allLong = names.stream().allMatch(n -> n.length() > 3);

// Count
long count = names.stream().count();

// Limit
List<String> firstTwo = names.stream().limit(2).collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array methods
const names = ["Alice", "Bob", "Charlie"];

// Find first (returns element, not Optional)
const first = names[0];  // "Alice"
const firstFind = names.find(name => name.startsWith("A"));  // "Alice"

// Find index
const indexOfBob = names.indexOf("Bob");  // 1
const findIndex = names.findIndex(name => name.startsWith("B"));  // 1

// Check if exists
const hasAlice = names.includes("Alice");  // true
const hasLongName = names.some(name => name.length > 3);  // true
const allLong = names.every(name => name.length > 3);  // false

// Count
const count = names.length;  // 3

// Slice (first two)
const firstTwo = names.slice(0, 2);  // ["Alice", "Bob"]

// Flat map (ES2019)
const matrix = [[1, 2], [3, 4], [5, 6]];
const flattened = matrix.flat();  // [1, 2, 3, 4, 5, 6]

// Sort (modifies in place!)
const nums = [3, 1, 4, 1, 5];
nums.sort((a, b) => a - b);  // [1, 1, 3, 4, 5]
```
</UniversalEditor>

## 方法链

JavaScript 数组方法可以像 Java streams 一样链接:

<UniversalEditor title="方法链">
```java !! java
// Java - Stream chaining
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .limit(5)
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array method chaining
const result = numbers
    .filter(n => n % 2 === 0)
    .map(n => n * 2)
    .slice(0, 5);

// Real-world example
const users = [
    { name: "Alice", age: 25, score: 85 },
    { name: "Bob", age: 17, score: 92 },
    { name: "Charlie", age: 30, score: 78 },
    { name: "David", age: 22, score: 88 }
];

// Get names of adult users with high scores, sorted
const topAdults = users
    .filter(user => user.age >= 18)           // Filter adults
    .filter(user => user.score >= 80)         // Filter high scores
    .sort((a, b) => b.score - a.score)        // Sort by score desc
    .map(user => user.name);                  // Get names

console.log(topAdults);  // ["Bob", "David", "Alice"]

// Calculate average score
const averageScore = users
    .map(user => user.score)
    .reduce((sum, score, _, arr) => sum + score / arr.length, 0);

console.log(averageScore);  // 85.75
```
</UniversalEditor>

## 迭代模式

### 模式 1: 转换和过滤

<UniversalEditor title="转换和过滤模式">
```java !! java
// Java
List<String> words = Arrays.asList("hello", "world", "java", "stream");

List<String> result = words.stream()
    .filter(w -> w.length() > 4)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript
const words = ["hello", "world", "java", "javascript"];

const result = words
    .filter(w => w.length > 4)
    .map(w => w.toUpperCase())
    .sort();

console.log(result);  // ["HELLO", "JAVASCRIPT", "WORLD"]
```
</UniversalEditor>

### 模式 2: 查找和更新

<UniversalEditor title="查找和更新模式">
```java !! java
// Java - Immutable approach
List<User> users = getUsers();
User updatedUser = users.stream()
    .filter(u -> u.getId() == targetId)
    .findFirst()
    .map(u -> new User(u.getId(), u.getName(), true))
    .orElse(null);
```

```javascript !! js
// JavaScript - Find and update
const users = [
    { id: 1, name: "Alice", active: false },
    { id: 2, name: "Bob", active: false }
];

const targetId = 1;
const updatedUsers = users.map(user => {
    if (user.id === targetId) {
        return { ...user, active: true };
    }
    return user;
});

console.log(updatedUsers);
// [
//   { id: 1, name: "Alice", active: true },
//   { id: 2, name: "Bob", active: false }
// ]
```
</UniversalEditor>

### 模式 3: 归约为对象

<UniversalEditor title="归约为对象模式">
```java !! java
// Java - Group by with Collectors.groupingBy
List<User> users = getUsers();
Map<String, List<User>> byRole = users.stream()
    .collect(Collectors.groupingBy(User::getRole));
```

```javascript !! js
// JavaScript - Group by with reduce
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

const byRole = users.reduce((acc, user) => ({
    ...acc,
    [user.role]: [...(acc[user.role] || []), user]
}), {});

console.log(byRole);
// {
//   admin: [
//     { name: "Alice", role: "admin" },
//     { name: "Charlie", role: "admin" }
//   ],
//   user: [{ name: "Bob", role: "user" }]
// }
```
</UniversalEditor>

## 性能考虑

<UniversalEditor title="性能: 循环 vs 数组方法">
```java !! java
// Java - Streams have overhead
// For simple operations, traditional loops can be faster
List<Integer> numbers = /* large list */;

// Stream (cleaner but some overhead)
List<Integer> result = numbers.stream()
    .filter(n -> n > 0)
    .collect(Collectors.toList());

// Traditional loop (faster for simple cases)
List<Integer> result2 = new ArrayList<>();
for (Integer n : numbers) {
    if (n > 0) {
        result2.add(n);
    }
}
```

```javascript !! js
// JavaScript - Similar trade-offs
const numbers = /* large array */;

// Array methods (cleaner, similar performance)
const result = numbers.filter(n => n > 0);

// Traditional for loop (often faster)
const result2 = [];
for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 0) {
        result2.push(numbers[i]);
    }
}

// for...of (clean, good middle ground)
const result3 = [];
for (const n of numbers) {
    if (n > 0) {
        result3.push(n);
    }
}

// General rule:
// - Use array methods for readability (usually fast enough)
// - Use traditional loops for performance-critical code
// - Avoid forEach when you might need to break (use for...of)
```
</UniversalEditor>

## 常见陷阱

### 陷阱 1: 在数组上使用 for...in

<UniversalEditor title="for...in 陷阱">
```javascript !! js
// ❌ BAD: for...in iterates over keys, not values
const arr = [10, 20, 30];
for (const i in arr) {
    console.log(i);  // "0", "1", "2" (strings, not numbers!)
    console.log(arr[i]);  // 10, 20, 30
}

// Also iterates over inherited properties
Array.prototype.customProp = "inherited";
for (const i in arr) {
    console.log(i);  // "0", "1", "2", "customProp"
}

// ✅ GOOD: Use for...of for arrays
for (const value of arr) {
    console.log(value);  // 10, 20, 30
}

// ✅ GOOD: Use forEach for index and value
arr.forEach((value, index) => {
    console.log(`${index}: ${value}`);
});
```
</UniversalEditor>

### 陷阱 2: 在迭代时修改数组

<UniversalEditor title="迭代期间修改">
```javascript !! js
// ❌ BAD: Removing elements during iteration
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 === 0) {
        numbers.splice(i, 1);  // Removes element
    }
}
// Result: [1, 3, 5] but skips some elements!

// ✅ GOOD: Filter instead
const filtered = numbers.filter(n => n % 2 !== 0);
// Result: [1, 3, 5]

// ✅ GOOD: Iterate backwards if you must modify
for (let i = numbers.length - 1; i >= 0; i--) {
    if (numbers[i] % 2 === 0) {
        numbers.splice(i, 1);
    }
}
```
</UniversalEditor>

### 陷阱 3: 在数组方法中忘记返回

<UniversalEditor title="缺少返回值">
```javascript !! js
// ❌ BAD: Forgetting return
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => {
    n * 2;  // No return! Results in [undefined, undefined, ...]
});

// ✅ GOOD: Explicit return
const doubled2 = numbers.map(n => {
    return n * 2;
});

// ✅ GOOD: Implicit return (one-liner)
const doubled3 = numbers.map(n => n * 2);

// ⚠️ Watch out with curly braces
const doubled4 = numbers.map(n => { n * 2 });  // Wrong!
const doubled5 = numbers.map(n => ({ value: n * 2 }));  // Need parentheses for object
```
</UniversalEditor>

## 最佳实践

<UniversalEditor title="最佳实践总结">
```java !! java
// Java: Use streams for readability
List<String> names = Arrays.asList("alice", "bob", "charlie");

List<String> result = names.stream()
    .filter(n -> n.length() > 3)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());

// Use traditional loops for performance or when need to break
for (String name : names) {
    if (name.equals("bob")) break;
    System.out.println(name);
}
```

```javascript !! js
// JavaScript: Use array methods for readability
const names = ["alice", "bob", "charlie"];

const result = names
    .filter(n => n.length > 3)
    .map(n => n.toUpperCase())
    .sort();

// Use for...of when you need to break
for (const name of names) {
    if (name === "bob") break;
    console.log(name);
}

// Use reduce for complex aggregations
const summary = names.reduce((acc, name) => ({
    count: acc.count + 1,
    totalLength: acc.totalLength + name.length,
    avgLength: (acc.totalLength + name.length) / (acc.count + 1)
}), { count: 0, totalLength: 0, avgLength: 0 });

// Avoid forEach when you could use map/filter
// ❌ BAD
const results = [];
items.forEach(item => {
    if (item.isValid) {
        results.push(transform(item));
    }
});

// ✅ GOOD
const results = items
    .filter(item => item.isValid)
    .map(transform);
```
</UniversalEditor>

## 练习

### 练习 1: 数组转换
将此 Java 代码转换为 JavaScript:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squares = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .collect(Collectors.toList());
```

### 练习 2: 查找用户
编写一个按 ID 查找用户的函数:
```javascript
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
];

function findUser(users, targetId) {
    // Return the user with matching ID, or null
}
```

### 练习 3: 归约为对象
按角色分组用户:
```javascript
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

// Create object: { admin: [...], user: [...] }
```

### 练习 4: 条件逻辑
修复代码以使用严格相等:
```javascript
function processValue(value) {
    if (value == "0") {  // Bug: uses loose equality
        return "zero";
    }
    return value;
}
```

## 总结

### 关键要点

1. **条件语句:**
   - if/else 与 Java 相同
   - Switch 使用宽松相等(小心!)
   - 三元运算符完全相同
   - 短路求值提供默认值

2. **循环:**
   - 传统 for/while/do-while 完全相同
   - for...of 用于数组值(类似 Java 的 for-each)
   - for...in 用于对象键(不是数组!)
   - break 和 continue 工作方式相同

3. **数组方法:**
   - forEach: 迭代(不能中断)
   - map: 转换为新数组
   - filter: 选择元素
   - reduce: 归约为单个值
   - find/findIndex: 搜索元素
   - some/every: 测试条件

4. **方法链:**
   - 数组方法可以链接
   - 类似 Java streams
   - 比嵌套循环更易读

5. **最佳实践:**
   - 使用 for...of 进行迭代(可以中断)
   - 使用数组方法进行转换
   - 避免在数组上使用 for...in
   - 不要在迭代时修改数组

## 下一步是什么?

你已经掌握了控制流和迭代!接下来是**模块 3: 函数**,我们将探索 JavaScript 强大的函数功能:

- 函数声明 vs 表达式
- 箭头函数
- 闭包
- 高阶函数
- 默认参数
- Rest 和 spread 参数
- 函数中的 `this` 关键字

准备深入了解 JavaScript 函数了吗?让我们继续!
