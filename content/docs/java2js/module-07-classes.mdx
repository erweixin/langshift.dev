---
title: "Module 7: Classes and Inheritance"
description: "Learn ES6 classes, inheritance, and object-oriented patterns in JavaScript"
---

## Module 7: Classes and Inheritance

JavaScript introduced class syntax in ES6 (2015), making object-oriented programming more familiar to Java developers. However, JavaScript classes are syntactic sugar over prototypes and work differently from Java classes.

## Learning Objectives

By the end of this module, you will:
✅ Understand ES6 class syntax
✅ Master constructors and methods
✅ Learn inheritance with `extends`
✅ Understand the `super` keyword
✅ Know static methods and properties
✅ Learn about private fields (ES2022)

## Class Syntax

<UniversalEditor title="Class Definition Comparison">
```java !! java
// Java - Traditional class
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void greet() {
        System.out.println("Hello, I'm " + name);
    }
}

// Usage
User user = new User("John", 25);
user.greet();
```

```javascript !! js
// JavaScript - ES6 class syntax
class User {
    // Field declarations (ES2022+)
    name;
    age;

    // Constructor
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    // Instance method
    greet() {
        console.log(`Hello, I'm ${this.name}`);
    }

    // Getter
    get info() {
        return `${this.name} (${this.age})`;
    }

    // Setter
    set setName(name) {
        this.name = name;
    }
}

// Usage
const user = new User("John", 25);
user.greet();  // "Hello, I'm John"
console.log(user.info);  // "John (25)"

// Classes are first-class citizens
const UserClass = User;
const user2 = new UserClass("Jane", 30);
```
</UniversalEditor>

### Hoisting

<UniversalEditor title="Class Hoisting">
```java !! java
// Java - No hoisting
User user = new User();  // Compilation error if User not defined

public class User {
    // ...
}
```

```javascript !! js
// JavaScript - Classes are NOT hoisted
// ❌ BAD: Using class before declaration
const user = new User();  // ReferenceError

class User {
    constructor(name) {
        this.name = name;
    }
}

// ✅ GOOD: Declare class first
class User2 {
    constructor(name) {
        this.name = name;
    }
}

const user2 = new User2("John");  // Works

// Function declarations ARE hoisted
const user3 = createUser("Bob");  // Works!

function createUser(name) {
    return { name };
}
```
</UniversalEditor>

### Class Expressions

<UniversalEditor title="Class Expressions">
```java !! java
// Java - Anonymous classes
Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println("Running");
    }
};

// Lambda (Java 8+)
Runnable r2 = () -> System.out.println("Running");
```

```javascript !! js
// JavaScript - Class expressions
const User = class {
    constructor(name) {
        this.name = name;
    }

    greet() {
        console.log(`Hi, ${this.name}`);
    }
};

const user = new User("John");
user.greet();

// Named class expression (better for debugging)
const User2 = class UserClass {
    constructor(name) {
        this.name = name;
    }
};

// Can be exported immediately
export default class {
    constructor() {
        // ...
    }
}
```
</UniversalEditor>

## Inheritance

<UniversalEditor title="Inheritance Comparison">
```java !! java
// Java - Extends keyword
public class Animal {
    protected String name;

    public Animal(String name) {
        this.name = name;
    }

    public void speak() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    private String breed;

    public Dog(String name, String breed) {
        super(name);  // Call parent constructor
        this.breed = breed;
    }

    @Override
    public void speak() {
        System.out.println("Woof!");
    }

    public void fetch() {
        System.out.println("Fetching!");
    }
}
```

```javascript !! js
// JavaScript - Extends keyword (similar syntax)
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log("Some sound");
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);  // Must call super before using 'this'
        this.breed = breed;
    }

    speak() {
        console.log("Woof!");
    }

    fetch() {
        console.log("Fetching!");
    }
}

const dog = new Dog("Buddy", "Labrador");
dog.speak();  // "Woof!"
dog.fetch();  // "Fetching!"
console.log(dog instanceof Dog);     // true
console.log(dog instanceof Animal);  // true
```
</UniversalEditor>

### Super Keyword

<UniversalEditor title="Super Keyword Usage">
```java !! java
// Java - Super for parent methods
public class Dog extends Animal {
    @Override
    public void speak() {
        super.speak();  // Call parent method
        System.out.println("Woof!");
    }

    public void displayInfo() {
        System.out.println(super.name);  // Access parent field
    }
}
```

```javascript !! js
// JavaScript - Super keyword

class Parent {
    constructor(name) {
        this.name = name;
    }

    greet() {
        return `Hello, I'm ${this.name}`;
    }

    static getType() {
        return "Parent";
    }
}

class Child extends Parent {
    constructor(name, age) {
        super(name);  // Call parent constructor (required!)
        this.age = age;
    }

    greet() {
        // Call parent method
        const parentGreeting = super.greet();
        return `${parentGreeting} and I'm ${this.age}`;
    }

    // Override static method
    static getType() {
        return `${super.getType()} -> Child`;
    }
}

const child = new Child("John", 25);
console.log(child.greet());  // "Hello, I'm John and I'm 25"
console.log(Child.getType());  // "Parent -> Child"

// Super in object literals
const parent = {
    greet() {
        return "Hello from parent";
    }
};

const child2 = {
    __proto__: parent,
    greet() {
        return super.greet() + " and child";
    }
};

console.log(child2.greet());  // "Hello from parent and child"
```
</UniversalEditor>

## Static Members

<UniversalEditor title="Static Methods and Properties">
```java !! java
// Java - Static members
public class MathUtil {
    private static final double PI = 3.14159;

    public static double circleArea(double radius) {
        return PI * radius * radius;
    }

    public static class Constants {
        public static final String APP_NAME = "MyApp";
    }
}

// Usage
double area = MathUtil.circleArea(5.0);
String name = MathUtil.Constants.APP_NAME;
```

```javascript !! js
// JavaScript - Static methods and properties

class MathUtil {
    // Static property (ES2022+)
    static PI = 3.14159;

    // Static method
    static circleArea(radius) {
        return this.PI * radius * radius;
    }

    // Static methods can't access instance properties
    static notValid() {
        // console.log(this.name);  // Error: undefined
    }
}

// Usage (no instantiation needed)
console.log(MathUtil.PI);  // 3.14159
console.log(MathUtil.circleArea(5));  // 78.53975

// Static code block (ES2022+)
class AppConfig {
    static config = {};

    static {
        // Runs once when class is defined
        this.config = {
            apiUrl: "https://api.example.com",
            timeout: 5000
        };
        console.log("Config initialized");
    }

    static get(key) {
        return this.config[key];
    }
}

console.log(AppConfig.get("apiUrl"));  // "https://api.example.com"

// Static methods with inheritance
class Parent {
    static staticMethod() {
        return "Parent";
    }
}

class Child extends Parent {
    static staticMethod() {
        // Call parent static method
        return `${super.staticMethod()} -> Child`;
    }
}

console.log(Child.staticMethod());  // "Parent -> Child"
```
</UniversalEditor>

## Private Fields

<UniversalEditor title="Private Fields">
```java !! java
// Java - Private fields
public class BankAccount {
    private double balance;

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            this.balance += amount;
        }
    }

    public double getBalance() {
        return this.balance;
    }
}
```

```javascript !! js
// JavaScript - Private fields (ES2022+)
class BankAccount {
    // Private fields (declared with #)
    #balance;

    constructor(initialBalance) {
        this.#balance = initialBalance;
    }

    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
        }
    }

    getBalance() {
        return this.#balance;
    }

    // Private methods (ES2022+)
    #validateAmount(amount) {
        return amount > 0 && !isNaN(amount);
    }

    withdraw(amount) {
        if (this.#validateAmount(amount)) {
            this.#balance -= amount;
        }
    }
}

const account = new BankAccount(100);
account.deposit(50);
console.log(account.getBalance());  // 150
console.log(account.#balance);      // SyntaxError! (truly private)

// Private fields are not inherited
class SavingsAccount extends BankAccount {
    #interestRate;

    constructor(initialBalance, interestRate) {
        super(initialBalance);
        this.#interestRate = interestRate;
    }

    addInterest() {
        const balance = this.getBalance();
        const interest = balance * this.#interestRate;
        this.deposit(interest);
    }
}

// Before private fields: Convention with _
class User {
    constructor(name) {
        this._name = name;  // Privacy by convention only
    }

    getName() {
        return this._name;
    }
}
```
</UniversalEditor>

## Getters and Setters

<UniversalEditor title="Property Getters and Setters">
```java !! java
// Java - Getters and setters
public class User {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name != null && !name.isEmpty()) {
            this.name = name;
        }
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        }
    }
}
```

```javascript !! js
// JavaScript - Getters and setters
class User {
    constructor(name, age) {
        this._name = name;  // Convention for backing property
        this._age = age;
    }

    // Getter
    get name() {
        return this._name;
    }

    // Setter
    set name(value) {
        if (value && value.trim().length > 0) {
            this._name = value;
        }
    }

    get age() {
        return this._age;
    }

    set age(value) {
        if (value >= 0) {
            this._age = value;
        }
    }

    // Computed property
    get info() {
        return `${this._name} is ${this._age} years old`;
    }
}

const user = new User("John", 25);

// Access like properties (not methods!)
console.log(user.name);  // "John" (calls getter)
user.name = "Jane";       // Calls setter
console.log(user.name);  // "Jane"
user.name = "";          // Fails validation
console.log(user.name);  // "Jane" (unchanged)

console.log(user.info);  // "Jane is 25 years old"

// Object literals also support getters/setters
const person = {
    _firstName: "John",
    _lastName: "Doe",

    get fullName() {
        return `${this._firstName} ${this._lastName}`;
    },

    set fullName(value) {
        [this._firstName, this._lastName] = value.split(" ");
    }
};

console.log(person.fullName);  // "John Doe"
person.fullName = "Jane Smith";
console.log(person.fullName);  // "Jane Smith"
```
</UniversalEditor>

## Instance vs Static vs Private

<UniversalEditor title="Member Types Summary">
```java !! java
// Java - Member types
public class Example {
    private int instanceField;        // Instance
    private static int staticField;   // Static

    public void instanceMethod() { }

    public static void staticMethod() { }
}
```

```javascript !! js
// JavaScript - All member types

class Example {
    // Public instance field
    instanceField = 1;

    // Static field
    static staticField = 2;

    // Private instance field
    #privateField = 3;

    // Static private field
    static #staticPrivate = 4;

    // Instance method
    instanceMethod() {
        console.log(this.instanceField);  // ✓ Access
        console.log(this.#privateField);  // ✓ Access
        console.log(Example.staticField); // ✓ Access
        // console.log(Example.#staticPrivate);  // ✗ Can't access private static
    }

    // Static method
    static staticMethod() {
        console.log(this.staticField);   // ✓ Access
        console.log(this.#staticPrivate); // ✓ Access
        // console.log(this.instanceField); // ✗ Can't access instance
    }
}

const ex = new Example();
ex.instanceMethod();
Example.staticMethod();

// Accessing members
console.log(ex.instanceField);  // 1
console.log(Example.staticField);  // 2
// console.log(ex.#privateField);  // SyntaxError!
```
</UniversalEditor>

## Method Overriding and Polymorphism

<UniversalEditor title="Method Overriding">
```java !! java
// Java - Method overriding
public class Animal {
    public void speak() {
        System.out.println("Animal sound");
    }

    public void perform() {
        speak();  // Calls overridden version in subclass
    }
}

public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}

Dog dog = new Dog();
dog.perform();  // "Woof!" (polymorphic call)
```

```javascript !! js
// JavaScript - Method overriding (works similarly)

class Animal {
    speak() {
        console.log("Animal sound");
    }

    perform() {
        this.speak();  // Polymorphic - calls subclass version
    }
}

class Dog extends Animal {
    speak() {
        console.log("Woof!");
    }
}

const dog = new Dog();
dog.perform();  // "Woof!"

// Explicit parent method call
class Dog2 extends Animal {
    speak() {
        super.speak();  // "Animal sound"
        console.log("Woof!");
    }
}

const dog2 = new Dog2();
dog2.speak();  // "Animal sound" then "Woof!"
```
</UniversalEditor>

## Common Patterns

### Pattern 1: Singleton

<UniversalEditor title="Singleton Pattern">
```java !! java
// Java - Singleton
public class Database {
    private static Database instance;

    private Database() {
        // Private constructor
    }

    public static synchronized Database getInstance() {
        if (instance == null) {
            instance = new Database();
        }
        return instance;
    }
}
```

```javascript !! js
// JavaScript - Singleton with class

class Database {
    constructor() {
        if (Database.instance) {
            return Database.instance;
        }
        this.connection = "connected";
        Database.instance = this;
    }

    static getInstance() {
        if (!Database.instance) {
            Database.instance = new Database();
        }
        return Database.instance;
    }
}

const db1 = Database.getInstance();
const db2 = Database.getInstance();
console.log(db1 === db2);  // true

// Simpler: Use object literal
const config = Object.freeze({
    apiUrl: "https://api.example.com",
    timeout: 5000
});
```
</UniversalEditor>

### Pattern 2: Mixin Pattern

<UniversalEditor title="Mixin Pattern">
```java !! java
// Java - Multiple inheritance not supported
// Use interfaces for similar behavior
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    public void fly() { /* ... */ }
    public void swim() { /* ... */ }
}
```

```javascript !! js
// JavaScript - Mixin pattern

const Flyable = {
    fly() {
        console.log("Flying!");
    }
};

const Swimmable = {
    swim() {
        console.log("Swimming!");
    }
};

class Duck {}
Object.assign(Duck.prototype, Flyable, Swimmable);

const duck = new Duck();
duck.fly();   // "Flying!"
duck.swim();  // "Swimming!"

// Mixin factory function
function mix(...mixins) {
    return function(targetClass) {
        Object.assign(targetClass.prototype, ...mixins);
        return targetClass;
    };
}

class Bird {}
const MixedBird = mix(Flyable)(Bird);

const bird = new MixedBird();
bird.fly();  // "Flying!"
```
</UniversalEditor>

### Pattern 3: Factory with Classes

<UniversalEditor title="Factory with Classes">
```javascript !! js
// Abstract base class
class Vehicle {
    constructor(make, model) {
        if (this.constructor === Vehicle) {
            throw new Error("Abstract class cannot be instantiated");
        }
        this.make = make;
        this.model = model;
    }

    // Abstract method
    start() {
        throw new Error("Must implement start()");
    }
}

class Car extends Vehicle {
    start() {
        console.log(`${this.make} ${this.model} is starting`);
    }
}

class Motorcycle extends Vehicle {
    start() {
        console.log(`${this.make} ${this.model} vroom!`);
    }
}

// Factory function
function createVehicle(type, make, model) {
    switch (type) {
        case "car":
            return new Car(make, model);
        case "motorcycle":
            return new Motorcycle(make, model);
        default:
            throw new Error("Unknown vehicle type");
    }
}

const car = createVehicle("car", "Toyota", "Camry");
car.start();  // "Toyota Camry is starting"
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Class Best Practices">
```java !! java
// Java: Clear encapsulation
public class User {
    private final String name;  // Immutable
    private int age;

    public User(String name, int age) {
        this.name = Objects.requireNonNull(name);
        this.age = age;
    }

    public String getName() {
        return name;
    }

    // Validation in setters
    public void setAge(int age) {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        this.age = age;
    }
}
```

```javascript !! js
// JavaScript: Similar principles

// 1. Use classes for objects with behavior
class User {
    // Use private fields (ES2022+)
    #name;
    #age;

    constructor(name, age) {
        this.#name = name;
        this.#age = age;
    }

    get name() {
        return this.#name;
    }

    get age() {
        return this.#age;
    }

    set age(value) {
        if (value >= 0) {
            this.#age = value;
        }
    }
}

// 2. Use object literals for simple data
const config = { apiUrl: "https://api.example.com" };

// 3. Prefer composition over inheritance
// Good
class TodoApp {
    constructor(storage, logger) {
        this.storage = storage;
        this.logger = logger;
    }
}

// Avoid: Deep inheritance chains
// Bad
class Animal {}
class Mammal extends Animal {}
class Dog extends Mammal {}
class Labrador extends Dog {}

// 4. Use static methods for utility functions
class MathUtils {
    static clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
    }
}

// 5. Use getters/setters for computed or validated properties
class Temperature {
    #celsius;

    get celsius() {
        return this.#celsius;
    }

    set celsius(value) {
        this.#celsius = value;
    }

    get fahrenheit() {
        return (this.#celsius * 9/5) + 32;
    }

    set fahrenheit(value) {
        this.#celsius = (value - 32) * 5/9;
    }
}

// 6. Always call super() in subclass constructors
class Child extends Parent {
    constructor(name) {
        super(name);  // Must be first line
        // ...
    }
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Create a Class
```javascript
// Create a Rectangle class with:
// - width, height properties
// - area() method
// - perimeter() method
// - get isSquare() getter
```

### Exercise 2: Inheritance
```javascript
// Create Shape base class
// Create Circle and Rectangle subclasses
// Each should have area() method
```

### Exercise 3: Private Fields
```javascript
// Create BankAccount class with:
// - Private #balance field
// - deposit() and withdraw() methods
// - Validation for negative amounts
```

### Exercise 4: Static Methods
```javascript
// Create MathUtility class with:
// - Static methods: clamp(), lerp(), randomInRange()
// - Use them without instantiation
```

## Summary

### Key Takeaways

1. **Class Syntax:**
   - Syntactic sugar over prototypes
   - Not hoisted (unlike functions)
   - Can be named or anonymous

2. **Inheritance:**
   - `extends` for inheritance
   - `super` to call parent
   - Must call `super()` before `this`

3. **Static Members:**
   - `static` keyword
   - Accessed via class name
   - Don't require instantiation

4. **Private Fields:**
   - `#` prefix (ES2022+)
   - Truly encapsulated
   - Cannot be accessed outside class

5. **Getters/Setters:**
   - Computed properties
   - Validation
   - Encapsulation

6. **Best Practices:**
   - Classes for behavior, objects for data
   - Prefer composition over deep inheritance
   - Use private fields for true encapsulation
   - Static methods for utilities

### Comparison Table: Java vs JavaScript

| Feature | Java | JavaScript |
|---------|------|------------|
| **Syntax** | `class Name { }` | Same (ES6+) |
| **Inheritance** | `extends` (single) | `extends` (single) |
| **Interfaces** | Yes | No (use protocols) |
| **Abstract** | `abstract` keyword | Manual enforcement |
| **Private** | `private` keyword | `#` prefix (ES2022+) |
| **Protected** | `protected` keyword | Convention (`_name`) |
| **Static** | `static` keyword | Same |
| **Final** | `final` keyword | No (use Object.freeze) |
| **Super** | `super.method()` | Same |
| **Constructor** | Same name as class | `constructor()` |

## What's Next?

You've mastered JavaScript classes! Next up is **Module 8: Prototypes and Prototype Chain**, where we'll explore:

- How prototypes work under the hood
- Prototype chain lookup
- Object.create() and prototype inheritance
- Constructor functions
- The relationship between classes and prototypes
- When to use prototypes vs classes

Ready to understand JavaScript's prototype system? Let's continue!
