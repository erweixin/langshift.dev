---
title: "Module 6: Objects"
description: "Master JavaScript object literals, methods, and manipulation techniques"
---

## Module 6: Objects

JavaScript objects are quite different from Java objects. They're dynamic, mutable collections of properties. Let's explore how to work with objects effectively.

## Learning Objectives

By the end of this module, you will:
✅ Understand object literals and creation
✅ Master property access (dot vs bracket notation)
✅ Learn object methods and computed properties
✅ Understand property descriptors and attributes
✅ Know how to clone and merge objects
✅ Master object destructuring

## Object Literals

JavaScript objects are created using literal syntax:

<UniversalEditor title="Object Creation">
```java !! java
// Java - Classes required
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public int getAge() { return age; }
}

User user = new User("John", 25);
```

```javascript !! js
// JavaScript - Object literals (simple and direct)
const user = {
    name: "John",
    age: 25
};

console.log(user.name);  // "John"
console.log(user.age);   // 25

// Can add properties anytime
user.email = "john@example.com";
user.isActive = true;

// Can delete properties
delete user.isActive;

// Empty object
const empty = {};

// Nested objects
const person = {
    name: "John",
    address: {
        street: "123 Main St",
        city: "NYC",
        country: "USA"
    }
};

console.log(person.address.city);  // "NYC"
```
</UniversalEditor>

### Property Access

<UniversalEditor title="Property Access Patterns">
```java !! java
// Java - Direct field access or getters/setters
User user = new User("John", 25);
String name = user.getName();  // Getter
user.setAge(26);               // Setter

// Direct field (if public)
user.name = "Jane";
```

```javascript !! js
// JavaScript - Dot notation vs bracket notation
const user = {
    name: "John",
    age: 25,
    "first name": "John",  // Property with space
    "user-email": "john@example.com"  // Invalid as identifier
};

// Dot notation (most common)
console.log(user.name);  // "John"

// Bracket notation (for dynamic keys or special characters)
console.log(user["first name"]);  // "John"
console.log(user["user-email"]);  // "john@example.com"

// Bracket notation with variables
const key = "age";
console.log(user[key]);  // 25

// Dynamic property access
function getProperty(obj, prop) {
    return obj[prop];
}

console.log(getProperty(user, "name"));  // "John"

// Nested access
const config = {
    server: {
        port: 3000,
        host: "localhost"
    }
};

const serverKey = "server";
const portKey = "port";
console.log(config[serverKey][portKey]);  // 3000

// Optional chaining (ES2020)
const data = {
    user: {
        address: {
            city: "NYC"
        }
    }
};

console.log(data.user?.address?.city);  // "NYC"
console.log(data.user?.phone?.number);  // undefined (no error)
console.log(data.nonExistent?.property);  // undefined
```
</UniversalEditor>

### Computed Properties

<UniversalEditor title="Computed Properties">
```java !! java
// Java - Dynamic properties not typical
// Would use Map
Map<String, Object> data = new HashMap<>();
data.put("field_" + 1, "value1");
data.put("field_" + 2, "value2");
```

```javascript !! js
// JavaScript - Computed property names (ES6+)
const prefix = "user";
const id = 1;

const user = {
    [`${prefix}_${id}`]: "John",
    [`${prefix}_${id + 1}`]: "Jane"
};

console.log(user.user_1);  // "John"
console.log(user.user_2);  // "Jane"

// Dynamic method names
const methodName = "greet";
const calc = {
    [methodName]() {
        return "Hello!";
    },
    ["calc_" + "sum"](a, b) {
        return a + b;
    }
};

console.log(calc.greet());       // "Hello!"
console.log(calc.calc_sum(5, 3));  // 8

// Practical: Create getters/setters dynamically
function createAccessor(propertyName) {
    return {
        get [propertyName]() {
            return this[`_${propertyName}`];
        },
        set [propertyName](value) {
            this[`_${propertyName}`] = value;
        }
    };
}

const user = Object.assign(
    { _name: "John" },
    createAccessor("name")
);

console.log(user.name);  // "John"
user.name = "Jane";
console.log(user.name);  // "Jane"
```
</UniversalEditor>

## Object Methods

JavaScript provides several methods for working with objects:

<UniversalEditor title="Object Static Methods">
```java !! java
// Java - Reflection
import java.lang.reflect.Field;

User user = new User("John", 25);
Class<?> clazz = user.getClass();
Field[] fields = clazz.getDeclaredFields();

for (Field field : fields) {
    field.setAccessible(true);
    System.out.println(field.getName() + ": " + field.get(user));
}
```

```javascript !! js
// JavaScript - Object methods

const user = {
    name: "John",
    age: 25,
    email: "john@example.com"
};

// Object.keys(): Get property names
const keys = Object.keys(user);
console.log(keys);  // ["name", "age", "email"]

// Object.values(): Get property values
const values = Object.values(user);
console.log(values);  // ["John", 25, "john@example.com"]

// Object.entries(): Get [key, value] pairs
const entries = Object.entries(user);
console.log(entries);
// [["name", "John"], ["age", 25], ["email", "john@example.com"]]

// Convert entries back to object
const fromEntries = Object.fromEntries(entries);
console.log(fromEntries);  // { name: "John", age: 25, email: "john@example.com" }

// Object.assign(): Copy properties
const target = { a: 1, b: 2 };
const source = { b: 3, c: 4 };
const merged = Object.assign(target, source);
console.log(merged);  // { a: 1, b: 3, c: 4 }
// Note: target is modified!

// Safer: Spread operator
const merged2 = { ...target, ...source };
console.log(merged2);  // { a: 1, b: 3, c: 4 }
// target is unchanged

// Object.freeze(): Make immutable
const frozen = Object.freeze({ name: "John" });
frozen.name = "Jane";  // Silently fails (strict mode: error)
console.log(frozen.name);  // "John"

// Object.seal(): Prevent adding/removing properties
const sealed = Object.seal({ name: "John" });
sealed.name = "Jane";  // Allowed
sealed.age = 25;       // Fails
console.log(sealed);  // { name: "Jane" }

// Check state
console.log(Object.isFrozen(frozen));  // true
console.log(Object.isSealed(sealed));  // true
```
</UniversalEditor>

### Property Descriptors

<UniversalEditor title="Property Descriptors">
```java !! java
// Java - No direct equivalent
// Properties are determined by fields and methods
```

```javascript !! js
// JavaScript - Fine-grained property control

const user = { name: "John" };

// Get property descriptor
const descriptor = Object.getOwnPropertyDescriptor(user, "name");
console.log(descriptor);
// {
//   value: "John",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

// Define property with descriptor
const person = {};
Object.defineProperty(person, "name", {
    value: "John",
    writable: false,      // Cannot be changed
    enumerable: true,     // Shows up in loops
    configurable: false   // Cannot be deleted or reconfigured
});

person.name = "Jane";  // Silently fails
console.log(person.name);  // "John"

// Getters and setters
const user2 = {
    _firstName: "John",
    _lastName: "Doe",

    get firstName() {
        return this._firstName;
    },

    set firstName(value) {
        this._firstName = value;
    },

    get fullName() {
        return `${this._firstName} ${this._lastName}`;
    }
};

console.log(user2.firstName);  // "John"
user2.firstName = "Jane";
console.log(user2.fullName);  // "Jane Doe"

// Define properties with getters/setters
const account = {
    _balance: 0,

    get balance() {
        return this._balance;
    },

    set balance(value) {
        if (value >= 0) {
            this._balance = value;
        }
    }
};

account.balance = 100;
console.log(account.balance);  // 100

account.balance = -50;  // Validation fails
console.log(account.balance);  // 100 (unchanged)

// Multiple properties
Object.defineProperties(user, {
    firstName: {
        value: "John",
        writable: true
    },
    lastName: {
        value: "Doe",
        writable: true
    },
    fullName: {
        get() {
            return `${this.firstName} ${this.lastName}`;
        }
    }
});
```
</UniversalEditor>

## Object Destructuring

Destructuring unpacks properties into variables:

<UniversalEditor title="Object Destructuring">
```java !! java
// Java - Manual extraction
User user = new User("John", 25);
String name = user.getName();
int age = user.getAge();

// Or use objects/tuples (Java 16+)
record User(String name, int age) {}
User user = new User("John", 25);
String name = user.name();
int age = user.age();
```

```javascript !! js
// JavaScript - Object destructuring

const user = {
    name: "John",
    age: 25,
    email: "john@example.com",
    city: "NYC"
};

// Basic destructuring
const { name, age } = user;
console.log(name);  // "John"
console.log(age);   // 25

// Different variable names
const { name: userName, age: userAge } = user;
console.log(userName);  // "John"

// Default values
const { name: n, country = "USA" } = user;
console.log(country);  // "USA" (user didn't have country)

// Nested destructuring
const data = {
    user: {
        name: "John",
        address: {
            city: "NYC",
            country: "USA"
        }
    }
};

const { user: { name, address: { city } } } = data;
console.log(name);  // "John"
console.log(city);  // "NYC"

// Rest operator
const { name, ...rest } = user;
console.log(name);  // "John"
console.log(rest);  // { age: 25, email: "john@example.com", city: "NYC" }

// Destructuring in function parameters
function greet({ name, age = 30 }) {
    console.log(`Hello ${name}, you are ${age}`);
}

greet(user);  // "Hello John, you are 25"

// Destructuring with arrays
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

const [{ id: firstId }, { name: secondName }] = users;
console.log(firstId);    // 1
console.log(secondName); // "Bob"

// Practical: API response
function processUser({ data: { user: { name, email }, meta } }) {
    console.log(name, email, meta);
}

processUser({
    data: {
        user: { name: "John", email: "john@example.com" },
        meta: { timestamp: 1234567890 }
    }
});
```
</UniversalEditor>

## Object Cloning and Merging

<UniversalEditor title="Object Cloning">
```java !! java
// Java - Clone not straightforward
// Need to implement Cloneable or use copy constructors

public class User implements Cloneable {
    private String name;
    private int age;

    public User(User other) {
        this.name = other.name;
        this.age = other.age;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

User original = new User("John", 25);
User copy = new User(original);
```

```javascript !! js
// JavaScript - Multiple ways to clone

// Shallow clone with spread
const original = { name: "John", age: 25 };
const clone = { ...original };

clone.name = "Jane";
console.log(original.name);  // "John" (unchanged)

// Object.assign() for shallow clone
const clone2 = Object.assign({}, original);

// ⚠️ Shallow clone issue with nested objects
const nested = {
    user: {
        name: "John",
        address: {
            city: "NYC"
        }
    }
};

const shallow = { ...nested };
shallow.user.name = "Jane";
shallow.user.address.city = "LA";

console.log(nested.user.name);  // "Jane" (changed!)
console.log(nested.user.address.city);  // "LA" (changed!)

// Deep clone with JSON
const deep1 = JSON.parse(JSON.stringify(nested));
deep1.user.name = "Alice";
console.log(nested.user.name);  // "Jane" (unchanged)

// Deep clone with structuredClone (modern)
const deep2 = structuredClone(nested);

// Deep clone utility
function deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
        return obj;
    }

    if (obj instanceof Date) {
        return new Date(obj);
    }

    if (obj instanceof Array) {
        return obj.map(item => deepClone(item));
    }

    const cloned = {};
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloned[key] = deepClone(obj[key]);
        }
    }
    return cloned;
}

// Merging objects
const defaults = {
    theme: "light",
    language: "en",
    timeout: 5000
};

const userConfig = {
    language: "fr",
    timeout: 10000
};

// Merge (userConfig overrides defaults)
const config = { ...defaults, ...userConfig };
console.log(config);
// { theme: "light", language: "fr", timeout: 10000 }

// Deep merge utility
function deepMerge(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();

    if (isObject(target) && isObject(source)) {
        for (const key in source) {
            if (isObject(source[key])) {
                if (!target[key]) Object.assign(target, { [key]: {} });
                deepMerge(target[key], source[key]);
            } else {
                Object.assign(target, { [key]: source[key] });
            }
        }
    }
    return deepMerge(target, ...sources);
}

function isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
}

const merged = deepMerge(
    { user: { name: "John", settings: { theme: "light" } } },
    { user: { settings: { language: "en" } } }
);
console.log(merged);
// { user: { name: "John", settings: { theme: "light", language: "en" } } }
```
</UniversalEditor>

## This Context in Objects

<UniversalEditor title="This in Objects">
```java !! java
// Java - 'this' always refers to current instance
public class Counter {
    private int count = 0;

    public void increment() {
        this.count++;  // 'this' is the Counter instance
    }
}
```

```javascript !! js
// JavaScript - 'this' depends on call site

const user = {
    name: "John",
    age: 25,

    greet() {
        console.log(`Hello, I'm ${this.name}`);
    },

    // Arrow function: 'this' from surrounding scope
    greetArrow: () => {
        console.log(`Hello, I'm ${this.name}`);  // undefined!
    },

    // Nested function issue
    nestedGreet() {
        // 'this' works here
        console.log(this.name);

        setTimeout(function() {
            // 'this' is lost here!
            console.log(this.name);  // undefined
        }, 1000);

        // Solution 1: Arrow function
        setTimeout(() => {
            console.log(this.name);  // "John" - works!
        }, 1000);

        // Solution 2: Bind
        setTimeout(function() {
            console.log(this.name);  // "John"
        }.bind(this), 1000);

        // Solution 3: Capture this
        const self = this;
        setTimeout(function() {
            console.log(self.name);  // "John"
        }, 1000);
    }
};

user.greet();       // "Hello, I'm John"
user.greetArrow();  // "Hello, I'm undefined"

// 'this' depends on call site
const greet = user.greet;
greet();  // "Hello, I'm undefined" (not called as method)

// Explicit this binding
const greet2 = user.greet.bind(user);
greet2();  // "Hello, I'm John"

// Call and apply
user.greet.call({ name: "Jane" });  // "Hello, I'm Jane"
user.greet.apply({ name: "Bob" });  // "Hello, I'm Bob"
```
</UniversalEditor>

## Common Patterns

### Pattern 1: Factory Functions

<UniversalEditor title="Factory Functions">
```java !! java
// Java - Static factory methods
public class User {
    private String name;
    private int age;

    public static User create(String name, int age) {
        return new User(name, age);
    }

    public static User fromJson(String json) {
        // Parse and create
    }
}
```

```javascript !! js
// JavaScript - Factory functions (simple, no classes needed)

function createUser(name, age) {
    return {
        name,
        age,
        greet() {
            console.log(`Hi, I'm ${this.name}`);
        },
        incrementAge() {
            this.age++;
            return this;  // Chaining
        }
    };
}

const user = createUser("John", 25);
user.greet();  // "Hi, I'm John"
user.incrementAge().greet();  // Chaining

// Factory with closures (private data)
function createCounter() {
    let count = 0;  // Private

    return {
        increment() {
            count++;
            return this;
        },
        getCount() {
            return count;
        },
        reset() {
            count = 0;
            return this;
        }
    };
}

const counter = createCounter();
console.log(counter.increment().increment().getCount());  // 2
console.log(counter.count);  // undefined (truly private)
```
</UniversalEditor>

### Pattern 2: Options Object Pattern

<UniversalEditor title="Options Object Pattern">
```javascript !! js
// Function with many parameters (bad)
function createUser(name, age, email, active, role, permissions) {
    // Hard to remember parameter order
    // Can't skip optional parameters
}

// Options object pattern (good)
function createUser(options) {
    const defaults = {
        active: true,
        role: "user",
        permissions: []
    };

    const config = { ...defaults, ...options };

    return {
        ...config,
        createdAt: new Date()
    };
}

const user = createUser({
    name: "John",
    age: 25,
    role: "admin"
});

console.log(user);
// {
//   name: "John",
//   age: 25,
//   active: true,  // from defaults
//   role: "admin",
//   permissions: [],  // from defaults
//   createdAt: Date
// }

// With destructuring
function createUser2({ name, age, active = true, role = "user" } = {}) {
    return { name, age, active, role, createdAt: new Date() };
}

const user2 = createUser2({ name: "Jane", age: 30 });
console.log(user2);
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Object Best Practices">
```java !! java
// Java: Use classes, encapsulation
public class User {
    private String name;
    private int age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    // Getters/setters for all fields
}
```

```javascript !! js
// JavaScript: Embrace object literals

// 1. Use object literals for simple data
const user = {
    name: "John",
    age: 25
};

// 2. Use computed properties for dynamic keys
const key = "user_" + Date.now();
const users = {
    [key]: { name: "John" }
};

// 3. Use method shorthand
const calculator = {
    add(a, b) {  // Not: add: function(a, b)
        return a + b;
    },

    subtract(a, b) {
        return a - b;
    }
};

// 4. Use destructuring for clean property access
const { name, age } = getUser();

// 5. Use spread for immutable updates
const updatedUser = { ...user, age: 26 };

// 6. Use Object.freeze for constants
const CONFIG = Object.freeze({
    apiUrl: "https://api.example.com",
    timeout: 5000
});

// 7. Use optional chaining for safe access
const city = user?.address?.city ?? "Unknown";

// 8. Avoid prototypes with object literals
// (we'll cover classes in module 7)
```
</UniversalEditor>

## Exercises

### Exercise 1: Object Manipulation
```javascript
const user = { name: "John", age: 25, email: "john@example.com" };

// 1. Add phone property
// 2. Remove email property
// 3. Update age to 26
// 4. Clone the object
// 5. Get all property names
// 6. Get all property values
```

### Exercise 2: Destructuring
```javascript
const config = {
    server: {
        host: "localhost",
        port: 3000
    },
    database: {
        name: "mydb",
        port: 5432
    }
};

// Extract: serverHost, serverPort, dbName
```

### Exercise 3: Merge Objects
```javascript
const defaults = { theme: "light", lang: "en", timeout: 5000 };
const userSettings = { lang: "fr", notifications: true };

// Merge with userSettings overriding defaults
```

### Exercise 4: Factory Function
```javascript
// Create a factory function that makes rectangle objects
// with: width, height, area() method, perimeter() method
function createRectangle(width, height) {
    // Return object with methods
}
```

## Summary

### Key Takeaways

1. **Object Literals:**
   - Simple, direct syntax
   - Can add/remove properties anytime
   - Supports nested structures

2. **Property Access:**
   - Dot notation for known keys
   - Bracket notation for dynamic/special keys
   - Optional chaining for safe access

3. **Object Methods:**
   - `Object.keys()`: Get property names
   - `Object.values()`: Get property values
   - `Object.entries()`: Get key-value pairs
   - `Object.assign()`: Merge objects

4. **Destructuring:**
   - Extract properties cleanly
   - Support for default values
   - Renaming and nested destructuring

5. **Cloning:**
   - Spread for shallow clone
   - `structuredClone()` for deep clone
   - Watch out for nested objects

6. **This Context:**
   - Depends on call site
   - Arrow functions capture surrounding this
   - Use `bind()` for explicit binding

### Comparison Table: Java vs JavaScript

| Feature | Java | JavaScript |
|---------|------|------------|
| **Creation** | `new Class()` | Literal `{}` |
| **Properties** | Fixed (fields) | Dynamic |
| **Methods** | Class methods | Object functions |
| **Access** | Direct or getters/setters | Dot or bracket notation |
| **This** | Always current instance | Depends on call site |
| **Cloning** | Manual or Cloneable | Spread or structuredClone |
| **Immutable** | `final` fields | `Object.freeze()` |

## What's Next?

You've mastered JavaScript objects! Next up is **Module 7: Classes and Inheritance**, where we'll explore:

- ES6 class syntax
- Constructors and methods
- Inheritance with `extends`
- Super keyword
- Static methods and properties
- Private fields (ES2022)

Ready to explore JavaScript's class system? Let's continue!
