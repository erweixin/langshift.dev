---
title: "Module 12: DOM Manipulation"
description: "Master DOM traversal, manipulation, and best practices"
---

## Module 12: DOM Manipulation

The Document Object Model (DOM) is JavaScript's interface to HTML documents. This module teaches you how to dynamically interact with web pages.

## Learning Objectives

By the end of this module, you will:
✅ Understand DOM structure and traversal
✅ Master element selection methods
✅ Learn to modify DOM elements
✅ Understand creating and removing elements
✅ Know performance best practices
✅ Master DOM manipulation patterns

## DOM vs Java GUI

<UniversalEditor title="DOM vs Java Swing/JavaFX">
```java !! java
// Java - Swing
JFrame frame = new JFrame("My App");
JButton button = new JButton("Click me");
frame.add(button);
frame.setVisible(true);

// JavaFX
Button btn = new Button("Click me");
Scene scene = new Scene(new StackPane(btn), 300, 250);
stage.setScene(scene);
stage.show();
```

```javascript !! js
// JavaScript - DOM
const button = document.createElement("button");
button.textContent = "Click me";
document.body.appendChild(button);
```
</UniversalEditor>

## Selecting Elements

<UniversalEditor title="Element Selection">
```javascript !! js
// Modern methods (preferred)
const byId = document.getElementById("myId");
const byClass = document.getElementsByClassName("myClass");
const byTag = document.getElementsByTagName("div");

// Query selectors (most flexible)
const element = document.querySelector("#myId");
const allElements = document.querySelectorAll(".myClass");

// CSS selectors
const element1 = document.querySelector("#container .item");
const element2 = document.querySelector("button[data-action='submit']");
const element3 = document.querySelector("ul > li:first-child");

// Context selection
const container = document.querySelector("#container");
const items = container.querySelectorAll(".item");  // Only within container

// Performance considerations
// getElementById is fastest for ID lookup
// querySelector is slower but more flexible

// Best practice: Cache selectors
const button = document.getElementById("submit");
button.addEventListener("click", handleClick);
```
</UniversalEditor>

## Traversing the DOM

<UniversalEditor title="DOM Traversal">
```javascript !! js
const parent = document.getElementById("parent");

// Children
const children = parent.children;  // HTMLCollection (live)
const childNodes = parent.childNodes;  // NodeList (live)
const firstChild = parent.firstElementChild;
const lastChild = parent.lastElementChild;

// Siblings
const nextSibling = element.nextElementSibling;
const prevSibling = element.previousElementSibling;

// Parent
const parent = element.parentElement;

// Walking the DOM tree
function walkDOM(node, callback) {
    callback(node);
    node = node.firstChild;
    while (node) {
        walkDOM(node, callback);
        node = node.nextSibling;
    }
}

// Finding elements
const closestParent = element.closest(".container");
const matches = element.matches(".active");
```
</UniversalEditor>

## Modifying Elements

<UniversalEditor title="Modifying Elements">
```javascript !! js
const element = document.querySelector("#myElement");

// Content
element.textContent = "New text";  // Plain text
element.innerHTML = "<strong>New HTML</strong>";  // HTML (security risk!)

// Attributes
element.setAttribute("class", "active");
element.getAttribute("class");
element.hasAttribute("class");
element.removeAttribute("class");

// Properties (preferred)
element.id = "myId";
element.className = "my-class";
element.href = "https://example.com";
element.disabled = true;

// Classes
element.classList.add("active");
element.classList.remove("inactive");
element.classList.toggle("active");
element.classList.contains("active");

// Multiple classes
element.classList.add("class1", "class2");
element.classList.remove("class1", "class2");

// Replace class
element.classList.replace("old", "new");

// Styles
element.style.color = "red";
element.style.backgroundColor = "blue";

// CSS custom properties
element.style.setProperty("--main-color", "#00ff00");
const color = element.style.getPropertyValue("--main-color");

// Dataset (data-* attributes)
element.dataset.userId = "123";
console.log(element.dataset.userId);  // "123"
```
</UniversalEditor>

## Creating and Removing Elements

<UniversalEditor title="Creating and Removing">
```javascript !! js
// Create element
const div = document.createElement("div");
div.textContent = "Hello";
div.className = "greeting";

// Add to DOM
document.body.appendChild(div);
container.insertBefore(div, container.firstChild);

// Replace element
parent.replaceChild(newElement, oldElement);

// Clone element
const clone = element.cloneNode(true);  // Deep clone
const shallow = element.cloneNode(false);  // Shallow clone

// Remove element
parent.removeChild(child);
child.remove();  // Modern

// Insert HTML (security risk!)
element.insertAdjacentHTML("beforeend", "<span>New</span>");

// Insert positions:
// "beforebegin" - Before element
// "afterbegin" - Inside, at start
// "beforeend" - Inside, at end
// "afterend" - After element

// Insert element
const span = document.createElement("span");
element.insertAdjacentElement("beforeend", span);
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="DOM Best Practices">
```javascript !! js
// 1. Minimize reflows and repaints
// Bad: Multiple reflows
element.style.width = "100px";
element.style.height = "100px";
element.style.margin = "10px";

// Good: Single reflow
element.style.cssText = "width: 100px; height: 100px; margin: 10px;";

// Better: Use classes
element.className = "optimized-style";

// 2. Batch DOM updates
// Bad: Multiple DOM insertions
items.forEach(item => {
    document.body.appendChild(createElement(item));
});

// Good: Document fragment
const fragment = document.createDocumentFragment();
items.forEach(item => {
    fragment.appendChild(createElement(item));
});
document.body.appendChild(fragment);  // Single reflow

// 3. Cache DOM queries
// Bad
function update() {
    document.getElementById("result").textContent = "Done";
}

// Good
const result = document.getElementById("result");
function update() {
    result.textContent = "Done";
}

// 4. Use event delegation
// Bad (many listeners)
items.forEach(item => {
    item.addEventListener("click", handleClick);
});

// Good (single listener)
container.addEventListener("click", (e) => {
    if (e.target.matches(".item")) {
        handleClick(e);
    }
});
```
</UniversalEditor>

## Exercises

### Exercise 1: Dynamic List
Create a function that builds a list from an array:
```javascript
function buildList(items) {
    // Create <ul> with <li> for each item
}
```

### Exercise 2: Toggle Classes
```javascript
// Add "active" class on click, remove from others
function setupTabs(tabs) {
    // Implementation
}
```

### Exercise 3: Form Validation
```javascript
// Validate form on submit
function validateForm(form) {
    // Check required fields
    // Show errors
}
```

## Summary

### Key Takeaways

1. **Selection:** Use querySelector/querySelectorAll
2. **Traversal:** parentElement, children, nextElementSibling
3. **Modification:** textContent, classList, style
4. **Performance:** Minimize reflows, batch updates, cache queries

### Comparison: Java vs JavaScript

| Feature | Java | JavaScript |
|---------|------|------------|
| **DOM Access** | No DOM | document methods |
| **Event Handling** | Listeners | addEventListener |
| **Styling** | CSS files | Inline + classes |
| **Updates** | Repaint | Reflow/repaint |

## What's Next?

Next: **Module 13: Event Handling** - Master events, propagation, and delegation!
