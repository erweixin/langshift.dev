---
title: "Module 2: Control Flow and Loops"
description: "Master JavaScript's control flow statements, loops, and iteration patterns"
---

## Module 2: Control Flow and Loops

In this module, we'll explore how JavaScript handles control flow and iteration. You'll find many similarities with Java, but JavaScript offers some powerful features that make iteration more expressive.

## Learning Objectives

By the end of this module, you will:
✅ Master conditional statements (if/else, switch, ternary)
✅ Understand all loop types (for, while, do-while, for...of, for...in)
✅ Learn functional iteration methods (map, filter, reduce)
✅ Discover短路求值 (short-circuit evaluation)
✅ Know when to use each iteration pattern

## Conditional Statements

### if/else Statements

JavaScript's if/else is nearly identical to Java:

<UniversalEditor title="if/else Comparison">
```java !! java
// Java - if/else
int age = 18;

if (age >= 18) {
    System.out.println("Adult");
} else if (age >= 13) {
    System.out.println("Teenager");
} else {
    System.out.println("Child");
}

// Ternary operator
String status = (age >= 18) ? "Adult" : "Minor";

// With null check
String name = null;
String displayName = (name != null) ? name : "Guest";
```

```javascript !! js
// JavaScript - if/else (same syntax)
let age = 18;

if (age >= 18) {
    console.log("Adult");
} else if (age >= 13) {
    console.log("Teenager");
} else {
    console.log("Child");
}

// Ternary operator (same)
let status = (age >= 18) ? "Adult" : "Minor";

// With null/undefined check
let name = null;
let displayName = (name !== null && name !== undefined) ? name : "Guest";

// Or simpler with nullish coalescing
let displayName2 = name ?? "Guest";
```
</UniversalEditor>

### Short-Circuit Evaluation

JavaScript uses short-circuit evaluation for logical operators:

<UniversalEditor title="Short-Circuit Evaluation">
```java !! java
// Java - Logical operators always return boolean
boolean isValid = true;
String name = "John";

// Both conditions are always evaluated to boolean
if (isValid && name != null && name.length() > 0) {
    // ...
}

// Cannot use logical operators for default values
// This doesn't work in Java:
// String displayName = name || "Guest";  // Compilation error!
```

```javascript !! js
// JavaScript - Short-circuit evaluation
let isValid = true;
let name = "John";

// && returns first falsy value or last truthy value
let result1 = isValid && name;  // "John" (both truthy)
let result2 = isValid && null;  // null (stops at null)
let result3 = false && name;   // false (stops at false)

// || returns first truthy value or last falsy value
let displayName = name || "Guest";  // "John" (name is truthy)
let displayName2 = null || "Guest"; // "Guest" (null is falsy)

// Practical pattern: Default values
function greet(name) {
    name = name || "Guest";  // Use "Guest" if name is falsy
    console.log(`Hello, ${name}`);
}

greet("John");  // "Hello, John"
greet("");      // "Hello, Guest" (empty string is falsy)
greet(null);    // "Hello, Guest"

// Nullish coalescing (ES2020) - only for null/undefined
function greet2(name) {
    let displayName = name ?? "Guest";
    console.log(`Hello, ${displayName}`);
}

greet2("");      // "Hello, " (empty string is NOT null/undefined)
greet2(null);    // "Hello, Guest"

// Optional chaining for safe property access
const user = { profile: { name: "John" } };
const username = user?.profile?.name ?? "Guest";  // "John"
const username2 = user?.settings?.theme ?? "dark";  // "dark" (settings doesn't exist)
```
</UniversalEditor>

### switch Statements

JavaScript's switch has some important differences from Java:

<UniversalEditor title="switch Statement Comparison">
```java !! java
// Java - switch with strict type matching
int dayOfWeek = 1;
String dayName;

switch (dayOfWeek) {
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case 3:
        dayName = "Wednesday";
        break;
    default:
        dayName = "Unknown";
}

// Java - switch expressions (Java 14+)
String dayType = switch (dayOfWeek) {
    case 1, 2, 3, 4, 5 -> "Weekday";
    case 6, 7 -> "Weekend";
    default -> "Invalid";
};
```

```javascript !! js
// JavaScript - switch with loose equality (be careful!)
let dayOfWeek = 1;
let dayName;

switch (dayOfWeek) {
    case 1:
        dayName = "Monday";
        break;
    case 2:
        dayName = "Tuesday";
        break;
    case "1":  // ⚠️ This matches too! (loose equality)
        dayName = "Monday (string)";
        break;
    default:
        dayName = "Unknown";
}

// Pitfall: Loose equality
let x = "1";
switch (x) {
    case 1:  // This matches! ("1" == 1 is true)
        console.log("Equal");
        break;
}

// Solution: Use strict equality checks
function strictSwitch(value) {
    if (value === 1) {
        return "One";
    } else if (value === 2) {
        return "Two";
    } else {
        return "Unknown";
    }
}

// Or use object lookup (better pattern)
const dayMap = {
    1: "Monday",
    2: "Tuesday",
    3: "Wednesday",
    4: "Thursday",
    5: "Friday",
    6: "Saturday",
    7: "Sunday"
};

const dayName2 = dayMap[dayOfWeek] ?? "Unknown";
```
</UniversalEditor>

## Traditional Loops

### for Loop

JavaScript's traditional for loop is similar to Java's:

<UniversalEditor title="for Loop Comparison">
```java !! java
// Java - for loop
for (int i = 0; i < 5; i++) {
    System.out.println("Iteration " + i);
}

// Enhanced for loop (for-each)
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// With index
for (int i = 0; i < numbers.length; i++) {
    System.out.println("Index " + i + ": " + numbers[i]);
}
```

```javascript !! js
// JavaScript - for loop (same syntax)
for (let i = 0; i < 5; i++) {
    console.log("Iteration " + i);
}

// for...of loop (modern for-each)
const numbers = [1, 2, 3, 4, 5];
for (const num of numbers) {
    console.log(num);
}

// With index using entries()
for (const [index, num] of numbers.entries()) {
    console.log(`Index ${index}: ${num}`);
}

// for...in loop (iterate over indices/keys)
for (const index in numbers) {
    console.log(`Index ${index}: ${numbers[index]}`);
}

// ⚠️ Be careful: for...in is for objects, not arrays
const user = { name: "John", age: 25 };
for (const key in user) {
    console.log(`${key}: ${user[key]}`);
}
```
</UniversalEditor>

### while and do-while Loops

These are identical to Java:

<UniversalEditor title="while and do-while">
```java !! java
// Java - while loop
int count = 0;
while (count < 5) {
    System.out.println("Count: " + count);
    count++;
}

// do-while loop
int i = 0;
do {
    System.out.println("At least once: " + i);
    i++;
} while (i < 5);
```

```javascript !! js
// JavaScript - while loop (same)
let count = 0;
while (count < 5) {
    console.log("Count: " + count);
    count++;
}

// do-while loop (same)
let i = 0;
do {
    console.log("At least once: " + i);
    i++;
} while (i < 5);

// Practical example: Input validation
function guessNumber() {
    let guess;
    let target = 42;

    do {
        guess = parseInt(prompt("Guess a number:"));
        if (guess < target) {
            console.log("Too low!");
        } else if (guess > target) {
            console.log("Too high!");
        }
    } while (guess !== target);

    console.log("Correct!");
}
```
</UniversalEditor>

### break and continue

JavaScript supports break and continue just like Java:

<UniversalEditor title="break and continue">
```java !! java
// Java - break and continue
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;  // Exit loop
    }
    if (i % 2 == 0) {
        continue;  // Skip to next iteration
    }
    System.out.println("Odd number: " + i);
}

// Labeled breaks (for nested loops)
outer:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (i == 1 && j == 1) {
            break outer;  // Exit outer loop
        }
        System.out.println(i + ", " + j);
    }
}
```

```javascript !! js
// JavaScript - break and continue (same)
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break;  // Exit loop
    }
    if (i % 2 === 0) {
        continue;  // Skip to next iteration
    }
    console.log("Odd number: " + i);
}

// Labeled breaks (same as Java)
outer:
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        if (i === 1 && j === 1) {
            break outer;  // Exit outer loop
        }
        console.log(`${i}, ${j}`);
    }
}

// Practical example: Search
function findUser(users, targetId) {
    for (const user of users) {
        if (user.id === targetId) {
            return user;  // Found it, exit early
        }
    }
    return null;  // Not found
}
```
</UniversalEditor>

## Modern Iteration Methods

JavaScript provides powerful array methods that Java developers will recognize from streams:

### Array.prototype.forEach

<UniversalEditor title="forEach vs for-each">
```java !! java
// Java - for-each loop
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}

// Java 8+ forEach with lambda
names.forEach(name -> System.out.println(name));

// With index (need IntStream)
IntStream.range(0, names.size())
         .forEach(i -> System.out.println(i + ": " + names.get(i)));
```

```javascript !! js
// JavaScript - forEach method
const names = ["Alice", "Bob", "Charlie"];
names.forEach(name => {
    console.log(name);
});

// With index
names.forEach((name, index) => {
    console.log(`${index}: ${name}`);
});

// Note: Cannot break out of forEach!
// Use a for...of loop if you need to break
for (const name of names) {
    if (name === "Bob") break;  // This works
    console.log(name);
}

// forEach doesn't return anything
const result = names.forEach(name => name.toUpperCase());
console.log(result);  // undefined
```
</UniversalEditor>

### Array.prototype.map

Creates a new array by transforming each element:

<UniversalEditor title="map Comparison">
```java !! java
// Java - Stream.map()
List<String> names = Arrays.asList("alice", "bob", "charlie");
List<String> upperNames = names.stream()
                               .map(String::toUpperCase)
                               .collect(Collectors.toList());

// Or with lambda
List<Integer> lengths = names.stream()
                            .map(name -> name.length())
                            .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array.map()
const names = ["alice", "bob", "charlie"];
const upperNames = names.map(name => name.toUpperCase());
console.log(upperNames);  // ["ALICE", "BOB", "CHARLIE"]

// Get lengths
const lengths = names.map(name => name.length());
console.log(lengths);  // [5, 3, 7]

// Transform objects
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

const userIds = users.map(user => user.id);
console.log(userIds);  // [1, 2]

// With index
const numbered = names.map((name, i) => `${i + 1}. ${name}`);
console.log(numbered);  // ["1. Alice", "2. Bob", "3. Charlie"]
```
</UniversalEditor>

### Array.prototype.filter

Creates a new array with elements that pass a test:

<UniversalEditor title="filter Comparison">
```java !! java
// Java - Stream.filter()
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
List<Integer> evens = numbers.stream()
                              .filter(n -> n % 2 == 0)
                              .collect(Collectors.toList());

// Chain multiple operations
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .filter(n -> n > 5)
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array.filter()
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);  // [2, 4, 6, 8, 10]

// Chain methods
const result = numbers
    .filter(n => n % 2 === 0)
    .filter(n => n > 5);
console.log(result);  // [6, 8, 10]

// Filter objects
const users = [
    { id: 1, name: "Alice", age: 25 },
    { id: 2, name: "Bob", age: 17 },
    { id: 3, name: "Charlie", age: 30 }
];

const adults = users.filter(user => user.age >= 18);
console.log(adults);  // [{ id: 1, ... }, { id: 3, ... }]

// Remove null/undefined values
const values = [1, null, 2, undefined, 3, null, 4];
const clean = values.filter(v => v != null);
console.log(clean);  // [1, 2, 3, 4]
```
</UniversalEditor>

### Array.prototype.reduce

Reduces array to single value:

<UniversalEditor title="reduce Comparison">
```java !! java
// Java - Stream.reduce()
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);

int product = numbers.stream()
                     .reduce(1, (a, b) -> a * b);

// With Optional
Optional<Integer> max = numbers.stream()
                               .reduce(Integer::max);
```

```javascript !! js
// JavaScript - Array.reduce()
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum);  // 15

const product = numbers.reduce((acc, n) => acc * n, 1);
console.log(product);  // 120

// Find max
const max = numbers.reduce((acc, n) => Math.max(acc, n), -Infinity);
console.log(max);  // 5

// Group by
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

const byRole = users.reduce((acc, user) => {
    if (!acc[user.role]) {
        acc[user.role] = [];
    }
    acc[user.role].push(user);
    return acc;
}, {});

console.log(byRole);
// {
//   admin: [{ name: "Alice", ... }, { name: "Charlie", ... }],
//   user: [{ name: "Bob", ... }]
// }
```
</UniversalEditor>

### Other Array Methods

<UniversalEditor title="More Array Methods">
```java !! java
// Java - Various stream operations
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// Find first
Optional<String> first = names.stream().findFirst();

// Any match
boolean hasAlice = names.stream().anyMatch(n -> n.equals("Alice"));

// All match
boolean allLong = names.stream().allMatch(n -> n.length() > 3);

// Count
long count = names.stream().count();

// Limit
List<String> firstTwo = names.stream().limit(2).collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array methods
const names = ["Alice", "Bob", "Charlie"];

// Find first (returns element, not Optional)
const first = names[0];  // "Alice"
const firstFind = names.find(name => name.startsWith("A"));  // "Alice"

// Find index
const indexOfBob = names.indexOf("Bob");  // 1
const findIndex = names.findIndex(name => name.startsWith("B"));  // 1

// Check if exists
const hasAlice = names.includes("Alice");  // true
const hasLongName = names.some(name => name.length > 3);  // true
const allLong = names.every(name => name.length > 3);  // false

// Count
const count = names.length;  // 3

// Slice (first two)
const firstTwo = names.slice(0, 2);  // ["Alice", "Bob"]

// Flat map (ES2019)
const matrix = [[1, 2], [3, 4], [5, 6]];
const flattened = matrix.flat();  // [1, 2, 3, 4, 5, 6]

// Sort (modifies in place!)
const nums = [3, 1, 4, 1, 5];
nums.sort((a, b) => a - b);  // [1, 1, 3, 4, 5]
```
</UniversalEditor>

## Method Chaining

JavaScript array methods can be chained just like Java streams:

<UniversalEditor title="Method Chaining">
```java !! java
// Java - Stream chaining
List<Integer> result = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 2)
    .limit(5)
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript - Array method chaining
const result = numbers
    .filter(n => n % 2 === 0)
    .map(n => n * 2)
    .slice(0, 5);

// Real-world example
const users = [
    { name: "Alice", age: 25, score: 85 },
    { name: "Bob", age: 17, score: 92 },
    { name: "Charlie", age: 30, score: 78 },
    { name: "David", age: 22, score: 88 }
];

// Get names of adult users with high scores, sorted
const topAdults = users
    .filter(user => user.age >= 18)           // Filter adults
    .filter(user => user.score >= 80)         // Filter high scores
    .sort((a, b) => b.score - a.score)        // Sort by score desc
    .map(user => user.name);                  // Get names

console.log(topAdults);  // ["Bob", "David", "Alice"]

// Calculate average score
const averageScore = users
    .map(user => user.score)
    .reduce((sum, score, _, arr) => sum + score / arr.length, 0);

console.log(averageScore);  // 85.75
```
</UniversalEditor>

## Iteration Patterns

### Pattern 1: Transform and Filter

<UniversalEditor title="Transform and Filter Pattern">
```java !! java
// Java
List<String> words = Arrays.asList("hello", "world", "java", "stream");

List<String> result = words.stream()
    .filter(w -> w.length() > 4)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());
```

```javascript !! js
// JavaScript
const words = ["hello", "world", "java", "javascript"];

const result = words
    .filter(w => w.length > 4)
    .map(w => w.toUpperCase())
    .sort();

console.log(result);  // ["HELLO", "JAVASCRIPT", "WORLD"]
```
</UniversalEditor>

### Pattern 2: Find and Update

<UniversalEditor title="Find and Update Pattern">
```java !! java
// Java - Immutable approach
List<User> users = getUsers();
User updatedUser = users.stream()
    .filter(u -> u.getId() == targetId)
    .findFirst()
    .map(u -> new User(u.getId(), u.getName(), true))
    .orElse(null);
```

```javascript !! js
// JavaScript - Find and update
const users = [
    { id: 1, name: "Alice", active: false },
    { id: 2, name: "Bob", active: false }
];

const targetId = 1;
const updatedUsers = users.map(user => {
    if (user.id === targetId) {
        return { ...user, active: true };
    }
    return user;
});

console.log(updatedUsers);
// [
//   { id: 1, name: "Alice", active: true },
//   { id: 2, name: "Bob", active: false }
// ]
```
</UniversalEditor>

### Pattern 3: Reduce to Object

<UniversalEditor title="Reduce to Object Pattern">
```java !! java
// Java - Group by with Collectors.groupingBy
List<User> users = getUsers();
Map<String, List<User>> byRole = users.stream()
    .collect(Collectors.groupingBy(User::getRole));
```

```javascript !! js
// JavaScript - Group by with reduce
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

const byRole = users.reduce((acc, user) => ({
    ...acc,
    [user.role]: [...(acc[user.role] || []), user]
}), {});

console.log(byRole);
// {
//   admin: [
//     { name: "Alice", role: "admin" },
//     { name: "Charlie", role: "admin" }
//   ],
//   user: [{ name: "Bob", role: "user" }]
// }
```
</UniversalEditor>

## Performance Considerations

<UniversalEditor title="Performance: Loops vs Array Methods">
```java !! java
// Java - Streams have overhead
// For simple operations, traditional loops can be faster
List<Integer> numbers = /* large list */;

// Stream (cleaner but some overhead)
List<Integer> result = numbers.stream()
    .filter(n -> n > 0)
    .collect(Collectors.toList());

// Traditional loop (faster for simple cases)
List<Integer> result2 = new ArrayList<>();
for (Integer n : numbers) {
    if (n > 0) {
        result2.add(n);
    }
}
```

```javascript !! js
// JavaScript - Similar trade-offs
const numbers = /* large array */;

// Array methods (cleaner, similar performance)
const result = numbers.filter(n => n > 0);

// Traditional for loop (often faster)
const result2 = [];
for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] > 0) {
        result2.push(numbers[i]);
    }
}

// for...of (clean, good middle ground)
const result3 = [];
for (const n of numbers) {
    if (n > 0) {
        result3.push(n);
    }
}

// General rule:
// - Use array methods for readability (usually fast enough)
// - Use traditional loops for performance-critical code
// - Avoid forEach when you might need to break (use for...of)
```
</UniversalEditor>

## Common Pitfalls

### Pitfall 1: Using for...in on Arrays

<UniversalEditor title="for...in Pitfall">
```javascript !! js
// ❌ BAD: for...in iterates over keys, not values
const arr = [10, 20, 30];
for (const i in arr) {
    console.log(i);  // "0", "1", "2" (strings, not numbers!)
    console.log(arr[i]);  // 10, 20, 30
}

// Also iterates over inherited properties
Array.prototype.customProp = "inherited";
for (const i in arr) {
    console.log(i);  // "0", "1", "2", "customProp"
}

// ✅ GOOD: Use for...of for arrays
for (const value of arr) {
    console.log(value);  // 10, 20, 30
}

// ✅ GOOD: Use forEach for index and value
arr.forEach((value, index) => {
    console.log(`${index}: ${value}`);
});
```
</UniversalEditor>

### Pitfall 2: Modifying Array While Iterating

<UniversalEditor title="Modification During Iteration">
```javascript !! js
// ❌ BAD: Removing elements during iteration
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    if (numbers[i] % 2 === 0) {
        numbers.splice(i, 1);  // Removes element
    }
}
// Result: [1, 3, 5] but skips some elements!

// ✅ GOOD: Filter instead
const filtered = numbers.filter(n => n % 2 !== 0);
// Result: [1, 3, 5]

// ✅ GOOD: Iterate backwards if you must modify
for (let i = numbers.length - 1; i >= 0; i--) {
    if (numbers[i] % 2 === 0) {
        numbers.splice(i, 1);
    }
}
```
</UniversalEditor>

### Pitfall 3: Forgetting Return in Array Methods

<UniversalEditor title="Missing Return">
```javascript !! js
// ❌ BAD: Forgetting return
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => {
    n * 2;  // No return! Results in [undefined, undefined, ...]
});

// ✅ GOOD: Explicit return
const doubled2 = numbers.map(n => {
    return n * 2;
});

// ✅ GOOD: Implicit return (one-liner)
const doubled3 = numbers.map(n => n * 2);

// ⚠️ Watch out with curly braces
const doubled4 = numbers.map(n => { n * 2 });  // Wrong!
const doubled5 = numbers.map(n => ({ value: n * 2 }));  // Need parentheses for object
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Best Practices Summary">
```java !! java
// Java: Use streams for readability
List<String> names = Arrays.asList("alice", "bob", "charlie");

List<String> result = names.stream()
    .filter(n -> n.length() > 3)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());

// Use traditional loops for performance or when need to break
for (String name : names) {
    if (name.equals("bob")) break;
    System.out.println(name);
}
```

```javascript !! js
// JavaScript: Use array methods for readability
const names = ["alice", "bob", "charlie"];

const result = names
    .filter(n => n.length > 3)
    .map(n => n.toUpperCase())
    .sort();

// Use for...of when you need to break
for (const name of names) {
    if (name === "bob") break;
    console.log(name);
}

// Use reduce for complex aggregations
const summary = names.reduce((acc, name) => ({
    count: acc.count + 1,
    totalLength: acc.totalLength + name.length,
    avgLength: (acc.totalLength + name.length) / (acc.count + 1)
}), { count: 0, totalLength: 0, avgLength: 0 });

// Avoid forEach when you could use map/filter
// ❌ BAD
const results = [];
items.forEach(item => {
    if (item.isValid) {
        results.push(transform(item));
    }
});

// ✅ GOOD
const results = items
    .filter(item => item.isValid)
    .map(transform);
```
</UniversalEditor>

## Exercises

### Exercise 1: Array Transformation
Convert this Java code to JavaScript:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> squares = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .collect(Collectors.toList());
```

### Exercise 2: Find User
Write a function to find a user by ID:
```javascript
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
];

function findUser(users, targetId) {
    // Return the user with matching ID, or null
}
```

### Exercise 3: Reduce to Object
Group users by role:
```javascript
const users = [
    { name: "Alice", role: "admin" },
    { name: "Bob", role: "user" },
    { name: "Charlie", role: "admin" }
];

// Create object: { admin: [...], user: [...] }
```

### Exercise 4: Conditional Logic
Fix the code to use strict equality:
```javascript
function processValue(value) {
    if (value == "0") {  // Bug: uses loose equality
        return "zero";
    }
    return value;
}
```

## Summary

### Key Takeaways

1. **Conditionals:**
   - if/else works the same as Java
   - Switch uses loose equality (be careful!)
   - Ternary operator is identical
   - Short-circuit evaluation provides default values

2. **Loops:**
   - Traditional for/while/do-while are identical
   - for...of for array values (like Java's for-each)
   - for...in for object keys (NOT arrays!)
   - break and continue work the same

3. **Array Methods:**
   - forEach: Iterate (can't break)
   - map: Transform to new array
   - filter: Select elements
   - reduce: Aggregate to single value
   - find/findIndex: Search elements
   - some/every: Test conditions

4. **Method Chaining:**
   - Array methods can be chained
   - Similar to Java streams
   - More readable than nested loops

5. **Best Practices:**
   - Use for...of for iteration (can break)
   - Use array methods for transformations
   - Avoid for...in on arrays
   - Don't modify arrays while iterating

## What's Next?

You've mastered control flow and iteration! Next up is **Module 3: Functions**, where we'll explore JavaScript's powerful function features:

- Function declarations vs expressions
- Arrow functions
- Closures
- Higher-order functions
- Default parameters
- Rest and spread parameters
- The `this` keyword in functions

Ready to dive deeper into JavaScript functions? Let's go!
