---
title: "Module 3: Functions Basics"
description: "Learn JavaScript function declarations, expressions, arrow functions, and core concepts"
---

## Module 3: Functions Basics

Welcome to one of the most important modules! Functions in JavaScript are far more powerful and flexible than methods in Java. Understanding functions deeply is crucial to becoming an effective JavaScript developer.

## Learning Objectives

By the end of this module, you will:
✅ Understand function declarations vs expressions
✅ Master arrow functions (ES6+)
✅ Learn about default parameters
✅ Understand rest and spread parameters
✅ Know the difference between parameters and arguments
✅ Learn about function hoisting

## Function Basics: Java vs JavaScript

In Java, methods are always attached to classes. In JavaScript, functions are first-class citizens - they can exist independently, be assigned to variables, passed as arguments, and returned from other functions.

<UniversalEditor title="Function Declaration Comparison">
```java !! java
// Java - Methods are class members
public class Calculator {

    // Method declaration
    public int add(int a, int b) {
        return a + b;
    }

    // Method overloading
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Main method
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        int result = calc.add(5, 3);
        System.out.println(result);  // 8
    }
}
```

```javascript !! js
// JavaScript - Functions can exist independently
// Function declaration
function add(a, b) {
    return a + b;
}

// Call the function
const result = add(5, 3);
console.log(result);  // 8

// Can be assigned to variable
const multiply = function(a, b) {
    return a * b;
};

// Arrow function (ES6+)
const subtract = (a, b) => a - b;

// All of these are valid
console.log(add(2, 3));        // 5
console.log(multiply(2, 3));   // 6
console.log(subtract(5, 2));   // 3
```
</UniversalEditor>

## Function Declarations

Function declarations are similar to Java methods but don't require a class:

<UniversalEditor title="Function Declaration Syntax">
```java !! java
// Java - Method inside class
public class Utils {
    public static int calculate(int x, int y) {
        return x + y;
    }

    // Instance method
    public String format(String text) {
        return text.toUpperCase();
    }
}

// Calling
Utils.calculate(5, 3);
Utils utils = new Utils();
utils.format("hello");
```

```javascript !! js
// JavaScript - Standalone functions
function calculate(x, y) {
    return x + y;
}

// Can be called before declaration (hoisting)
console.log(add(5, 3));  // 8 - Works!

function add(a, b) {
    return a + b;
}

// No public/private modifiers (yet - ES2022 has #)
function privateFunction() {
    return "private";
}

// Naming convention: camelCase
function getUserById(id) {
    // ... implementation
}

function calculateTotalPrice(items, taxRate) {
    // ... implementation
}
```
</UniversalEditor>

### Function Hoisting

Function declarations are "hoisted" - they can be called before they're defined:

<UniversalEditor title="Function Hoisting">
```java !! java
// Java - No hoisting
public class Example {
    public static void main(String[] args) {
        greet();  // Compilation error! Method not defined yet
    }

    public static void greet() {
        System.out.println("Hello!");
    }
}
```

```javascript !! js
// JavaScript - Hoisting works for declarations
greet();  // "Hello!" - Works because of hoisting

function greet() {
    console.log("Hello!");
}

// Hoisting doesn't work for expressions
greet2();  // TypeError: greet2 is not a function

const greet2 = function() {
    console.log("Hello 2!");
};

// What actually happens:
// 1. Declaration is hoisted
function greet() {
    console.log("Hello!");
}
// 2. Assignment stays in place
// (greet2 is undefined until the assignment)
```
</UniversalEditor>

## Function Expressions

JavaScript allows functions to be assigned to variables:

<UniversalEditor title="Function Expressions">
```java !! java
// Java - Lambda expressions (Java 8+)
interface Operation {
    int apply(int a, int b);
}

public class Calculator {
    public static void main(String[] args) {
        Operation add = (a, b) -> a + b;
        Operation multiply = (a, b) -> a * b;

        System.out.println(add.apply(5, 3));       // 8
        System.out.println(multiply.apply(5, 3));  // 15
    }
}
```

```javascript !! js
// JavaScript - Function expressions
const add = function(a, b) {
    return a + b;
};

const multiply = function(a, b) {
    return a * b;
};

console.log(add(5, 3));       // 8
console.log(multiply(5, 3));  // 15

// Anonymous function (no name)
setTimeout(function() {
    console.log("Delayed execution");
}, 1000);

// Named function expression (better for debugging)
const divide = function divideNumbers(a, b) {
    if (b === 0) {
        throw new Error("Cannot divide by zero");
    }
    return a / b;
};

// The name is only visible inside the function
console.log(divide(10, 2));  // 5
// console.log(divideNumbers(10, 2));  // ReferenceError
```
</UniversalEditor>

## Arrow Functions

Arrow functions (introduced in ES6) are a concise way to write functions:

<UniversalEditor title="Arrow Functions">
```java !! java
// Java - Lambda expressions
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Single expression
numbers.stream()
    .map(n -> n * 2)
    .forEach(System.out::println);

// Multiple statements (need braces)
numbers.stream()
    .map(n -> {
        int doubled = n * 2;
        return doubled + 1;
    })
    .forEach(System.out::println);
```

```javascript !! js
// JavaScript - Arrow functions
const numbers = [1, 2, 3, 4, 5];

// Single expression (implicit return)
const doubled = numbers.map(n => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

// Multiple parameters (need parentheses)
const sum = numbers.reduce((a, b) => a + b, 0);

// No parameters (need parentheses)
const getRandom = () => Math.random();

// Multiple statements (need braces and explicit return)
const processed = numbers.map(n => {
    const doubled = n * 2;
    return doubled + 1;
});

// Returning object literals (need parentheses)
const createUser = name => ({ name, id: Date.now() });
const user = createUser("John");
console.log(user);  // { name: "John", id: 1234567890 }

// Arrow functions are anonymous
// Use variable name for identification
const add = (a, b) => a + b;
```
</UniversalEditor>

### Arrow Function Limitations

Arrow functions are not always appropriate. They differ from regular functions in important ways:

<UniversalEditor title="Arrow Function Limitations">
```java !! java
// Java - 'this' refers to the object
public class Counter {
    private int count = 0;

    public Runnable getIncrementer() {
        return () -> {
            this.count++;  // 'this' refers to Counter instance
            System.out.println(this.count);
        };
    }
}
```

```javascript !! js
// JavaScript - Arrow functions lexically bind 'this'
const counter = {
    count: 0,
    increment: function() {
        console.log(this.count);  // 'this' refers to counter
    },

    // Arrow function as method (NOT recommended)
    incrementBad: () => {
        console.log(this.count);  // 'this' is not counter!
        // 'this' is lexically bound from surrounding scope
    }
};

counter.increment();      // 0 (correct)
counter.incrementBad();   // undefined (wrong!)

// Correct usage: callback functions
const timer = {
    seconds: 0,
    start: function() {
        // Regular function would lose 'this'
        // setInterval(function() {
        //     this.seconds++;  // Error: 'this' is not timer
        // }, 1000);

        // Arrow function preserves 'this'
        setInterval(() => {
            this.seconds++;
            console.log(this.seconds);
        }, 1000);
    }
};

timer.start();  // Works correctly!
```
</UniversalEditor>

## Default Parameters

JavaScript supports default parameter values:

<UniversalEditor title="Default Parameters">
```java !! java
// Java - Method overloading
public class Greeter {
    public void greet(String name) {
        greet(name, "Hello");
    }

    public void greet(String name, String greeting) {
        System.out.println(greeting + ", " + name);
    }

    // Or use null checks
    public void greet2(String name, String greeting) {
        if (greeting == null) {
            greeting = "Hello";
        }
        System.out.println(greeting + ", " + name);
    }
}
```

```javascript !! js
// JavaScript - Default parameters
function greet(name, greeting = "Hello") {
    console.log(`${greeting}, ${name}`);
}

greet("John");           // "Hello, John"
greet("Jane", "Hi");     // "Hi, Jane"

// Default with undefined
greet("Bob", undefined); // "Hello, Bob" (uses default)
greet("Alice", null);    // "null, Alice" (null is a value!)

// Expressions as defaults
function createUser(name, role = "user", createdAt = Date.now()) {
    return { name, role, createdAt };
}

const user1 = createUser("John");
console.log(user1);  // { name: "John", role: "user", createdAt: 1234567890 }

const user2 = createUser("Jane", "admin");
console.log(user2);  // { name: "Jane", role: "admin", createdAt: 1234567890 }

// Default can reference previous parameters
function createArray(size, defaultValue = 0) {
    return Array(size).fill(defaultValue);
}

console.log(createArray(5));         // [0, 0, 0, 0, 0]
console.log(createArray(3, "x"));    // ["x", "x", "x"]
```
</UniversalEditor>

## Rest Parameters

Rest parameters allow functions to accept indefinite number of arguments:

<UniversalEditor title="Rest Parameters">
```java !! java
// Java - Varargs
public class Sum {
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    public static void main(String[] args) {
        Sum s = new Sum();
        System.out.println(s.sum(1, 2, 3));        // 6
        System.out.println(s.sum(1, 2, 3, 4, 5));  // 15
    }
}
```

```javascript !! js
// JavaScript - Rest parameters
function sum(...numbers) {
    return numbers.reduce((total, n) => total + n, 0);
}

console.log(sum(1, 2, 3));        // 6
console.log(sum(1, 2, 3, 4, 5));  // 15
console.log(sum());               // 0

// Rest parameter must be last
function log(message, ...args) {
    console.log(message, args);
}

log("Values:", 1, 2, 3);  // "Values:" [1, 2, 3]

// Destructuring with rest
function getUserInfo(firstName, lastName, ...details) {
    return {
        name: `${firstName} ${lastName}`,
        details
    };
}

const info = getUserInfo("John", "Doe", "Engineer", "NYC", 30);
console.log(info);
// {
//   name: "John Doe",
//   details: ["Engineer", "NYC", 30]
// }

// Arrow functions with rest
const multiply = (multiplier, ...numbers) => {
    return numbers.map(n => n * multiplier);
};

console.log(multiply(2, 1, 2, 3));  // [2, 4, 6]
```
</UniversalEditor>

## Spread Operator

The spread operator expands arrays/objects into individual elements:

<UniversalEditor title="Spread Operator">
```java !! java
// Java - Arrays can't be easily spread
int[] arr1 = {1, 2, 3};
int[] arr2 = {4, 5, 6};
// Need manual copying or System.arraycopy

// Java varargs for method calls
public void printAll(String... messages) {
    for (String msg : messages) {
        System.out.println(msg);
    }
}

printAll("Hello", "World");  // Works
// Can't easily spread an existing array
```

```javascript !! js
// JavaScript - Spread operator
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// Combine arrays
const combined = [...arr1, ...arr2];
console.log(combined);  // [1, 2, 3, 4, 5, 6]

// Add elements
const withExtra = [0, ...arr1, 4, ...arr2, 7];
console.log(withExtra);  // [0, 1, 2, 3, 4, 4, 5, 6, 7]

// Copy array
const copy = [...arr1];

// Spread in function calls
const numbers = [1, 2, 3, 4, 5];
console.log(Math.max(...numbers));  // 5
console.log(Math.min(...numbers));  // 1

// Spread with strings
const chars = [..."hello"];
console.log(chars);  // ["h", "e", "l", "l", "o"]

// Spread objects
const user = { name: "John", age: 25 };
const enhanced = { ...user, role: "admin" };
console.log(enhanced);  // { name: "John", age: 25, role: "admin" }

// Override properties
const updated = { ...user, age: 26 };
console.log(updated);  // { name: "John", age: 26 }

// Merge objects
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const merged = { ...obj1, ...obj2 };
console.log(merged);  // { a: 1, b: 2, c: 3, d: 4 }
```
</UniversalEditor>

## Parameters vs Arguments

<UniversalEditor title="Parameters vs Arguments">
```java !! java
// Java - Parameters (in declaration)
public int add(int a, int b) {  // a and b are parameters
    return a + b;
}

// Arguments (in call)
int result = add(5, 3);  // 5 and 3 are arguments
```

```javascript !! js
// JavaScript - Same concept, but more flexible
function add(a, b) {  // a and b are parameters
    console.log(a);  // undefined if argument not provided
    console.log(b);  // undefined if argument not provided
    return a + b;
}

add(5, 3);  // 5 and 3 are arguments
add(5);     // Only 5 is provided, b is undefined
add(5, 3, 7);  // 7 is ignored (no error!)

// Access all arguments (old way)
function sumAll() {
    // arguments is array-like object
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
        total += arguments[i];
    }
    return total;
}

console.log(sumAll(1, 2, 3, 4, 5));  // 15

// Modern way: rest parameters
function sumAllModern(...numbers) {
    return numbers.reduce((sum, n) => sum + n, 0);
}

console.log(sumAllModern(1, 2, 3, 4, 5));  // 15
```
</UniversalEditor>

## Return Values

<UniversalEditor title="Return Values">
```java !! java
// Java - Must declare return type
public int add(int a, int b) {
    return a + b;
}

// Void return type
public void print(String message) {
    System.out.println(message);
    // No return needed
}

// All paths must return value
public int max(int a, int b) {
    if (a > b) {
        return a;
    }
    // Error: Missing return statement
}
```

```javascript !! js
// JavaScript - No return type declaration
function add(a, b) {
    return a + b;
}

// No return = undefined
function print(message) {
    console.log(message);
    // Returns undefined implicitly
}

const result = print("Hello");
console.log(result);  // undefined

// Early returns
function max(a, b) {
    if (a > b) {
        return a;
    }
    return b;
}

// Conditional return
function getDiscount(amount) {
    if (amount > 1000) {
        return 0.2;  // 20% discount
    }
    if (amount > 500) {
        return 0.1;  // 10% discount
    }
    return 0;  // No discount
}

// Multiple return values (via array or object)
function getMinMax(numbers) {
    return {
        min: Math.min(...numbers),
        max: Math.max(...numbers)
    };
}

const { min, max } = getMinMax([1, 5, 3, 9, 2]);
console.log(min, max);  // 1 9
```
</UniversalEditor>

## First-Class Functions

Functions are first-class citizens - they can be:

1. Assigned to variables
2. Passed as arguments
3. Returned from other functions
4. Stored in data structures

<UniversalEditor title="First-Class Functions">
```java !! java
// Java - Limited support
interface Operation {
    int apply(int a, int b);
}

public class Calculator {
    public int calculate(Operation op, int a, int b) {
        return op.apply(a, b);
    }

    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // Pass lambda as argument
        int result = calc.calculate((x, y) -> x + y, 5, 3);
        System.out.println(result);  // 8
    }
}
```

```javascript !! js
// JavaScript - Full first-class function support

// 1. Assigned to variables
const greet = function(name) {
    return `Hello, ${name}`;
};

// 2. Passed as arguments
function applyOperation(a, b, operation) {
    return operation(a, b);
}

const sum = (x, y) => x + y;
const difference = (x, y) => x - y;

console.log(applyOperation(10, 5, sum));         // 15
console.log(applyOperation(10, 5, difference));  // 5

// 3. Returned from functions
function createMultiplier(multiplier) {
    return function(number) {
        return number * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5));  // 10
console.log(triple(5));  // 15

// 4. Stored in data structures
const operations = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => a / b
};

console.log(operations.add(5, 3));        // 8
console.log(operations.multiply(4, 3));   // 12

// Array of functions
const transformers = [
    x => x * 2,
    x => x + 10,
    x => x * x
];

const value = 5;
const results = transformers.map(fn => fn(value));
console.log(results);  // [10, 15, 25]
```
</UniversalEditor>

## Common Patterns

### Pattern 1: Function Factory

<UniversalEditor title="Function Factory Pattern">
```java !! java
// Java - Not easily possible
// Would need classes and interfaces
```

```javascript !! js
// JavaScript - Function factory
function createValidator(regex) {
    return function(value) {
        return regex.test(value);
    };
}

const isEmail = createValidator /^[^\s@]+@[^\s@]+\.[^\s@]+$/);
const isPhone = createValidator(/^\d{3}-\d{3}-\d{4}$/);

console.log(isEmail("test@example.com"));  // true
console.log(isPhone("123-456-7890"));      // true

// Practical example: API client creator
function createApiClient(baseUrl) {
    return async function(endpoint, options = {}) {
        const response = await fetch(`${baseUrl}${endpoint}`, options);
        return response.json();
    };
}

const api = createApiClient("https://api.example.com");
const users = await api("/users");
const posts = await api("/posts");
```
</UniversalEditor>

### Pattern 2: Configuration Object

<UniversalEditor title="Configuration Object Pattern">
```java !! java
// Java - Builder pattern
public class Request {
    private String url;
    private String method = "GET";
    private Map<String, String> headers = new HashMap<>();

    public static class Builder {
        // Builder implementation
    }
}

Request request = new Request.Builder()
    .url("https://api.example.com")
    .method("POST")
    .build();
```

```javascript !! js
// JavaScript - Configuration object with defaults
function makeRequest(url, options = {}) {
    const defaults = {
        method: "GET",
        headers: {
            "Content-Type": "application/json"
        },
        body: null
    };

    const config = { ...defaults, ...options };

    return fetch(url, config);
}

// Usage
makeRequest("https://api.example.com/users", {
    method: "POST",
    body: JSON.stringify({ name: "John" })
});

// Destructured parameters
function createUser({ name, email, role = "user", active = true }) {
    return { name, email, role, active };
}

const user = createUser({
    name: "John",
    email: "john@example.com"
    // role and active use defaults
});
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Function Best Practices">
```java !! java
// Java: Clear method signatures
public class UserService {
    private UserRepository repository;

    public UserService(UserRepository repository) {
        this.repository = repository;
    }

    public Optional<User> findById(Long id) {
        return repository.findById(id);
    }

    public List<User> findActiveUsers() {
        return repository.findAll()
                        .stream()
                        .filter(User::isActive)
                        .collect(Collectors.toList());
    }
}
```

```javascript !! js
// JavaScript: Similar principles

// 1. Use descriptive names
function calculateMonthlyPayment(principal, rate, months) {
    // Good
}

function calc(p, r, m) {
    // Bad - not descriptive
}

// 2. Keep functions small and focused
function validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

function validatePassword(password) {
    return password.length >= 8;
}

// Instead of one big function
function validateCredentials(email, password) {
    // Validates everything
}

// 3. Use default parameters for optional arguments
function fetchUsers(options = {}) {
    const {
        limit = 10,
        offset = 0,
        active = true
    } = options;

    // Implementation
}

// 4. Prefer arrow functions for callbacks
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);

// 5. Use regular functions for methods
const calculator = {
    add: function(a, b) {
        return a + b;
    },

    // Or use shorthand (still has correct 'this')
    subtract(a, b) {
        return a - b;
    }
};

// 6. Return early to reduce nesting
function processUser(user) {
    if (!user) {
        return null;
    }

    if (!user.isActive) {
        return null;
    }

    if (!user.email) {
        return null;
    }

    // Main logic
    return transformUser(user);
}
```
</UniversalEditor>

## Common Pitfalls

### Pitfall 1: Forgetting Return in Arrow Functions

<UniversalEditor title="Missing Return">
```javascript !! js
// ❌ BAD: Implicit return with curly braces
const doubled = [1, 2, 3].map(n => {
    n * 2;
});
// Result: [undefined, undefined, undefined]

// ✅ GOOD: Either use explicit return
const doubled2 = [1, 2, 3].map(n => {
    return n * 2;
});

// ✅ GOOD: Or remove curly braces for implicit return
const doubled3 = [1, 2, 3].map(n => n * 2);

// ⚠️ Need parentheses for object literals
const users = ["alice", "bob"].map(name => ({ name }));
// Correct: ({ name }) creates object

// Without parentheses:
const bad = ["alice"].map(name => { name });
// Result: [undefined] - { name } is a code block, not object
```
</UniversalEditor>

### Pitfall 2: Using Arrow Functions for Methods

<UniversalEditor title="Arrow Function as Method">
```javascript !! js
// ❌ BAD: Arrow function doesn't have own 'this'
const counter = {
    count: 0,
    increment: () => {
        this.count++;  // 'this' is not counter!
    }
};

// ✅ GOOD: Use regular function or shorthand
const counter2 = {
    count: 0,
    increment: function() {
        this.count++;  // 'this' is counter2
    },

    // Or shorthand (same as function)
    decrement() {
        this.count--;  // 'this' is counter2
    }
};
```
</UniversalEditor>

### Pitfall 3: Mutable Default Parameters

<UniversalEditor title="Mutable Default Parameters">
```javascript !! js
// ❌ BAD: Mutable default is shared across calls
function addItem(item, list = []) {
    list.push(item);
    return list;
}

const list1 = addItem("a");  // ["a"]
const list2 = addItem("b");  // ["a", "b"] - Not a new array!

// ✅ GOOD: Create new array in function body
function addItemSafe(item, list) {
    const items = list ? [...list] : [];
    items.push(item);
    return items;
}

// Or use null check
function addItemSafe2(item, list) {
    if (!list) list = [];
    return [...list, item];
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Convert to Arrow Functions
Convert these functions to arrow functions:
```javascript
function add(a, b) {
    return a + b;
}

function square(x) {
    return x * x;
}

function greet(name) {
    return "Hello, " + name;
}
```

### Exercise 2: Default Parameters
Add default parameters:
```javascript
function createUser(name, email, role) {
    return { name, email, role };
}

// role should default to "user"
// email should default to empty string
```

### Exercise 3: Rest Parameters
Create a function that calculates average:
```javascript
function average(/* numbers */) {
    // Accept any number of arguments
    // Return the average
}

average(1, 2, 3, 4, 5);  // 3
average(10, 20);        // 15
```

### Exercise 4: Function Factory
Create a function that returns a function:
```javascript
function createGreeter(greeting) {
    // Return a function that greets with the specified greeting
}

const sayHello = createGreeter("Hello");
const sayHi = createGreeter("Hi");

sayHello("John");  // "Hello, John"
sayHi("Jane");     // "Hi, Jane"
```

## Summary

### Key Takeaways

1. **Function Declarations:**
   - Hoisted (can call before definition)
   - Traditional function syntax
   - Good for standalone functions

2. **Function Expressions:**
   - Not hoisted
   - Assigned to variables
   - Good for callbacks and closures

3. **Arrow Functions:**
   - Concise syntax
   - Lexical `this` binding
   - Perfect for callbacks
   - Not suitable for methods

4. **Default Parameters:**
   - Provide default values
   - Can be expressions
   - Only triggered by `undefined`, not `null`

5. **Rest/Spread:**
   - Rest: Collect arguments into array
   - Spread: Expand array/object into elements
   - Powerful for manipulation

6. **First-Class Functions:**
   - Can be assigned, passed, returned
   - Enable higher-order functions
   - Support functional programming

### Comparison Table: Java vs JavaScript

| Feature | Java | JavaScript |
|---------|------|------------|
| **Declaration** | Inside classes only | Can be standalone |
| **Hoisting** | No | Yes (declarations only) |
| **Overloading** | Yes (multiple signatures) | No (use default params or rest) |
| **Return type** | Must declare | No declaration needed |
| **Default params** | Via overloading | Built-in support |
| **Varargs** | `Type...` | `...args` (rest) |
| **Lambda** | `() -> expression` | `() => expression` |
| **This binding** | Always instance | Depends on call site (arrow: lexical) |

## What's Next?

You've learned the basics of JavaScript functions! In **Module 4: Functions Advanced**, we'll explore:

- Closures and lexical scope
- Higher-order functions
- Currying and partial application
- Memoization
- Recursion in JavaScript
- The `arguments` object
- Function properties and methods

Ready to level up your function skills? Let's continue!
