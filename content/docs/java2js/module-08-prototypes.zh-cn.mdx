---
title: "模块 8: 原型和原型链"
description: "理解 JavaScript 的原型系统及其如何实现继承"
---

## 模块 8: 原型和原型链

现在你已经了解了 ES6 类,让我们深入了解 JavaScript 的实际工作原理。类是 JavaScript 基于原型的继承系统之上的语法糖。理解原型对于高级 JavaScript 开发至关重要。

## 学习目标

完成本模块后,你将:
✅ 理解什么是原型
✅ 掌握原型链查找
✅ 学习 Object.create() 和原型继承
✅ 理解构造函数
✅ 了解类和原型之间的关系
✅ 学习何时使用原型 vs 类

## 原型 vs 类

Java 使用基于类的继承,而 JavaScript 使用基于原型的继承:

<UniversalEditor title="继承模型">
```java !! java
// Java - 基于类的继承
public class Animal {
    public void speak() {
        System.out.println("Some sound");
    }
}

public class Dog extends Animal {
    @Override
    public void speak() {
        System.out.println("Woof!");
    }
}

// 实例方法在类中定义
// 每个实例有相同的方法
Animal animal = new Dog();
animal.speak();  // "Woof!"
```

```javascript !! js
// JavaScript - 基于原型的继承
// 对象直接继承自其他对象

const animal = {
    speak() {
        console.log("Some sound");
    }
};

const dog = Object.create(animal);
dog.speak = function() {
    console.log("Woof!");
};

dog.speak();  // "Woof!"
// 但仍可以通过原型访问 animal 的方法
delete dog.speak;
dog.speak();  // "Some sound" (来自原型!)

// 类只是原型的语法糖
class Animal2 {
    speak() {
        console.log("Some sound");
    }
}

class Dog2 extends Animal2 {
    speak() {
        console.log("Woof!");
    }
}

const dog2 = new Dog2();
console.log(Object.getPrototypeOf(dog2) === Dog2.prototype);  // true
console.log(Object.getPrototypeOf(Dog2.prototype) === Animal2.prototype);  // true
```
</UniversalEditor>

## 原型链

每个对象都有一个指向另一个对象的内部链接,称为其原型。这形成了一个链:

<UniversalEditor title="原型链">
```java !! java
// Java - 类层次结构
Object -> Animal -> Dog

// 方法查找: 检查类,然后父类
Dog dog = new Dog();
// dog.toString() 查找 Dog,然后 Animal,然后 Object
```

```javascript !! js
// JavaScript - 原型链
const grandParent = {
    name: "GrandParent",
    greet() {
        console.log(`Hello from ${this.name}`);
    }
};

const parent = Object.create(grandParent);
parent.name = "Parent";

const child = Object.create(parent);
child.name = "Child";

// 查找沿链向上
child.greet();  // "Hello from Child"
// 1. 检查 child - 有 name 属性
// 2. 在 child 中查找 greet() - 未找到
// 3. 检查 parent - 没有 greet()
// 4. 检查 grandParent - 找到 greet()!

console.log(child.hasOwnProperty("name"));  // true
console.log(child.hasOwnProperty("greet")); // false (继承)

// 完整原型链
console.log(Object.getPrototypeOf(child) === parent);              // true
console.log(Object.getPrototypeOf(parent) === grandParent);        // true
console.log(Object.getPrototypeOf(grandParent) === Object.prototype); // true
console.log(Object.getPrototypeOf(Object.prototype) === null);     // true (链的末尾)

// 使用 hasOwnProperty 进行属性查找
for (let key in child) {
    console.log(key, child.hasOwnProperty(key));
    // name true (自有属性)
    // greet false (继承)
}
```
</UniversalEditor>

## Object.create()

Object.create() 创建一个具有指定原型的新对象:

<UniversalEditor title="Object.create()">
```java !! java
// Java - 继承需要类
public class Animal {
    public void speak() {
        System.out.println("Sound");
    }
}

public class Dog extends Animal {
    // Dog 继承自 Animal
}
```

```javascript !! js
// JavaScript - 直接对象继承

// 创建具有特定原型的对象
const animal = {
    speak() {
        console.log("Some sound");
    }
};

const dog = Object.create(animal);
dog.bark = function() {
    console.log("Woof!");
};

dog.speak();  // "Some sound" (来自原型)
dog.bark();   // "Woof!" (自有属性)

console.log(Object.getPrototypeOf(dog) === animal);  // true

// 创建 null 原型(无继承方法)
const empty = Object.create(null);
empty.toString();  // TypeError! (无 Object.prototype 方法)

// Object.create 与属性描述符
const person = Object.create(Object.prototype, {
    name: {
        value: "John",
        writable: true,
        enumerable: true,
        configurable: true
    },
    age: {
        value: 25,
        writable: true
    }
});

console.log(person.name);  // "John"

// 实际: 创建具有默认方法的对象
const withLogging = {
    log(method) {
        return function(...args) {
            console.log(`Calling ${method} with:`, args);
            const result = this[method](...args);
            console.log(`Result:`, result);
            return result;
        };
    }
};

const calculator = Object.create(withLogging);
calculator.add = function(a, b) {
    return a + b;
};

calculator.multiply = function(a, b) {
    return a * b;
};

calculator.log("add")(5, 3);  // 记录日志然后返回 8
```
</UniversalEditor>

## 构造函数

在 ES6 类之前,JavaScript 使用构造函数:

<UniversalEditor title="构造函数">
```java !! java
// Java - 类构造函数
public class User {
    private String name;

    public User(String name) {
        this.name = name;
    }
}

User user = new User("John");
```

```javascript !! js
// JavaScript - 构造函数 (ES6 之前)

function User(name) {
    this.name = name;
}

// 方法添加到原型
User.prototype.greet = function() {
    console.log(`Hello, I'm ${this.name}`);
};

User.prototype.getAge = function() {
    return this.age;
};

// 使用 'new' 创建实例
const user = new User("John");
user.greet();  // "Hello, I'm John"

// 'new' 做什么:
// 1. 创建新对象
// 2. 设置对象的 __proto__ 为构造函数的 prototype
// 3. 用 'this' = 新对象执行构造函数
// 4. 返回新对象(或显式返回)

// 手动等效的 'new'
function createFromConstructor(Constructor, ...args) {
    const obj = Object.create(Constructor.prototype);
    const result = Constructor.apply(obj, args);
    return result instanceof Object ? result : obj;
}

const user2 = createFromConstructor(User, "Jane");
user2.greet();  // "Hello, I'm Jane"

// 检查实例
console.log(user instanceof User);  // true
console.log(user instanceof Object);  // true

// 构造函数属性
console.log(User.prototype.constructor === User);  // true
console.log(user.constructor === User);  // true

// 箭头函数不能是构造函数
const BadUser = (name) => {
    this.name = name;
};

// const bad = new BadUser("John");  // TypeError!
```
</UniversalEditor>

## 原型属性 vs 实例属性

<UniversalEditor title="属性放置">
```java !! java
// Java - 实例方法(所有实例相同)
public class User {
    public void greet() {
        // 所有 User 实例的相同方法
    }
}

// 静态方法(类级别)
public static User create(String name) {
    return new User(name);
}
```

```javascript ^^ js
// JavaScript - 原型 vs 实例

// 原型上的方法(共享)
function User(name) {
    this.name = name;  // 实例属性(每个实例唯一)
}

// 原型属性(共享)
User.prototype.species = "Homo sapiens";

// 原型方法(共享)
User.prototype.greet = function() {
    console.log(`Hi, I'm ${this.name}`);
};

const user1 = new User("John");
const user2 = new User("Jane");

console.log(user1.greet === user2.greet);  // true (相同函数)
console.log(user1.species === user2.species);  // true

// 覆盖原型属性
user1.species = "Alien";
console.log(user1.species);  // "Alien" (实例属性)
console.log(user2.species);  // "Homo sapiens" (原型)

// 删除以再次显示原型
delete user1.species;
console.log(user1.species);  // "Homo sapiens" (来自原型)

// 何时使用原型 vs 实例:
// - 方法: 原型(共享)
// - 实例数据: 构造函数(唯一)
// - 类常量: 原型或静态

// 现代等效的类
class User2 {
    static species = "Homo sapiens";  // 静态(类级别)

    constructor(name) {
        this.name = name;  // 实例
    }

    greet() {  // 原型(共享)
        console.log(`Hi, I'm ${this.name}`);
    }
}
```
</UniversalEditor>

## 修改原型

即使在创建对象之后,你也可以修改原型:

<UniversalEditor title="原型修改">
```java !! java
// Java - 不能在运行时修改类
// (除非使用字节码操作)
```

```javascript !! js
// JavaScript - 原型是可修改的

const arr = [1, 2, 3];
// arr.sum() 不存在

// 添加方法到 Array 原型
Array.prototype.sum = function() {
    return this.reduce((a, b) => a + b, 0);
};

console.log(arr.sum());  // 6

// 现在所有数组都有 sum()
const arr2 = [4, 5, 6];
console.log(arr2.sum());  // 15

// ⚠️ 修改内置原型要小心!
// 可能破坏代码或导致冲突

// 更好: 创建自己的类
class MyArray extends Array {
    sum() {
        return this.reduce((a, b) => a + b, 0);
    }
}

const myArr = new MyArray(1, 2, 3);
console.log(myArr.sum());  // 6

// Polyfill 示例(添加缺失的方法)
if (!Array.prototype.first) {
    Array.prototype.first = function() {
        return this[0];
    };
}

if (!String.prototype.capitalize) {
    String.prototype.capitalize = function() {
        return this.charAt(0).toUpperCase() + this.slice(1);
    };
}

console.log("hello".capitalize());  // "Hello"
```
</UniversalEditor>

## 原型继承模式

### 模式 1: 原型委托

<UniversalEditor title="原型委托">
```javascript !! js
// 简单原型链
const animal = {
    init(name) {
        this.name = name;
    },
    speak() {
        console.log(`${this.name} makes a sound`);
    }
};

const dog = Object.create(animal);
dog.bark = function() {
    console.log(`${this.name} barks`);
};

const myDog = Object.create(dog);
myDog.init("Buddy");

myDog.speak();  // "Buddy makes a sound" (来自 animal)
myDog.bark();   // "Buddy barks" (来自 dog)

console.log(myDog instanceof Object);  // true
// 无法在没有构造函数的原型链中检查 instanceof
```
</UniversalEditor>

### 模式 2: 构造函数继承

<UniversalEditor title="构造函数继承">
```javascript !! js
// 父构造函数
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function() {
    console.log(`${this.name} makes a sound`);
};

// 子构造函数
function Dog(name, breed) {
    Animal.call(this, name);  // 调用父构造函数
    this.breed = breed;
}

// 继承原型
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;  // 修复构造函数

// 添加子方法
Dog.prototype.bark = function() {
    console.log(`${this.name} barks`);
};

// 重写父方法
Dog.prototype.speak = function() {
    Animal.prototype.speak.call(this);  // 调用父类
    this.bark();
};

const dog = new Dog("Buddy", "Labrador");
dog.speak();  // "Buddy makes a sound" 然后 "Buddy barks"

console.log(dog instanceof Dog);     // true
console.log(dog instanceof Animal);  // true

// 现代等效(类更简单!)
class Animal2 {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog2 extends Animal2 {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    bark() {
        console.log(`${this.name} barks`);
    }
    speak() {
        super.speak();
        this.bark();
    }
}
```
</UniversalEditor>

### 模式 3: 函数式继承

<UniversalEditor title="函数式继承">
```java !! java
// Java - 组合优于继承
interface Flyable {
    void fly();
}

class Bird implements Flyable {
    public void fly() {
        System.out.println("Flying");
    }
}

class Bat implements Flyable {
    public void fly() {
        System.out.println("Flying");
    }
}
```

```javascript ^^ js
// JavaScript - 使用原型的 Mixin

const Flyable = {
    fly() {
        console.log("Flying!");
    }
};

const Swimmable = {
    swim() {
        console.log("Swimming!");
    }
};

function Duck(name) {
    this.name = name;
}

// 混合功能
Object.assign(Duck.prototype, Flyable, Swimmable);

const duck = new Duck("Donald");
duck.fly();   // "Flying!"
duck.swim();  // "Swimming!"

// 或使用 Object.create 与多个原型
const flyingSwimmer = Object.assign(
    Object.create(Object.prototype),
    Flyable,
    Swimmable
);

const duck2 = Object.create(flyingSwimmer);
duck2.name = "Daisy";
duck2.fly();   // "Flying!"
```
</UniversalEditor>

## 原型 vs 类

<UniversalEditor title="原型 vs 类">
```javascript !! js
// 原型(灵活,动态)
const animal = {
    speak() {
        console.log("Sound");
    }
};

const dog = Object.create(animal);

// 可以随时修改原型
animal.speak = function() {
    console.log("Loud sound");
};

dog.speak();  // "Loud sound" (反映原型变化)

// 类(结构化,熟悉)
class Animal2 {
    speak() {
        console.log("Sound");
    }
}

class Dog2 extends Animal2 {
    // 创建后不能轻易修改 Animal2.prototype
    // 最好使用继承或重写方法
}

// 何时使用:

// 原型用于:
// - 需要动态修改
// - 创建简单对象层次结构
// - 想要内存效率(共享方法)
// - 不需要 'new' 操作符

const utils = {
    log(msg) {
        console.log(msg);
    },
    warn(msg) {
        console.warn(msg);
    }
};

// 类用于:
// - 需要构造函数逻辑
// - 想要熟悉的 OOP 结构
// - 需要 instanceof 检查
// - 构建复杂应用

class UserService {
    constructor(apiUrl) {
        this.apiUrl = apiUrl;
    }

    async getUser(id) {
        const response = await fetch(`${this.apiUrl}/users/${id}`);
        return response.json();
    }
}
```
</UniversalEditor>

## 性能考虑

<UniversalEditor title="原型性能">
```javascript !! js
// 原型查找有成本
const obj = {
    a: 1,
    b: 2,
    c: 3
};

// 直接属性访问(快)
console.log(obj.a);

// 深原型链(慢)
const proto1 = { x: 1 };
const proto2 = Object.create(proto1);
const proto3 = Object.create(proto2);
const obj2 = Object.create(proto3);

// 需要多次查找来找到 x
console.log(obj2.x);  // 检查 obj2, proto3, proto2, proto1

// 浅原型链(快)
const obj3 = Object.create({ x: 1 });
console.log(obj3.x);  // 只有一次查找

// 缓存频繁访问的原型属性
function fastAccess(obj) {
    const proto = Object.getPrototypeOf(obj);
    const method = proto.method;

    // 使用缓存的引用
    return function() {
        return method.call(obj);
    };
}

// 自有属性比原型查找快
const fast = { name: "Fast" };
const slow = Object.create({ name: "Slow" });

// 直接访问 vs 原型查找
console.time("direct");
for (let i = 0; i < 1000000; i++) {
    fast.name;
}
console.timeEnd("direct");  // ~2ms

console.time("prototype");
for (let i = 0; i < 1000000; i++) {
    slow.name;
}
console.timeEnd("prototype");  // ~3ms (稍慢)
```
</UniversalEditor>

## 常见陷阱

### 陷阱 1: 修改 Object.prototype

<UniversalEditor title="不要修改 Object.prototype">
```javascript !! js
// ❌ 错误: 修改 Object.prototype 影响一切
Object.prototype.each = function(fn) {
    for (let key in this) {
        fn(this[key], key);
    }
};

// 现在即使是空对象也有 'each'
const empty = {};
empty.each(x => console.log(x));  // 意外!

// 也破坏 for...in 循环
for (let key in empty) {
    console.log(key);  // "each" (不想要的!)
}

// ✅ 正确: 使用自己的基础对象
const MyBaseObject = {
    each(fn) {
        for (let key in this) {
            if (this.hasOwnProperty(key)) {
                fn(this[key], key);
            }
        }
    }
};

const myObj = Object.create(MyyBaseObject);
myObj.each(x => console.log(x));  // 按预期工作
```
</UniversalEditor>

### 陷阱 2: 原型污染

<UniversalEditor title="原型污染">
```javascript !! js
// 安全漏洞: 原型污染

function merge(target, source) {
    for (let key in source) {
        if (typeof source[key] === "object" && typeof target[key] === "object") {
            merge(target[key], source[key]);
        } else {
            target[key] = source[key];
        }
    }
    return target;
}

// 恶意输入
const malicious = {
    __proto__: {
        isAdmin: true
    }
};

const empty = {};
merge(empty, malicious);

// 现在所有对象都有 isAdmin = true!
console.log(({}).isAdmin);  // true (安全问题!)

// ✅ 正确: 验证键
function safeMerge(target, source) {
    for (let key in source) {
        // 跳过危险键
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
            continue;
        }
        // ... 其余合并逻辑
    }
    return target;
}

// 或使用 Object.create(null) 用于纯数据对象
const pure = Object.create(null);
// pure 没有原型,所以不可能原型污染
```
</UniversalEditor>

## 最佳实践

<UniversalEditor title="原型最佳实践">
```java !! java
// Java: 清晰的类层次结构
public abstract class Animal {
    public abstract void speak();
}

public class Dog extends Animal {
    public void speak() {
        System.out.println("Woof!");
    }
}
```

```javascript !! js
// JavaScript: 选择正确的方法

// 1. 大多数情况下使用类(现代,熟悉)
class Animal {
    speak() {
        console.log("Sound");
    }
}

class Dog extends Animal {
    speak() {
        console.log("Woof!");
    }
}

// 2. 使用 Object.create 用于简单原型
const animal = {
    speak() {
        console.log("Sound");
    }
};

const dog = Object.create(animal);

// 3. 不要修改内置原型
// ❌ Array.prototype.first = function() { return this[0]; };

// ✅ 创建子类或工具函数
class MyArray extends Array {
    first() {
        return this[0];
    }
}

// 4. 在 for...in 中使用 hasOwnProperty
for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
        // 只有自有属性
    }
}

// 或使用 Object.keys()
Object.keys(obj).forEach(key => {
    // 只有自有可枚举属性
});

// 5. 理解 instanceof 限制
// 只适用于构造函数
const obj = Object.create(null);
obj instanceof Object;  // false (无原型链)

// 使用 Object.getPrototypeOf() 代替
console.log(Object.getPrototypeOf(obj) === null);  // true

// 6. 优先使用组合而非深层原型链
// 不好: 深层继承
class A {}
class B extends A {}
class C extends B {}
class D extends C {}

// 好: 组合
class D {
    constructor(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;
    }
}
```
</UniversalEditor>

## 练习

### 练习 1: 原型链
```javascript
const grandParent = { a: 1 };
const parent = Object.create(grandParent);
parent.b = 2;
const child = Object.create(parent);
child.c = 3;

// 这些会输出什么?
console.log(child.a);
console.log(child.b);
console.log(child.hasOwnProperty("a"));
console.log(child.hasOwnProperty("b"));
```

### 练习 2: 使用 Object.create 创建
```javascript
// 创建一个具有 start() 和 stop() 方法的 vehicle 原型
// 创建继承自 vehicle 的 car 和 motorcycle 对象
```

### 练习 3: 构造函数
```javascript
// 创建一个 Book 构造函数
// 添加方法到原型: getTitle(), getAuthor()
// 创建实例并测试
```

### 练习 4: 原型链查找
```javascript
// 创建 3 层原型链
// 添加一个只存在于第 3 层的方法
// 测试第 1 层可以访问它
```

## 总结

### 关键要点

1. **原型:**
   - 每个对象都有原型
   - 原型链用于属性查找
   - 无需类即可实现继承

2. **Object.create():**
   - 创建具有特定原型的对象
   - 支持属性描述符
   - 可以创建 null 原型对象

3. **构造函数:**
   - ES6 之前的类模式
   - 方法添加到原型
   - 'new' 关键字创建实例

4. **原型链:**
   - 查找沿链向上
   - 首先找到自有属性
   - 在 Object.prototype 然后 null 结束

5. **类 vs 原型:**
   - 类是原型的语法糖
   - 类在大多数情况下更清晰
   - 原型提供更多灵活性

6. **最佳实践:**
   - 不要修改内置原型
   - 使用类获得结构
   - 使用 Object.create 进行简单继承
   - 理解原型性能

### 比较表: Java vs JavaScript

| 特性 | Java | JavaScript |
|---------|------|------------|
| **继承** | 基于类 | 基于原型 |
| **链** | 类层次结构 | 原型链 |
| **方法** | 在类定义中 | 在原型对象上 |
| **查找** | 编译时 | 运行时(链遍历) |
| **修改** | 运行时不能修改 | 可以随时修改 |
| **检查** | `instanceof` | `instanceof` 或 `Object.getPrototypeOf()` |

## 下一步?

你已经掌握了 JavaScript 的原型系统!接下来是 **模块 9: This 和上下文**,我们将探索:

- `this` 绑定如何工作
- Call、apply 和 bind 方法
- 箭头函数和词法 this
- 不同上下文中的 this
- 常见的 this 相关陷阱
- 管理上下文的最佳实践

准备掌握 `this` 关键字了吗?让我们继续!
