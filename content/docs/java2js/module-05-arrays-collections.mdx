---
title: "Module 5: Arrays and Collections"
description: "Master JavaScript arrays, Sets, Maps, and collection methods"
---

## Module 5: Arrays and Collections

JavaScript's collection types are different from Java's. Arrays are more flexible, and JavaScript offers additional collection types like Set and Map. Let's explore these powerful data structures.

## Learning Objectives

By the end of this module, you will:
✅ Master JavaScript array creation and manipulation
✅ Understand array methods (mutating vs non-mutating)
✅ Learn about Set and Map data structures
✅ Know when to use WeakSet and WeakMap
✅ Understand array destructuring
✅ Learn performance considerations

## Array Basics

JavaScript arrays are more like dynamic lists than Java's arrays:

<UniversalEditor title="Array Creation and Basics">
```java !! java
// Java - Fixed-size arrays
int[] numbers = new int[5];
numbers[0] = 1;
numbers[1] = 2;
// numbers[5] = 3;  // ArrayIndexOutOfBoundsException

// Array initializer
int[] moreNumbers = {1, 2, 3, 4, 5};

// Size is fixed
System.out.println(numbers.length);  // 5

// Cannot change size
// To add elements, need ArrayList
```

```javascript !! js
// JavaScript - Dynamic arrays
const numbers = [1, 2, 3, 4, 5];

// Can add elements
numbers.push(6);       // Add to end
numbers.unshift(0);    // Add to beginning

// Can remove elements
numbers.pop();         // Remove from end
numbers.shift();       // Remove from beginning

// Dynamic length
console.log(numbers.length);  // 5 (after push/pop)

// Mixed types (not recommended but possible)
const mixed = [1, "hello", true, { id: 1 }, [1, 2, 3]];

// Sparse arrays
const sparse = [1, , , 4];  // Holes in array
console.log(sparse.length); // 4
console.log(sparse[1]);     // undefined

// Array constructor (avoid - use literal syntax)
const arr = new Array(5);   // Creates array with 5 empty slots
const arr2 = new Array(1, 2, 3);  // Creates [1, 2, 3]
// Better: const arr = [1, 2, 3];
```
</UniversalEditor>

### Array Length

<UniversalEditor title="Array Length Behavior">
```java !! java
// Java - Length is fixed
int[] arr = {1, 2, 3};
System.out.println(arr.length);  // 3

arr.length = 5;  // Compilation error! Cannot change length
```

```javascript !! js
// JavaScript - Length is writable
let arr = [1, 2, 3];
console.log(arr.length);  // 3

// Setting length truncates or adds undefined
arr.length = 5;
console.log(arr);  // [1, 2, 3, undefined × 2]

arr.length = 2;
console.log(arr);  // [1, 2]

// Clear array
arr.length = 0;
console.log(arr);  // []

// Practical: Fast truncate
const bigArray = [1, 2, 3, 4, 5];
bigArray.length = 3;  // Keep only first 3 elements

// Check if empty
if (arr.length === 0) {
    console.log("Array is empty");
}

// Truthy/falsy
if (arr.length) {  // Works because 0 is falsy
    console.log("Array has elements");
}
```
</UniversalEditor>

## Array Methods - Mutating vs Non-Mutating

JavaScript distinguishes between methods that modify the array and those that create a new array:

### Mutating Methods

<UniversalEditor title="Mutating Array Methods">
```java !! java
// Java - Arrays don't have methods
// Use ArrayList or utility classes
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
list.add("d");           // Add to end
list.add(0, "start");    // Add at index
list.remove(0);          // Remove at index
list.set(0, "x");        // Replace at index
```

```javascript !! js
// JavaScript - Mutating methods

const arr = [1, 2, 3, 4, 5];

// push: Add to end
arr.push(6);
console.log(arr);  // [1, 2, 3, 4, 5, 6]

// pop: Remove from end
arr.pop();
console.log(arr);  // [1, 2, 3, 4, 5]

// unshift: Add to beginning
arr.unshift(0);
console.log(arr);  // [0, 1, 2, 3, 4, 5]

// shift: Remove from beginning
arr.shift();
console.log(arr);  // [1, 2, 3, 4, 5]

// splice: Remove/add at any position
arr.splice(2, 1);  // Remove 1 element at index 2
console.log(arr);  // [1, 2, 4, 5]

arr.splice(2, 0, 3);  // Insert 3 at index 2
console.log(arr);  // [1, 2, 3, 4, 5]

// sort: Sorts in place
arr.sort((a, b) => a - b);
console.log(arr);  // [1, 2, 3, 4, 5]

// reverse: Reverses in place
arr.reverse();
console.log(arr);  // [5, 4, 3, 2, 1]

// fill: Fill with value
arr.fill(0);
console.log(arr);  // [0, 0, 0, 0, 0]
```
</UniversalEditor>

### Non-Mutating Methods

<UniversalEditor title="Non-Mutating Array Methods">
```java !! java
// Java - Streams create new collections
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> doubled = numbers.stream()
    .map(n -> n * 2)
    .collect(Collectors.toList());

List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

// Original list unchanged
```

```javascript !! js
// JavaScript - Non-mutating methods
const numbers = [1, 2, 3, 4, 5];

// map: Transform to new array
const doubled = numbers.map(n => n * 2);
console.log(doubled);    // [2, 4, 6, 8, 10]
console.log(numbers);    // [1, 2, 3, 4, 5] (unchanged)

// filter: Select elements
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens);      // [2, 4]
console.log(numbers);    // [1, 2, 3, 4, 5] (unchanged)

// slice: Extract portion
const first3 = numbers.slice(0, 3);
console.log(first3);     // [1, 2, 3]

// concat: Combine arrays
const more = [6, 7, 8];
const combined = numbers.concat(more);
console.log(combined);   // [1, 2, 3, 4, 5, 6, 7, 8]

// join: Convert to string
const str = numbers.join("-");
console.log(str);        // "1-2-3-4-5"

// flat: Flatten nested arrays
const nested = [1, [2, [3, [4]]]];
const flat = nested.flat(2);
console.log(flat);       // [1, 2, 3, [4]]

// flatMap: Map and flatten in one step
const sentences = ["Hello world", "Goodbye earth"];
const words = sentences.flatMap(s => s.split(" "));
console.log(words);      // ["Hello", "world", "Goodbye", "earth"]
```
</UniversalEditor>

## Array Destructuring

Destructuring allows unpacking values from arrays:

<UniversalEditor title="Array Destructuring">
```java !! java
// Java - Manual unpacking
int[] coordinates = {10, 20, 30};
int x = coordinates[0];
int y = coordinates[1];
int z = coordinates[2];

// Or use objects/classes
public class Point {
    public int x, y, z;
    // Constructor, getters, setters...
}
```

```javascript !! js
// JavaScript - Destructuring
const coordinates = [10, 20, 30];

// Basic destructuring
const [x, y, z] = coordinates;
console.log(x, y, z);  // 10 20 30

// Skip elements
const [first, , third] = coordinates;
console.log(first, third);  // 10 30

// Rest operator
const [head, ...tail] = coordinates;
console.log(head);  // 10
console.log(tail);  // [20, 30]

// Default values
const [a = 1, b = 2, c = 3] = [10];
console.log(a, b, c);  // 10 2 3

// Swap variables
let m = 1, n = 2;
[m, n] = [n, m];
console.log(m, n);  // 2 1

// Destructuring function returns
function getStats() {
    return [100, 50, [25, 75]];
}
const [total, min, [max1, max2]] = getStats();
console.log(total, min, max1, max2);  // 100 50 25 75

// Practical: Parse URL
const url = "https://example.com/users/123";
const [, protocol, domain, path, id] = url.split(/\/+/);
console.log(protocol);  // "https:"
console.log(domain);    // "example.com"
console.log(path);      // "users"
console.log(id);        // "123"
```
</UniversalEditor>

## Searching and Querying

<UniversalEditor title="Array Search Methods">
```java !! java
// Java - Search methods
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

boolean hasAlice = names.contains("Alice");  // true
int indexOfBob = names.indexOf("Bob");       // 1

// With streams
Optional<String> found = names.stream()
    .filter(n -> n.startsWith("B"))
    .findFirst();

boolean allLong = names.stream()
    .allMatch(n -> n.length() > 3);

boolean anyLong = names.stream()
    .anyMatch(n -> n.length() > 4);
```

```javascript !! js
// JavaScript - Search methods
const names = ["Alice", "Bob", "Charlie"];

// indexOf: Find index
const indexOfBob = names.indexOf("Bob");
console.log(indexOfBob);  // 1

const indexOfXYZ = names.indexOf("XYZ");
console.log(indexOfXYZ);  // -1 (not found)

// includes: Check existence
const hasAlice = names.includes("Alice");
console.log(hasAlice);  // true

// find: Find element matching predicate
const found = names.find(name => name.startsWith("B"));
console.log(found);  // "Bob"

// findIndex: Find index of matching element
const foundIndex = names.findIndex(name => name.startsWith("B"));
console.log(foundIndex);  // 1

// some: Check if any element matches
const anyLong = names.some(name => name.length > 4);
console.log(anyLong);  // true

// every: Check if all elements match
const allLong = names.every(name => name.length > 3);
console.log(allLong);  // true

// lastIndexOf: Find from end
const dupes = [1, 2, 3, 2, 1];
console.log(dupes.lastIndexOf(2));  // 3

// Practical: Find user by ID
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" },
    { id: 3, name: "Charlie" }
];

const user = users.find(u => u.id === 2);
console.log(user);  // { id: 2, name: "Bob" }

const userIndex = users.findIndex(u => u.id === 2);
console.log(userIndex);  // 1
```
</UniversalEditor>

## Array Reduction

<UniversalEditor title="Array Reduction Methods">
```java !! java
// Java - Reduce with streams
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Sum
int sum = numbers.stream().reduce(0, Integer::sum);

// Product
int product = numbers.stream().reduce(1, (a, b) -> a * b);

// Joining
String joined = names.stream().collect(Collectors.joining(", "));

// To map
Map<Integer, String> map = names.stream()
    .collect(Collectors.toMap(
        String::length,
        Function.identity(),
        (a, b) -> a  // Merge function
    ));
```

```javascript !! js
// JavaScript - Reduce methods
const numbers = [1, 2, 3, 4, 5];

// reduce: Reduce to single value
const sum = numbers.reduce((acc, n) => acc + n, 0);
console.log(sum);  // 15

const product = numbers.reduce((acc, n) => acc * n, 1);
console.log(product);  // 120

const max = numbers.reduce((acc, n) => Math.max(acc, n), -Infinity);
console.log(max);  // 5

const min = numbers.reduce((acc, n) => Math.min(acc, n), Infinity);
console.log(min);  // 1

// reduceRight: Reduce from right to left
const flattened = [[1, 2], [3, 4], [5, 6]].reduce((acc, arr) => acc.concat(arr), []);
console.log(flattened);  // [1, 2, 3, 4, 5, 6]

// Practical: Group by
const words = ["apple", "banana", "avocado", "cherry", "blueberry"];
const grouped = words.reduce((acc, word) => {
    const first = word[0];
    if (!acc[first]) acc[first] = [];
    acc[first].push(word);
    return acc;
}, {});

console.log(grouped);
// { a: ["apple", "avocado"], b: ["banana", "blueberry"], c: ["cherry"] }

// Practical: Build lookup map
const users = [
    { id: 1, name: "Alice" },
    { id: 2, name: "Bob" }
];

const userMap = users.reduce((acc, user) => {
    acc[user.id] = user;
    return acc;
}, {});

console.log(userMap[1]);  // { id: 1, name: "Alice" }
```
</UniversalEditor>

## Set and Map

JavaScript offers Set and Map collections similar to Java's:

<UniversalEditor title="Set Comparison">
```java !! java
// Java - HashSet
Set<String> names = new HashSet<>();
names.add("Alice");
names.add("Bob");
names.add("Alice");  // Duplicate ignored

System.out.println(names.contains("Alice"));  // true
System.out.println(names.size());  // 2

names.remove("Alice");

for (String name : names) {
    System.out.println(name);
}

// LinkedHashSet (maintains insertion order)
Set<String> ordered = new LinkedHashSet<>();

// TreeSet (sorted)
Set<String> sorted = new TreeSet<>();
```

```javascript !! js
// JavaScript - Set
const names = new Set();
names.add("Alice");
names.add("Bob");
names.add("Alice");  // Duplicate ignored

console.log(names.has("Alice"));  // true
console.log(names.size);  // 2

names.delete("Alice");
console.log(names.has("Alice"));  // false

// Iterate
for (const name of names) {
    console.log(name);
}

// Convert to array
const nameArray = [...names];
console.log(nameArray);  // ["Bob"]

// Initialize from array
const numbers = new Set([1, 2, 3, 2, 1]);
console.log(numbers);  // Set {1, 2, 3}

// Practical: Remove duplicates
const dupes = [1, 2, 2, 3, 3, 3, 4];
const unique = [...new Set(dupes)];
console.log(unique);  // [1, 2, 3, 4]

// Set methods
const set = new Set([1, 2, 3]);
set.clear();  // Remove all
console.log(set.size);  // 0

// Set operations
const a = new Set([1, 2, 3]);
const b = new Set([3, 4, 5]);

// Union
const union = new Set([...a, ...b]);
console.log(union);  // Set {1, 2, 3, 4, 5}

// Intersection
const intersection = new Set([...a].filter(x => b.has(x)));
console.log(intersection);  // Set {3}

// Difference
const difference = new Set([...a].filter(x => !b.has(x)));
console.log(difference);  // Set {1, 2}
```
</UniversalEditor>

<UniversalEditor title="Map Comparison">
```java !! java
// Java - HashMap
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 87);

System.out.println(scores.get("Alice"));  // 95
System.out.println(scores.containsKey("Bob"));  // true

scores.remove("Alice");

for (Map.Entry<String, Integer> entry : scores.entrySet()) {
    System.out.println(entry.getKey() + ": " + entry.getValue());
}

// LinkedHashMap (maintains insertion order)
// TreeMap (sorted by keys)
```

```javascript !! js
// JavaScript - Map
const scores = new Map();
scores.set("Alice", 95);
scores.set("Bob", 87);

console.log(scores.get("Alice"));  // 95
console.log(scores.has("Bob"));  // true

scores.delete("Alice");
console.log(scores.has("Alice"));  // false

// Iterate
for (const [name, score] of scores) {
    console.log(`${name}: ${score}`);
}

// Initialize from array of pairs
const data = new Map([
    ["Alice", 95],
    ["Bob", 87]
]);

// Map vs Object: Map keys can be any type
const map = new Map();
const key1 = { id: 1 };
const key2 = { id: 2 };

map.set(key1, "Value 1");
map.set(key2, "Value 2");
map.set("string", "String key");
map.set(123, "Number key");

console.log(map.get(key1));  // "Value 1"

// Object keys are always strings/symbols
const obj = {};
obj[key1] = "Value";  // key converted to "[object Object]"
obj[key2] = "Value";  // Overwrites previous!

// Map iteration order is guaranteed
const orderedMap = new Map([
    ["z", 1],
    ["a", 2],
    ["m", 3]
]);

for (const [key, value] of orderedMap) {
    console.log(key, value);  // Maintains insertion order
}

// Map methods
const map2 = new Map([["a", 1], ["b", 2]]);
console.log(map2.keys());    // MapIterator {"a", "b"}
console.log(map2.values());  // MapIterator {1, 2}
console.log(map2.entries()); // MapIterator {"a" => 1, "b" => 2}

// Convert Map to Object
const map3 = new Map([["a", 1], ["b", 2]]);
const obj2 = Object.fromEntries(map3);
console.log(obj2);  // { a: 1, b: 2 }

// Convert Object to Map
const obj3 = { a: 1, b: 2 };
const map4 = new Map(Object.entries(obj3));
```
</UniversalEditor>

## WeakSet and WeakMap

WeakSet and WeakMap hold object references weakly (allowing garbage collection):

<UniversalEditor title="WeakSet and WeakMap">
```java !! java
// Java - WeakHashMap
Map<String, Integer> weakMap = new WeakHashMap<>();
// Keys are weakly referenced
// When key is no longer strongly reachable, entry is removed

// No direct equivalent of WeakSet (until Java 9 with IdentityHashMap)
```

```javascript !! js
// JavaScript - WeakSet and WeakMap

// WeakSet: Only holds objects, no iteration
const weakSet = new WeakSet();
let obj1 = { id: 1 };
let obj2 = { id: 2 };

weakSet.add(obj1);
weakSet.add(obj2);
// weakSet.add("string");  // TypeError!

console.log(weakSet.has(obj1));  // true

obj1 = null;  // Remove strong reference
// obj1 will be garbage collected, WeakSet entry removed

// Use case: Track objects without preventing GC
function processObjects(objects) {
    const processed = new WeakSet();

    return objects.filter(obj => {
        if (processed.has(obj)) {
            return false;  // Already processed
        }
        processed.add(obj);
        return true;
    });
}

// WeakMap: Keys must be objects, values can be anything
const weakMap = new WeakMap();
const key1 = { id: 1 };
const key2 = { id: 2 };

weakMap.set(key1, "Metadata 1");
weakMap.set(key2, "Metadata 2");

console.log(weakMap.get(key1));  // "Metadata 1"
console.log(weakMap.has(key1));  // true

weakMap.delete(key1);

// Use case: Private data
const privateData = new WeakMap();

class User {
    constructor(name, age) {
        privateData.set(this, { age, secret: "xyz" });
        this.name = name;
    }

    getAge() {
        return privateData.get(this).age;
    }

    getSecret() {
        return privateData.get(this).secret;
    }
}

const user = new User("Alice", 25);
console.log(user.name);    // "Alice" (public)
console.log(user.getAge());  // 25 (accessed via WeakMap)
console.log(user.age);     // undefined (truly private)

// Use case: DOM node metadata
const nodeData = new WeakMap();

function setupNode(node) {
    nodeData.set(node, {
        clickCount: 0,
        lastClick: null
    });

    node.addEventListener("click", () => {
        const data = nodeData.get(node);
        data.clickCount++;
        data.lastClick = Date.now();
        console.log(`Clicked ${data.clickCount} times`);
    });
}

// When node is removed from DOM, metadata is automatically GC'd
```
</UniversalEditor>

## Performance Considerations

<UniversalEditor title="Array Performance Tips">
```java !! java
// Java - ArrayList vs LinkedList
// ArrayList: O(1) random access, O(n) insert/delete
// LinkedList: O(n) random access, O(1) insert/delete

// Use ArrayList for most cases
List<Integer> list = new ArrayList<>();

// Pre-size when possible
List<Integer> sized = new ArrayList<>(1000);
```

```javascript !! js
// JavaScript - Array performance

// 1. Pre-allocate when size known (helps V8 optimize)
const arr = new Array(1000);
// Or
const arr2 = [];
arr2.length = 1000;

// 2. Use typed arrays for numeric data
const int8 = new Int8Array(1000);      // 8-bit integers
const int16 = new Int16Array(1000);    // 16-bit integers
const float64 = new Float64Array(1000); // 64-bit floats

// Performance comparison
const regular = [];
for (let i = 0; i < 1000000; i++) {
    regular.push(i);
}

const typed = new Int32Array(1000000);
for (let i = 0; i < typed.length; i++) {
    typed[i] = i;
}

// 3. Avoid sparse arrays
const sparse = [];  // Bad
sparse[1000] = 1;   // Creates holes

const dense = new Array(1001).fill(0);  // Good
dense[1000] = 1;

// 4. Use for loop for heavy operations (faster than forEach)
const numbers = [1, 2, 3, 4, 5];

// Slower (function call overhead)
numbers.forEach(n => {
    // Process n
});

// Faster
for (let i = 0; i < numbers.length; i++) {
    const n = numbers[i];
    // Process n
}

// 5. Set/Map lookup vs Array includes
const arr = [1, 2, 3, 4, 5];
const set = new Set([1, 2, 3, 4, 5]);

// Array: O(n)
arr.includes(3);

// Set: O(1)
set.has(3);

// For large datasets, use Set/Map for lookups
const largeArray = Array.from({ length: 100000 }, (_, i) => i);
const largeSet = new Set(largeArray);

// Fast lookup
console.time("array");
largeArray.includes(99999);
console.timeEnd("array");  // ~5ms

console.time("set");
largeSet.has(99999);
console.timeEnd("set");    // ~0ms

// 6. Array spread vs concat
const a = [1, 2, 3];
const b = [4, 5, 6];

// Modern: spread (slower for very large arrays)
const combined = [...a, ...b];

// Traditional: concat (often faster)
const combined2 = a.concat(b);
```
</UniversalEditor>

## Common Patterns

### Pattern 1: Chunking

<UniversalEditor title="Chunk Array Pattern">
```java !! java
// Java - Chunk into sublists
public static <T> List<List<T>> chunk(List<T> list, int size) {
    List<List<T>> chunks = new ArrayList<>();
    for (int i = 0; i < list.size(); i += size) {
        chunks.add(list.subList(i, Math.min(i + size, list.size())));
    }
    return chunks;
}
```

```javascript !! js
// JavaScript - Chunk array
function chunk(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
        chunks.push(array.slice(i, i + size));
    }
    return chunks;
}

const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
console.log(chunk(numbers, 3));
// [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

// Functional approach
function chunkFunctional(array, size) {
    return Array.from(
        { length: Math.ceil(array.length / size) },
        (_, i) => array.slice(i * size, i * size + size)
    );
}
```
</UniversalEditor>

### Pattern 2: Flatten

<UniversalEditor title="Flatten Pattern">
```javascript !! js
// Flatten nested arrays
const nested = [1, [2, [3, [4, 5]]]];

// Shallow flatten
const flat1 = nested.flat();
console.log(flat1);  // [1, 2, [3, [4, 5]]]

// Deep flatten (specify depth)
const flat2 = nested.flat(2);
console.log(flat2);  // [1, 2, 3, [4, 5]]

// Infinite flatten
const flat3 = nested.flat(Infinity);
console.log(flat3);  // [1, 2, 3, 4, 5]

// Custom flatten function
function flatten(arr) {
    const result = [];

    for (const item of arr) {
        if (Array.isArray(item)) {
            result.push(...flatten(item));
        } else {
            result.push(item);
        }
    }

    return result;
}
```
</UniversalEditor>

## Best Practices

<UniversalEditor title="Collection Best Practices">
```java !! java
// Java: Use appropriate collection type
List<String> list = new ArrayList<>();  // Ordered, allows duplicates
Set<String> set = new HashSet<>();      // Unordered, unique
Map<String, Integer> map = new HashMap<>();  // Key-value pairs

// Choose based on needs:
// - ArrayList: Fast random access
// - LinkedList: Frequent insertions/deletions
// - HashSet: Fast lookups, unique elements
// - TreeSet: Sorted elements
// - HashMap: Fast key lookups
// - TreeMap: Sorted keys
```

```javascript !! js
// JavaScript: Choose wisely

// 1. Use arrays for ordered data
const items = ["apple", "banana", "cherry"];

// 2. Use Set for uniqueness
const uniqueItems = new Set(["apple", "banana", "apple"]);

// 3. Use Map for key-value with non-string keys
const metadata = new Map();
const element = document.getElementById("myDiv");
metadata.set(element, { clicks: 0 });

// 4. Use object for simple string keys
const config = {
    apiUrl: "https://api.example.com",
    timeout: 5000,
    retries: 3
};

// 5. Prefer non-mutating methods
const numbers = [1, 2, 3, 4, 5];

// Good: Returns new array
const doubled = numbers.map(n => n * 2);

// Be careful: Modifies in place
numbers.reverse();  // Modifies original!

// To avoid mutation: Create copy first
const reversed = [...numbers].reverse();

// 6. Use destructuring for clarity
const [first, second, ...rest] = numbers;

// 7. Use spread for immutable updates
const state = { count: 0, name: "app" };
const newState = { ...state, count: 1 };  // Copy with update

const list = [1, 2, 3];
const newList = [...list, 4];  // Copy with addition

// 8. Leverage Set for deduplication
const dupes = [1, 2, 2, 3, 3, 3];
const unique = [...new Set(dupes)];
```
</UniversalEditor>

## Exercises

### Exercise 1: Array Manipulation
Implement these operations:
```javascript
const arr = [1, 2, 3, 4, 5];

// 1. Add 0 to beginning
// 2. Add 6 to end
// 3. Remove first element
// 4. Remove last element
// 5. Double all elements (non-mutating)
// 6. Filter out even numbers
// 7. Sum all numbers
```

### Exercise 2: Set Operations
Create Set utility functions:
```javascript
// Union of two sets
function union(setA, setB) { }

// Intersection of two sets
function intersection(setA, setB) { }

// Difference of two sets
function difference(setA, setB) { }
```

### Exercise 3: Chunk Array
Split array into chunks of size n:
```javascript
function chunk(array, size) {
    // Return array of arrays
}

chunk([1, 2, 3, 4, 5, 6, 7], 3);
// [[1, 2, 3], [4, 5, 6], [7]]
```

### Exercise 4: Map Operations
Create frequency map:
```javascript
function frequencyMap(array) {
    // Return Map with element counts
}

frequencyMap(["apple", "banana", "apple", "cherry", "banana", "apple"]);
// Map {"apple" => 3, "banana" => 2, "cherry" => 1}
```

## Summary

### Key Takeaways

1. **Arrays:**
   - Dynamic size (can grow/shrink)
   - Mixed types possible
   - Rich set of methods
   - Distinguish mutating vs non-mutating

2. **Destructuring:**
   - Unpack values cleanly
   - Skip with commas
   - Rest operator for remaining
   - Default values

3. **Set:**
   - Unique values only
   - Fast lookups (O(1))
   - Good for deduplication
   - WeakSet for memory management

4. **Map:**
   - Any key type
   - Maintains insertion order
   - Fast lookups (O(1))
   - WeakMap for metadata

5. **Performance:**
   - Pre-allocate when possible
   - Use typed arrays for numbers
   - Set/Map for large lookups
   - for loops for heavy operations

### Comparison Table: Java vs JavaScript

| Feature | Java | JavaScript |
|---------|------|------------|
| **Array type** | Fixed size, single type | Dynamic, mixed types |
| **Growth** | Need ArrayList | Automatic |
| **Set** | HashSet, TreeSet, LinkedHashSet | Set (insertion ordered) |
| **Map** | HashMap, TreeMap, LinkedHashMap | Map (insertion ordered) |
| **Weak refs** | WeakHashMap | WeakSet, WeakMap |
| **Typed arrays** | No | Int8Array, Float64Array, etc. |
| **Destructuring** | No | Yes (ES6+) |

## What's Next?

You've mastered JavaScript collections! Next up is **Module 6: Objects**, where we'll explore:

- Object literals and creation
- Property getters and setters
- Object methods (keys, values, entries)
- Object destructuring
- Spread operator with objects
- Object.freeze and Object.seal

Ready to dive deeper into JavaScript objects? Let's continue!
