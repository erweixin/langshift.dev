---
title: "Module 07: Inheritance and Polymorphism"
description: "Learn Java inheritance, polymorphism, method overriding, and abstract classes compared to JavaScript prototype inheritance."
---

# Module 07: Inheritance and Polymorphism

In this module, we'll explore Java's inheritance and polymorphism mechanisms and compare them with JavaScript's prototype-based inheritance. Java provides a structured class hierarchy with method overriding and polymorphism, while JavaScript uses prototype chains for inheritance.

## Learning Objectives

By the end of this module, you will be able to:
- Understand Java inheritance and class hierarchies
- Compare Java inheritance with JavaScript prototype chains
- Implement method overriding and polymorphism
- Use abstract classes and methods
- Apply inheritance best practices
- Understand the difference between inheritance and composition

## Inheritance Basics

### 1. Class Inheritance

Java uses explicit class inheritance with the `extends` keyword, while JavaScript uses prototype chains.

<UniversalEditor title="Class Inheritance" compare={true}>
```javascript !! js
// JavaScript - Prototype-based inheritance
// Base class (constructor function)
function Animal(name, species) {
    this.name = name;
    this.species = species;
}

// Add methods to prototype
Animal.prototype.makeSound = function() {
    return "Some animal sound";
};

Animal.prototype.getInfo = function() {
    return `${this.name} is a ${this.species}`;
};

Animal.prototype.sleep = function() {
    return `${this.name} is sleeping`;
};

// Derived class (constructor function)
function Dog(name, breed) {
    // Call parent constructor
    Animal.call(this, name, "Dog");
    this.breed = breed;
}

// Set up prototype chain
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// Override methods
Dog.prototype.makeSound = function() {
    return "Woof! Woof!";
};

// Add new methods
Dog.prototype.fetch = function() {
    return `${this.name} is fetching the ball`;
};

// ES6 Class inheritance
class AnimalClass {
    constructor(name, species) {
        this.name = name;
        this.species = species;
    }
    
    makeSound() {
        return "Some animal sound";
    }
    
    getInfo() {
        return `${this.name} is a ${this.species}`;
    }
    
    sleep() {
        return `${this.name} is sleeping`;
    }
}

class DogClass extends AnimalClass {
    constructor(name, breed) {
        super(name, "Dog"); // Call parent constructor
        this.breed = breed;
    }
    
    // Override method
    makeSound() {
        return "Woof! Woof!";
    }
    
    // Add new method
    fetch() {
        return `${this.name} is fetching the ball`;
    }
}

class CatClass extends AnimalClass {
    constructor(name, color) {
        super(name, "Cat");
        this.color = color;
    }
    
    // Override method
    makeSound() {
        return "Meow! Meow!";
    }
    
    // Add new method
    climb() {
        return `${this.name} is climbing the tree`;
    }
}

// Usage examples
const animal = new Animal("Generic", "Unknown");
const dog = new Dog("Buddy", "Golden Retriever");
const cat = new CatClass("Whiskers", "Orange");

console.log(animal.makeSound());
console.log(dog.makeSound());
console.log(cat.makeSound());

console.log(dog.getInfo());
console.log(dog.fetch());
console.log(cat.climb());

// Check inheritance
console.log(dog instanceof Animal); // true
console.log(dog instanceof Dog); // true
console.log(cat instanceof AnimalClass); // true
```

```java !! java
// Java - Class-based inheritance
public class Animal {
    // Protected fields (accessible in subclasses)
    protected String name;
    protected String species;
    
    // Constructor
    public Animal(String name, String species) {
        this.name = name;
        this.species = species;
    }
    
    // Methods that can be overridden
    public String makeSound() {
        return "Some animal sound";
    }
    
    public String getInfo() {
        return name + " is a " + species;
    }
    
    public String sleep() {
        return name + " is sleeping";
    }
    
    // Final method (cannot be overridden)
    public final String getSpecies() {
        return species;
    }
    
    // Static method
    public static String getAnimalType() {
        return "Animal";
    }
    
    // Getter methods
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

// Derived class using inheritance
public class Dog extends Animal {
    private String breed;
    
    // Constructor calling parent constructor
    public Dog(String name, String breed) {
        super(name, "Dog"); // Call parent constructor
        this.breed = breed;
    }
    
    // Method overriding
    @Override
    public String makeSound() {
        return "Woof! Woof!";
    }
    
    // Add new method
    public String fetch() {
        return name + " is fetching the ball";
    }
    
    // Override getInfo to include breed
    @Override
    public String getInfo() {
        return super.getInfo() + " (Breed: " + breed + ")";
    }
    
    // Getter for breed
    public String getBreed() {
        return breed;
    }
    
    public void setBreed(String breed) {
        this.breed = breed;
    }
}

// Another derived class
public class Cat extends Animal {
    private String color;
    
    public Cat(String name, String color) {
        super(name, "Cat");
        this.color = color;
    }
    
    // Method overriding
    @Override
    public String makeSound() {
        return "Meow! Meow!";
    }
    
    // Add new method
    public String climb() {
        return name + " is climbing the tree";
    }
    
    // Override getInfo to include color
    @Override
    public String getInfo() {
        return super.getInfo() + " (Color: " + color + ")";
    }
    
    // Getter for color
    public String getColor() {
        return color;
    }
    
    public void setColor(String color) {
        this.color = color;
    }
}

// Main class to demonstrate inheritance
class InheritanceDemo {
    public static void main(String[] args) {
        Animal animal = new Animal("Generic", "Unknown");
        Dog dog = new Dog("Buddy", "Golden Retriever");
        Cat cat = new Cat("Whiskers", "Orange");
        
        // Method calls
        System.out.println(animal.makeSound());
        System.out.println(dog.makeSound());
        System.out.println(cat.makeSound());
        
        System.out.println(dog.getInfo());
        System.out.println(dog.fetch());
        System.out.println(cat.climb());
        
        // Polymorphism
        Animal[] animals = {animal, dog, cat};
        for (Animal a : animals) {
            System.out.println(a.makeSound()); // Different behavior for each type
        }
        
        // Instanceof checks
        System.out.println("Dog is Animal: " + (dog instanceof Animal));
        System.out.println("Dog is Dog: " + (dog instanceof Dog));
        System.out.println("Cat is Animal: " + (cat instanceof Animal));
        
        // Access to protected fields
        System.out.println("Dog species: " + dog.getSpecies());
    }
}
```
</UniversalEditor>

### 2. Method Overriding and Polymorphism

Java provides explicit method overriding with the `@Override` annotation, while JavaScript uses prototype-based method replacement.

<UniversalEditor title="Method Overriding and Polymorphism" compare={true}>
```javascript !! js
// JavaScript - Method overriding and polymorphism
// Base class
class Shape {
    constructor(color) {
        this.color = color;
    }
    
    getArea() {
        return 0;
    }
    
    getPerimeter() {
        return 0;
    }
    
    getInfo() {
        return `Shape with color ${this.color}`;
    }
    
    // Static method
    static getShapeType() {
        return "Shape";
    }
}

// Derived classes
class Circle extends Shape {
    constructor(color, radius) {
        super(color);
        this.radius = radius;
    }
    
    // Override methods
    getArea() {
        return Math.PI * this.radius * this.radius;
    }
    
    getPerimeter() {
        return 2 * Math.PI * this.radius;
    }
    
    getInfo() {
        return `Circle with radius ${this.radius} and color ${this.color}`;
    }
    
    // Add new method
    getDiameter() {
        return 2 * this.radius;
    }
}

class Rectangle extends Shape {
    constructor(color, width, height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    // Override methods
    getArea() {
        return this.width * this.height;
    }
    
    getPerimeter() {
        return 2 * (this.width + this.height);
    }
    
    getInfo() {
        return `Rectangle with width ${this.width}, height ${this.height} and color ${this.color}`;
    }
    
    // Add new method
    isSquare() {
        return this.width === this.height;
    }
}

class Triangle extends Shape {
    constructor(color, side1, side2, side3) {
        super(color);
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }
    
    // Override methods
    getArea() {
        // Heron's formula
        const s = (this.side1 + this.side2 + this.side3) / 2;
        return Math.sqrt(s * (s - this.side1) * (s - this.side2) * (s - this.side3));
    }
    
    getPerimeter() {
        return this.side1 + this.side2 + this.side3;
    }
    
    getInfo() {
        return `Triangle with sides ${this.side1}, ${this.side2}, ${this.side3} and color ${this.color}`;
    }
    
    // Add new method
    isEquilateral() {
        return this.side1 === this.side2 && this.side2 === this.side3;
    }
}

// Polymorphism demonstration
function demonstratePolymorphism() {
    const shapes = [
        new Shape("black"),
        new Circle("red", 5),
        new Rectangle("blue", 4, 6),
        new Triangle("green", 3, 4, 5)
    ];
    
    shapes.forEach(shape => {
        console.log(shape.getInfo());
        console.log(`Area: ${shape.getArea().toFixed(2)}`);
        console.log(`Perimeter: ${shape.getPerimeter().toFixed(2)}`);
        console.log("---");
    });
}

// Method overriding with different approaches
class AdvancedShape extends Shape {
    constructor(color, name) {
        super(color);
        this.name = name;
    }
    
    // Override with additional functionality
    getInfo() {
        const baseInfo = super.getInfo();
        return `${baseInfo} - Name: ${this.name}`;
    }
    
    // Override with completely different behavior
    getArea() {
        return -1; // Indicates area not calculated
    }
}

// Usage
demonstratePolymorphism();

const circle = new Circle("red", 5);
const rectangle = new Rectangle("blue", 4, 6);
const triangle = new Triangle("green", 3, 4, 5);

console.log("Circle diameter:", circle.getDiameter());
console.log("Rectangle is square:", rectangle.isSquare());
console.log("Triangle is equilateral:", triangle.isEquilateral());

// Polymorphic array
const shapes = [circle, rectangle, triangle];
shapes.forEach(shape => {
    console.log(`${shape.constructor.name} area: ${shape.getArea().toFixed(2)}`);
});
```

```java !! java
// Java - Method overriding and polymorphism
public abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // Abstract methods (must be implemented by subclasses)
    public abstract double getArea();
    public abstract double getPerimeter();
    
    // Concrete method that can be overridden
    public String getInfo() {
        return "Shape with color " + color;
    }
    
    // Final method (cannot be overridden)
    public final String getColor() {
        return color;
    }
    
    // Static method
    public static String getShapeType() {
        return "Shape";
    }
    
    // Setter
    public void setColor(String color) {
        this.color = color;
    }
}

// Concrete derived class
public class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    // Override abstract methods
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
    
    // Override concrete method
    @Override
    public String getInfo() {
        return String.format("Circle with radius %.2f and color %s", radius, color);
    }
    
    // Add new method
    public double getDiameter() {
        return 2 * radius;
    }
    
    // Getters and setters
    public double getRadius() {
        return radius;
    }
    
    public void setRadius(double radius) {
        this.radius = radius;
    }
}

public class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    // Override abstract methods
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
    
    // Override concrete method
    @Override
    public String getInfo() {
        return String.format("Rectangle with width %.2f, height %.2f and color %s", 
                           width, height, color);
    }
    
    // Add new method
    public boolean isSquare() {
        return width == height;
    }
    
    // Getters and setters
    public double getWidth() {
        return width;
    }
    
    public void setWidth(double width) {
        this.width = width;
    }
    
    public double getHeight() {
        return height;
    }
    
    public void setHeight(double height) {
        this.height = height;
    }
}

public class Triangle extends Shape {
    private double side1;
    private double side2;
    private double side3;
    
    public Triangle(String color, double side1, double side2, double side3) {
        super(color);
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }
    
    // Override abstract methods
    @Override
    public double getArea() {
        // Heron's formula
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }
    
    @Override
    public double getPerimeter() {
        return side1 + side2 + side3;
    }
    
    // Override concrete method
    @Override
    public String getInfo() {
        return String.format("Triangle with sides %.2f, %.2f, %.2f and color %s", 
                           side1, side2, side3, color);
    }
    
    // Add new method
    public boolean isEquilateral() {
        return side1 == side2 && side2 == side3;
    }
    
    // Getters and setters
    public double getSide1() { return side1; }
    public void setSide1(double side1) { this.side1 = side1; }
    public double getSide2() { return side2; }
    public void setSide2(double side2) { this.side2 = side2; }
    public double getSide3() { return side3; }
    public void setSide3(double side3) { this.side3 = side3; }
}

// Main class to demonstrate polymorphism
class PolymorphismDemo {
    public static void main(String[] args) {
        // Create different shapes
        Circle circle = new Circle("red", 5);
        Rectangle rectangle = new Rectangle("blue", 4, 6);
        Triangle triangle = new Triangle("green", 3, 4, 5);
        
        // Polymorphic array
        Shape[] shapes = {circle, rectangle, triangle};
        
        // Demonstrate polymorphism
        for (Shape shape : shapes) {
            System.out.println(shape.getInfo());
            System.out.printf("Area: %.2f%n", shape.getArea());
            System.out.printf("Perimeter: %.2f%n", shape.getPerimeter());
            System.out.println("---");
        }
        
        // Access specific methods through casting
        System.out.println("Circle diameter: " + circle.getDiameter());
        System.out.println("Rectangle is square: " + rectangle.isSquare());
        System.out.println("Triangle is equilateral: " + triangle.isEquilateral());
        
        // Polymorphic method calls
        demonstratePolymorphism(shapes);
        
        // Method overriding demonstration
        System.out.println("Shape type: " + Shape.getShapeType());
        System.out.println("Circle color: " + circle.getColor());
    }
    
    // Method demonstrating polymorphism
    public static void demonstratePolymorphism(Shape[] shapes) {
        System.out.println("Polymorphic method calls:");
        for (Shape shape : shapes) {
            System.out.printf("%s area: %.2f%n", 
                            shape.getClass().getSimpleName(), shape.getArea());
        }
    }
}
```
</UniversalEditor>

## Abstract Classes and Methods

### 1. Abstract Classes

Java provides abstract classes for partial implementation, while JavaScript doesn't have a direct equivalent.

<UniversalEditor title="Abstract Classes and Methods" compare={true}>
```javascript !! js
// JavaScript - Simulating abstract classes
// Base class with abstract-like methods
class AbstractVehicle {
    constructor(make, model, year) {
        if (new.target === AbstractVehicle) {
            throw new Error("AbstractVehicle cannot be instantiated directly");
        }
        this.make = make;
        this.model = model;
        this.year = year;
    }
    
    // Abstract-like method (must be implemented by subclasses)
    startEngine() {
        throw new Error("startEngine method must be implemented");
    }
    
    // Abstract-like method
    getVehicleType() {
        throw new Error("getVehicleType method must be implemented");
    }
    
    // Concrete method
    getInfo() {
        return `${this.year} ${this.make} ${this.model}`;
    }
    
    // Concrete method
    getAge() {
        const currentYear = new Date().getFullYear();
        return currentYear - this.year;
    }
    
    // Static method
    static getVehicleCategory() {
        return "Vehicle";
    }
}

// Concrete derived class
class Car extends AbstractVehicle {
    constructor(make, model, year, fuelType) {
        super(make, model, year);
        this.fuelType = fuelType;
    }
    
    // Implement abstract-like method
    startEngine() {
        return `Starting ${this.fuelType} engine of ${this.getInfo()}`;
    }
    
    // Implement abstract-like method
    getVehicleType() {
        return "Car";
    }
    
    // Add new method
    honk() {
        return "Honk! Honk!";
    }
    
    // Override concrete method
    getInfo() {
        return `${super.getInfo()} (${this.fuelType})`;
    }
}

class Motorcycle extends AbstractVehicle {
    constructor(make, model, year, engineSize) {
        super(make, model, year);
        this.engineSize = engineSize;
    }
    
    // Implement abstract-like method
    startEngine() {
        return `Starting ${this.engineSize}cc engine of ${this.getInfo()}`;
    }
    
    // Implement abstract-like method
    getVehicleType() {
        return "Motorcycle";
    }
    
    // Add new method
    wheelie() {
        return "Doing a wheelie!";
    }
    
    // Override concrete method
    getInfo() {
        return `${super.getInfo()} (${this.engineSize}cc)`;
    }
}

// Factory pattern for creating vehicles
class VehicleFactory {
    static createVehicle(type, make, model, year, ...args) {
        switch (type.toLowerCase()) {
            case 'car':
                return new Car(make, model, year, args[0]);
            case 'motorcycle':
                return new Motorcycle(make, model, year, args[0]);
            default:
                throw new Error(`Unknown vehicle type: ${type}`);
        }
    }
}

// Usage examples
try {
    // This would throw an error
    // const vehicle = new AbstractVehicle("Generic", "Model", 2020);
} catch (error) {
    console.log("Error:", error.message);
}

const car = new Car("Toyota", "Camry", 2020, "Gasoline");
const motorcycle = new Motorcycle("Honda", "CBR600RR", 2019, 600);

console.log(car.startEngine());
console.log(motorcycle.startEngine());

console.log(car.getVehicleType());
console.log(motorcycle.getVehicleType());

console.log(car.honk());
console.log(motorcycle.wheelie());

// Polymorphic array
const vehicles = [car, motorcycle];
vehicles.forEach(vehicle => {
    console.log(`${vehicle.getVehicleType()}: ${vehicle.getInfo()}`);
    console.log(vehicle.startEngine());
});

// Factory usage
const factoryCar = VehicleFactory.createVehicle("car", "Ford", "Mustang", 2021, "Gasoline");
console.log(factoryCar.getInfo());
```

```java !! java
// Java - Abstract classes and methods
public abstract class AbstractVehicle {
    protected String make;
    protected String model;
    protected int year;
    
    // Constructor
    public AbstractVehicle(String make, String model, int year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }
    
    // Abstract methods (must be implemented by subclasses)
    public abstract String startEngine();
    public abstract String getVehicleType();
    
    // Concrete methods
    public String getInfo() {
        return year + " " + make + " " + model;
    }
    
    public int getAge() {
        int currentYear = java.time.Year.now().getValue();
        return currentYear - year;
    }
    
    // Final method (cannot be overridden)
    public final String getMake() {
        return make;
    }
    
    // Static method
    public static String getVehicleCategory() {
        return "Vehicle";
    }
    
    // Getters and setters
    public String getModel() {
        return model;
    }
    
    public void setModel(String model) {
        this.model = model;
    }
    
    public int getYear() {
        return year;
    }
    
    public void setYear(int year) {
        this.year = year;
    }
}

// Concrete derived class
public class Car extends AbstractVehicle {
    private String fuelType;
    
    public Car(String make, String model, int year, String fuelType) {
        super(make, model, year);
        this.fuelType = fuelType;
    }
    
    // Implement abstract methods
    @Override
    public String startEngine() {
        return "Starting " + fuelType + " engine of " + getInfo();
    }
    
    @Override
    public String getVehicleType() {
        return "Car";
    }
    
    // Add new method
    public String honk() {
        return "Honk! Honk!";
    }
    
    // Override concrete method
    @Override
    public String getInfo() {
        return super.getInfo() + " (" + fuelType + ")";
    }
    
    // Getter and setter
    public String getFuelType() {
        return fuelType;
    }
    
    public void setFuelType(String fuelType) {
        this.fuelType = fuelType;
    }
}

public class Motorcycle extends AbstractVehicle {
    private int engineSize;
    
    public Motorcycle(String make, String model, int year, int engineSize) {
        super(make, model, year);
        this.engineSize = engineSize;
    }
    
    // Implement abstract methods
    @Override
    public String startEngine() {
        return "Starting " + engineSize + "cc engine of " + getInfo();
    }
    
    @Override
    public String getVehicleType() {
        return "Motorcycle";
    }
    
    // Add new method
    public String wheelie() {
        return "Doing a wheelie!";
    }
    
    // Override concrete method
    @Override
    public String getInfo() {
        return super.getInfo() + " (" + engineSize + "cc)";
    }
    
    // Getter and setter
    public int getEngineSize() {
        return engineSize;
    }
    
    public void setEngineSize(int engineSize) {
        this.engineSize = engineSize;
    }
}

// Factory class for creating vehicles
public class VehicleFactory {
    public static AbstractVehicle createVehicle(String type, String make, String model, int year, Object... args) {
        switch (type.toLowerCase()) {
            case "car":
                return new Car(make, model, year, (String) args[0]);
            case "motorcycle":
                return new Motorcycle(make, model, year, (Integer) args[0]);
            default:
                throw new IllegalArgumentException("Unknown vehicle type: " + type);
        }
    }
}

// Main class to demonstrate abstract classes
class AbstractClassDemo {
    public static void main(String[] args) {
        // This would cause compilation error:
        // AbstractVehicle vehicle = new AbstractVehicle("Generic", "Model", 2020);
        
        Car car = new Car("Toyota", "Camry", 2020, "Gasoline");
        Motorcycle motorcycle = new Motorcycle("Honda", "CBR600RR", 2019, 600);
        
        System.out.println(car.startEngine());
        System.out.println(motorcycle.startEngine());
        
        System.out.println(car.getVehicleType());
        System.out.println(motorcycle.getVehicleType());
        
        System.out.println(car.honk());
        System.out.println(motorcycle.wheelie());
        
        // Polymorphic array
        AbstractVehicle[] vehicles = {car, motorcycle};
        for (AbstractVehicle vehicle : vehicles) {
            System.out.println(vehicle.getVehicleType() + ": " + vehicle.getInfo());
            System.out.println(vehicle.startEngine());
        }
        
        // Factory usage
        AbstractVehicle factoryCar = VehicleFactory.createVehicle("car", "Ford", "Mustang", 2021, "Gasoline");
        System.out.println(factoryCar.getInfo());
        
        // Demonstrate abstract class features
        System.out.println("Vehicle category: " + AbstractVehicle.getVehicleCategory());
        System.out.println("Car age: " + car.getAge() + " years");
        System.out.println("Car make: " + car.getMake());
    }
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Inheritance Implementation

<UniversalEditor title="Exercise 1: Inheritance Implementation">
```java !! java
// TODO: Implement these classes with proper inheritance
public abstract class Employee {
    // TODO: Add protected fields for name, id, salary
    
    // TODO: Implement constructor
    
    // TODO: Add abstract method calculateBonus()
    
    // TODO: Add concrete methods getInfo() and getSalary()
    
    // TODO: Add getters and setters
}

public class Manager extends Employee {
    // TODO: Add private field for department
    
    // TODO: Implement constructor calling parent constructor
    
    // TODO: Override calculateBonus() method
    
    // TODO: Override getInfo() method
    
    // TODO: Add method to manage team
}

public class Developer extends Employee {
    // TODO: Add private field for programming language
    
    // TODO: Implement constructor calling parent constructor
    
    // TODO: Override calculateBonus() method
    
    // TODO: Override getInfo() method
    
    // TODO: Add method to write code
}

public class InheritanceExercises {
    public static void main(String[] args) {
        // Test your implementations
        Manager manager = new Manager("John Doe", "M001", 80000, "Engineering");
        Developer developer = new Developer("Jane Smith", "D001", 70000, "Java");
        
        System.out.println(manager.getInfo());
        System.out.println("Manager bonus: $" + manager.calculateBonus());
        System.out.println(manager.manageTeam());
        
        System.out.println(developer.getInfo());
        System.out.println("Developer bonus: $" + developer.calculateBonus());
        System.out.println(developer.writeCode());
        
        // Polymorphic array
        Employee[] employees = {manager, developer};
        for (Employee emp : employees) {
            System.out.println(emp.getInfo() + " - Bonus: $" + emp.calculateBonus());
        }
    }
}
```
</UniversalEditor>

### Exercise 2: Polymorphism and Method Overriding

<UniversalEditor title="Exercise 2: Polymorphism and Method Overriding">
```java !! java
// TODO: Implement a polymorphic banking system
public abstract class BankAccount {
    // TODO: Add protected fields for accountNumber, balance, owner
    
    // TODO: Implement constructor
    
    // TODO: Add abstract method calculateInterest()
    
    // TODO: Add concrete methods deposit(), withdraw(), getBalance()
    
    // TODO: Override toString() method
}

public class SavingsAccount extends BankAccount {
    // TODO: Add private field for interest rate
    
    // TODO: Implement constructor
    
    // TODO: Override calculateInterest() method
    
    // TODO: Override toString() method
    
    // TODO: Add method to add interest to balance
}

public class CheckingAccount extends BankAccount {
    // TODO: Add private field for overdraft limit
    
    // TODO: Implement constructor
    
    // TODO: Override calculateInterest() method
    
    // TODO: Override withdraw() method to handle overdraft
    
    // TODO: Override toString() method
}

public class PolymorphismExercises {
    public static void main(String[] args) {
        // Test your implementations
        SavingsAccount savings = new SavingsAccount("S001", 10000, "Alice", 0.05);
        CheckingAccount checking = new CheckingAccount("C001", 5000, "Bob", 1000);
        
        System.out.println(savings);
        System.out.println("Interest: $" + savings.calculateInterest());
        savings.addInterest();
        System.out.println("After interest: " + savings.getBalance());
        
        System.out.println(checking);
        System.out.println("Interest: $" + checking.calculateInterest());
        checking.withdraw(6000); // Should use overdraft
        System.out.println("After withdrawal: " + checking.getBalance());
        
        // Polymorphic array
        BankAccount[] accounts = {savings, checking};
        for (BankAccount account : accounts) {
            System.out.println(account + " - Interest: $" + account.calculateInterest());
        }
    }
}
```
</UniversalEditor>

## Summary

In this module, we explored Java's inheritance and polymorphism mechanisms and compared them with JavaScript's prototype-based inheritance:

### Key Points:
1. **Class Inheritance**: Java uses explicit `extends` keyword for inheritance
2. **Method Overriding**: Java provides `@Override` annotation for explicit method overriding
3. **Polymorphism**: Java supports runtime polymorphism through method overriding
4. **Abstract Classes**: Java provides abstract classes for partial implementation
5. **Access Control**: Java uses `protected` for inheritance-specific access

### Next Steps:
- Practice implementing class hierarchies with proper inheritance
- Master method overriding and polymorphism patterns
- Explore abstract classes and their use cases
- Prepare for the next module on interfaces and abstract classes

## Additional Resources

- [Java Inheritance](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html)
- [Java Polymorphism](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html)
- [Java Abstract Classes](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)

---

**Exercise Tips**: Focus on understanding the difference between inheritance and composition. Practice implementing proper class hierarchies with abstract classes. Create polymorphic systems that demonstrate runtime behavior changes. 