---
title: "Module 06: Classes and Objects"
description: "Learn Java classes and objects, constructors, access modifiers, and encapsulation compared to JavaScript object-oriented programming."
---

# Module 06: Classes and Objects

In this module, we'll explore Java's class-based object-oriented programming and compare it with JavaScript's prototype-based approach. Java provides a structured way to define classes with constructors, access modifiers, and encapsulation, while JavaScript offers more flexible object creation patterns.

## Learning Objectives

By the end of this module, you will be able to:
- Understand Java class structure and object creation
- Compare Java classes with JavaScript object patterns
- Implement constructors and access modifiers
- Apply encapsulation principles
- Use static members and instance methods
- Understand the difference between class-based and prototype-based OOP

## Class Basics

### 1. Class Declaration and Object Creation

Java uses a strict class-based approach, while JavaScript offers multiple ways to create objects.

<UniversalEditor title="Class Declaration and Object Creation" compare={true}>
```javascript !! js
// JavaScript - Multiple ways to create objects
// Object literal
const person1 = {
    name: "Alice",
    age: 25,
    greet: function() {
        return `Hello, I'm ${this.name}`;
    }
};

// Constructor function (ES5 style)
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.greet = function() {
        return `Hello, I'm ${this.name}`;
    };
}

// ES6 Class syntax
class PersonClass {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    greet() {
        return `Hello, I'm ${this.name}`;
    }
    
    getAge() {
        return this.age;
    }
    
    setAge(age) {
        if (age >= 0) {
            this.age = age;
        }
    }
}

// Factory function pattern
function createPerson(name, age) {
    return {
        name: name,
        age: age,
        greet: function() {
            return `Hello, I'm ${this.name}`;
        },
        getAge: function() {
            return this.age;
        },
        setAge: function(age) {
            if (age >= 0) {
                this.age = age;
            }
        }
    };
}

// Usage examples
console.log(person1.greet());

const person2 = new Person("Bob", 30);
console.log(person2.greet());

const person3 = new PersonClass("Charlie", 35);
console.log(person3.greet());
console.log(person3.getAge());
person3.setAge(36);
console.log(person3.getAge());

const person4 = createPerson("David", 40);
console.log(person4.greet());
```

```java !! java
// Java - Class-based object-oriented programming
public class Person {
    // Instance variables (fields)
    private String name;
    private int age;
    
    // Default constructor
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
    
    // Parameterized constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Copy constructor
    public Person(Person other) {
        this.name = other.name;
        this.age = other.age;
    }
    
    // Getter methods
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    // Setter methods
    public void setName(String name) {
        if (name != null && !name.trim().isEmpty()) {
            this.name = name;
        }
    }
    
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        }
    }
    
    // Instance method
    public String greet() {
        return "Hello, I'm " + name;
    }
    
    // Method with parameters
    public String greetWithMessage(String message) {
        return message + ", I'm " + name;
    }
    
    // Method that returns boolean
    public boolean isAdult() {
        return age >= 18;
    }
    
    // Method that modifies object state
    public void haveBirthday() {
        age++;
    }
    
    // Static method (belongs to class, not instance)
    public static Person createAdult(String name) {
        return new Person(name, 18);
    }
    
    // Static method for comparison
    public static boolean isSameAge(Person p1, Person p2) {
        return p1.age == p2.age;
    }
    
    // Override toString method
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
    
    // Override equals method
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && Objects.equals(name, person.name);
    }
    
    // Override hashCode method
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}

// Main class to demonstrate usage
class ClassBasicsDemo {
    public static void main(String[] args) {
        // Creating objects using different constructors
        Person person1 = new Person();
        Person person2 = new Person("Alice", 25);
        Person person3 = new Person(person2); // Copy constructor
        
        // Using getter and setter methods
        System.out.println(person1.getName()); // "Unknown"
        person1.setName("Bob");
        person1.setAge(30);
        System.out.println(person1.getName()); // "Bob"
        
        // Using instance methods
        System.out.println(person2.greet());
        System.out.println(person2.greetWithMessage("Hi there"));
        System.out.println("Is adult: " + person2.isAdult());
        
        // Using static methods
        Person adult = Person.createAdult("Charlie");
        System.out.println(adult);
        System.out.println("Same age: " + Person.isSameAge(person2, person3));
        
        // Object lifecycle
        person2.haveBirthday();
        System.out.println("After birthday: " + person2.getAge());
        
        // toString method
        System.out.println(person2);
    }
}
```
</UniversalEditor>

### 2. Access Modifiers and Encapsulation

Java provides strict access control, while JavaScript relies on conventions and closures for encapsulation.

<UniversalEditor title="Access Modifiers and Encapsulation" compare={true}>
```javascript !! js
// JavaScript - Encapsulation patterns
// Module pattern for encapsulation
const BankAccount = (function() {
    // Private variables
    let accountNumber = 0;
    
    // Private function to generate account number
    function generateAccountNumber() {
        return ++accountNumber;
    }
    
    // Private function to validate amount
    function validateAmount(amount) {
        return typeof amount === 'number' && amount > 0;
    }
    
    // Constructor function
    function BankAccount(owner, initialBalance = 0) {
        // Private properties (using closure)
        const _accountNumber = generateAccountNumber();
        let _balance = initialBalance;
        const _owner = owner;
        const _transactions = [];
        
        // Private method to log transaction
        function logTransaction(type, amount) {
            _transactions.push({
                type: type,
                amount: amount,
                timestamp: new Date(),
                balance: _balance
            });
        }
        
        // Public methods (returned object)
        return {
            // Getter methods
            getAccountNumber: function() {
                return _accountNumber;
            },
            
            getBalance: function() {
                return _balance;
            },
            
            getOwner: function() {
                return _owner;
            },
            
            getTransactions: function() {
                return [..._transactions]; // Return copy
            },
            
            // Setter methods
            setOwner: function(newOwner) {
                if (newOwner && typeof newOwner === 'string') {
                    _owner = newOwner;
                }
            },
            
            // Business methods
            deposit: function(amount) {
                if (validateAmount(amount)) {
                    _balance += amount;
                    logTransaction('deposit', amount);
                    return true;
                }
                return false;
            },
            
            withdraw: function(amount) {
                if (validateAmount(amount) && _balance >= amount) {
                    _balance -= amount;
                    logTransaction('withdraw', amount);
                    return true;
                }
                return false;
            },
            
            transfer: function(targetAccount, amount) {
                if (this.withdraw(amount)) {
                    targetAccount.deposit(amount);
                    logTransaction('transfer', amount);
                    return true;
                }
                return false;
            },
            
            // Utility methods
            getTransactionHistory: function() {
                return _transactions.map(t => 
                    `${t.timestamp.toISOString()}: ${t.type} $${t.amount} (Balance: $${t.balance})`
                );
            }
        };
    }
    
    // Static method
    BankAccount.getTotalAccounts = function() {
        return accountNumber;
    };
    
    return BankAccount;
})();

// ES6 Class with private fields (newer browsers)
class ModernBankAccount {
    #accountNumber;
    #balance;
    #owner;
    #transactions = [];
    
    static #totalAccounts = 0;
    
    constructor(owner, initialBalance = 0) {
        this.#accountNumber = ++ModernBankAccount.#totalAccounts;
        this.#balance = initialBalance;
        this.#owner = owner;
    }
    
    // Private method
    #logTransaction(type, amount) {
        this.#transactions.push({
            type: type,
            amount: amount,
            timestamp: new Date(),
            balance: this.#balance
        });
    }
    
    // Public methods
    getAccountNumber() {
        return this.#accountNumber;
    }
    
    getBalance() {
        return this.#balance;
    }
    
    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            this.#logTransaction('deposit', amount);
            return true;
        }
        return false;
    }
    
    withdraw(amount) {
        if (amount > 0 && this.#balance >= amount) {
            this.#balance -= amount;
            this.#logTransaction('withdraw', amount);
            return true;
        }
        return false;
    }
    
    static getTotalAccounts() {
        return ModernBankAccount.#totalAccounts;
    }
}

// Usage
const account1 = new BankAccount("Alice", 1000);
const account2 = new BankAccount("Bob", 500);

console.log(account1.getAccountNumber());
console.log(account1.getBalance());

account1.deposit(200);
account1.withdraw(100);
console.log(account1.getBalance());

account1.transfer(account2, 150);
console.log(account1.getBalance());
console.log(account2.getBalance());

console.log(account1.getTransactionHistory());
console.log("Total accounts:", BankAccount.getTotalAccounts());
```

```java !! java
// Java - Access modifiers and encapsulation
public class BankAccount {
    // Private fields (encapsulation)
    private int accountNumber;
    private double balance;
    private String owner;
    private List<Transaction> transactions;
    
    // Static field (shared across all instances)
    private static int totalAccounts = 0;
    
    // Private static method
    private static int generateAccountNumber() {
        return ++totalAccounts;
    }
    
    // Private method for validation
    private boolean validateAmount(double amount) {
        return amount > 0;
    }
    
    // Private method to log transaction
    private void logTransaction(String type, double amount) {
        transactions.add(new Transaction(type, amount, balance));
    }
    
    // Default constructor
    public BankAccount() {
        this.accountNumber = generateAccountNumber();
        this.balance = 0.0;
        this.owner = "Unknown";
        this.transactions = new ArrayList<>();
    }
    
    // Parameterized constructor
    public BankAccount(String owner, double initialBalance) {
        this.accountNumber = generateAccountNumber();
        this.owner = owner;
        this.balance = initialBalance;
        this.transactions = new ArrayList<>();
        
        if (initialBalance > 0) {
            logTransaction("initial deposit", initialBalance);
        }
    }
    
    // Copy constructor
    public BankAccount(BankAccount other) {
        this.accountNumber = generateAccountNumber();
        this.owner = other.owner;
        this.balance = other.balance;
        this.transactions = new ArrayList<>(other.transactions);
    }
    
    // Getter methods (public access)
    public int getAccountNumber() {
        return accountNumber;
    }
    
    public double getBalance() {
        return balance;
    }
    
    public String getOwner() {
        return owner;
    }
    
    public List<Transaction> getTransactions() {
        return new ArrayList<>(transactions); // Return copy for encapsulation
    }
    
    // Setter methods with validation
    public void setOwner(String owner) {
        if (owner != null && !owner.trim().isEmpty()) {
            this.owner = owner;
        }
    }
    
    // Business methods
    public boolean deposit(double amount) {
        if (validateAmount(amount)) {
            balance += amount;
            logTransaction("deposit", amount);
            return true;
        }
        return false;
    }
    
    public boolean withdraw(double amount) {
        if (validateAmount(amount) && balance >= amount) {
            balance -= amount;
            logTransaction("withdraw", amount);
            return true;
        }
        return false;
    }
    
    public boolean transfer(BankAccount targetAccount, double amount) {
        if (withdraw(amount)) {
            targetAccount.deposit(amount);
            logTransaction("transfer", amount);
            return true;
        }
        return false;
    }
    
    // Utility methods
    public List<String> getTransactionHistory() {
        return transactions.stream()
            .map(Transaction::toString)
            .collect(Collectors.toList());
    }
    
    // Static method
    public static int getTotalAccounts() {
        return totalAccounts;
    }
    
    // Static method to create account
    public static BankAccount createAccount(String owner) {
        return new BankAccount(owner, 0.0);
    }
    
    // Override toString
    @Override
    public String toString() {
        return String.format("BankAccount{accountNumber=%d, owner='%s', balance=%.2f}", 
                           accountNumber, owner, balance);
    }
    
    // Inner class for transactions
    public static class Transaction {
        private String type;
        private double amount;
        private double balance;
        private Date timestamp;
        
        public Transaction(String type, double amount, double balance) {
            this.type = type;
            this.amount = amount;
            this.balance = balance;
            this.timestamp = new Date();
        }
        
        // Getters
        public String getType() { return type; }
        public double getAmount() { return amount; }
        public double getBalance() { return balance; }
        public Date getTimestamp() { return timestamp; }
        
        @Override
        public String toString() {
            return String.format("%s: %s $%.2f (Balance: $%.2f)", 
                               timestamp, type, amount, balance);
        }
    }
}

// Main class to demonstrate encapsulation
class EncapsulationDemo {
    public static void main(String[] args) {
        BankAccount account1 = new BankAccount("Alice", 1000.0);
        BankAccount account2 = new BankAccount("Bob", 500.0);
        
        System.out.println("Account 1: " + account1);
        System.out.println("Account 2: " + account2);
        
        // Using public methods
        account1.deposit(200.0);
        account1.withdraw(100.0);
        System.out.println("Account 1 balance: $" + account1.getBalance());
        
        account1.transfer(account2, 150.0);
        System.out.println("After transfer:");
        System.out.println("Account 1 balance: $" + account1.getBalance());
        System.out.println("Account 2 balance: $" + account2.getBalance());
        
        // Transaction history
        System.out.println("Transaction history:");
        account1.getTransactionHistory().forEach(System.out::println);
        
        // Static method
        System.out.println("Total accounts created: " + BankAccount.getTotalAccounts());
        
        // Demonstrating encapsulation
        // This would cause compilation error:
        // account1.balance = 1000000; // Private field not accessible
        
        // This is the proper way:
        account1.deposit(1000000);
    }
}
```
</UniversalEditor>

## Static Members

### 1. Static Fields and Methods

Java provides static members that belong to the class rather than instances, while JavaScript uses different patterns for shared data.

<UniversalEditor title="Static Members" compare={true}>
```javascript !! js
// JavaScript - Static-like patterns
// Constructor function with static properties
function Counter() {
    Counter.totalCount = (Counter.totalCount || 0) + 1;
    this.id = Counter.totalCount;
    this.count = 0;
}

// Static method
Counter.getTotalCount = function() {
    return Counter.totalCount || 0;
};

// Static factory method
Counter.create = function(initialValue = 0) {
    const counter = new Counter();
    counter.count = initialValue;
    return counter;
};

// Static utility methods
Counter.compare = function(counter1, counter2) {
    return counter1.count - counter2.count;
};

// Instance methods
Counter.prototype.increment = function() {
    this.count++;
};

Counter.prototype.decrement = function() {
    this.count--;
};

Counter.prototype.getValue = function() {
    return this.count;
};

// ES6 Class with static members
class MathUtils {
    // Static field (ES2022+)
    static PI = 3.14159;
    static E = 2.71828;
    
    // Static method
    static add(a, b) {
        return a + b;
    }
    
    static multiply(a, b) {
        return a * b;
    }
    
    static power(base, exponent) {
        return Math.pow(base, exponent);
    }
    
    // Static factory method
    static createRandomNumber(min, max) {
        return Math.random() * (max - min) + min;
    }
    
    // Static utility method
    static isEven(number) {
        return number % 2 === 0;
    }
    
    static isOdd(number) {
        return number % 2 !== 0;
    }
    
    // Instance method
    constructor(value = 0) {
        this.value = value;
    }
    
    add(other) {
        this.value += other;
        return this;
    }
    
    multiply(other) {
        this.value *= other;
        return this;
    }
    
    getValue() {
        return this.value;
    }
}

// Module pattern with static-like behavior
const DatabaseConnection = (function() {
    // Private static variables
    let connectionCount = 0;
    const connections = new Map();
    
    // Private static method
    function generateConnectionId() {
        return `conn_${++connectionCount}`;
    }
    
    // Constructor
    function DatabaseConnection(databaseName) {
        this.id = generateConnectionId();
        this.databaseName = databaseName;
        this.isConnected = false;
        
        connections.set(this.id, this);
    }
    
    // Static methods
    DatabaseConnection.getTotalConnections = function() {
        return connectionCount;
    };
    
    DatabaseConnection.getActiveConnections = function() {
        return Array.from(connections.values()).filter(conn => conn.isConnected);
    };
    
    DatabaseConnection.closeAll = function() {
        connections.forEach(conn => conn.disconnect());
        connections.clear();
    };
    
    // Instance methods
    DatabaseConnection.prototype.connect = function() {
        this.isConnected = true;
        console.log(`Connected to ${this.databaseName}`);
    };
    
    DatabaseConnection.prototype.disconnect = function() {
        this.isConnected = false;
        connections.delete(this.id);
        console.log(`Disconnected from ${this.databaseName}`);
    };
    
    return DatabaseConnection;
})();

// Usage examples
console.log("Counter total:", Counter.getTotalCount());

const counter1 = new Counter();
const counter2 = Counter.create(10);

counter1.increment();
counter1.increment();
counter2.decrement();

console.log("Counter 1:", counter1.getValue());
console.log("Counter 2:", counter2.getValue());
console.log("Comparison:", Counter.compare(counter1, counter2));

// MathUtils usage
console.log("PI:", MathUtils.PI);
console.log("2 + 3:", MathUtils.add(2, 3));
console.log("2 * 3:", MathUtils.multiply(2, 3));
console.log("Is 4 even?", MathUtils.isEven(4));

const math = new MathUtils(5);
math.add(3).multiply(2);
console.log("Result:", math.getValue());

// DatabaseConnection usage
const db1 = new DatabaseConnection("users");
const db2 = new DatabaseConnection("products");

db1.connect();
db2.connect();

console.log("Total connections:", DatabaseConnection.getTotalConnections());
console.log("Active connections:", DatabaseConnection.getActiveConnections());

DatabaseConnection.closeAll();
```

```java !! java
// Java - Static members
public class Counter {
    // Static field (shared across all instances)
    private static int totalCount = 0;
    
    // Instance fields
    private int id;
    private int count;
    
    // Static method to get total count
    public static int getTotalCount() {
        return totalCount;
    }
    
    // Static factory method
    public static Counter create(int initialValue) {
        Counter counter = new Counter();
        counter.count = initialValue;
        return counter;
    }
    
    // Static utility method
    public static int compare(Counter counter1, Counter counter2) {
        return counter1.count - counter2.count;
    }
    
    // Constructor
    public Counter() {
        totalCount++;
        this.id = totalCount;
        this.count = 0;
    }
    
    // Instance methods
    public void increment() {
        count++;
    }
    
    public void decrement() {
        count--;
    }
    
    public int getValue() {
        return count;
    }
    
    public int getId() {
        return id;
    }
}

// Math utilities class with static methods
public class MathUtils {
    // Static constants
    public static final double PI = 3.14159;
    public static final double E = 2.71828;
    
    // Static methods
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double add(double a, double b) {
        return a + b;
    }
    
    public static int multiply(int a, int b) {
        return a * b;
    }
    
    public static double multiply(double a, double b) {
        return a * b;
    }
    
    public static double power(double base, double exponent) {
        return Math.pow(base, exponent);
    }
    
    public static double createRandomNumber(double min, double max) {
        return Math.random() * (max - min) + min;
    }
    
    public static boolean isEven(int number) {
        return number % 2 == 0;
    }
    
    public static boolean isOdd(int number) {
        return number % 2 != 0;
    }
    
    // Static block for initialization
    static {
        System.out.println("MathUtils class loaded");
    }
}

// Database connection class with static management
public class DatabaseConnection {
    // Static fields
    private static int connectionCount = 0;
    private static Map<String, DatabaseConnection> connections = new HashMap<>();
    
    // Instance fields
    private String id;
    private String databaseName;
    private boolean isConnected;
    
    // Private static method
    private static String generateConnectionId() {
        return "conn_" + (++connectionCount);
    }
    
    // Static methods
    public static int getTotalConnections() {
        return connectionCount;
    }
    
    public static List<DatabaseConnection> getActiveConnections() {
        return connections.values().stream()
            .filter(conn -> conn.isConnected)
            .collect(Collectors.toList());
    }
    
    public static void closeAll() {
        connections.values().forEach(DatabaseConnection::disconnect);
        connections.clear();
    }
    
    // Constructor
    public DatabaseConnection(String databaseName) {
        this.id = generateConnectionId();
        this.databaseName = databaseName;
        this.isConnected = false;
        connections.put(this.id, this);
    }
    
    // Instance methods
    public void connect() {
        this.isConnected = true;
        System.out.println("Connected to " + databaseName);
    }
    
    public void disconnect() {
        this.isConnected = false;
        connections.remove(this.id);
        System.out.println("Disconnected from " + databaseName);
    }
    
    // Getters
    public String getId() { return id; }
    public String getDatabaseName() { return databaseName; }
    public boolean isConnected() { return isConnected; }
    
    @Override
    public String toString() {
        return String.format("DatabaseConnection{id='%s', database='%s', connected=%s}", 
                           id, databaseName, isConnected);
    }
}

// Main class to demonstrate static members
class StaticMembersDemo {
    public static void main(String[] args) {
        // Counter examples
        System.out.println("Initial total count: " + Counter.getTotalCount());
        
        Counter counter1 = new Counter();
        Counter counter2 = Counter.create(10);
        
        counter1.increment();
        counter1.increment();
        counter2.decrement();
        
        System.out.println("Counter 1 value: " + counter1.getValue());
        System.out.println("Counter 2 value: " + counter2.getValue());
        System.out.println("Comparison: " + Counter.compare(counter1, counter2));
        System.out.println("Total counters: " + Counter.getTotalCount());
        
        // MathUtils examples
        System.out.println("PI: " + MathUtils.PI);
        System.out.println("2 + 3: " + MathUtils.add(2, 3));
        System.out.println("2.5 + 3.5: " + MathUtils.add(2.5, 3.5));
        System.out.println("2 * 3: " + MathUtils.multiply(2, 3));
        System.out.println("2^3: " + MathUtils.power(2, 3));
        System.out.println("Is 4 even? " + MathUtils.isEven(4));
        System.out.println("Random number: " + MathUtils.createRandomNumber(1, 10));
        
        // DatabaseConnection examples
        DatabaseConnection db1 = new DatabaseConnection("users");
        DatabaseConnection db2 = new DatabaseConnection("products");
        
        db1.connect();
        db2.connect();
        
        System.out.println("Total connections: " + DatabaseConnection.getTotalConnections());
        System.out.println("Active connections: " + DatabaseConnection.getActiveConnections());
        
        DatabaseConnection.closeAll();
        System.out.println("After closing all: " + DatabaseConnection.getActiveConnections());
    }
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Class Implementation

<UniversalEditor title="Exercise 1: Class Implementation">
```java !! java
// TODO: Implement these classes
public class Student {
    // TODO: Add private fields for name, id, grades, and major
    
    // TODO: Implement constructors (default, parameterized, copy)
    
    // TODO: Implement getter and setter methods
    
    // TODO: Implement methods to add grade, calculate GPA, and check if student is passing
    
    // TODO: Override toString, equals, and hashCode methods
}

public class Rectangle {
    // TODO: Add private fields for width and height
    
    // TODO: Implement constructors
    
    // TODO: Implement getter and setter methods with validation
    
    // TODO: Implement methods to calculate area, perimeter, and check if it's a square
    
    // TODO: Implement static methods to compare rectangles
}

public class ClassExercises {
    public static void main(String[] args) {
        // Test your implementations
        Student student1 = new Student("Alice", "S001", "Computer Science");
        student1.addGrade(85);
        student1.addGrade(92);
        student1.addGrade(78);
        
        System.out.println("Student: " + student1);
        System.out.println("GPA: " + student1.calculateGPA());
        System.out.println("Is passing: " + student1.isPassing());
        
        Rectangle rect1 = new Rectangle(5, 3);
        Rectangle rect2 = new Rectangle(4, 4);
        
        System.out.println("Rectangle 1 area: " + rect1.calculateArea());
        System.out.println("Rectangle 1 perimeter: " + rect1.calculatePerimeter());
        System.out.println("Rectangle 1 is square: " + rect1.isSquare());
        System.out.println("Rectangle 2 is square: " + rect2.isSquare());
        
        System.out.println("Larger area: " + Rectangle.getLargerArea(rect1, rect2));
    }
}
```
</UniversalEditor>

### Exercise 2: Encapsulation and Static Members

<UniversalEditor title="Exercise 2: Encapsulation and Static Members">
```java !! java
// TODO: Implement a Library class with proper encapsulation
public class Library {
    // TODO: Add private static fields for total books and borrowed books
    
    // TODO: Add private instance fields for book management
    
    // TODO: Implement constructors
    
    // TODO: Implement methods to add book, borrow book, return book
    
    // TODO: Implement static methods to get library statistics
    
    // TODO: Implement proper encapsulation with getters and setters
}

public class Book {
    // TODO: Implement Book class with proper encapsulation
    
    // TODO: Add fields for title, author, ISBN, availability
    
    // TODO: Implement constructors and methods
    
    // TODO: Override toString and equals methods
}

public class EncapsulationExercises {
    public static void main(String[] args) {
        // Test your implementations
        Library library = new Library("Central Library");
        
        Book book1 = new Book("Java Programming", "John Doe", "1234567890");
        Book book2 = new Book("Python Basics", "Jane Smith", "0987654321");
        
        library.addBook(book1);
        library.addBook(book2);
        
        System.out.println("Library: " + library.getName());
        System.out.println("Total books: " + Library.getTotalBooks());
        System.out.println("Available books: " + library.getAvailableBooks());
        
        library.borrowBook("1234567890");
        System.out.println("After borrowing: " + library.getAvailableBooks());
        
        library.returnBook("1234567890");
        System.out.println("After returning: " + library.getAvailableBooks());
    }
}
```
</UniversalEditor>

## Summary

In this module, we explored Java's class-based object-oriented programming and compared it with JavaScript's prototype-based approach:

### Key Points:
1. **Class Structure**: Java provides strict class definitions with constructors and access modifiers
2. **Encapsulation**: Java uses access modifiers for proper encapsulation
3. **Static Members**: Java supports static fields and methods that belong to the class
4. **Object Creation**: Java uses constructors while JavaScript offers multiple patterns
5. **Access Control**: Java has strict access control compared to JavaScript's conventions

### Next Steps:
- Practice implementing classes with proper encapsulation
- Master constructor patterns and method overloading
- Explore static members and their use cases
- Prepare for the next module on inheritance and polymorphism

## Additional Resources

- [Java Classes and Objects](https://docs.oracle.com/javase/tutorial/java/javaOO/)
- [Java Access Modifiers](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)
- [Java Static Members](https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html)

---

**Exercise Tips**: Focus on understanding the difference between instance and static members. Practice implementing proper encapsulation with getters and setters. Create classes that demonstrate real-world scenarios. 