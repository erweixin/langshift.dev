---
title: "Idiomatic Java"
description: "Learn Java coding conventions, design pattern applications, testing best practices, and code organization principles to write elegant and efficient Java code"
---

# Idiomatic Java

Java, as a mature programming language, has rich idioms and best practices. Mastering these idioms helps you write more elegant, efficient, and maintainable code.

## Coding Conventions

### 1. Naming Conventions

#### Class and Method Naming
<UniversalEditor title="Naming Conventions">
```java !! java
// Correct naming conventions
public class UserService { // Class names use PascalCase
    private static final int MAX_RETRY_COUNT = 3; // Constants use UPPER_SNAKE_CASE
    
    private String userName; // Field names use camelCase
    
    public void createUser() { // Method names use camelCase
        // Method implementation
    }
    
    public boolean isValidEmail(String email) { // Boolean methods use is/has/can prefix
        return email != null && email.contains("@");
    }
    
    public User findById(Long id) { // Query methods use find/get/load prefix
        return userRepository.findById(id);
    }
    
    public void saveUser(User user) { // Operation methods use save/update/delete prefix
        userRepository.save(user);
    }
}

// Enum naming
public enum UserStatus {
    ACTIVE, INACTIVE, SUSPENDED // Enum values use UPPER_SNAKE_CASE
}

// Interface naming
public interface UserRepository { // Interface names use PascalCase, often ending with -able or -er
    User findById(Long id);
    void save(User user);
}
```

```javascript !! js
// JavaScript naming conventions comparison
class UserService { // Class names use PascalCase
    static MAX_RETRY_COUNT = 3; // Constants use UPPER_SNAKE_CASE
    
    constructor() {
        this.userName = ''; // Field names use camelCase
    }
    
    createUser() { // Method names use camelCase
        // Method implementation
    }
    
    isValidEmail(email) { // Boolean methods use is/has/can prefix
        return email != null && email.includes('@');
    }
    
    findById(id) { // Query methods use find/get/load prefix
        return this.userRepository.findById(id);
    }
    
    saveUser(user) { // Operation methods use save/update/delete prefix
        this.userRepository.save(user);
    }
}

// Enums (using objects to simulate)
const UserStatus = {
    ACTIVE: 'ACTIVE',
    INACTIVE: 'INACTIVE',
    SUSPENDED: 'SUSPENDED'
};
```
</UniversalEditor>

#### Package Naming
<UniversalEditor title="Package Naming Conventions">
```java !! java
// Correct package naming
package com.example.project.controller; // All lowercase, separated by dots
package com.example.project.service;
package com.example.project.repository;
package com.example.project.entity;
package com.example.project.dto;
package com.example.project.config;
package com.example.project.util;

// Avoid using Java reserved words
package com.example.project.string; // Wrong: string is a reserved word
package com.example.project.String; // Wrong: starts with uppercase

// Correct approach
package com.example.project.text;
package com.example.project.util;
```
</UniversalEditor>

### 2. Code Formatting

#### Indentation and Spacing
<UniversalEditor title="Code Formatting">
```java !! java
// Correct code formatting
public class UserService {
    private static final int MAX_RETRY_COUNT = 3;
    
    public User createUser(UserCreateRequest request) {
        // Validate input
        if (request == null) {
            throw new IllegalArgumentException("Request cannot be null");
        }
        
        // Business logic
        User user = new User();
        user.setEmail(request.getEmail());
        user.setName(request.getName());
        
        // Save user
        return userRepository.save(user);
    }
    
    public List<User> findUsersByEmail(String email) {
        return userRepository.findByEmailContaining(email)
                .stream()
                .filter(User::isActive)
                .collect(Collectors.toList());
    }
}

// Correct method chaining format
public class UserBuilder {
    public UserBuilder withEmail(String email) {
        this.email = email;
        return this;
    }
    
    public UserBuilder withName(String name) {
        this.name = name;
        return this;
    }
    
    public User build() {
        return new User(email, name);
    }
}
```

```javascript !! js
// JavaScript code formatting comparison
class UserService {
    static MAX_RETRY_COUNT = 3;
    
    createUser(request) {
        // Validate input
        if (!request) {
            throw new Error('Request cannot be null');
        }
        
        // Business logic
        const user = {
            email: request.email,
            name: request.name
        };
        
        // Save user
        return this.userRepository.save(user);
    }
    
    findUsersByEmail(email) {
        return this.userRepository.findByEmailContaining(email)
            .filter(user => user.isActive);
    }
}

// Method chaining
class UserBuilder {
    withEmail(email) {
        this.email = email;
        return this;
    }
    
    withName(name) {
        this.name = name;
        return this;
    }
    
    build() {
        return { email: this.email, name: this.name };
    }
}
```
</UniversalEditor>

### 3. Comments and Documentation

#### JavaDoc Comments
<UniversalEditor title="JavaDoc Comments">
```java !! java
/**
 * Service class for managing user operations.
 * 
 * <p>This class provides methods for creating, updating, and deleting users.
 * It also includes validation logic and business rules.</p>
 * 
 * @author John Doe
 * @version 1.0
 * @since 1.0
 */
public class UserService {
    
    /**
     * Creates a new user with the provided information.
     * 
     * <p>This method validates the input data and ensures that the email
     * is unique before creating the user.</p>
     * 
     * @param request the user creation request containing user details
     * @return the created user with generated ID
     * @throws IllegalArgumentException if the request is null or invalid
     * @throws UserExistsException if a user with the same email already exists
     * @see UserCreateRequest
     * @see User
     */
    public User createUser(UserCreateRequest request) {
        // Implementation
    }
    
    /**
     * Finds a user by their unique identifier.
     * 
     * @param id the user ID
     * @return the user if found
     * @throws UserNotFoundException if no user exists with the given ID
     */
    public User findById(Long id) {
        // Implementation
    }
}
```

```javascript !! js
// JSDoc comments in JavaScript
/**
 * Service class for managing user operations.
 * 
 * @description This class provides methods for creating, updating, and deleting users.
 * It also includes validation logic and business rules.
 * 
 * @author John Doe
 * @version 1.0
 * @since 1.0
 */
class UserService {
    
    /**
     * Creates a new user with the provided information.
     * 
     * @description This method validates the input data and ensures that the email
     * is unique before creating the user.
     * 
     * @param {UserCreateRequest} request - The user creation request containing user details
     * @returns {User} The created user with generated ID
     * @throws {Error} If the request is null or invalid
     * @throws {Error} If a user with the same email already exists
     */
    createUser(request) {
        // Implementation
    }
    
    /**
     * Finds a user by their unique identifier.
     * 
     * @param {number} id - The user ID
     * @returns {User} The user if found
     * @throws {Error} If no user exists with the given ID
     */
    findById(id) {
        // Implementation
    }
}
```
</UniversalEditor>

## Design Patterns

### 1. Builder Pattern

#### Object Construction
<UniversalEditor title="Builder Pattern">
```java !! java
// Builder pattern for complex object construction
public class User {
    private final String email;
    private final String name;
    private final String phone;
    private final String address;
    private final LocalDate birthDate;
    
    private User(Builder builder) {
        this.email = builder.email;
        this.name = builder.name;
        this.phone = builder.phone;
        this.address = builder.address;
        this.birthDate = builder.birthDate;
    }
    
    // Getters
    public String getEmail() { return email; }
    public String getName() { return name; }
    public String getPhone() { return phone; }
    public String getAddress() { return address; }
    public LocalDate getBirthDate() { return birthDate; }
    
    // Builder class
    public static class Builder {
        private String email;
        private String name;
        private String phone;
        private String address;
        private LocalDate birthDate;
        
        public Builder email(String email) {
            this.email = email;
            return this;
        }
        
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        
        public Builder phone(String phone) {
            this.phone = phone;
            return this;
        }
        
        public Builder address(String address) {
            this.address = address;
            return this;
        }
        
        public Builder birthDate(LocalDate birthDate) {
            this.birthDate = birthDate;
            return this;
        }
        
        public User build() {
            if (email == null || name == null) {
                throw new IllegalStateException("Email and name are required");
            }
            return new User(this);
        }
    }
}

// Usage
User user = new User.Builder()
    .email("john@example.com")
    .name("John Doe")
    .phone("123-456-7890")
    .address("123 Main St")
    .birthDate(LocalDate.of(1990, 1, 1))
    .build();
```

```javascript !! js
// Builder pattern in JavaScript
class User {
    constructor(builder) {
        this.email = builder.email;
        this.name = builder.name;
        this.phone = builder.phone;
        this.address = builder.address;
        this.birthDate = builder.birthDate;
    }
    
    static get Builder() {
        return class Builder {
            constructor() {
                this.email = null;
                this.name = null;
                this.phone = null;
                this.address = null;
                this.birthDate = null;
            }
            
            email(email) {
                this.email = email;
                return this;
            }
            
            name(name) {
                this.name = name;
                return this;
            }
            
            phone(phone) {
                this.phone = phone;
                return this;
            }
            
            address(address) {
                this.address = address;
                return this;
            }
            
            birthDate(birthDate) {
                this.birthDate = birthDate;
                return this;
            }
            
            build() {
                if (!this.email || !this.name) {
                    throw new Error('Email and name are required');
                }
                return new User(this);
            }
        };
    }
}

// Usage
const user = new User.Builder()
    .email('john@example.com')
    .name('John Doe')
    .phone('123-456-7890')
    .address('123 Main St')
    .birthDate(new Date('1990-01-01'))
    .build();
```
</UniversalEditor>

### 2. Factory Pattern

#### Object Creation
<UniversalEditor title="Factory Pattern">
```java !! java
// Factory pattern for object creation
public interface PaymentMethod {
    void processPayment(BigDecimal amount);
}

public class CreditCardPayment implements PaymentMethod {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Processing credit card payment: " + amount);
    }
}

public class PayPalPayment implements PaymentMethod {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Processing PayPal payment: " + amount);
    }
}

public class BankTransferPayment implements PaymentMethod {
    @Override
    public void processPayment(BigDecimal amount) {
        System.out.println("Processing bank transfer: " + amount);
    }
}

// Factory class
public class PaymentMethodFactory {
    
    public static PaymentMethod createPaymentMethod(String type) {
        switch (type.toLowerCase()) {
            case "creditcard":
                return new CreditCardPayment();
            case "paypal":
                return new PayPalPayment();
            case "banktransfer":
                return new BankTransferPayment();
            default:
                throw new IllegalArgumentException("Unknown payment method: " + type);
        }
    }
}

// Usage
PaymentMethod payment = PaymentMethodFactory.createPaymentMethod("creditcard");
payment.processPayment(new BigDecimal("100.00"));
```

```javascript !! js
// Factory pattern in JavaScript
class PaymentMethod {
    processPayment(amount) {
        throw new Error('processPayment must be implemented');
    }
}

class CreditCardPayment extends PaymentMethod {
    processPayment(amount) {
        console.log(`Processing credit card payment: ${amount}`);
    }
}

class PayPalPayment extends PaymentMethod {
    processPayment(amount) {
        console.log(`Processing PayPal payment: ${amount}`);
    }
}

class BankTransferPayment extends PaymentMethod {
    processPayment(amount) {
        console.log(`Processing bank transfer: ${amount}`);
    }
}

// Factory function
class PaymentMethodFactory {
    static createPaymentMethod(type) {
        switch (type.toLowerCase()) {
            case 'creditcard':
                return new CreditCardPayment();
            case 'paypal':
                return new PayPalPayment();
            case 'banktransfer':
                return new BankTransferPayment();
            default:
                throw new Error(`Unknown payment method: ${type}`);
        }
    }
}

// Usage
const payment = PaymentMethodFactory.createPaymentMethod('creditcard');
payment.processPayment(100.00);
```
</UniversalEditor>

### 3. Strategy Pattern

#### Algorithm Selection
<UniversalEditor title="Strategy Pattern">
```java !! java
// Strategy pattern for algorithm selection
public interface SortingStrategy {
    void sort(int[] array);
}

public class BubbleSortStrategy implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Using bubble sort");
        // Bubble sort implementation
    }
}

public class QuickSortStrategy implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Using quick sort");
        // Quick sort implementation
    }
}

public class MergeSortStrategy implements SortingStrategy {
    @Override
    public void sort(int[] array) {
        System.out.println("Using merge sort");
        // Merge sort implementation
    }
}

// Context class
public class Sorter {
    private SortingStrategy strategy;
    
    public void setStrategy(SortingStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sort(int[] array) {
        if (strategy == null) {
            throw new IllegalStateException("Sorting strategy not set");
        }
        strategy.sort(array);
    }
}

// Usage
Sorter sorter = new Sorter();
sorter.setStrategy(new QuickSortStrategy());
sorter.sort(new int[]{5, 2, 8, 1, 9});
```

```javascript !! js
// Strategy pattern in JavaScript
class SortingStrategy {
    sort(array) {
        throw new Error('sort must be implemented');
    }
}

class BubbleSortStrategy extends SortingStrategy {
    sort(array) {
        console.log('Using bubble sort');
        // Bubble sort implementation
    }
}

class QuickSortStrategy extends SortingStrategy {
    sort(array) {
        console.log('Using quick sort');
        // Quick sort implementation
    }
}

class MergeSortStrategy extends SortingStrategy {
    sort(array) {
        console.log('Using merge sort');
        // Merge sort implementation
    }
}

// Context class
class Sorter {
    constructor() {
        this.strategy = null;
    }
    
    setStrategy(strategy) {
        this.strategy = strategy;
    }
    
    sort(array) {
        if (!this.strategy) {
            throw new Error('Sorting strategy not set');
        }
        this.strategy.sort(array);
    }
}

// Usage
const sorter = new Sorter();
sorter.setStrategy(new QuickSortStrategy());
sorter.sort([5, 2, 8, 1, 9]);
```
</UniversalEditor>

## Testing Best Practices

### 1. Unit Testing

#### Test Structure
<UniversalEditor title="Unit Testing Structure">
```java !! java
// Unit test structure
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @Mock
    private EmailService emailService;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    @DisplayName("Should create user successfully")
    void createUser_WithValidData_ShouldCreateUser() {
        // Arrange
        UserCreateRequest request = new UserCreateRequest();
        request.setEmail("test@example.com");
        request.setName("Test User");
        
        User expectedUser = new User();
        expectedUser.setId(1L);
        expectedUser.setEmail("test@example.com");
        expectedUser.setName("Test User");
        
        when(userRepository.save(any(User.class))).thenReturn(expectedUser);
        when(emailService.sendWelcomeEmail(anyString())).thenReturn(true);
        
        // Act
        User result = userService.createUser(request);
        
        // Assert
        assertNotNull(result);
        assertEquals(1L, result.getId());
        assertEquals("test@example.com", result.getEmail());
        assertEquals("Test User", result.getName());
        
        verify(userRepository).save(any(User.class));
        verify(emailService).sendWelcomeEmail("test@example.com");
    }
    
    @Test
    @DisplayName("Should throw exception when email is invalid")
    void createUser_WithInvalidEmail_ShouldThrowException() {
        // Arrange
        UserCreateRequest request = new UserCreateRequest();
        request.setEmail("invalid-email");
        request.setName("Test User");
        
        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            userService.createUser(request);
        });
        
        verify(userRepository, never()).save(any(User.class));
        verify(emailService, never()).sendWelcomeEmail(anyString());
    }
    
    @Test
    @DisplayName("Should throw exception when user already exists")
    void createUser_WithExistingEmail_ShouldThrowException() {
        // Arrange
        UserCreateRequest request = new UserCreateRequest();
        request.setEmail("existing@example.com");
        request.setName("Test User");
        
        when(userRepository.existsByEmail("existing@example.com")).thenReturn(true);
        
        // Act & Assert
        assertThrows(UserExistsException.class, () -> {
            userService.createUser(request);
        });
        
        verify(userRepository, never()).save(any(User.class));
    }
}
```

```javascript !! js
// Jest unit test structure
const UserService = require('../services/UserService');
const UserRepository = require('../repositories/UserRepository');
const EmailService = require('../services/EmailService');

// Mock dependencies
jest.mock('../repositories/UserRepository');
jest.mock('../services/EmailService');

describe('UserService', () => {
    let userService;
    let userRepository;
    let emailService;
    
    beforeEach(() => {
        userService = new UserService();
        userRepository = new UserRepository();
        emailService = new EmailService();
        
        // Clear all mocks
        jest.clearAllMocks();
    });
    
    describe('createUser', () => {
        test('should create user successfully', async () => {
            // Arrange
            const request = {
                email: 'test@example.com',
                name: 'Test User'
            };
            
            const expectedUser = {
                id: 1,
                email: 'test@example.com',
                name: 'Test User'
            };
            
            UserRepository.prototype.save = jest.fn().mockResolvedValue(expectedUser);
            EmailService.prototype.sendWelcomeEmail = jest.fn().mockResolvedValue(true);
            
            // Act
            const result = await userService.createUser(request);
            
            // Assert
            expect(result).toEqual(expectedUser);
            expect(UserRepository.prototype.save).toHaveBeenCalledWith(expect.objectContaining({
                email: 'test@example.com',
                name: 'Test User'
            }));
            expect(EmailService.prototype.sendWelcomeEmail).toHaveBeenCalledWith('test@example.com');
        });
        
        test('should throw exception when email is invalid', async () => {
            // Arrange
            const request = {
                email: 'invalid-email',
                name: 'Test User'
            };
            
            // Act & Assert
            await expect(userService.createUser(request))
                .rejects.toThrow('Invalid email format');
            
            expect(UserRepository.prototype.save).not.toHaveBeenCalled();
            expect(EmailService.prototype.sendWelcomeEmail).not.toHaveBeenCalled();
        });
        
        test('should throw exception when user already exists', async () => {
            // Arrange
            const request = {
                email: 'existing@example.com',
                name: 'Test User'
            };
            
            UserRepository.prototype.existsByEmail = jest.fn().mockResolvedValue(true);
            
            // Act & Assert
            await expect(userService.createUser(request))
                .rejects.toThrow('User already exists');
            
            expect(UserRepository.prototype.save).not.toHaveBeenCalled();
        });
    });
});
```
</UniversalEditor>

### 2. Integration Testing

#### Test Configuration
<UniversalEditor title="Integration Testing">
```java !! java
// Integration test configuration
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
@Transactional
class UserControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    @DisplayName("Should create user via REST API")
    void createUser_ShouldReturnCreatedUser() {
        // Arrange
        UserCreateRequest request = new UserCreateRequest();
        request.setEmail("integration@example.com");
        request.setName("Integration User");
        
        // Act
        ResponseEntity<User> response = restTemplate.postForEntity(
            "/api/users",
            request,
            User.class
        );
        
        // Assert
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("integration@example.com", response.getBody().getEmail());
        
        // Verify database
        User savedUser = userRepository.findByEmail("integration@example.com").orElse(null);
        assertNotNull(savedUser);
        assertEquals("Integration User", savedUser.getName());
    }
    
    @Test
    @DisplayName("Should return 400 for invalid request")
    void createUser_WithInvalidRequest_ShouldReturnBadRequest() {
        // Arrange
        UserCreateRequest request = new UserCreateRequest();
        request.setEmail("invalid-email");
        request.setName("Test User");
        
        // Act
        ResponseEntity<ErrorResponse> response = restTemplate.postForEntity(
            "/api/users",
            request,
            ErrorResponse.class
        );
        
        // Assert
        assertEquals(HttpStatus.BAD_REQUEST, response.getStatusCode());
        assertNotNull(response.getBody());
        assertTrue(response.getBody().getMessage().contains("Invalid email"));
    }
}
```

```javascript !! js
// Supertest integration testing
const request = require('supertest');
const app = require('../app');
const User = require('../models/User');

describe('User API Integration Tests', () => {
    beforeEach(async () => {
        // Clean up database before each test
        await User.destroy({ where: {} });
    });
    
    describe('POST /api/users', () => {
        test('should create user via REST API', async () => {
            // Arrange
            const userData = {
                email: 'integration@example.com',
                name: 'Integration User'
            };
            
            // Act
            const response = await request(app)
                .post('/api/users')
                .send(userData)
                .expect(201);
            
            // Assert
            expect(response.body.email).toBe('integration@example.com');
            expect(response.body.name).toBe('Integration User');
            
            // Verify database
            const savedUser = await User.findOne({
                where: { email: 'integration@example.com' }
            });
            expect(savedUser).toBeTruthy();
            expect(savedUser.name).toBe('Integration User');
        });
        
        test('should return 400 for invalid request', async () => {
            // Arrange
            const userData = {
                email: 'invalid-email',
                name: 'Test User'
            };
            
            // Act & Assert
            const response = await request(app)
                .post('/api/users')
                .send(userData)
                .expect(400);
            
            expect(response.body.message).toContain('Invalid email');
        });
    });
});
```
</UniversalEditor>

## Code Organization Principles

### 1. Single Responsibility Principle

#### Class Design
<UniversalEditor title="Single Responsibility Principle">
```java !! java
// Wrong: Class with multiple responsibilities
public class UserManager {
    public void createUser(User user) {
        // User creation logic
    }
    
    public void sendEmail(String to, String subject, String body) {
        // Email sending logic
    }
    
    public void saveToDatabase(User user) {
        // Database operations
    }
    
    public void validateUser(User user) {
        // Validation logic
    }
}

// Correct: Separate classes with single responsibilities
public class UserService {
    private final UserRepository userRepository;
    private final UserValidator userValidator;
    private final EmailService emailService;
    
    public UserService(UserRepository userRepository, 
                      UserValidator userValidator,
                      EmailService emailService) {
        this.userRepository = userRepository;
        this.userValidator = userValidator;
        this.emailService = emailService;
    }
    
    public User createUser(UserCreateRequest request) {
        User user = new User(request.getEmail(), request.getName());
        userValidator.validate(user);
        User savedUser = userRepository.save(user);
        emailService.sendWelcomeEmail(savedUser.getEmail());
        return savedUser;
    }
}

public class UserValidator {
    public void validate(User user) {
        if (user.getEmail() == null || !user.getEmail().contains("@")) {
            throw new IllegalArgumentException("Invalid email");
        }
        if (user.getName() == null || user.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("Name is required");
        }
    }
}

public class EmailService {
    public void sendWelcomeEmail(String email) {
        // Email sending logic
    }
}
```

```javascript !! js
// JavaScript: Similar principle
// Wrong: Class with multiple responsibilities
class UserManager {
    createUser(user) {
        // User creation logic
    }
    
    sendEmail(to, subject, body) {
        // Email sending logic
    }
    
    saveToDatabase(user) {
        // Database operations
    }
    
    validateUser(user) {
        // Validation logic
    }
}

// Correct: Separate classes with single responsibilities
class UserService {
    constructor(userRepository, userValidator, emailService) {
        this.userRepository = userRepository;
        this.userValidator = userValidator;
        this.emailService = emailService;
    }
    
    async createUser(request) {
        const user = new User(request.email, request.name);
        this.userValidator.validate(user);
        const savedUser = await this.userRepository.save(user);
        await this.emailService.sendWelcomeEmail(savedUser.email);
        return savedUser;
    }
}

class UserValidator {
    validate(user) {
        if (!user.email || !user.email.includes('@')) {
            throw new Error('Invalid email');
        }
        if (!user.name || user.name.trim() === '') {
            throw new Error('Name is required');
        }
    }
}

class EmailService {
    async sendWelcomeEmail(email) {
        // Email sending logic
    }
}
```
</UniversalEditor>

### 2. Dependency Inversion Principle

#### Interface Design
<UniversalEditor title="Dependency Inversion Principle">
```java !! java
// Wrong: High-level module depends on low-level module
public class UserService {
    private MySQLUserRepository userRepository; // Direct dependency on concrete class
    
    public UserService() {
        this.userRepository = new MySQLUserRepository(); // Tight coupling
    }
    
    public User findById(Long id) {
        return userRepository.findById(id);
    }
}

// Correct: High-level module depends on abstraction
public interface UserRepository {
    User findById(Long id);
    User save(User user);
    void delete(Long id);
}

public class UserService {
    private final UserRepository userRepository; // Depends on interface
    
    public UserService(UserRepository userRepository) { // Dependency injection
        this.userRepository = userRepository;
    }
    
    public User findById(Long id) {
        return userRepository.findById(id);
    }
}

// Implementation classes
public class MySQLUserRepository implements UserRepository {
    @Override
    public User findById(Long id) {
        // MySQL implementation
    }
    
    @Override
    public User save(User user) {
        // MySQL implementation
    }
    
    @Override
    public void delete(Long id) {
        // MySQL implementation
    }
}

public class PostgreSQLUserRepository implements UserRepository {
    @Override
    public User findById(Long id) {
        // PostgreSQL implementation
    }
    
    @Override
    public User save(User user) {
        // PostgreSQL implementation
    }
    
    @Override
    public void delete(Long id) {
        // PostgreSQL implementation
    }
}
```

```javascript !! js
// JavaScript: Similar principle
// Wrong: Direct dependency on concrete class
class UserService {
    constructor() {
        this.userRepository = new MySQLUserRepository(); // Tight coupling
    }
    
    findById(id) {
        return this.userRepository.findById(id);
    }
}

// Correct: Depends on abstraction
class UserService {
    constructor(userRepository) { // Dependency injection
        this.userRepository = userRepository;
    }
    
    findById(id) {
        return this.userRepository.findById(id);
    }
}

// Implementation classes
class MySQLUserRepository {
    async findById(id) {
        // MySQL implementation
    }
    
    async save(user) {
        // MySQL implementation
    }
    
    async delete(id) {
        // MySQL implementation
    }
}

class PostgreSQLUserRepository {
    async findById(id) {
        // PostgreSQL implementation
    }
    
    async save(user) {
        // PostgreSQL implementation
    }
    
    async delete(id) {
        // PostgreSQL implementation
    }
}
```
</UniversalEditor>

## Summary

Idiomatic Java development involves:

1. **Coding Conventions**: Consistent naming, formatting, and documentation
2. **Design Patterns**: Builder, Factory, Strategy patterns for clean code
3. **Testing Best Practices**: Unit and integration testing with proper structure
4. **Code Organization**: Single responsibility and dependency inversion principles

These practices help create maintainable, testable, and scalable Java applications. As a JavaScript developer, many of these concepts have parallels in JavaScript, but Java's stricter typing and different ecosystem introduce additional considerations.

## Best Practices

1. **Follow naming conventions consistently**
2. **Use design patterns appropriately**
3. **Write comprehensive tests**
4. **Apply SOLID principles**
5. **Document your code with JavaDoc**
6. **Use dependency injection**
7. **Keep classes focused on single responsibilities**

## Exercises

1. Refactor code to follow naming conventions
2. Implement design patterns in your projects
3. Write unit and integration tests
4. Apply SOLID principles to your code
5. Create comprehensive documentation

## Next Steps

In the next module, we'll explore advanced topics and advanced Java features. 