---
title: "模組 04: 陣列和集合"
description: "學習 Java 陣列、集合框架和資料結構，與 JavaScript 模式進行對比。"
---

# 模組 04: 陣列和集合

在本模組中，我們將探索 Java 的陣列系統和全面的集合框架。雖然 JavaScript 有單一陣列類型可以儲存混合資料，但 Java 提供強類型陣列和豐富的集合類來滿足不同的用例。

## 學習目標

通過本模組的學習，你將能夠：
- 理解 Java 陣列及其類型安全
- 掌握集合框架（List、Set、Map）
- 比較 Java 集合與 JavaScript 陣列和物件
- 使用泛型實現類型安全的集合
- 應用資料結構選擇的最佳實踐

## 陣列

### 1. 陣列宣告和初始化

Java 陣列是固定大小和強類型的，與 JavaScript 的動態陣列不同。

<UniversalEditor title="陣列宣告和初始化" compare={true}>
```javascript !! js
// JavaScript - 陣列宣告和初始化
// 動態陣列，可儲存混合類型
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "hello", true, {name: "John"}];
let empty = [];

// 陣列建構函式
let array1 = new Array(5);  // 建立長度為 5 的陣列
let array2 = new Array(1, 2, 3, 4, 5);

// Array.from() 和展開運算子
let arrayFrom = Array.from("hello");  // ['h', 'e', 'l', 'l', 'o']
let spreadArray = [...numbers, 6, 7, 8];

// 陣列方法
numbers.push(6);  // 新增到末尾
numbers.unshift(0);  // 新增到開頭
let popped = numbers.pop();  // 從末尾移除
let shifted = numbers.shift();  // 從開頭移除

console.log("Numbers:", numbers);
console.log("Mixed:", mixed);
console.log("Array from string:", arrayFrom);
console.log("Spread array:", spreadArray);
```

```java !! java
// Java - 陣列宣告和初始化
public class ArrayBasics {
    public static void main(String[] args) {
        // 陣列宣告和初始化
        int[] numbers = {1, 2, 3, 4, 5};
        String[] names = {"Alice", "Bob", "Charlie"};
        
        // 帶大小的陣列宣告
        int[] array1 = new int[5];  // 建立包含 5 個元素的陣列（全部為 0）
        String[] array2 = new String[3];  // 建立包含 3 個元素的陣列（全部為 null）
        
        // 多維陣列
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        int[][] matrix2 = new int[3][4];  // 3x4 矩陣
        
        // 陣列長度屬性
        System.out.println("Numbers length: " + numbers.length);
        System.out.println("Matrix rows: " + matrix.length);
        System.out.println("Matrix columns: " + matrix[0].length);
        
        // 陣列存取和修改
        numbers[0] = 10;
        System.out.println("First element: " + numbers[0]);
        
        // 陣列迭代
        System.out.println("Numbers array:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.print(numbers[i] + " ");
        }
        System.out.println();
        
        // 增強 for 迴圈（for-each）
        System.out.println("Names array:");
        for (String name : names) {
            System.out.print(name + " ");
        }
        System.out.println();
        
        // Arrays 工具類
        int[] copy = java.util.Arrays.copyOf(numbers, numbers.length);
        java.util.Arrays.sort(copy);
        System.out.println("Sorted copy: " + java.util.Arrays.toString(copy));
    }
}
```
</UniversalEditor>

### 2. 陣列操作和方法

<UniversalEditor title="陣列操作和方法" compare={true}>
```javascript !! js
// JavaScript - 陣列操作和方法
let fruits = ["apple", "banana", "orange", "grape"];

// 新增元素
fruits.push("mango");  // 新增到末尾
fruits.unshift("kiwi");  // 新增到開頭
fruits.splice(2, 0, "pear");  // 在索引 2 處插入

// 移除元素
fruits.pop();  // 從末尾移除
fruits.shift();  // 從開頭移除
fruits.splice(1, 1);  // 移除索引 1 處的 1 個元素

// 查詢元素
let index = fruits.indexOf("banana");
let lastIndex = fruits.lastIndexOf("apple");
let includes = fruits.includes("orange");

// 陣列轉換
let upperFruits = fruits.map(fruit => fruit.toUpperCase());
let longFruits = fruits.filter(fruit => fruit.length > 5);
let allLong = fruits.every(fruit => fruit.length > 3);
let someLong = fruits.some(fruit => fruit.length > 6);

// 陣列歸約
let concatenated = fruits.reduce((acc, fruit) => acc + ", " + fruit, "");
let totalLength = fruits.reduce((sum, fruit) => sum + fruit.length, 0);

// 排序
fruits.sort();  // 字母順序
fruits.reverse();  // 反轉順序

console.log("Fruits:", fruits);
console.log("Index of banana:", index);
console.log("Upper fruits:", upperFruits);
console.log("Long fruits:", longFruits);
console.log("Concatenated:", concatenated);
```

```java !! java
// Java - 陣列操作和方法
import java.util.Arrays;

public class ArrayOperations {
    public static void main(String[] args) {
        String[] fruits = {"apple", "banana", "orange", "grape"};
        
        // 陣列是固定大小的，所以需要建立新陣列來修改
        // 新增元素（建立新陣列）
        String[] newFruits = new String[fruits.length + 1];
        System.arraycopy(fruits, 0, newFruits, 0, fruits.length);
        newFruits[fruits.length] = "mango";
        fruits = newFruits;
        
        // Arrays 工具類方法
        System.out.println("Original: " + Arrays.toString(fruits));
        
        // 排序
        Arrays.sort(fruits);
        System.out.println("Sorted: " + Arrays.toString(fruits));
        
        // 搜尋
        int index = Arrays.binarySearch(fruits, "banana");
        System.out.println("Index of banana: " + index);
        
        // 複製陣列
        String[] copy = Arrays.copyOf(fruits, fruits.length);
        String[] partialCopy = Arrays.copyOfRange(fruits, 1, 3);
        
        // 填充陣列
        int[] numbers = new int[5];
        Arrays.fill(numbers, 42);
        System.out.println("Filled array: " + Arrays.toString(numbers));
        
        // 比較陣列
        boolean equals = Arrays.equals(fruits, copy);
        System.out.println("Arrays equal: " + equals);
        
        // 帶索引的陣列迭代
        System.out.println("Fruits with index:");
        for (int i = 0; i < fruits.length; i++) {
            System.out.println(i + ": " + fruits[i]);
        }
        
        // 增強 for 迴圈
        System.out.println("All fruits:");
        for (String fruit : fruits) {
            System.out.print(fruit + " ");
        }
        System.out.println();
        
        // 查詢最大值/最小值（數值陣列）
        int[] numbers2 = {3, 7, 2, 9, 1, 8, 5};
        int max = Arrays.stream(numbers2).max().orElse(0);
        int min = Arrays.stream(numbers2).min().orElse(0);
        System.out.println("Max: " + max + ", Min: " + min);
    }
}
```
</UniversalEditor>

## 集合框架

### 1. List 介面

List 是有序集合，允許重複元素。

<UniversalEditor title="List 介面" compare={true}>
```javascript !! js
// JavaScript - 陣列作為 List
let list = ["apple", "banana", "orange"];

// 新增元素
list.push("grape");  // 新增到末尾
list.unshift("kiwi");  // 新增到開頭
list.splice(2, 0, "pear");  // 在索引 2 處插入

// 移除元素
list.pop();  // 從末尾移除
list.shift();  // 從開頭移除
list.splice(1, 1);  // 移除索引 1 處的元素

// 存取元素
let first = list[0];
let last = list[list.length - 1];
let element = list[2];

// 查詢元素
let index = list.indexOf("banana");
let lastIndex = list.lastIndexOf("apple");
let includes = list.includes("orange");

// List 轉換
let upperList = list.map(item => item.toUpperCase());
let filteredList = list.filter(item => item.length > 5);

// List 迭代
list.forEach((item, index) => {
    console.log(`${index}: ${item}`);
});

console.log("List:", list);
console.log("First:", first);
console.log("Index of banana:", index);
console.log("Upper list:", upperList);
```

```java !! java
// Java - List 介面
import java.util.*;

public class ListExamples {
    public static void main(String[] args) {
        // ArrayList - 動態陣列實現
        List<String> arrayList = new ArrayList<>();
        arrayList.add("apple");
        arrayList.add("banana");
        arrayList.add("orange");
        
        // LinkedList - 雙向鏈表實現
        List<String> linkedList = new LinkedList<>();
        linkedList.add("grape");
        linkedList.add("kiwi");
        linkedList.add("pear");
        
        // 新增元素
        arrayList.add("grape");  // 新增到末尾
        arrayList.add(0, "kiwi");  // 在索引 0 處新增
        arrayList.addAll(linkedList);  // 新增另一個列表的所有元素
        
        // 移除元素
        arrayList.remove("banana");  // 按值移除
        arrayList.remove(0);  // 按索引移除
        arrayList.removeIf(item -> item.length() > 5);  // 按條件移除
        
        // 存取元素
        String first = arrayList.get(0);
        String last = arrayList.get(arrayList.size() - 1);
        
        // 查詢元素
        int index = arrayList.indexOf("orange");
        int lastIndex = arrayList.lastIndexOf("apple");
        boolean contains = arrayList.contains("grape");
        
        // List 轉換
        List<String> upperList = new ArrayList<>();
        for (String item : arrayList) {
            upperList.add(item.toUpperCase());
        }
        
        // List 迭代
        System.out.println("ArrayList elements:");
        for (int i = 0; i < arrayList.size(); i++) {
            System.out.println(i + ": " + arrayList.get(i));
        }
        
        // 增強 for 迴圈
        System.out.println("All elements:");
        for (String item : arrayList) {
            System.out.print(item + " ");
        }
        System.out.println();
        
        // Lambda forEach（Java 8+）
        arrayList.forEach(item -> System.out.print(item + " "));
        System.out.println();
        
        // List 方法
        System.out.println("Size: " + arrayList.size());
        System.out.println("Is empty: " + arrayList.isEmpty());
        System.out.println("Contains orange: " + contains);
        System.out.println("Index of orange: " + index);
        
        // 排序
        Collections.sort(arrayList);
        System.out.println("Sorted: " + arrayList);
        
        // 反轉
        Collections.reverse(arrayList);
        System.out.println("Reversed: " + arrayList);
    }
}
```
</UniversalEditor>

### 2. Set 介面

Set 是不允許重複元素的集合。

<UniversalEditor title="Set 介面" compare={true}>
```javascript !! js
// JavaScript - Set 物件
let set = new Set(["apple", "banana", "orange"]);

// 新增元素
set.add("grape");
set.add("banana");  // 不會新增重複項

// 移除元素
set.delete("banana");
set.clear();  // 移除所有元素

// 檢查元素
let hasApple = set.has("apple");
let size = set.size;

// Set 操作
let set1 = new Set([1, 2, 3, 4]);
let set2 = new Set([3, 4, 5, 6]);

// 聯集
let union = new Set([...set1, ...set2]);

// 交集
let intersection = new Set([...set1].filter(x => set2.has(x)));

// 差集
let difference = new Set([...set1].filter(x => !set2.has(x)));

// Set 迭代
set1.forEach(value => {
    console.log("Value:", value);
});

// 轉換為陣列
let array = [...set1];

console.log("Set:", set);
console.log("Has apple:", hasApple);
console.log("Size:", size);
console.log("Union:", union);
console.log("Intersection:", intersection);
console.log("Difference:", difference);
```

```java !! java
// Java - Set 介面
import java.util.*;

public class SetExamples {
    public static void main(String[] args) {
        // HashSet - 無序，無重複
        Set<String> hashSet = new HashSet<>();
        hashSet.add("apple");
        hashSet.add("banana");
        hashSet.add("orange");
        hashSet.add("banana");  // 不會新增重複項
        
        // LinkedHashSet - 維護插入順序
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("grape");
        linkedHashSet.add("kiwi");
        linkedHashSet.add("pear");
        
        // TreeSet - 排序順序
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("zebra");
        treeSet.add("apple");
        treeSet.add("banana");
        
        // 新增元素
        hashSet.add("grape");
        hashSet.addAll(linkedHashSet);
        
        // 移除元素
        hashSet.remove("banana");
        hashSet.removeIf(item -> item.length() > 5);
        
        // 檢查元素
        boolean contains = hashSet.contains("apple");
        boolean isEmpty = hashSet.isEmpty();
        int size = hashSet.size();
        
        // Set 操作
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        
        // 聯集
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        
        // 交集
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        // 差集
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        
        // Set 迭代
        System.out.println("HashSet elements:");
        for (String item : hashSet) {
            System.out.print(item + " ");
        }
        System.out.println();
        
        // Lambda forEach
        treeSet.forEach(item -> System.out.print(item + " "));
        System.out.println();
        
        // Set 方法
        System.out.println("HashSet: " + hashSet);
        System.out.println("LinkedHashSet: " + linkedHashSet);
        System.out.println("TreeSet: " + treeSet);
        System.out.println("Contains apple: " + contains);
        System.out.println("Size: " + size);
        System.out.println("Union: " + union);
        System.out.println("Intersection: " + intersection);
        System.out.println("Difference: " + difference);
        
        // 轉換為陣列
        String[] array = hashSet.toArray(new String[0]);
        System.out.println("Array: " + Arrays.toString(array));
    }
}
```
</UniversalEditor>

### 3. Map 介面

Map 儲存鍵值對，類似於 JavaScript 物件。

<UniversalEditor title="Map 介面" compare={true}>
```javascript !! js
// JavaScript - 物件作為 Map
let map = {
    "name": "John",
    "age": 30,
    "city": "NYC"
};

// 新增/更新元素
map.email = "john@example.com";
map["phone"] = "123-456-7890";

// 移除元素
delete map.age;
let removed = map.city;
delete map.city;

// 檢查元素
let hasName = "name" in map;
let hasAge = map.hasOwnProperty("age");
let value = map.name;
let undefinedValue = map.nonexistent;

// 物件方法
let keys = Object.keys(map);
let values = Object.values(map);
let entries = Object.entries(map);

// 物件迭代
for (let key in map) {
    if (map.hasOwnProperty(key)) {
        console.log(`${key}: ${map[key]}`);
    }
}

Object.entries(map).forEach(([key, value]) => {
    console.log(`${key}: ${value}`);
});

// Map 物件（ES6）
let mapObject = new Map();
mapObject.set("name", "John");
mapObject.set("age", 30);
mapObject.set("city", "NYC");

mapObject.set("email", "john@example.com");
mapObject.delete("age");
let hasKey = mapObject.has("name");
let mapValue = mapObject.get("name");
let mapSize = mapObject.size;

console.log("Object map:", map);
console.log("Has name:", hasName);
console.log("Keys:", keys);
console.log("Values:", values);
console.log("Map object:", mapObject);
console.log("Map size:", mapSize);
```

```java !! java
// Java - Map 介面
import java.util.*;

public class MapExamples {
    public static void main(String[] args) {
        // HashMap - 無序鍵值對
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("name", "John");
        hashMap.put("age", "30");
        hashMap.put("city", "NYC");
        
        // LinkedHashMap - 維護插入順序
        Map<String, String> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("email", "john@example.com");
        linkedHashMap.put("phone", "123-456-7890");
        
        // TreeMap - 按鍵排序
        Map<String, String> treeMap = new TreeMap<>();
        treeMap.put("zebra", "animal");
        treeMap.put("apple", "fruit");
        treeMap.put("banana", "fruit");
        
        // 新增/更新元素
        hashMap.put("email", "john@example.com");
        hashMap.putAll(linkedHashMap);
        
        // 移除元素
        hashMap.remove("age");
        hashMap.remove("nonexistent", "default");  // 僅當值匹配時移除
        
        // 檢查元素
        boolean containsKey = hashMap.containsKey("name");
        boolean containsValue = hashMap.containsValue("John");
        String value = hashMap.get("name");
        String defaultValue = hashMap.getOrDefault("nonexistent", "default");
        
        // Map 操作
        Set<String> keys = hashMap.keySet();
        Collection<String> values = hashMap.values();
        Set<Map.Entry<String, String>> entries = hashMap.entrySet();
        
        // Map 迭代
        System.out.println("HashMap entries:");
        for (Map.Entry<String, String> entry : hashMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Lambda forEach
        hashMap.forEach((key, val) -> System.out.println(key + " -> " + val));
        
        // Map 方法
        System.out.println("HashMap: " + hashMap);
        System.out.println("LinkedHashMap: " + linkedHashMap);
        System.out.println("TreeMap: " + treeMap);
        System.out.println("Contains key 'name': " + containsKey);
        System.out.println("Value for 'name': " + value);
        System.out.println("Size: " + hashMap.size());
        System.out.println("Is empty: " + hashMap.isEmpty());
        
        // 轉換為集合
        System.out.println("Keys: " + keys);
        System.out.println("Values: " + values);
        
        // 不同值類型的 Map
        Map<String, Object> mixedMap = new HashMap<>();
        mixedMap.put("name", "John");
        mixedMap.put("age", 30);
        mixedMap.put("active", true);
        mixedMap.put("scores", Arrays.asList(85, 92, 78));
        
        System.out.println("Mixed map: " + mixedMap);
        
        // 巢狀 Map
        Map<String, Map<String, String>> nestedMap = new HashMap<>();
        Map<String, String> innerMap = new HashMap<>();
        innerMap.put("street", "123 Main St");
        innerMap.put("city", "NYC");
        nestedMap.put("address", innerMap);
        
        System.out.println("Nested map: " + nestedMap);
    }
}
```
</UniversalEditor>

## 泛型

### 1. 泛型集合

泛型為集合提供類型安全。

<UniversalEditor title="泛型集合" compare={true}>
```javascript !! js
// JavaScript - 沒有泛型，但可以用 JSDoc 強制類型
/**
 * @template T
 * @param {T[]} array
 * @returns {T}
 */
function getFirst(array) {
    return array[0];
}

/**
 * @template T
 * @param {T[]} array
 * @param {function(T): boolean} predicate
 * @returns {T[]}
 */
function filter(array, predicate) {
    return array.filter(predicate);
}

// 使用
let numbers = [1, 2, 3, 4, 5];
let strings = ["hello", "world", "test"];

let firstNumber = getFirst(numbers);
let firstString = getFirst(strings);

let evenNumbers = filter(numbers, n => n % 2 === 0);
let longStrings = filter(strings, s => s.length > 4);

console.log("First number:", firstNumber);
console.log("First string:", firstString);
console.log("Even numbers:", evenNumbers);
console.log("Long strings:", longStrings);
```

```java !! java
// Java - 泛型提供編譯時類型安全
import java.util.*;

public class GenericCollections {
    public static void main(String[] args) {
        // 泛型 List
        List<String> stringList = new ArrayList<>();
        stringList.add("hello");
        stringList.add("world");
        // stringList.add(123);  // 編譯時錯誤！
        
        List<Integer> intList = new ArrayList<>();
        intList.add(1);
        intList.add(2);
        intList.add(3);
        
        // 泛型 Set
        Set<String> stringSet = new HashSet<>();
        stringSet.add("apple");
        stringSet.add("banana");
        
        // 泛型 Map
        Map<String, Integer> stringIntMap = new HashMap<>();
        stringIntMap.put("one", 1);
        stringIntMap.put("two", 2);
        
        // 泛型方法
        String firstString = getFirst(stringList);
        Integer firstInt = getFirst(intList);
        
        List<String> filteredStrings = filter(stringList, s -> s.length() > 4);
        List<Integer> evenNumbers = filter(intList, n -> n % 2 == 0);
        
        // 泛型類
        Box<String> stringBox = new Box<>("Hello");
        Box<Integer> intBox = new Box<>(42);
        
        System.out.println("First string: " + firstString);
        System.out.println("First int: " + firstInt);
        System.out.println("Filtered strings: " + filteredStrings);
        System.out.println("Even numbers: " + evenNumbers);
        System.out.println("String box: " + stringBox.getContent());
        System.out.println("Int box: " + intBox.getContent());
        
        // 萬用字元
        List<Number> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2.5);
        numbers.add(3L);
        
        printList(numbers);
        printList(stringList);
    }
    
    // 泛型方法
    public static <T> T getFirst(List<T> list) {
        if (list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }
    
    // 帶謂詞的泛型方法
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                result.add(item);
            }
        }
        return result;
    }
    
    // 萬用字元方法
    public static void printList(List<?> list) {
        for (Object item : list) {
            System.out.print(item + " ");
        }
        System.out.println();
    }
    
    // 泛型類
    static class Box<T> {
        private T content;
        
        public Box(T content) {
            this.content = content;
        }
        
        public T getContent() {
            return content;
        }
        
        public void setContent(T content) {
            this.content = content;
        }
    }
}
```
</UniversalEditor>

## 最佳實踐

### 1. 集合選擇

<UniversalEditor title="集合選擇最佳實踐" compare={true}>
```javascript !! js
// JavaScript - 集合選擇模式
// 使用陣列進行有序集合
let orderedList = [1, 2, 3, 4, 5];

// 使用 Set 進行唯一值
let uniqueValues = new Set([1, 2, 2, 3, 3, 4]);

// 使用 Map 進行鍵值對
let keyValueMap = new Map([
    ["name", "John"],
    ["age", 30],
    ["city", "NYC"]
]);

// 使用物件進行簡單鍵值儲存
let simpleObject = {
    name: "John",
    age: 30,
    city: "NYC"
};

// 效能考慮
// 陣列操作
let array = [1, 2, 3, 4, 5];
array.push(6);  // O(1) - 攤銷
array.unshift(0);  // O(n) - 移動所有元素
array.splice(2, 1);  // O(n) - 移動元素

// Set 操作
let set = new Set([1, 2, 3]);
set.add(4);  // O(1) - 平均情況
set.has(2);  // O(1) - 平均情況
set.delete(2);  // O(1) - 平均情況

// Map 操作
let map = new Map();
map.set("key", "value");  // O(1) - 平均情況
map.get("key");  // O(1) - 平均情況
map.delete("key");  // O(1) - 平均情況

console.log("Ordered list:", orderedList);
console.log("Unique values:", uniqueValues);
console.log("Key-value map:", keyValueMap);
console.log("Simple object:", simpleObject);
```

```java !! java
// Java - 集合選擇最佳實踐
import java.util.*;

public class CollectionBestPractices {
    public static void main(String[] args) {
        // 使用 ArrayList 進行隨機存取和迭代
        List<String> arrayList = new ArrayList<>();
        arrayList.add("apple");
        arrayList.add("banana");
        arrayList.add("orange");
        
        // 使用 LinkedList 進行頻繁插入/刪除
        List<String> linkedList = new LinkedList<>();
        linkedList.add("grape");
        linkedList.add("kiwi");
        linkedList.add("pear");
        
        // 使用 HashSet 進行唯一元素，不需要順序
        Set<String> hashSet = new HashSet<>();
        hashSet.add("red");
        hashSet.add("green");
        hashSet.add("blue");
        
        // 使用 LinkedHashSet 進行唯一元素，維護插入順序
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("first");
        linkedHashSet.add("second");
        linkedHashSet.add("third");
        
        // 使用 TreeSet 進行排序唯一元素
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("zebra");
        treeSet.add("apple");
        treeSet.add("banana");
        
        // 使用 HashMap 進行鍵值對，不需要順序
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("one", 1);
        hashMap.put("two", 2);
        hashMap.put("three", 3);
        
        // 使用 LinkedHashMap 進行鍵值對，維護插入順序
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("first", 1);
        linkedHashMap.put("second", 2);
        linkedHashMap.put("third", 3);
        
        // 使用 TreeMap 進行排序鍵值對
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("zebra", 26);
        treeMap.put("apple", 1);
        treeMap.put("banana", 2);
        
        // 效能考慮
        System.out.println("ArrayList (隨機存取): " + arrayList);
        System.out.println("LinkedList (頻繁修改): " + linkedList);
        System.out.println("HashSet (唯一，無順序): " + hashSet);
        System.out.println("LinkedHashSet (唯一，插入順序): " + linkedHashSet);
        System.out.println("TreeSet (唯一，排序): " + treeSet);
        System.out.println("HashMap (鍵值對，無順序): " + hashMap);
        System.out.println("LinkedHashMap (鍵值對，插入順序): " + linkedHashMap);
        System.out.println("TreeMap (鍵值對，排序): " + treeMap);
        
        // 集合效能總結
        System.out.println("\n效能總結:");
        System.out.println("ArrayList: O(1) get/set, O(n) insert/delete");
        System.out.println("LinkedList: O(n) get/set, O(1) insert/delete");
        System.out.println("HashSet: O(1) add/remove/contains");
        System.out.println("TreeSet: O(log n) add/remove/contains");
        System.out.println("HashMap: O(1) put/get/remove");
        System.out.println("TreeMap: O(log n) put/get/remove");
    }
}
```
</UniversalEditor>

## 練習題目

### 練習 1: 陣列和 List 操作

<UniversalEditor title="練習 1: 陣列和 List 操作">
```java !! java
// TODO: 完成這些陣列和 List 操作
public class ArrayListExercise {
    public static void main(String[] args) {
        // 1. 建立一個方法，查詢陣列中的第二大元素
        
        // 2. 建立一個方法，原地反轉陣列
        
        // 3. 建立一個方法，查詢兩個陣列之間的公共元素
        
        // 4. 建立一個方法，從列表中移除重複項
        
        // 5. 建立一個方法，查詢列表中最長的字串
        
        // 測試你的實現
        int[] numbers = {3, 7, 2, 9, 1, 8, 5, 4, 6};
        String[] words = {"apple", "banana", "orange", "grape", "kiwi"};
        
        System.out.println("Second largest: " + findSecondLargest(numbers));
        reverseArray(numbers);
        System.out.println("Reversed array: " + Arrays.toString(numbers));
        
        int[] array1 = {1, 2, 3, 4, 5};
        int[] array2 = {4, 5, 6, 7, 8};
        System.out.println("Common elements: " + findCommonElements(array1, array2));
        
        List<String> list = Arrays.asList("apple", "banana", "apple", "orange", "banana");
        System.out.println("Without duplicates: " + removeDuplicates(list));
        System.out.println("Longest string: " + findLongestString(list));
    }
    
    // 在這裡實現你的方法
}
```
</UniversalEditor>

### 練習 2: 集合框架

<UniversalEditor title="練習 2: 集合框架">
```java !! java
// TODO: 實現這些集合操作
public class CollectionExercise {
    public static void main(String[] args) {
        // 1. 建立一個方法，計算列表中單詞的頻率
        
        // 2. 建立一個方法，查詢最頻繁的元素
        
        // 3. 建立一個方法，檢查兩個列表是否為變位詞
        
        // 4. 建立一個方法，按長度分組字串
        
        // 5. 建立一個方法，查詢多個集合的交集
        
        // 測試你的實現
        List<String> words = Arrays.asList("hello", "world", "hello", "java", "world", "hello");
        System.out.println("Word frequencies: " + countWordFrequencies(words));
        System.out.println("Most frequent: " + findMostFrequent(words));
        
        List<String> list1 = Arrays.asList("listen", "silent");
        List<String> list2 = Arrays.asList("triangle", "integral");
        System.out.println("Are anagrams: " + areAnagrams(list1.get(0), list1.get(1)));
        System.out.println("Are anagrams: " + areAnagrams(list2.get(0), list2.get(1)));
        
        List<String> strings = Arrays.asList("a", "bb", "ccc", "dd", "eee");
        System.out.println("Grouped by length: " + groupByLength(strings));
        
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        Set<Integer> set3 = new HashSet<>(Arrays.asList(4, 5, 6, 7));
        System.out.println("Intersection: " + findIntersection(set1, set2, set3));
    }
    
    // 在這裡實現你的方法
}
```
</UniversalEditor>

## 總結

在本模組中，我們探索了 Java 的陣列系統和集合框架，並將其與 JavaScript 模式進行了比較：

### 關鍵要點：
1. **陣列**: Java 陣列是固定大小和強類型的，與 JavaScript 的動態陣列不同
2. **集合框架**: 為不同用例提供專門的資料結構（List、Set、Map）
3. **泛型**: 在編譯時確保類型安全
4. **效能**: 不同集合具有不同的效能特徵
5. **最佳實踐**: 為特定需求選擇正確的集合

### 下一步：
- 練習使用不同的集合類型
- 理解何時使用每種集合
- 掌握泛型語法和萬用字元
- 為下一個關於物件導向程式設計的模組做準備

## 額外資源

- [Java 集合框架](https://docs.oracle.com/javase/tutorial/collections/)
- [Java 泛型](https://docs.oracle.com/javase/tutorial/java/generics/)
- [Java 陣列](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html)

---

**練習提示**: 建立演示每種集合類型使用的小程式。專注於理解何時使用每種集合及其效能特徵。 