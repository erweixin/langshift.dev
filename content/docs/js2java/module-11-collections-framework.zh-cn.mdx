---
title: "模块 11：集合框架"
description: "学习 Java 集合框架、List、Set、Map 接口及其实现，对比 JavaScript 数组和对象集合。"
---

# 模块 11：集合框架

在本模块中，我们将探索 Java 的综合集合框架，并与 JavaScript 基于数组和对象的集合进行对比。我们将学习 List、Set 和 Map 接口、它们的实现以及如何有效使用它们。

## 学习目标

在本模块结束时，你将能够：
- 理解 Java 集合框架层次结构
- 对比 Java 集合与 JavaScript 数组和对象
- 有效使用 List、Set 和 Map 接口
- 选择合适的集合实现
- 在实际场景中应用集合
- 理解集合的性能特征

## 集合框架概述

### 1. List 接口和实现

Java 通过 List 接口提供有序集合，而 JavaScript 使用数组实现类似功能。

<UniversalEditor title="List 接口和实现" compare={true}>
```javascript !! js
// JavaScript - 基于数组的集合
// 数组作为 List 等价物
class ArrayList {
    constructor() {
        this.items = [];
    }
    
    add(item) {
        this.items.push(item);
    }
    
    addAt(index, item) {
        this.items.splice(index, 0, item);
    }
    
    get(index) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('索引越界');
        }
        return this.items[index];
    }
    
    set(index, item) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('索引越界');
        }
        this.items[index] = item;
    }
    
    remove(index) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('索引越界');
        }
        return this.items.splice(index, 1)[0];
    }
    
    removeItem(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            return this.remove(index);
        }
        return null;
    }
    
    size() {
        return this.items.length;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    contains(item) {
        return this.items.includes(item);
    }
    
    indexOf(item) {
        return this.items.indexOf(item);
    }
    
    clear() {
        this.items = [];
    }
    
    toArray() {
        return [...this.items];
    }
    
    toString() {
        return `[${this.items.join(', ')}]`;
    }
}

// 链表实现（模拟 LinkedList）
class ListNode {
    constructor(data) {
        this.data = data;
        this.next = null;
        this.prev = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    
    add(item) {
        const newNode = new ListNode(item);
        
        if (!this.head) {
            this.head = this.tail = newNode;
        } else {
            newNode.prev = this.tail;
            this.tail.next = newNode;
            this.tail = newNode;
        }
        this.length++;
    }
    
    addAt(index, item) {
        if (index < 0 || index > this.length) {
            throw new Error('索引越界');
        }
        
        if (index === this.length) {
            this.add(item);
            return;
        }
        
        const newNode = new ListNode(item);
        const current = this.getNodeAt(index);
        
        newNode.next = current;
        newNode.prev = current.prev;
        
        if (current.prev) {
            current.prev.next = newNode;
        } else {
            this.head = newNode;
        }
        
        current.prev = newNode;
        this.length++;
    }
    
    get(index) {
        const node = this.getNodeAt(index);
        return node.data;
    }
    
    getNodeAt(index) {
        if (index < 0 || index >= this.length) {
            throw new Error('索引越界');
        }
        
        let current;
        if (index < this.length / 2) {
            current = this.head;
            for (let i = 0; i < index; i++) {
                current = current.next;
            }
        } else {
            current = this.tail;
            for (let i = this.length - 1; i > index; i--) {
                current = current.prev;
            }
        }
        return current;
    }
    
    remove(index) {
        const node = this.getNodeAt(index);
        
        if (node.prev) {
            node.prev.next = node.next;
        } else {
            this.head = node.next;
        }
        
        if (node.next) {
            node.next.prev = node.prev;
        } else {
            this.tail = node.prev;
        }
        
        this.length--;
        return node.data;
    }
    
    size() {
        return this.length;
    }
    
    isEmpty() {
        return this.length === 0;
    }
    
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    
    toArray() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        return result;
    }
    
    toString() {
        return `[${this.toArray().join(', ')}]`;
    }
}

// 使用示例
const arrayList = new ArrayList();
arrayList.add("Apple");
arrayList.add("Banana");
arrayList.add("Cherry");

console.log("ArrayList:", arrayList.toString());
console.log("元素索引 1:", arrayList.get(1)); // "Banana"
console.log("包含 Apple:", arrayList.contains("Apple")); // true

const linkedList = new LinkedList();
linkedList.add("First");
linkedList.add("Second");
linkedList.add("Third");

console.log("LinkedList:", linkedList.toString());
console.log("大小:", linkedList.size()); // 3

// 数组方法对比
const numbers = [1, 2, 3, 4, 5];

// 添加元素
numbers.push(6); // 末尾添加
numbers.unshift(0); // 开头添加
numbers.splice(3, 0, 2.5); // 在索引 3 插入

// 删除元素
numbers.pop(); // 删除末尾
numbers.shift(); // 删除开头
numbers.splice(2, 1); // 删除索引 2

// 查找元素
const index = numbers.indexOf(3);
const found = numbers.find(x => x > 2);
const exists = numbers.includes(4);

// 转换操作
const doubled = numbers.map(x => x * 2);
const filtered = numbers.filter(x => x % 2 === 0);
const sum = numbers.reduce((acc, x) => acc + x, 0);

console.log("原始数组:", numbers);
console.log("翻倍:", doubled);
console.log("偶数:", filtered);
console.log("总和:", sum);
```

```java !! java
// Java - List 接口和实现
import java.util.*;

public class ListDemo {
    public static void main(String[] args) {
        // ArrayList - 动态数组实现
        List<String> arrayList = new ArrayList<>();
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add("Cherry");
        
        System.out.println("ArrayList: " + arrayList);
        System.out.println("元素索引 1: " + arrayList.get(1)); // "Banana"
        System.out.println("包含 Apple: " + arrayList.contains("Apple")); // true
        
        // 在指定位置插入
        arrayList.add(1, "Avocado");
        System.out.println("插入后: " + arrayList);
        
        // 删除元素
        arrayList.remove("Banana");
        arrayList.remove(0); // 删除索引 0
        System.out.println("删除后: " + arrayList);
        
        // LinkedList - 双向链表实现
        List<String> linkedList = new LinkedList<>();
        linkedList.add("First");
        linkedList.add("Second");
        linkedList.add("Third");
        
        System.out.println("LinkedList: " + linkedList);
        System.out.println("大小: " + linkedList.size()); // 3
        
        // LinkedList 特有方法
        LinkedList<String> ll = (LinkedList<String>) linkedList;
        ll.addFirst("Zero");
        ll.addLast("Fourth");
        System.out.println("添加首尾后: " + ll);
        
        String first = ll.removeFirst();
        String last = ll.removeLast();
        System.out.println("删除首尾: " + first + ", " + last);
        System.out.println("最终: " + ll);
        
        // Vector - 同步的 ArrayList
        List<Integer> vector = new Vector<>();
        vector.add(1);
        vector.add(2);
        vector.add(3);
        
        System.out.println("Vector: " + vector);
        
        // 列表操作示例
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        // 添加元素
        numbers.add(6); // 末尾添加
        numbers.add(0, 0); // 开头添加
        numbers.add(3, 2.5); // 在索引 3 插入（会编译错误，因为类型不匹配）
        // numbers.add(3, 2); // 正确的方式
        
        // 删除元素
        numbers.remove(numbers.size() - 1); // 删除末尾
        numbers.remove(0); // 删除开头
        numbers.remove(Integer.valueOf(3)); // 删除值为 3 的元素
        
        // 查找元素
        int index = numbers.indexOf(4);
        boolean exists = numbers.contains(5);
        
        System.out.println("处理后的数字列表: " + numbers);
        System.out.println("4 的索引: " + index);
        System.out.println("包含 5: " + exists);
        
        // 使用 Stream API 进行函数式操作
        List<Integer> originalNumbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // 转换操作
        List<Integer> doubled = originalNumbers.stream()
                .map(x -> x * 2)
                .collect(Collectors.toList());
        
        List<Integer> filtered = originalNumbers.stream()
                .filter(x -> x % 2 == 0)
                .collect(Collectors.toList());
        
        int sum = originalNumbers.stream()
                .mapToInt(Integer::intValue)
                .sum();
        
        System.out.println("原始列表: " + originalNumbers);
        System.out.println("翻倍: " + doubled);
        System.out.println("偶数: " + filtered);
        System.out.println("总和: " + sum);
        
        // 列表性能比较
        System.out.println("\n性能特征:");
        System.out.println("ArrayList - 随机访问: O(1), 插入/删除: O(n)");
        System.out.println("LinkedList - 随机访问: O(n), 插入/删除: O(1)");
        System.out.println("Vector - 与 ArrayList 类似，但线程安全");
    }
}
```
</UniversalEditor>

### 2. Set 接口和实现

Java 的 Set 接口确保唯一性，而 JavaScript 使用 Set 对象或对象属性实现类似功能。

<UniversalEditor title="Set 接口和实现" compare={true}>
```javascript !! js
// JavaScript - Set 和唯一性集合
// 原生 Set
const nativeSet = new Set();
nativeSet.add("Apple");
nativeSet.add("Banana");
nativeSet.add("Apple"); // 重复，不会添加

console.log("原生 Set:", nativeSet);
console.log("大小:", nativeSet.size); // 2
console.log("包含 Apple:", nativeSet.has("Apple")); // true

// 自定义 HashSet 实现
class HashSet {
    constructor() {
        this.items = {};
        this.count = 0;
    }
    
    add(item) {
        const key = this.hash(item);
        if (!this.items[key]) {
            this.items[key] = item;
            this.count++;
            return true;
        }
        return false;
    }
    
    remove(item) {
        const key = this.hash(item);
        if (this.items[key]) {
            delete this.items[key];
            this.count--;
            return true;
        }
        return false;
    }
    
    contains(item) {
        const key = this.hash(item);
        return this.items.hasOwnProperty(key);
    }
    
    size() {
        return this.count;
    }
    
    isEmpty() {
        return this.count === 0;
    }
    
    clear() {
        this.items = {};
        this.count = 0;
    }
    
    values() {
        return Object.values(this.items);
    }
    
    hash(item) {
        if (typeof item === 'string') {
            return item;
        } else if (typeof item === 'number') {
            return 'num_' + item;
        } else if (typeof item === 'object') {
            return 'obj_' + JSON.stringify(item);
        }
        return String(item);
    }
    
    toString() {
        return `{${this.values().join(', ')}}`;
    }
}

// 排序 Set 实现（模拟 TreeSet）
class TreeSet {
    constructor(compareFn = null) {
        this.items = [];
        this.compare = compareFn || ((a, b) => {
            if (a < b) return -1;
            if (a > b) return 1;
            return 0;
        });
    }
    
    add(item) {
        const index = this.findInsertionIndex(item);
        if (index < this.items.length && this.compare(this.items[index], item) === 0) {
            return false; // 已存在
        }
        this.items.splice(index, 0, item);
        return true;
    }
    
    remove(item) {
        const index = this.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }
    
    contains(item) {
        return this.indexOf(item) !== -1;
    }
    
    indexOf(item) {
        let left = 0;
        let right = this.items.length - 1;
        
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            const cmp = this.compare(this.items[mid], item);
            
            if (cmp === 0) {
                return mid;
            } else if (cmp < 0) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    
    findInsertionIndex(item) {
        let left = 0;
        let right = this.items.length;
        
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (this.compare(this.items[mid], item) < 0) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
    
    size() {
        return this.items.length;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    clear() {
        this.items = [];
    }
    
    first() {
        if (this.isEmpty()) {
            throw new Error('Set 为空');
        }
        return this.items[0];
    }
    
    last() {
        if (this.isEmpty()) {
            throw new Error('Set 为空');
        }
        return this.items[this.items.length - 1];
    }
    
    values() {
        return [...this.items];
    }
    
    toString() {
        return `{${this.items.join(', ')}}`;
    }
}

// 使用示例
console.log("\n=== HashSet 示例 ===");
const hashSet = new HashSet();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Cherry");
hashSet.add("Apple"); // 重复

console.log("HashSet:", hashSet.toString());
console.log("大小:", hashSet.size()); // 3
console.log("包含 Banana:", hashSet.contains("Banana")); // true

console.log("\n=== TreeSet 示例 ===");
const treeSet = new TreeSet();
treeSet.add(5);
treeSet.add(2);
treeSet.add(8);
treeSet.add(3);
treeSet.add(2); // 重复

console.log("TreeSet:", treeSet.toString()); // 自动排序
console.log("第一个:", treeSet.first()); // 2
console.log("最后一个:", treeSet.last()); // 8

// Set 操作
const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);

// 并集
const union = new Set([...set1, ...set2]);
console.log("并集:", union);

// 交集
const intersection = new Set([...set1].filter(x => set2.has(x)));
console.log("交集:", intersection);

// 差集
const difference = new Set([...set1].filter(x => !set2.has(x)));
console.log("差集:", difference);

// 对称差集
const symmetricDifference = new Set([
    ...[...set1].filter(x => !set2.has(x)),
    ...[...set2].filter(x => !set1.has(x))
]);
console.log("对称差集:", symmetricDifference);
```

```java !! java
// Java - Set 接口和实现
import java.util.*;

public class SetDemo {
    public static void main(String[] args) {
        // HashSet - 基于哈希表的实现
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Cherry");
        hashSet.add("Apple"); // 重复，不会添加
        
        System.out.println("HashSet: " + hashSet);
        System.out.println("大小: " + hashSet.size()); // 3
        System.out.println("包含 Banana: " + hashSet.contains("Banana")); // true
        
        // TreeSet - 基于红黑树的排序实现
        Set<Integer> treeSet = new TreeSet<>();
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
        treeSet.add(3);
        treeSet.add(2); // 重复，不会添加
        
        System.out.println("TreeSet: " + treeSet); // 自动排序
        
        // TreeSet 特有方法
        TreeSet<Integer> ts = (TreeSet<Integer>) treeSet;
        System.out.println("第一个: " + ts.first()); // 2
        System.out.println("最后一个: " + ts.last()); // 8
        System.out.println("小于 5 的元素: " + ts.headSet(5)); // [2, 3]
        System.out.println("大于等于 5 的元素: " + ts.tailSet(5)); // [5, 8]
        System.out.println("3 到 7 之间: " + ts.subSet(3, 8)); // [3, 5]
        
        // LinkedHashSet - 保持插入顺序的 HashSet
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("First");
        linkedHashSet.add("Second");
        linkedHashSet.add("Third");
        linkedHashSet.add("First"); // 重复
        
        System.out.println("LinkedHashSet: " + linkedHashSet); // 保持插入顺序
        
        // Set 操作示例
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        
        // 并集
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("并集: " + union);
        
        // 交集
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("交集: " + intersection);
        
        // 差集
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("差集: " + difference);
        
        // 对称差集
        Set<Integer> symmetricDifference = new HashSet<>(set1);
        symmetricDifference.addAll(set2);
        Set<Integer> temp = new HashSet<>(set1);
        temp.retainAll(set2);
        symmetricDifference.removeAll(temp);
        System.out.println("对称差集: " + symmetricDifference);
        
        // 使用 Stream API 进行集合操作
        Set<String> fruits = Set.of("apple", "banana", "cherry", "date");
        
        // 过滤
        Set<String> longNames = fruits.stream()
                .filter(s -> s.length() > 5)
                .collect(Collectors.toSet());
        System.out.println("长名称水果: " + longNames);
        
        // 转换
        Set<String> upperCaseFruits = fruits.stream()
                .map(String::toUpperCase)
                .collect(Collectors.toSet());
        System.out.println("大写水果: " + upperCaseFruits);
        
        // 性能特征
        System.out.println("\n性能特征:");
        System.out.println("HashSet - 添加/删除/查找: 平均 O(1)");
        System.out.println("TreeSet - 添加/删除/查找: O(log n), 有序");
        System.out.println("LinkedHashSet - 与 HashSet 相似，但保持插入顺序");
    }
}
```
</UniversalEditor>

### 3. Map 接口和实现

Java 的 Map 接口提供键值对存储，而 JavaScript 使用对象或 Map 对象。

<UniversalEditor title="Map 接口和实现" compare={true}>
```javascript !! js
// JavaScript - 对象和 Map
// 原生 Map
const nativeMap = new Map();
nativeMap.set("name", "张三");
nativeMap.set("age", 30);
nativeMap.set("city", "北京");

console.log("原生 Map:", nativeMap);
console.log("姓名:", nativeMap.get("name"));
console.log("包含 age:", nativeMap.has("age"));
console.log("大小:", nativeMap.size);

// 对象作为 Map
const objMap = {
    name: "李四",
    age: 25,
    city: "上海"
};

console.log("对象 Map:", objMap);
console.log("姓名:", objMap.name);
console.log("包含 age:", "age" in objMap);

// 自定义 HashMap 实现
class HashMap {
    constructor(initialCapacity = 16) {
        this.buckets = new Array(initialCapacity);
        this.size = 0;
        this.capacity = initialCapacity;
        this.loadFactor = 0.75;
    }
    
    hash(key) {
        let hash = 0;
        const str = String(key);
        for (let i = 0; i < str.length; i++) {
            hash = ((hash << 5) - hash + str.charCodeAt(i)) & 0x7fffffff;
        }
        return hash % this.capacity;
    }
    
    put(key, value) {
        if (this.size >= this.capacity * this.loadFactor) {
            this.resize();
        }
        
        const index = this.hash(key);
        if (!this.buckets[index]) {
            this.buckets[index] = [];
        }
        
        const bucket = this.buckets[index];
        for (let i = 0; i < bucket.length; i++) {
            if (bucket[i].key === key) {
                const oldValue = bucket[i].value;
                bucket[i].value = value;
                return oldValue;
            }
        }
        
        bucket.push({ key, value });
        this.size++;
        return null;
    }
    
    get(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        if (bucket) {
            for (const entry of bucket) {
                if (entry.key === key) {
                    return entry.value;
                }
            }
        }
        return undefined;
    }
    
    remove(key) {
        const index = this.hash(key);
        const bucket = this.buckets[index];
        
        if (bucket) {
            for (let i = 0; i < bucket.length; i++) {
                if (bucket[i].key === key) {
                    const value = bucket[i].value;
                    bucket.splice(i, 1);
                    this.size--;
                    return value;
                }
            }
        }
        return undefined;
    }
    
    containsKey(key) {
        return this.get(key) !== undefined;
    }
    
    containsValue(value) {
        for (const bucket of this.buckets) {
            if (bucket) {
                for (const entry of bucket) {
                    if (entry.value === value) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    keys() {
        const result = [];
        for (const bucket of this.buckets) {
            if (bucket) {
                for (const entry of bucket) {
                    result.push(entry.key);
                }
            }
        }
        return result;
    }
    
    values() {
        const result = [];
        for (const bucket of this.buckets) {
            if (bucket) {
                for (const entry of bucket) {
                    result.push(entry.value);
                }
            }
        }
        return result;
    }
    
    entries() {
        const result = [];
        for (const bucket of this.buckets) {
            if (bucket) {
                for (const entry of bucket) {
                    result.push([entry.key, entry.value]);
                }
            }
        }
        return result;
    }
    
    clear() {
        this.buckets = new Array(this.capacity);
        this.size = 0;
    }
    
    isEmpty() {
        return this.size === 0;
    }
    
    getSize() {
        return this.size;
    }
    
    resize() {
        const oldBuckets = this.buckets;
        this.capacity *= 2;
        this.buckets = new Array(this.capacity);
        this.size = 0;
        
        for (const bucket of oldBuckets) {
            if (bucket) {
                for (const entry of bucket) {
                    this.put(entry.key, entry.value);
                }
            }
        }
    }
    
    toString() {
        const entries = this.entries().map(([k, v]) => `${k}: ${v}`);
        return `{${entries.join(', ')}}`;
    }
}

// 排序 Map 实现（模拟 TreeMap）
class TreeMap {
    constructor(compareFn = null) {
        this.entries = [];
        this.compare = compareFn || ((a, b) => {
            if (a < b) return -1;
            if (a > b) return 1;
            return 0;
        });
    }
    
    put(key, value) {
        const index = this.findInsertionIndex(key);
        if (index < this.entries.length && this.compare(this.entries[index].key, key) === 0) {
            const oldValue = this.entries[index].value;
            this.entries[index].value = value;
            return oldValue;
        }
        this.entries.splice(index, 0, { key, value });
        return null;
    }
    
    get(key) {
        const index = this.indexOf(key);
        return index !== -1 ? this.entries[index].value : undefined;
    }
    
    remove(key) {
        const index = this.indexOf(key);
        if (index !== -1) {
            const value = this.entries[index].value;
            this.entries.splice(index, 1);
            return value;
        }
        return undefined;
    }
    
    containsKey(key) {
        return this.indexOf(key) !== -1;
    }
    
    indexOf(key) {
        let left = 0;
        let right = this.entries.length - 1;
        
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            const cmp = this.compare(this.entries[mid].key, key);
            
            if (cmp === 0) {
                return mid;
            } else if (cmp < 0) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    
    findInsertionIndex(key) {
        let left = 0;
        let right = this.entries.length;
        
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (this.compare(this.entries[mid].key, key) < 0) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
    
    keys() {
        return this.entries.map(entry => entry.key);
    }
    
    values() {
        return this.entries.map(entry => entry.value);
    }
    
    size() {
        return this.entries.length;
    }
    
    firstKey() {
        if (this.entries.length === 0) {
            throw new Error('Map 为空');
        }
        return this.entries[0].key;
    }
    
    lastKey() {
        if (this.entries.length === 0) {
            throw new Error('Map 为空');
        }
        return this.entries[this.entries.length - 1].key;
    }
    
    toString() {
        const entryStrings = this.entries.map(e => `${e.key}: ${e.value}`);
        return `{${entryStrings.join(', ')}}`;
    }
}

// 使用示例
console.log("\n=== HashMap 示例 ===");
const hashMap = new HashMap();
hashMap.put("name", "王五");
hashMap.put("age", 28);
hashMap.put("city", "深圳");

console.log("HashMap:", hashMap.toString());
console.log("姓名:", hashMap.get("name"));
console.log("包含 age:", hashMap.containsKey("age"));
console.log("所有键:", hashMap.keys());

console.log("\n=== TreeMap 示例 ===");
const treeMap = new TreeMap();
treeMap.put("c", 3);
treeMap.put("a", 1);
treeMap.put("b", 2);

console.log("TreeMap:", treeMap.toString()); // 自动按键排序
console.log("第一个键:", treeMap.firstKey());
console.log("最后一个键:", treeMap.lastKey());

// Map 操作
const studentGrades = new Map([
    ["张三", 85],
    ["李四", 92],
    ["王五", 78],
    ["赵六", 96]
]);

console.log("\n=== 学生成绩 ===");
for (const [name, grade] of studentGrades) {
    console.log(`${name}: ${grade}`);
}

// 查找最高分
let maxGrade = 0;
let topStudent = "";
for (const [name, grade] of studentGrades) {
    if (grade > maxGrade) {
        maxGrade = grade;
        topStudent = name;
    }
}
console.log(`最高分: ${topStudent} (${maxGrade})`);

// 计算平均分
const totalGrades = Array.from(studentGrades.values());
const average = totalGrades.reduce((sum, grade) => sum + grade, 0) / totalGrades.length;
console.log(`平均分: ${average.toFixed(2)}`);
```

```java !! java
// Java - Map 接口和实现
import java.util.*;

public class MapDemo {
    public static void main(String[] args) {
        // HashMap - 基于哈希表的实现
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("name", "张三");
        hashMap.put("age", "30");
        hashMap.put("city", "北京");
        
        System.out.println("HashMap: " + hashMap);
        System.out.println("姓名: " + hashMap.get("name"));
        System.out.println("包含 age: " + hashMap.containsKey("age"));
        System.out.println("包含值 '北京': " + hashMap.containsValue("北京"));
        
        // TreeMap - 基于红黑树的排序实现
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("c", 3);
        treeMap.put("a", 1);
        treeMap.put("b", 2);
        treeMap.put("d", 4);
        
        System.out.println("TreeMap: " + treeMap); // 自动按键排序
        
        // TreeMap 特有方法
        TreeMap<String, Integer> tm = (TreeMap<String, Integer>) treeMap;
        System.out.println("第一个键: " + tm.firstKey()); // "a"
        System.out.println("最后一个键: " + tm.lastKey()); // "d"
        System.out.println("小于 'c' 的条目: " + tm.headMap("c")); // {a=1, b=2}
        System.out.println("大于等于 'c' 的条目: " + tm.tailMap("c")); // {c=3, d=4}
        System.out.println("'b' 到 'd' 之间: " + tm.subMap("b", "d")); // {b=2, c=3}
        
        // LinkedHashMap - 保持插入顺序的 HashMap
        Map<String, String> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("first", "第一个");
        linkedHashMap.put("second", "第二个");
        linkedHashMap.put("third", "第三个");
        
        System.out.println("LinkedHashMap: " + linkedHashMap); // 保持插入顺序
        
        // Hashtable - 同步的 HashMap（遗留类）
        Map<String, String> hashtable = new Hashtable<>();
        hashtable.put("sync", "同步");
        hashtable.put("legacy", "遗留");
        
        System.out.println("Hashtable: " + hashtable);
        
        // Map 操作示例
        Map<String, Integer> studentGrades = new HashMap<>();
        studentGrades.put("张三", 85);
        studentGrades.put("李四", 92);
        studentGrades.put("王五", 78);
        studentGrades.put("赵六", 96);
        
        System.out.println("\n=== 学生成绩 ===");
        
        // 遍历 Map
        for (Map.Entry<String, Integer> entry : studentGrades.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 使用 forEach (Java 8+)
        System.out.println("\n使用 forEach:");
        studentGrades.forEach((name, grade) -> 
            System.out.println(name + ": " + grade));
        
        // 查找最高分
        String topStudent = studentGrades.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("无");
        
        int maxGrade = Collections.max(studentGrades.values());
        System.out.println("最高分: " + topStudent + " (" + maxGrade + ")");
        
        // 计算平均分
        double average = studentGrades.values().stream()
                .mapToInt(Integer::intValue)
                .average()
                .orElse(0.0);
        System.out.println("平均分: " + String.format("%.2f", average));
        
        // 过滤及格学生
        Map<String, Integer> passedStudents = studentGrades.entrySet().stream()
                .filter(entry -> entry.getValue() >= 80)
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    Map.Entry::getValue
                ));
        System.out.println("及格学生: " + passedStudents);
        
        // Map 合并操作
        Map<String, Integer> additionalGrades = Map.of(
            "孙七", 88,
            "周八", 91
        );
        
        Map<String, Integer> allGrades = new HashMap<>(studentGrades);
        allGrades.putAll(additionalGrades);
        System.out.println("所有成绩: " + allGrades);
        
        // 使用 merge 方法
        Map<String, Integer> gradeUpdates = Map.of(
            "张三", 90,  // 更新
            "新学生", 85 // 新增
        );
        
        gradeUpdates.forEach((name, grade) -> 
            allGrades.merge(name, grade, Integer::max)); // 取最大值
        
        System.out.println("合并后成绩: " + allGrades);
        
        // 性能特征
        System.out.println("\n性能特征:");
        System.out.println("HashMap - 查找/插入/删除: 平均 O(1)");
        System.out.println("TreeMap - 查找/插入/删除: O(log n), 有序");
        System.out.println("LinkedHashMap - 与 HashMap 相似，但保持插入顺序");
        System.out.println("Hashtable - 与 HashMap 相似，但线程安全（已过时）");
    }
}
```
</UniversalEditor>

## 练习题

### 练习 1: 集合基础操作

<UniversalEditor title="练习 1: 集合基础操作">
```java !! java
// TODO: 实现集合基础操作
import java.util.*;

public class CollectionExercise1 {
    
    // TODO: 创建并操作 List
    public static void listOperations() {
        // TODO: 创建 ArrayList 并添加水果名称
        // TODO: 在指定位置插入元素
        // TODO: 删除指定元素和指定位置的元素
        // TODO: 查找元素索引
        // TODO: 使用 Collections.sort() 排序
        // TODO: 使用 Collections.reverse() 反转
        System.out.println("List 操作完成");
    }
    
    // TODO: 创建并操作 Set
    public static void setOperations() {
        // TODO: 创建 HashSet 并添加重复元素
        // TODO: 创建 TreeSet 并观察自动排序
        // TODO: 创建 LinkedHashSet 并观察插入顺序
        // TODO: 执行集合的并集、交集、差集操作
        System.out.println("Set 操作完成");
    }
    
    // TODO: 创建并操作 Map
    public static void mapOperations() {
        // TODO: 创建 HashMap 存储学生信息
        // TODO: 创建 TreeMap 并观察键的排序
        // TODO: 使用 putIfAbsent、merge 等方法
        // TODO: 遍历 Map 的不同方式
        System.out.println("Map 操作完成");
    }
    
    public static void main(String[] args) {
        listOperations();
        setOperations();
        mapOperations();
    }
}
```
</UniversalEditor>

### 练习 2: 高级集合应用

<UniversalEditor title="练习 2: 高级集合应用">
```java !! java
// TODO: 实现高级集合应用
import java.util.*;
import java.util.stream.Collectors;

public class CollectionExercise2 {
    
    // TODO: 实现图书管理系统
    static class Book {
        // TODO: 添加 title, author, year, isbn 字段
        // TODO: 实现构造函数
        // TODO: 实现 getter 方法
        // TODO: 重写 toString, equals, hashCode 方法
    }
    
    static class Library {
        // TODO: 使用适当的集合存储图书
        // TODO: 实现添加图书方法
        // TODO: 实现按标题查找图书方法
        // TODO: 实现按作者查找图书方法
        // TODO: 实现按年份范围查找图书方法
        // TODO: 实现删除图书方法
        // TODO: 实现获取所有作者列表方法（无重复）
        // TODO: 实现统计每个作者的图书数量方法
    }
    
    // TODO: 实现单词频率统计器
    static class WordCounter {
        // TODO: 使用 Map 存储单词和频率
        // TODO: 实现添加单词方法
        // TODO: 实现获取频率方法
        // TODO: 实现获取最常见单词方法
        // TODO: 实现按频率排序的单词列表方法
    }
    
    // TODO: 实现学生成绩管理系统
    static class Student {
        // TODO: 添加 name, id 字段
        // TODO: 实现构造函数和 getter 方法
        // TODO: 重写 equals, hashCode 方法
    }
    
    static class GradeManager {
        // TODO: 使用 Map<Student, Map<String, Integer>> 存储成绩
        // TODO: 实现添加成绩方法
        // TODO: 实现获取学生平均分方法
        // TODO: 实现获取科目平均分方法
        // TODO: 实现获取最高分学生方法
        // TODO: 实现获取不及格学生列表方法
    }
    
    public static void main(String[] args) {
        // TODO: 测试图书管理系统
        System.out.println("=== 图书管理系统测试 ===");
        Library library = new Library();
        // TODO: 添加测试数据并调用各种方法
        
        // TODO: 测试单词频率统计器
        System.out.println("\n=== 单词频率统计器测试 ===");
        WordCounter counter = new WordCounter();
        // TODO: 添加测试数据并调用各种方法
        
        // TODO: 测试学生成绩管理系统
        System.out.println("\n=== 学生成绩管理系统测试 ===");
        GradeManager gradeManager = new GradeManager();
        // TODO: 添加测试数据并调用各种方法
    }
}
```
</UniversalEditor>

## 总结

在本模块中，我们深入探索了 Java 集合框架，并与 JavaScript 的集合处理方法进行了对比：

### 关键要点：
1. **List 接口**：有序集合，允许重复元素
2. **Set 接口**：无重复元素的集合
3. **Map 接口**：键值对映射
4. **实现选择**：根据性能需求选择合适的实现
5. **Stream API**：现代函数式集合操作

### 性能对比：
- **ArrayList vs LinkedList**：随机访问 vs 插入删除
- **HashSet vs TreeSet**：哈希查找 vs 有序存储
- **HashMap vs TreeMap**：哈希查找 vs 有序键

### 下一步：
- 掌握各种集合的使用场景
- 练习集合的组合使用
- 学习 Stream API 高级操作
- 准备下一个模块：并发编程

## 其他资源

- [Java Collections Framework](https://docs.oracle.com/javase/tutorial/collections/)
- [Java Collection Performance](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)
- [Java Stream API](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

---

**练习提示**：重点理解不同集合的性能特征和使用场景。练习使用 Stream API 进行函数式编程。在实际项目中合理选择集合类型以优化性能。
