---
title: "模块 07: 继承和多态"
description: "学习 Java 继承、多态、方法重写和抽象类，与 JavaScript 原型继承进行对比。"
---

# 模块 07: 继承和多态

在本模块中，我们将探索 Java 的继承和多态机制，并将其与 JavaScript 基于原型的继承进行对比。Java 提供了具有方法重写和多态的结构化类层次结构，而 JavaScript 使用原型链进行继承。

## 学习目标

通过本模块的学习，你将能够：
- 理解 Java 继承和类层次结构
- 对比 Java 继承与 JavaScript 原型链
- 实现方法重写和多态
- 使用抽象类和方法
- 应用继承最佳实践
- 理解继承和组合之间的差异

## 继承基础

### 1. 类继承

Java 使用 `extends` 关键字进行显式类继承，而 JavaScript 使用原型链。

<UniversalEditor title="类继承" compare={true}>
```javascript !! js
// JavaScript - 基于原型的继承
// 基类（构造函数）
function Animal(name, species) {
    this.name = name;
    this.species = species;
}

// 向原型添加方法
Animal.prototype.makeSound = function() {
    return "Some animal sound";
};

Animal.prototype.getInfo = function() {
    return `${this.name} is a ${this.species}`;
};

Animal.prototype.sleep = function() {
    return `${this.name} is sleeping`;
};

// 派生类（构造函数）
function Dog(name, breed) {
    // 调用父构造函数
    Animal.call(this, name, "Dog");
    this.breed = breed;
}

// 设置原型链
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

// 重写方法
Dog.prototype.makeSound = function() {
    return "Woof! Woof!";
};

// 添加新方法
Dog.prototype.fetch = function() {
    return `${this.name} is fetching the ball`;
};

// ES6 类继承
class AnimalClass {
    constructor(name, species) {
        this.name = name;
        this.species = species;
    }
    
    makeSound() {
        return "Some animal sound";
    }
    
    getInfo() {
        return `${this.name} is a ${this.species}`;
    }
    
    sleep() {
        return `${this.name} is sleeping`;
    }
}

class DogClass extends AnimalClass {
    constructor(name, breed) {
        super(name, "Dog"); // 调用父构造函数
        this.breed = breed;
    }
    
    // 重写方法
    makeSound() {
        return "Woof! Woof!";
    }
    
    // 添加新方法
    fetch() {
        return `${this.name} is fetching the ball`;
    }
}

class CatClass extends AnimalClass {
    constructor(name, color) {
        super(name, "Cat");
        this.color = color;
    }
    
    // 重写方法
    makeSound() {
        return "Meow! Meow!";
    }
    
    // 添加新方法
    climb() {
        return `${this.name} is climbing the tree`;
    }
}

// 使用示例
const animal = new Animal("Generic", "Unknown");
const dog = new Dog("Buddy", "Golden Retriever");
const cat = new CatClass("Whiskers", "Orange");

console.log(animal.makeSound());
console.log(dog.makeSound());
console.log(cat.makeSound());

console.log(dog.getInfo());
console.log(dog.fetch());
console.log(cat.climb());

// 检查继承
console.log(dog instanceof Animal); // true
console.log(dog instanceof Dog); // true
console.log(cat instanceof AnimalClass); // true
```

```java !! java
// Java - 基于类的继承
public class Animal {
    // 受保护字段（在子类中可访问）
    protected String name;
    protected String species;
    
    // 构造函数
    public Animal(String name, String species) {
        this.name = name;
        this.species = species;
    }
    
    // 可以重写的方法
    public String makeSound() {
        return "Some animal sound";
    }
    
    public String getInfo() {
        return name + " is a " + species;
    }
    
    public String sleep() {
        return name + " is sleeping";
    }
    
    // Final 方法（不能重写）
    public final String getSpecies() {
        return species;
    }
    
    // 静态方法
    public static String getAnimalType() {
        return "Animal";
    }
    
    // Getter 方法
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

// 使用继承的派生类
public class Dog extends Animal {
    private String breed;
    
    // 调用父构造函数的构造函数
    public Dog(String name, String breed) {
        super(name, "Dog"); // 调用父构造函数
        this.breed = breed;
    }
    
    // 方法重写
    @Override
    public String makeSound() {
        return "Woof! Woof!";
    }
    
    // 添加新方法
    public String fetch() {
        return name + " is fetching the ball";
    }
    
    // 重写 getInfo 以包含品种
    @Override
    public String getInfo() {
        return super.getInfo() + " (Breed: " + breed + ")";
    }
    
    // Breed 的 getter
    public String getBreed() {
        return breed;
    }
    
    public void setBreed(String breed) {
        this.breed = breed;
    }
}

// 另一个派生类
public class Cat extends Animal {
    private String color;
    
    public Cat(String name, String color) {
        super(name, "Cat");
        this.color = color;
    }
    
    // 方法重写
    @Override
    public String makeSound() {
        return "Meow! Meow!";
    }
    
    // 添加新方法
    public String climb() {
        return name + " is climbing the tree";
    }
    
    // 重写 getInfo 以包含颜色
    @Override
    public String getInfo() {
        return super.getInfo() + " (Color: " + color + ")";
    }
    
    // Color 的 getter
    public String getColor() {
        return color;
    }
    
    public void setColor(String color) {
        this.color = color;
    }
}

// 主类演示继承
class InheritanceDemo {
    public static void main(String[] args) {
        Animal animal = new Animal("Generic", "Unknown");
        Dog dog = new Dog("Buddy", "Golden Retriever");
        Cat cat = new Cat("Whiskers", "Orange");
        
        // 方法调用
        System.out.println(animal.makeSound());
        System.out.println(dog.makeSound());
        System.out.println(cat.makeSound());
        
        System.out.println(dog.getInfo());
        System.out.println(dog.fetch());
        System.out.println(cat.climb());
        
        // 多态
        Animal[] animals = {animal, dog, cat};
        for (Animal a : animals) {
            System.out.println(a.makeSound()); // 每种类型的不同行为
        }
        
        // Instanceof 检查
        System.out.println("Dog is Animal: " + (dog instanceof Animal));
        System.out.println("Dog is Dog: " + (dog instanceof Dog));
        System.out.println("Cat is Animal: " + (cat instanceof Animal));
        
        // 访问受保护字段
        System.out.println("Dog species: " + dog.getSpecies());
    }
}
```
</UniversalEditor>

### 2. 方法重写和多态

Java 提供带有 `@Override` 注解的显式方法重写，而 JavaScript 使用基于原型的方法替换。

<UniversalEditor title="方法重写和多态" compare={true}>
```javascript !! js
// JavaScript - 方法重写和多态
// 基类
class Shape {
    constructor(color) {
        this.color = color;
    }
    
    getArea() {
        return 0;
    }
    
    getPerimeter() {
        return 0;
    }
    
    getInfo() {
        return `Shape with color ${this.color}`;
    }
    
    // 静态方法
    static getShapeType() {
        return "Shape";
    }
}

// 派生类
class Circle extends Shape {
    constructor(color, radius) {
        super(color);
        this.radius = radius;
    }
    
    // 重写方法
    getArea() {
        return Math.PI * this.radius * this.radius;
    }
    
    getPerimeter() {
        return 2 * Math.PI * this.radius;
    }
    
    getInfo() {
        return `Circle with radius ${this.radius} and color ${this.color}`;
    }
    
    // 添加新方法
    getDiameter() {
        return 2 * this.radius;
    }
}

class Rectangle extends Shape {
    constructor(color, width, height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    // 重写方法
    getArea() {
        return this.width * this.height;
    }
    
    getPerimeter() {
        return 2 * (this.width + this.height);
    }
    
    getInfo() {
        return `Rectangle with width ${this.width}, height ${this.height} and color ${this.color}`;
    }
    
    // 添加新方法
    isSquare() {
        return this.width === this.height;
    }
}

class Triangle extends Shape {
    constructor(color, side1, side2, side3) {
        super(color);
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }
    
    // 重写方法
    getArea() {
        // 海伦公式
        const s = (this.side1 + this.side2 + this.side3) / 2;
        return Math.sqrt(s * (s - this.side1) * (s - this.side2) * (s - this.side3));
    }
    
    getPerimeter() {
        return this.side1 + this.side2 + this.side3;
    }
    
    getInfo() {
        return `Triangle with sides ${this.side1}, ${this.side2}, ${this.side3} and color ${this.color}`;
    }
    
    // 添加新方法
    isEquilateral() {
        return this.side1 === this.side2 && this.side2 === this.side3;
    }
}

// 多态演示
function demonstratePolymorphism() {
    const shapes = [
        new Shape("black"),
        new Circle("red", 5),
        new Rectangle("blue", 4, 6),
        new Triangle("green", 3, 4, 5)
    ];
    
    shapes.forEach(shape => {
        console.log(shape.getInfo());
        console.log(`Area: ${shape.getArea().toFixed(2)}`);
        console.log(`Perimeter: ${shape.getPerimeter().toFixed(2)}`);
        console.log("---");
    });
}

// 方法重写与不同方法
class AdvancedShape extends Shape {
    constructor(color, name) {
        super(color);
        this.name = name;
    }
    
    // 重写并添加额外功能
    getInfo() {
        const baseInfo = super.getInfo();
        return `${baseInfo} - Name: ${this.name}`;
    }
    
    // 重写为完全不同的行为
    getArea() {
        return -1; // 表示面积未计算
    }
}

// 使用
demonstratePolymorphism();

const circle = new Circle("red", 5);
const rectangle = new Rectangle("blue", 4, 6);
const triangle = new Triangle("green", 3, 4, 5);

console.log("Circle diameter:", circle.getDiameter());
console.log("Rectangle is square:", rectangle.isSquare());
console.log("Triangle is equilateral:", triangle.isEquilateral());

// 多态数组
const shapes = [circle, rectangle, triangle];
shapes.forEach(shape => {
    console.log(`${shape.constructor.name} area: ${shape.getArea().toFixed(2)}`);
});
```

```java !! java
// Java - 方法重写和多态
public abstract class Shape {
    protected String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // 抽象方法（必须由子类实现）
    public abstract double getArea();
    public abstract double getPerimeter();
    
    // 可以重写的具体方法
    public String getInfo() {
        return "Shape with color " + color;
    }
    
    // Final 方法（不能重写）
    public final String getColor() {
        return color;
    }
    
    // 静态方法
    public static String getShapeType() {
        return "Shape";
    }
    
    // Setter
    public void setColor(String color) {
        this.color = color;
    }
}

// 具体派生类
public class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    // 重写抽象方法
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
    
    // 重写具体方法
    @Override
    public String getInfo() {
        return String.format("Circle with radius %.2f and color %s", radius, color);
    }
    
    // 添加新方法
    public double getDiameter() {
        return 2 * radius;
    }
    
    // Getters 和 setters
    public double getRadius() {
        return radius;
    }
    
    public void setRadius(double radius) {
        this.radius = radius;
    }
}

public class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }
    
    // 重写抽象方法
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
    
    // 重写具体方法
    @Override
    public String getInfo() {
        return String.format("Rectangle with width %.2f, height %.2f and color %s", 
                           width, height, color);
    }
    
    // 添加新方法
    public boolean isSquare() {
        return width == height;
    }
    
    // Getters 和 setters
    public double getWidth() {
        return width;
    }
    
    public void setWidth(double width) {
        this.width = width;
    }
    
    public double getHeight() {
        return height;
    }
    
    public void setHeight(double height) {
        this.height = height;
    }
}

public class Triangle extends Shape {
    private double side1;
    private double side2;
    private double side3;
    
    public Triangle(String color, double side1, double side2, double side3) {
        super(color);
        this.side1 = side1;
        this.side2 = side2;
        this.side3 = side3;
    }
    
    // 重写抽象方法
    @Override
    public double getArea() {
        // 海伦公式
        double s = (side1 + side2 + side3) / 2;
        return Math.sqrt(s * (s - side1) * (s - side2) * (s - side3));
    }
    
    @Override
    public double getPerimeter() {
        return side1 + side2 + side3;
    }
    
    // 重写具体方法
    @Override
    public String getInfo() {
        return String.format("Triangle with sides %.2f, %.2f, %.2f and color %s", 
                           side1, side2, side3, color);
    }
    
    // 添加新方法
    public boolean isEquilateral() {
        return side1 == side2 && side2 == side3;
    }
    
    // Getters 和 setters
    public double getSide1() { return side1; }
    public void setSide1(double side1) { this.side1 = side1; }
    public double getSide2() { return side2; }
    public void setSide2(double side2) { this.side2 = side2; }
    public double getSide3() { return side3; }
    public void setSide3(double side3) { this.side3 = side3; }
}

// 主类演示多态
class PolymorphismDemo {
    public static void main(String[] args) {
        // 创建不同的形状
        Circle circle = new Circle("red", 5);
        Rectangle rectangle = new Rectangle("blue", 4, 6);
        Triangle triangle = new Triangle("green", 3, 4, 5);
        
        // 多态数组
        Shape[] shapes = {circle, rectangle, triangle};
        
        // 演示多态
        for (Shape shape : shapes) {
            System.out.println(shape.getInfo());
            System.out.printf("Area: %.2f%n", shape.getArea());
            System.out.printf("Perimeter: %.2f%n", shape.getPerimeter());
            System.out.println("---");
        }
        
        // 通过类型转换访问特定方法
        System.out.println("Circle diameter: " + circle.getDiameter());
        System.out.println("Rectangle is square: " + rectangle.isSquare());
        System.out.println("Triangle is equilateral: " + triangle.isEquilateral());
        
        // 多态方法调用
        demonstratePolymorphism(shapes);
        
        // 方法重写演示
        System.out.println("Shape type: " + Shape.getShapeType());
        System.out.println("Circle color: " + circle.getColor());
    }
    
    // 演示多态的方法
    public static void demonstratePolymorphism(Shape[] shapes) {
        System.out.println("Polymorphic method calls:");
        for (Shape shape : shapes) {
            System.out.printf("%s area: %.2f%n", 
                            shape.getClass().getSimpleName(), shape.getArea());
        }
    }
}
```
</UniversalEditor>

## 抽象类和方法

### 1. 抽象类

Java 提供抽象类进行部分实现，而 JavaScript 没有直接等价物。

<UniversalEditor title="抽象类和方法" compare={true}>
```javascript !! js
// JavaScript - 模拟抽象类
// 具有抽象类方法的基类
class AbstractVehicle {
    constructor(make, model, year) {
        if (new.target === AbstractVehicle) {
            throw new Error("AbstractVehicle cannot be instantiated directly");
        }
        this.make = make;
        this.model = model;
        this.year = year;
    }
    
    // 抽象类方法（必须由子类实现）
    startEngine() {
        throw new Error("startEngine method must be implemented");
    }
    
    // 抽象类方法
    getVehicleType() {
        throw new Error("getVehicleType method must be implemented");
    }
    
    // 具体方法
    getInfo() {
        return `${this.year} ${this.make} ${this.model}`;
    }
    
    // 具体方法
    getAge() {
        const currentYear = new Date().getFullYear();
        return currentYear - this.year;
    }
    
    // 静态方法
    static getVehicleCategory() {
        return "Vehicle";
    }
}

// 具体派生类
class Car extends AbstractVehicle {
    constructor(make, model, year, fuelType) {
        super(make, model, year);
        this.fuelType = fuelType;
    }
    
    // 实现抽象类方法
    startEngine() {
        return `Starting ${this.fuelType} engine of ${this.getInfo()}`;
    }
    
    // 实现抽象类方法
    getVehicleType() {
        return "Car";
    }
    
    // 添加新方法
    honk() {
        return "Honk! Honk!";
    }
    
    // 重写具体方法
    getInfo() {
        return `${super.getInfo()} (${this.fuelType})`;
    }
}

class Motorcycle extends AbstractVehicle {
    constructor(make, model, year, engineSize) {
        super(make, model, year);
        this.engineSize = engineSize;
    }
    
    // 实现抽象类方法
    startEngine() {
        return `Starting ${this.engineSize}cc engine of ${this.getInfo()}`;
    }
    
    // 实现抽象类方法
    getVehicleType() {
        return "Motorcycle";
    }
    
    // 添加新方法
    wheelie() {
        return "Doing a wheelie!";
    }
    
    // 重写具体方法
    getInfo() {
        return `${super.getInfo()} (${this.engineSize}cc)`;
    }
}

// 创建车辆的工厂模式
class VehicleFactory {
    static createVehicle(type, make, model, year, ...args) {
        switch (type.toLowerCase()) {
            case 'car':
                return new Car(make, model, year, args[0]);
            case 'motorcycle':
                return new Motorcycle(make, model, year, args[0]);
            default:
                throw new Error(`Unknown vehicle type: ${type}`);
        }
    }
}

// 使用示例
try {
    // 这会抛出错误
    // const vehicle = new AbstractVehicle("Generic", "Model", 2020);
} catch (error) {
    console.log("Error:", error.message);
}

const car = new Car("Toyota", "Camry", 2020, "Gasoline");
const motorcycle = new Motorcycle("Honda", "CBR600RR", 2019, 600);

console.log(car.startEngine());
console.log(motorcycle.startEngine());

console.log(car.getVehicleType());
console.log(motorcycle.getVehicleType());

console.log(car.honk());
console.log(motorcycle.wheelie());

// 多态数组
const vehicles = [car, motorcycle];
vehicles.forEach(vehicle => {
    console.log(`${vehicle.getVehicleType()}: ${vehicle.getInfo()}`);
    console.log(vehicle.startEngine());
});

// 工厂使用
const factoryCar = VehicleFactory.createVehicle("car", "Ford", "Mustang", 2021, "Gasoline");
console.log(factoryCar.getInfo());
```

```java !! java
// Java - 抽象类和方法
public abstract class AbstractVehicle {
    protected String make;
    protected String model;
    protected int year;
    
    // 构造函数
    public AbstractVehicle(String make, String model, int year) {
        this.make = make;
        this.model = model;
        this.year = year;
    }
    
    // 抽象方法（必须由子类实现）
    public abstract String startEngine();
    public abstract String getVehicleType();
    
    // 具体方法
    public String getInfo() {
        return year + " " + make + " " + model;
    }
    
    public int getAge() {
        int currentYear = java.time.Year.now().getValue();
        return currentYear - year;
    }
    
    // Final 方法（不能重写）
    public final String getMake() {
        return make;
    }
    
    // 静态方法
    public static String getVehicleCategory() {
        return "Vehicle";
    }
    
    // Getters 和 setters
    public String getModel() {
        return model;
    }
    
    public void setModel(String model) {
        this.model = model;
    }
    
    public int getYear() {
        return year;
    }
    
    public void setYear(int year) {
        this.year = year;
    }
}

// 具体派生类
public class Car extends AbstractVehicle {
    private String fuelType;
    
    public Car(String make, String model, int year, String fuelType) {
        super(make, model, year);
        this.fuelType = fuelType;
    }
    
    // 实现抽象方法
    @Override
    public String startEngine() {
        return "Starting " + fuelType + " engine of " + getInfo();
    }
    
    @Override
    public String getVehicleType() {
        return "Car";
    }
    
    // 添加新方法
    public String honk() {
        return "Honk! Honk!";
    }
    
    // 重写具体方法
    @Override
    public String getInfo() {
        return super.getInfo() + " (" + fuelType + ")";
    }
    
    // Getter 和 setter
    public String getFuelType() {
        return fuelType;
    }
    
    public void setFuelType(String fuelType) {
        this.fuelType = fuelType;
    }
}

public class Motorcycle extends AbstractVehicle {
    private int engineSize;
    
    public Motorcycle(String make, String model, int year, int engineSize) {
        super(make, model, year);
        this.engineSize = engineSize;
    }
    
    // 实现抽象方法
    @Override
    public String startEngine() {
        return "Starting " + engineSize + "cc engine of " + getInfo();
    }
    
    @Override
    public String getVehicleType() {
        return "Motorcycle";
    }
    
    // 添加新方法
    public String wheelie() {
        return "Doing a wheelie!";
    }
    
    // 重写具体方法
    @Override
    public String getInfo() {
        return super.getInfo() + " (" + engineSize + "cc)";
    }
    
    // Getter 和 setter
    public int getEngineSize() {
        return engineSize;
    }
    
    public void setEngineSize(int engineSize) {
        this.engineSize = engineSize;
    }
}

// 创建车辆的工厂类
public class VehicleFactory {
    public static AbstractVehicle createVehicle(String type, String make, String model, int year, Object... args) {
        switch (type.toLowerCase()) {
            case "car":
                return new Car(make, model, year, (String) args[0]);
            case "motorcycle":
                return new Motorcycle(make, model, year, (Integer) args[0]);
            default:
                throw new IllegalArgumentException("Unknown vehicle type: " + type);
        }
    }
}

// 主类演示抽象类
class AbstractClassDemo {
    public static void main(String[] args) {
        // 这会导致编译错误：
        // AbstractVehicle vehicle = new AbstractVehicle("Generic", "Model", 2020);
        
        Car car = new Car("Toyota", "Camry", 2020, "Gasoline");
        Motorcycle motorcycle = new Motorcycle("Honda", "CBR600RR", 2019, 600);
        
        System.out.println(car.startEngine());
        System.out.println(motorcycle.startEngine());
        
        System.out.println(car.getVehicleType());
        System.out.println(motorcycle.getVehicleType());
        
        System.out.println(car.honk());
        System.out.println(motorcycle.wheelie());
        
        // 多态数组
        AbstractVehicle[] vehicles = {car, motorcycle};
        for (AbstractVehicle vehicle : vehicles) {
            System.out.println(vehicle.getVehicleType() + ": " + vehicle.getInfo());
            System.out.println(vehicle.startEngine());
        }
        
        // 工厂使用
        AbstractVehicle factoryCar = VehicleFactory.createVehicle("car", "Ford", "Mustang", 2021, "Gasoline");
        System.out.println(factoryCar.getInfo());
        
        // 演示抽象类特性
        System.out.println("Vehicle category: " + AbstractVehicle.getVehicleCategory());
        System.out.println("Car age: " + car.getAge() + " years");
        System.out.println("Car make: " + car.getMake());
    }
}
```
</UniversalEditor>

## 练习题

### 练习 1: 继承实现

<UniversalEditor title="练习 1: 继承实现">
```java !! java
// TODO: 实现具有适当继承的这些类
public abstract class Employee {
    // TODO: 添加受保护字段 name、id、salary
    
    // TODO: 实现构造函数
    
    // TODO: 添加抽象方法 calculateBonus()
    
    // TODO: 添加具体方法 getInfo() 和 getSalary()
    
    // TODO: 添加 getters 和 setters
}

public class Manager extends Employee {
    // TODO: 添加私有字段 department
    
    // TODO: 实现调用父构造函数的构造函数
    
    // TODO: 重写 calculateBonus() 方法
    
    // TODO: 重写 getInfo() 方法
    
    // TODO: 添加管理团队的方法
}

public class Developer extends Employee {
    // TODO: 添加私有字段 programming language
    
    // TODO: 实现调用父构造函数的构造函数
    
    // TODO: 重写 calculateBonus() 方法
    
    // TODO: 重写 getInfo() 方法
    
    // TODO: 添加编写代码的方法
}

public class InheritanceExercises {
    public static void main(String[] args) {
        // 测试你的实现
        Manager manager = new Manager("John Doe", "M001", 80000, "Engineering");
        Developer developer = new Developer("Jane Smith", "D001", 70000, "Java");
        
        System.out.println(manager.getInfo());
        System.out.println("Manager bonus: $" + manager.calculateBonus());
        System.out.println(manager.manageTeam());
        
        System.out.println(developer.getInfo());
        System.out.println("Developer bonus: $" + developer.calculateBonus());
        System.out.println(developer.writeCode());
        
        // 多态数组
        Employee[] employees = {manager, developer};
        for (Employee emp : employees) {
            System.out.println(emp.getInfo() + " - Bonus: $" + emp.calculateBonus());
        }
    }
}
```
</UniversalEditor>

### 练习 2: 多态和方法重写

<UniversalEditor title="练习 2: 多态和方法重写">
```java !! java
// TODO: 实现多态银行系统
public abstract class BankAccount {
    // TODO: 添加受保护字段 accountNumber、balance、owner
    
    // TODO: 实现构造函数
    
    // TODO: 添加抽象方法 calculateInterest()
    
    // TODO: 添加具体方法 deposit()、withdraw()、getBalance()
    
    // TODO: 重写 toString() 方法
}

public class SavingsAccount extends BankAccount {
    // TODO: 添加私有字段 interest rate
    
    // TODO: 实现构造函数
    
    // TODO: 重写 calculateInterest() 方法
    
    // TODO: 重写 toString() 方法
    
    // TODO: 添加将利息添加到余额的方法
}

public class CheckingAccount extends BankAccount {
    // TODO: 添加私有字段 overdraft limit
    
    // TODO: 实现构造函数
    
    // TODO: 重写 calculateInterest() 方法
    
    // TODO: 重写 withdraw() 方法以处理透支
    
    // TODO: 重写 toString() 方法
}

public class PolymorphismExercises {
    public static void main(String[] args) {
        // 测试你的实现
        SavingsAccount savings = new SavingsAccount("S001", 10000, "Alice", 0.05);
        CheckingAccount checking = new CheckingAccount("C001", 5000, "Bob", 1000);
        
        System.out.println(savings);
        System.out.println("Interest: $" + savings.calculateInterest());
        savings.addInterest();
        System.out.println("After interest: " + savings.getBalance());
        
        System.out.println(checking);
        System.out.println("Interest: $" + checking.calculateInterest());
        checking.withdraw(6000); // 应该使用透支
        System.out.println("After withdrawal: " + checking.getBalance());
        
        // 多态数组
        BankAccount[] accounts = {savings, checking};
        for (BankAccount account : accounts) {
            System.out.println(account + " - Interest: $" + account.calculateInterest());
        }
    }
}
```
</UniversalEditor>

## 总结

在本模块中，我们探索了 Java 的继承和多态机制，并将其与 JavaScript 基于原型的继承进行了对比：

### 关键要点：
1. **类继承**: Java 使用 `extends` 关键字进行显式继承
2. **方法重写**: Java 提供 `@Override` 注解进行显式方法重写
3. **多态**: Java 通过方法重写支持运行时多态
4. **抽象类**: Java 提供抽象类进行部分实现
5. **访问控制**: Java 使用 `protected` 进行继承特定访问

### 下一步：
- 练习实现具有适当继承的类层次结构
- 掌握方法重写和多态模式
- 探索抽象类及其用例
- 为下一个关于接口和抽象类的模块做准备

## 额外资源

- [Java 继承](https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html)
- [Java 多态](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html)
- [Java 抽象类](https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html)

---

**练习提示**: 专注于理解继承和组合之间的差异。练习实现具有抽象类的适当类层次结构。创建演示运行时行为变化的多态系统。 