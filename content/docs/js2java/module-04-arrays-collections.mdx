---
title: "Module 04: Arrays and Collections"
description: "Learn Java arrays, collections framework, and data structures compared to JavaScript patterns."
---

# Module 04: Arrays and Collections

In this module, we'll explore Java's array system and the comprehensive Collections Framework. While JavaScript has a single array type that can hold mixed data, Java provides strongly-typed arrays and a rich set of collection classes for different use cases.

## Learning Objectives

By the end of this module, you will be able to:
- Understand Java arrays and their type safety
- Master the Collections Framework (List, Set, Map)
- Compare Java collections with JavaScript arrays and objects
- Use generics for type-safe collections
- Apply best practices for data structure selection

## Arrays

### 1. Array Declaration and Initialization

Java arrays are fixed-size and strongly-typed, unlike JavaScript's dynamic arrays.

<UniversalEditor title="Array Declaration and Initialization" compare={true}>
```javascript !! js
// JavaScript - Array declaration and initialization
// Dynamic arrays with mixed types
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "hello", true, {name: "John"}];
let empty = [];

// Array constructor
let array1 = new Array(5);  // Creates array with length 5
let array2 = new Array(1, 2, 3, 4, 5);

// Array.from() and spread operator
let arrayFrom = Array.from("hello");  // ['h', 'e', 'l', 'l', 'o']
let spreadArray = [...numbers, 6, 7, 8];

// Array methods
numbers.push(6);  // Add to end
numbers.unshift(0);  // Add to beginning
let popped = numbers.pop();  // Remove from end
let shifted = numbers.shift();  // Remove from beginning

console.log("Numbers:", numbers);
console.log("Mixed:", mixed);
console.log("Array from string:", arrayFrom);
console.log("Spread array:", spreadArray);
```

```java !! java
// Java - Array declaration and initialization
public class ArrayBasics {
    public static void main(String[] args) {
        // Array declaration and initialization
        int[] numbers = {1, 2, 3, 4, 5};
        String[] names = {"Alice", "Bob", "Charlie"};
        
        // Array declaration with size
        int[] array1 = new int[5];  // Creates array with 5 elements (all 0)
        String[] array2 = new String[3];  // Creates array with 3 elements (all null)
        
        // Multi-dimensional arrays
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        int[][] matrix2 = new int[3][4];  // 3x4 matrix
        
        // Array length property
        System.out.println("Numbers length: " + numbers.length);
        System.out.println("Matrix rows: " + matrix.length);
        System.out.println("Matrix columns: " + matrix[0].length);
        
        // Array access and modification
        numbers[0] = 10;
        System.out.println("First element: " + numbers[0]);
        
        // Array iteration
        System.out.println("Numbers array:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.print(numbers[i] + " ");
        }
        System.out.println();
        
        // Enhanced for loop (for-each)
        System.out.println("Names array:");
        for (String name : names) {
            System.out.print(name + " ");
        }
        System.out.println();
        
        // Arrays utility class
        int[] copy = java.util.Arrays.copyOf(numbers, numbers.length);
        java.util.Arrays.sort(copy);
        System.out.println("Sorted copy: " + java.util.Arrays.toString(copy));
    }
}
```
</UniversalEditor>

### 2. Array Operations and Methods

<UniversalEditor title="Array Operations and Methods" compare={true}>
```javascript !! js
// JavaScript - Array operations and methods
let fruits = ["apple", "banana", "orange", "grape"];

// Adding elements
fruits.push("mango");  // Add to end
fruits.unshift("kiwi");  // Add to beginning
fruits.splice(2, 0, "pear");  // Insert at index 2

// Removing elements
fruits.pop();  // Remove from end
fruits.shift();  // Remove from beginning
fruits.splice(1, 1);  // Remove 1 element at index 1

// Finding elements
let index = fruits.indexOf("banana");
let lastIndex = fruits.lastIndexOf("apple");
let includes = fruits.includes("orange");

// Array transformation
let upperFruits = fruits.map(fruit => fruit.toUpperCase());
let longFruits = fruits.filter(fruit => fruit.length > 5);
let allLong = fruits.every(fruit => fruit.length > 3);
let someLong = fruits.some(fruit => fruit.length > 6);

// Array reduction
let concatenated = fruits.reduce((acc, fruit) => acc + ", " + fruit, "");
let totalLength = fruits.reduce((sum, fruit) => sum + fruit.length, 0);

// Sorting
fruits.sort();  // Alphabetical
fruits.reverse();  // Reverse order

console.log("Fruits:", fruits);
console.log("Index of banana:", index);
console.log("Upper fruits:", upperFruits);
console.log("Long fruits:", longFruits);
console.log("Concatenated:", concatenated);
```

```java !! java
// Java - Array operations and methods
import java.util.Arrays;

public class ArrayOperations {
    public static void main(String[] args) {
        String[] fruits = {"apple", "banana", "orange", "grape"};
        
        // Arrays are fixed-size, so we need to create new arrays for modifications
        // Adding elements (create new array)
        String[] newFruits = new String[fruits.length + 1];
        System.arraycopy(fruits, 0, newFruits, 0, fruits.length);
        newFruits[fruits.length] = "mango";
        fruits = newFruits;
        
        // Arrays utility class methods
        System.out.println("Original: " + Arrays.toString(fruits));
        
        // Sorting
        Arrays.sort(fruits);
        System.out.println("Sorted: " + Arrays.toString(fruits));
        
        // Searching
        int index = Arrays.binarySearch(fruits, "banana");
        System.out.println("Index of banana: " + index);
        
        // Copying arrays
        String[] copy = Arrays.copyOf(fruits, fruits.length);
        String[] partialCopy = Arrays.copyOfRange(fruits, 1, 3);
        
        // Filling arrays
        int[] numbers = new int[5];
        Arrays.fill(numbers, 42);
        System.out.println("Filled array: " + Arrays.toString(numbers));
        
        // Comparing arrays
        boolean equals = Arrays.equals(fruits, copy);
        System.out.println("Arrays equal: " + equals);
        
        // Array iteration with index
        System.out.println("Fruits with index:");
        for (int i = 0; i < fruits.length; i++) {
            System.out.println(i + ": " + fruits[i]);
        }
        
        // Enhanced for loop
        System.out.println("All fruits:");
        for (String fruit : fruits) {
            System.out.print(fruit + " ");
        }
        System.out.println();
        
        // Finding max/min (for numeric arrays)
        int[] numbers2 = {3, 7, 2, 9, 1, 8, 5};
        int max = Arrays.stream(numbers2).max().orElse(0);
        int min = Arrays.stream(numbers2).min().orElse(0);
        System.out.println("Max: " + max + ", Min: " + min);
    }
}
```
</UniversalEditor>

## Collections Framework

### 1. List Interface

Lists are ordered collections that allow duplicate elements.

<UniversalEditor title="List Interface" compare={true}>
```javascript !! js
// JavaScript - Array as List
let list = ["apple", "banana", "orange"];

// Adding elements
list.push("grape");  // Add to end
list.unshift("kiwi");  // Add to beginning
list.splice(2, 0, "pear");  // Insert at index 2

// Removing elements
list.pop();  // Remove from end
list.shift();  // Remove from beginning
list.splice(1, 1);  // Remove at index 1

// Accessing elements
let first = list[0];
let last = list[list.length - 1];
let element = list[2];

// Finding elements
let index = list.indexOf("banana");
let lastIndex = list.lastIndexOf("apple");
let includes = list.includes("orange");

// List transformation
let upperList = list.map(item => item.toUpperCase());
let filteredList = list.filter(item => item.length > 5);

// List iteration
list.forEach((item, index) => {
    console.log(`${index}: ${item}`);
});

console.log("List:", list);
console.log("First:", first);
console.log("Index of banana:", index);
console.log("Upper list:", upperList);
```

```java !! java
// Java - List Interface
import java.util.*;

public class ListExamples {
    public static void main(String[] args) {
        // ArrayList - dynamic array implementation
        List<String> arrayList = new ArrayList<>();
        arrayList.add("apple");
        arrayList.add("banana");
        arrayList.add("orange");
        
        // LinkedList - doubly-linked list implementation
        List<String> linkedList = new LinkedList<>();
        linkedList.add("grape");
        linkedList.add("kiwi");
        linkedList.add("pear");
        
        // Adding elements
        arrayList.add("grape");  // Add to end
        arrayList.add(0, "kiwi");  // Add at index 0
        arrayList.addAll(linkedList);  // Add all elements from another list
        
        // Removing elements
        arrayList.remove("banana");  // Remove by value
        arrayList.remove(0);  // Remove by index
        arrayList.removeIf(item -> item.length() > 5);  // Remove by condition
        
        // Accessing elements
        String first = arrayList.get(0);
        String last = arrayList.get(arrayList.size() - 1);
        
        // Finding elements
        int index = arrayList.indexOf("orange");
        int lastIndex = arrayList.lastIndexOf("apple");
        boolean contains = arrayList.contains("grape");
        
        // List transformation
        List<String> upperList = new ArrayList<>();
        for (String item : arrayList) {
            upperList.add(item.toUpperCase());
        }
        
        // List iteration
        System.out.println("ArrayList elements:");
        for (int i = 0; i < arrayList.size(); i++) {
            System.out.println(i + ": " + arrayList.get(i));
        }
        
        // Enhanced for loop
        System.out.println("All elements:");
        for (String item : arrayList) {
            System.out.print(item + " ");
        }
        System.out.println();
        
        // Lambda forEach (Java 8+)
        arrayList.forEach(item -> System.out.print(item + " "));
        System.out.println();
        
        // List methods
        System.out.println("Size: " + arrayList.size());
        System.out.println("Is empty: " + arrayList.isEmpty());
        System.out.println("Contains orange: " + contains);
        System.out.println("Index of orange: " + index);
        
        // Sorting
        Collections.sort(arrayList);
        System.out.println("Sorted: " + arrayList);
        
        // Reversing
        Collections.reverse(arrayList);
        System.out.println("Reversed: " + arrayList);
    }
}
```
</UniversalEditor>

### 2. Set Interface

Sets are collections that do not allow duplicate elements.

<UniversalEditor title="Set Interface" compare={true}>
```javascript !! js
// JavaScript - Set object
let set = new Set(["apple", "banana", "orange"]);

// Adding elements
set.add("grape");
set.add("banana");  // Won't add duplicate

// Removing elements
set.delete("banana");
set.clear();  // Remove all elements

// Checking elements
let hasApple = set.has("apple");
let size = set.size;

// Set operations
let set1 = new Set([1, 2, 3, 4]);
let set2 = new Set([3, 4, 5, 6]);

// Union
let union = new Set([...set1, ...set2]);

// Intersection
let intersection = new Set([...set1].filter(x => set2.has(x)));

// Difference
let difference = new Set([...set1].filter(x => !set2.has(x)));

// Set iteration
set1.forEach(value => {
    console.log("Value:", value);
});

// Convert to array
let array = [...set1];

console.log("Set:", set);
console.log("Has apple:", hasApple);
console.log("Size:", size);
console.log("Union:", union);
console.log("Intersection:", intersection);
console.log("Difference:", difference);
```

```java !! java
// Java - Set Interface
import java.util.*;

public class SetExamples {
    public static void main(String[] args) {
        // HashSet - unordered, no duplicates
        Set<String> hashSet = new HashSet<>();
        hashSet.add("apple");
        hashSet.add("banana");
        hashSet.add("orange");
        hashSet.add("banana");  // Won't add duplicate
        
        // LinkedHashSet - maintains insertion order
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("grape");
        linkedHashSet.add("kiwi");
        linkedHashSet.add("pear");
        
        // TreeSet - sorted order
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("zebra");
        treeSet.add("apple");
        treeSet.add("banana");
        
        // Adding elements
        hashSet.add("grape");
        hashSet.addAll(linkedHashSet);
        
        // Removing elements
        hashSet.remove("banana");
        hashSet.removeIf(item -> item.length() > 5);
        
        // Checking elements
        boolean contains = hashSet.contains("apple");
        boolean isEmpty = hashSet.isEmpty();
        int size = hashSet.size();
        
        // Set operations
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        
        // Union
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        
        // Intersection
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        // Difference
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        
        // Set iteration
        System.out.println("HashSet elements:");
        for (String item : hashSet) {
            System.out.print(item + " ");
        }
        System.out.println();
        
        // Lambda forEach
        treeSet.forEach(item -> System.out.print(item + " "));
        System.out.println();
        
        // Set methods
        System.out.println("HashSet: " + hashSet);
        System.out.println("LinkedHashSet: " + linkedHashSet);
        System.out.println("TreeSet: " + treeSet);
        System.out.println("Contains apple: " + contains);
        System.out.println("Size: " + size);
        System.out.println("Union: " + union);
        System.out.println("Intersection: " + intersection);
        System.out.println("Difference: " + difference);
        
        // Converting to array
        String[] array = hashSet.toArray(new String[0]);
        System.out.println("Array: " + Arrays.toString(array));
    }
}
```
</UniversalEditor>

### 3. Map Interface

Maps store key-value pairs, similar to JavaScript objects.

<UniversalEditor title="Map Interface" compare={true}>
```javascript !! js
// JavaScript - Object as Map
let map = {
    "name": "John",
    "age": 30,
    "city": "NYC"
};

// Adding/updating elements
map.email = "john@example.com";
map["phone"] = "123-456-7890";

// Removing elements
delete map.age;
let removed = map.city;
delete map.city;

// Checking elements
let hasName = "name" in map;
let hasAge = map.hasOwnProperty("age");
let value = map.name;
let undefinedValue = map.nonexistent;

// Object methods
let keys = Object.keys(map);
let values = Object.values(map);
let entries = Object.entries(map);

// Object iteration
for (let key in map) {
    if (map.hasOwnProperty(key)) {
        console.log(`${key}: ${map[key]}`);
    }
}

Object.entries(map).forEach(([key, value]) => {
    console.log(`${key}: ${value}`);
});

// Map object (ES6)
let mapObject = new Map();
mapObject.set("name", "John");
mapObject.set("age", 30);
mapObject.set("city", "NYC");

mapObject.set("email", "john@example.com");
mapObject.delete("age");
let hasKey = mapObject.has("name");
let mapValue = mapObject.get("name");
let mapSize = mapObject.size;

console.log("Object map:", map);
console.log("Has name:", hasName);
console.log("Keys:", keys);
console.log("Values:", values);
console.log("Map object:", mapObject);
console.log("Map size:", mapSize);
```

```java !! java
// Java - Map Interface
import java.util.*;

public class MapExamples {
    public static void main(String[] args) {
        // HashMap - unordered key-value pairs
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("name", "John");
        hashMap.put("age", "30");
        hashMap.put("city", "NYC");
        
        // LinkedHashMap - maintains insertion order
        Map<String, String> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("email", "john@example.com");
        linkedHashMap.put("phone", "123-456-7890");
        
        // TreeMap - sorted by keys
        Map<String, String> treeMap = new TreeMap<>();
        treeMap.put("zebra", "animal");
        treeMap.put("apple", "fruit");
        treeMap.put("banana", "fruit");
        
        // Adding/updating elements
        hashMap.put("email", "john@example.com");
        hashMap.putAll(linkedHashMap);
        
        // Removing elements
        hashMap.remove("age");
        hashMap.remove("nonexistent", "default");  // Remove only if value matches
        
        // Checking elements
        boolean containsKey = hashMap.containsKey("name");
        boolean containsValue = hashMap.containsValue("John");
        String value = hashMap.get("name");
        String defaultValue = hashMap.getOrDefault("nonexistent", "default");
        
        // Map operations
        Set<String> keys = hashMap.keySet();
        Collection<String> values = hashMap.values();
        Set<Map.Entry<String, String>> entries = hashMap.entrySet();
        
        // Map iteration
        System.out.println("HashMap entries:");
        for (Map.Entry<String, String> entry : hashMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Lambda forEach
        hashMap.forEach((key, val) -> System.out.println(key + " -> " + val));
        
        // Map methods
        System.out.println("HashMap: " + hashMap);
        System.out.println("LinkedHashMap: " + linkedHashMap);
        System.out.println("TreeMap: " + treeMap);
        System.out.println("Contains key 'name': " + containsKey);
        System.out.println("Value for 'name': " + value);
        System.out.println("Size: " + hashMap.size());
        System.out.println("Is empty: " + hashMap.isEmpty());
        
        // Converting to collections
        System.out.println("Keys: " + keys);
        System.out.println("Values: " + values);
        
        // Map with different value types
        Map<String, Object> mixedMap = new HashMap<>();
        mixedMap.put("name", "John");
        mixedMap.put("age", 30);
        mixedMap.put("active", true);
        mixedMap.put("scores", Arrays.asList(85, 92, 78));
        
        System.out.println("Mixed map: " + mixedMap);
        
        // Nested maps
        Map<String, Map<String, String>> nestedMap = new HashMap<>();
        Map<String, String> innerMap = new HashMap<>();
        innerMap.put("street", "123 Main St");
        innerMap.put("city", "NYC");
        nestedMap.put("address", innerMap);
        
        System.out.println("Nested map: " + nestedMap);
    }
}
```
</UniversalEditor>

## Generics

### 1. Generic Collections

Generics provide type safety for collections.

<UniversalEditor title="Generic Collections" compare={true}>
```javascript !! js
// JavaScript - No generics, but we can enforce types with JSDoc
/**
 * @template T
 * @param {T[]} array
 * @returns {T}
 */
function getFirst(array) {
    return array[0];
}

/**
 * @template T
 * @param {T[]} array
 * @param {function(T): boolean} predicate
 * @returns {T[]}
 */
function filter(array, predicate) {
    return array.filter(predicate);
}

// Usage
let numbers = [1, 2, 3, 4, 5];
let strings = ["hello", "world", "test"];

let firstNumber = getFirst(numbers);
let firstString = getFirst(strings);

let evenNumbers = filter(numbers, n => n % 2 === 0);
let longStrings = filter(strings, s => s.length > 4);

console.log("First number:", firstNumber);
console.log("First string:", firstString);
console.log("Even numbers:", evenNumbers);
console.log("Long strings:", longStrings);
```

```java !! java
// Java - Generics provide compile-time type safety
import java.util.*;

public class GenericCollections {
    public static void main(String[] args) {
        // Generic List
        List<String> stringList = new ArrayList<>();
        stringList.add("hello");
        stringList.add("world");
        // stringList.add(123);  // Compile-time error!
        
        List<Integer> intList = new ArrayList<>();
        intList.add(1);
        intList.add(2);
        intList.add(3);
        
        // Generic Set
        Set<String> stringSet = new HashSet<>();
        stringSet.add("apple");
        stringSet.add("banana");
        
        // Generic Map
        Map<String, Integer> stringIntMap = new HashMap<>();
        stringIntMap.put("one", 1);
        stringIntMap.put("two", 2);
        
        // Generic methods
        String firstString = getFirst(stringList);
        Integer firstInt = getFirst(intList);
        
        List<String> filteredStrings = filter(stringList, s -> s.length() > 4);
        List<Integer> evenNumbers = filter(intList, n -> n % 2 == 0);
        
        // Generic class
        Box<String> stringBox = new Box<>("Hello");
        Box<Integer> intBox = new Box<>(42);
        
        System.out.println("First string: " + firstString);
        System.out.println("First int: " + firstInt);
        System.out.println("Filtered strings: " + filteredStrings);
        System.out.println("Even numbers: " + evenNumbers);
        System.out.println("String box: " + stringBox.getContent());
        System.out.println("Int box: " + intBox.getContent());
        
        // Wildcards
        List<Number> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2.5);
        numbers.add(3L);
        
        printList(numbers);
        printList(stringList);
    }
    
    // Generic method
    public static <T> T getFirst(List<T> list) {
        if (list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }
    
    // Generic method with predicate
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                result.add(item);
            }
        }
        return result;
    }
    
    // Wildcard method
    public static void printList(List<?> list) {
        for (Object item : list) {
            System.out.print(item + " ");
        }
        System.out.println();
    }
    
    // Generic class
    static class Box<T> {
        private T content;
        
        public Box(T content) {
            this.content = content;
        }
        
        public T getContent() {
            return content;
        }
        
        public void setContent(T content) {
            this.content = content;
        }
    }
}
```
</UniversalEditor>

## Best Practices

### 1. Collection Selection

<UniversalEditor title="Collection Selection Best Practices" compare={true}>
```javascript !! js
// JavaScript - Collection selection patterns
// Use arrays for ordered collections
let orderedList = [1, 2, 3, 4, 5];

// Use Set for unique values
let uniqueValues = new Set([1, 2, 2, 3, 3, 4]);

// Use Map for key-value pairs
let keyValueMap = new Map([
    ["name", "John"],
    ["age", 30],
    ["city", "NYC"]
]);

// Use objects for simple key-value storage
let simpleObject = {
    name: "John",
    age: 30,
    city: "NYC"
};

// Performance considerations
// Array operations
let array = [1, 2, 3, 4, 5];
array.push(6);  // O(1) - amortized
array.unshift(0);  // O(n) - shifts all elements
array.splice(2, 1);  // O(n) - shifts elements

// Set operations
let set = new Set([1, 2, 3]);
set.add(4);  // O(1) - average case
set.has(2);  // O(1) - average case
set.delete(2);  // O(1) - average case

// Map operations
let map = new Map();
map.set("key", "value");  // O(1) - average case
map.get("key");  // O(1) - average case
map.delete("key");  // O(1) - average case

console.log("Ordered list:", orderedList);
console.log("Unique values:", uniqueValues);
console.log("Key-value map:", keyValueMap);
console.log("Simple object:", simpleObject);
```

```java !! java
// Java - Collection selection best practices
import java.util.*;

public class CollectionBestPractices {
    public static void main(String[] args) {
        // Use ArrayList for random access and iteration
        List<String> arrayList = new ArrayList<>();
        arrayList.add("apple");
        arrayList.add("banana");
        arrayList.add("orange");
        
        // Use LinkedList for frequent insertions/deletions
        List<String> linkedList = new LinkedList<>();
        linkedList.add("grape");
        linkedList.add("kiwi");
        linkedList.add("pear");
        
        // Use HashSet for unique elements, no order needed
        Set<String> hashSet = new HashSet<>();
        hashSet.add("red");
        hashSet.add("green");
        hashSet.add("blue");
        
        // Use LinkedHashSet for unique elements with insertion order
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("first");
        linkedHashSet.add("second");
        linkedHashSet.add("third");
        
        // Use TreeSet for sorted unique elements
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("zebra");
        treeSet.add("apple");
        treeSet.add("banana");
        
        // Use HashMap for key-value pairs, no order needed
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("one", 1);
        hashMap.put("two", 2);
        hashMap.put("three", 3);
        
        // Use LinkedHashMap for key-value pairs with insertion order
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("first", 1);
        linkedHashMap.put("second", 2);
        linkedHashMap.put("third", 3);
        
        // Use TreeMap for sorted key-value pairs
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("zebra", 26);
        treeMap.put("apple", 1);
        treeMap.put("banana", 2);
        
        // Performance considerations
        System.out.println("ArrayList (random access): " + arrayList);
        System.out.println("LinkedList (frequent modifications): " + linkedList);
        System.out.println("HashSet (unique, no order): " + hashSet);
        System.out.println("LinkedHashSet (unique, insertion order): " + linkedHashSet);
        System.out.println("TreeSet (unique, sorted): " + treeSet);
        System.out.println("HashMap (key-value, no order): " + hashMap);
        System.out.println("LinkedHashMap (key-value, insertion order): " + linkedHashMap);
        System.out.println("TreeMap (key-value, sorted): " + treeMap);
        
        // Collection performance summary
        System.out.println("\nPerformance Summary:");
        System.out.println("ArrayList: O(1) get/set, O(n) insert/delete");
        System.out.println("LinkedList: O(n) get/set, O(1) insert/delete");
        System.out.println("HashSet: O(1) add/remove/contains");
        System.out.println("TreeSet: O(log n) add/remove/contains");
        System.out.println("HashMap: O(1) put/get/remove");
        System.out.println("TreeMap: O(log n) put/get/remove");
    }
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Array and List Operations

<UniversalEditor title="Exercise 1: Array and List Operations">
```java !! java
// TODO: Complete these array and list operations
public class ArrayListExercise {
    public static void main(String[] args) {
        // 1. Create a method to find the second largest element in an array
        
        // 2. Create a method to reverse an array in-place
        
        // 3. Create a method to find common elements between two arrays
        
        // 4. Create a method to remove duplicates from a list
        
        // 5. Create a method to find the longest string in a list
        
        // Test your implementations
        int[] numbers = {3, 7, 2, 9, 1, 8, 5, 4, 6};
        String[] words = {"apple", "banana", "orange", "grape", "kiwi"};
        
        System.out.println("Second largest: " + findSecondLargest(numbers));
        reverseArray(numbers);
        System.out.println("Reversed array: " + Arrays.toString(numbers));
        
        int[] array1 = {1, 2, 3, 4, 5};
        int[] array2 = {4, 5, 6, 7, 8};
        System.out.println("Common elements: " + findCommonElements(array1, array2));
        
        List<String> list = Arrays.asList("apple", "banana", "apple", "orange", "banana");
        System.out.println("Without duplicates: " + removeDuplicates(list));
        System.out.println("Longest string: " + findLongestString(list));
    }
    
    // Implement your methods here
}
```
</UniversalEditor>

### Exercise 2: Collection Framework

<UniversalEditor title="Exercise 2: Collection Framework">
```java !! java
// TODO: Implement these collection operations
public class CollectionExercise {
    public static void main(String[] args) {
        // 1. Create a method to count word frequencies in a list
        
        // 2. Create a method to find the most frequent element
        
        // 3. Create a method to check if two lists are anagrams
        
        // 4. Create a method to group strings by length
        
        // 5. Create a method to find the intersection of multiple sets
        
        // Test your implementations
        List<String> words = Arrays.asList("hello", "world", "hello", "java", "world", "hello");
        System.out.println("Word frequencies: " + countWordFrequencies(words));
        System.out.println("Most frequent: " + findMostFrequent(words));
        
        List<String> list1 = Arrays.asList("listen", "silent");
        List<String> list2 = Arrays.asList("triangle", "integral");
        System.out.println("Are anagrams: " + areAnagrams(list1.get(0), list1.get(1)));
        System.out.println("Are anagrams: " + areAnagrams(list2.get(0), list2.get(1)));
        
        List<String> strings = Arrays.asList("a", "bb", "ccc", "dd", "eee");
        System.out.println("Grouped by length: " + groupByLength(strings));
        
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        Set<Integer> set3 = new HashSet<>(Arrays.asList(4, 5, 6, 7));
        System.out.println("Intersection: " + findIntersection(set1, set2, set3));
    }
    
    // Implement your methods here
}
```
</UniversalEditor>

## Summary

In this module, we explored Java's array system and Collections Framework, comparing them with JavaScript patterns:

### Key Points:
1. **Arrays**: Java arrays are fixed-size and strongly-typed, unlike JavaScript's dynamic arrays
2. **Collections Framework**: Provides specialized data structures (List, Set, Map) for different use cases
3. **Generics**: Ensure type safety at compile time
4. **Performance**: Different collections have different performance characteristics
5. **Best Practices**: Choose the right collection for your specific needs

### Next Steps:
- Practice using different collection types
- Understand when to use each collection
- Master generic syntax and wildcards
- Prepare for the next module on Object-Oriented Programming

## Additional Resources

- [Java Collections Framework](https://docs.oracle.com/javase/tutorial/collections/)
- [Java Generics](https://docs.oracle.com/javase/tutorial/java/generics/)
- [Java Arrays](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html)

---

**Practice Tip**: Create small programs that demonstrate the use of each collection type. Focus on understanding when to use each collection and their performance characteristics. 