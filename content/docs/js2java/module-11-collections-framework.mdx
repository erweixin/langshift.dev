---
title: "Module 11: Collections Framework"
description: "Learn Java Collections Framework, List, Set, Map interfaces, and their implementations compared to JavaScript arrays and object collections."
---

# Module 11: Collections Framework

In this module, we'll explore Java's comprehensive Collections Framework and compare it with JavaScript's array and object-based collections. We'll learn about List, Set, and Map interfaces, their implementations, and how to use them effectively.

## Learning Objectives

By the end of this module, you will be able to:
- Understand Java Collections Framework hierarchy
- Compare Java collections with JavaScript arrays and objects
- Use List, Set, and Map interfaces effectively
- Choose appropriate collection implementations
- Apply collections in real-world scenarios
- Understand collection performance characteristics

## Collections Framework Overview

### 1. List Interface and Implementations

Java provides ordered collections with List interface, while JavaScript uses arrays for similar functionality.

<UniversalEditor title="List Interface and Implementations" compare={true}>
```javascript !! js
// JavaScript - Array-based collections
// Array as List equivalent
class ArrayList {
    constructor() {
        this.items = [];
    }
    
    add(item) {
        this.items.push(item);
    }
    
    addAt(index, item) {
        this.items.splice(index, 0, item);
    }
    
    get(index) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('Index out of bounds');
        }
        return this.items[index];
    }
    
    set(index, item) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('Index out of bounds');
        }
        this.items[index] = item;
    }
    
    remove(index) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('Index out of bounds');
        }
        return this.items.splice(index, 1)[0];
    }
    
    removeItem(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            return this.remove(index);
        }
        return null;
    }
    
    size() {
        return this.items.length;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    contains(item) {
        return this.items.includes(item);
    }
    
    indexOf(item) {
        return this.items.indexOf(item);
    }
    
    lastIndexOf(item) {
        return this.items.lastIndexOf(item);
    }
    
    clear() {
        this.items = [];
    }
    
    toArray() {
        return [...this.items];
    }
    
    subList(fromIndex, toIndex) {
        return this.items.slice(fromIndex, toIndex);
    }
    
    forEach(callback) {
        this.items.forEach(callback);
    }
    
    filter(predicate) {
        return this.items.filter(predicate);
    }
    
    map(transform) {
        return this.items.map(transform);
    }
    
    reduce(reducer, initialValue) {
        return this.items.reduce(reducer, initialValue);
    }
    
    sort(compareFunction) {
        return [...this.items].sort(compareFunction);
    }
    
    reverse() {
        return [...this.items].reverse();
    }
}

// LinkedList implementation
class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    add(item) {
        const newNode = { data: item, next: null };
        
        if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
        } else {
            this.tail.next = newNode;
            this.tail = newNode;
        }
        this.size++;
    }
    
    addAt(index, item) {
        if (index < 0 || index > this.size) {
            throw new Error('Index out of bounds');
        }
        
        if (index === 0) {
            const newNode = { data: item, next: this.head };
            this.head = newNode;
            if (!this.tail) {
                this.tail = newNode;
            }
        } else if (index === this.size) {
            this.add(item);
            return;
        } else {
            let current = this.head;
            for (let i = 0; i < index - 1; i++) {
                current = current.next;
            }
            const newNode = { data: item, next: current.next };
            current.next = newNode;
        }
        this.size++;
    }
    
    get(index) {
        if (index < 0 || index >= this.size) {
            throw new Error('Index out of bounds');
        }
        
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        return current.data;
    }
    
    set(index, item) {
        if (index < 0 || index >= this.size) {
            throw new Error('Index out of bounds');
        }
        
        let current = this.head;
        for (let i = 0; i < index; i++) {
            current = current.next;
        }
        current.data = item;
    }
    
    remove(index) {
        if (index < 0 || index >= this.size) {
            throw new Error('Index out of bounds');
        }
        
        if (index === 0) {
            const removed = this.head.data;
            this.head = this.head.next;
            if (!this.head) {
                this.tail = null;
            }
            this.size--;
            return removed;
        }
        
        let current = this.head;
        for (let i = 0; i < index - 1; i++) {
            current = current.next;
        }
        
        const removed = current.next.data;
        current.next = current.next.next;
        
        if (index === this.size - 1) {
            this.tail = current;
        }
        this.size--;
        return removed;
    }
    
    size() {
        return this.size;
    }
    
    isEmpty() {
        return this.size === 0;
    }
    
    contains(item) {
        let current = this.head;
        while (current) {
            if (current.data === item) {
                return true;
            }
            current = current.next;
        }
        return false;
    }
    
    indexOf(item) {
        let current = this.head;
        let index = 0;
        while (current) {
            if (current.data === item) {
                return index;
            }
            current = current.next;
            index++;
        }
        return -1;
    }
    
    clear() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }
    
    toArray() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        return result;
    }
    
    forEach(callback) {
        let current = this.head;
        let index = 0;
        while (current) {
            callback(current.data, index);
            current = current.next;
            index++;
        }
    }
}

// Usage examples
const arrayList = new ArrayList();
arrayList.add("Apple");
arrayList.add("Banana");
arrayList.add("Cherry");

console.log("ArrayList size:", arrayList.size()); // 3
console.log("Contains 'Banana':", arrayList.contains("Banana")); // true
console.log("Index of 'Cherry':", arrayList.indexOf("Cherry")); // 2

arrayList.addAt(1, "Orange");
console.log("After insert:", arrayList.toArray()); // ["Apple", "Orange", "Banana", "Cherry"]

arrayList.remove(2);
console.log("After remove:", arrayList.toArray()); // ["Apple", "Orange", "Cherry"]

// LinkedList usage
const linkedList = new LinkedList();
linkedList.add("First");
linkedList.add("Second");
linkedList.add("Third");

console.log("LinkedList size:", linkedList.size()); // 3
console.log("Get at index 1:", linkedList.get(1)); // "Second"

linkedList.addAt(1, "Inserted");
console.log("After insert:", linkedList.toArray()); // ["First", "Inserted", "Second", "Third"]

linkedList.remove(2);
console.log("After remove:", linkedList.toArray()); // ["First", "Inserted", "Third"]

// Array methods comparison
const fruits = ["Apple", "Banana", "Cherry"];
console.log("Original array:", fruits);

fruits.push("Date");
console.log("After push:", fruits);

fruits.splice(1, 0, "Orange");
console.log("After splice insert:", fruits);

fruits.splice(2, 1);
console.log("After splice remove:", fruits);

const doubled = fruits.map(fruit => fruit + fruit);
console.log("Mapped:", doubled);

const filtered = fruits.filter(fruit => fruit.length > 5);
console.log("Filtered:", filtered);

const concatenated = fruits.reduce((acc, fruit) => acc + fruit, "");
console.log("Reduced:", concatenated);
```

```java !! java
// Java - Collections Framework List implementations
import java.util.*;

// ArrayList demonstration
public class ArrayListDemo {
    public static void main(String[] args) {
        // Creating ArrayList
        List<String> arrayList = new ArrayList<>();
        
        // Adding elements
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add("Cherry");
        
        System.out.println("ArrayList: " + arrayList);
        System.out.println("Size: " + arrayList.size());
        System.out.println("Contains 'Banana': " + arrayList.contains("Banana"));
        System.out.println("Index of 'Cherry': " + arrayList.indexOf("Cherry"));
        
        // Inserting at specific index
        arrayList.add(1, "Orange");
        System.out.println("After insert: " + arrayList);
        
        // Removing elements
        arrayList.remove(2);
        System.out.println("After remove: " + arrayList);
        
        // Setting elements
        arrayList.set(0, "Grape");
        System.out.println("After set: " + arrayList);
        
        // Getting elements
        System.out.println("Element at index 1: " + arrayList.get(1));
        
        // Sublist
        List<String> subList = arrayList.subList(0, 2);
        System.out.println("SubList: " + subList);
        
        // Iterating
        System.out.println("Iterating with for-each:");
        for (String fruit : arrayList) {
            System.out.println(fruit);
        }
        
        System.out.println("Iterating with forEach:");
        arrayList.forEach(System.out::println);
        
        // Converting to array
        String[] array = arrayList.toArray(new String[0]);
        System.out.println("Array: " + Arrays.toString(array));
        
        // Clearing
        arrayList.clear();
        System.out.println("After clear: " + arrayList);
        System.out.println("Is empty: " + arrayList.isEmpty());
    }
}

// LinkedList demonstration
public class LinkedListDemo {
    public static void main(String[] args) {
        // Creating LinkedList
        List<String> linkedList = new LinkedList<>();
        
        // Adding elements
        linkedList.add("First");
        linkedList.add("Second");
        linkedList.add("Third");
        
        System.out.println("LinkedList: " + linkedList);
        System.out.println("Size: " + linkedList.size());
        
        // Inserting at specific index
        linkedList.add(1, "Inserted");
        System.out.println("After insert: " + linkedList);
        
        // Removing elements
        linkedList.remove(2);
        System.out.println("After remove: " + linkedList);
        
        // Getting elements
        System.out.println("Element at index 1: " + linkedList.get(1));
        
        // LinkedList-specific operations
        LinkedList<String> ll = (LinkedList<String>) linkedList;
        
        // Adding to front and back
        ll.addFirst("Front");
        ll.addLast("Back");
        System.out.println("After addFirst/addLast: " + ll);
        
        // Removing from front and back
        String first = ll.removeFirst();
        String last = ll.removeLast();
        System.out.println("Removed first: " + first + ", last: " + last);
        System.out.println("After removeFirst/removeLast: " + ll);
        
        // Getting first and last
        System.out.println("First: " + ll.getFirst());
        System.out.println("Last: " + ll.getLast());
        
        // Iterating with ListIterator
        System.out.println("Forward iteration:");
        ListIterator<String> forward = ll.listIterator();
        while (forward.hasNext()) {
            System.out.println(forward.next());
        }
        
        System.out.println("Backward iteration:");
        ListIterator<String> backward = ll.listIterator(ll.size());
        while (backward.hasPrevious()) {
            System.out.println(backward.previous());
        }
    }
}

// Vector demonstration (thread-safe ArrayList)
public class VectorDemo {
    public static void main(String[] args) {
        // Creating Vector
        Vector<String> vector = new Vector<>();
        
        // Adding elements
        vector.add("Apple");
        vector.add("Banana");
        vector.add("Cherry");
        
        System.out.println("Vector: " + vector);
        System.out.println("Size: " + vector.size());
        System.out.println("Capacity: " + vector.capacity());
        
        // Vector-specific operations
        vector.addElement("Date");
        System.out.println("After addElement: " + vector);
        
        vector.insertElementAt("Orange", 1);
        System.out.println("After insertElementAt: " + vector);
        
        vector.removeElement("Banana");
        System.out.println("After removeElement: " + vector);
        
        vector.removeElementAt(2);
        System.out.println("After removeElementAt: " + vector);
        
        // Enumeration
        System.out.println("Using Enumeration:");
        Enumeration<String> enumeration = vector.elements();
        while (enumeration.hasMoreElements()) {
            System.out.println(enumeration.nextElement());
        }
        
        // Setting capacity
        vector.ensureCapacity(20);
        System.out.println("New capacity: " + vector.capacity());
        
        // Trimming capacity
        vector.trimToSize();
        System.out.println("After trim: " + vector.capacity());
    }
}

// Stack demonstration
public class StackDemo {
    public static void main(String[] args) {
        // Creating Stack
        Stack<String> stack = new Stack<>();
        
        // Pushing elements
        stack.push("First");
        stack.push("Second");
        stack.push("Third");
        
        System.out.println("Stack: " + stack);
        System.out.println("Size: " + stack.size());
        System.out.println("Is empty: " + stack.isEmpty());
        
        // Peeking
        System.out.println("Top element: " + stack.peek());
        
        // Popping elements
        while (!stack.isEmpty()) {
            System.out.println("Popped: " + stack.pop());
        }
        
        System.out.println("Stack after popping all: " + stack);
        
        // Stack-specific operations
        stack.push("A");
        stack.push("B");
        stack.push("C");
        
        System.out.println("Search 'B': " + stack.search("B")); // Returns distance from top
        System.out.println("Search 'A': " + stack.search("A")); // Returns distance from top
        
        // Iterating
        System.out.println("Iterating stack:");
        for (String item : stack) {
            System.out.println(item);
        }
    }
}

// Performance comparison
public class ListPerformanceDemo {
    public static void main(String[] args) {
        int size = 100000;
        
        // ArrayList performance
        List<Integer> arrayList = new ArrayList<>();
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("ArrayList add time: " + (endTime - startTime) + "ms");
        
        // LinkedList performance
        List<Integer> linkedList = new LinkedList<>();
        startTime = System.currentTimeMillis();
        
        for (int i = 0; i < size; i++) {
            linkedList.add(i);
        }
        
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList add time: " + (endTime - startTime) + "ms");
        
        // Random access performance
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            arrayList.get(i * 100);
        }
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList random access time: " + (endTime - startTime) + "ms");
        
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            linkedList.get(i * 100);
        }
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList random access time: " + (endTime - startTime) + "ms");
    }
}
```
</UniversalEditor>

### 2. Set Interface and Implementations

Java provides Set interface for unique collections, while JavaScript uses Set and object keys for similar functionality.

<UniversalEditor title="Set Interface and Implementations" compare={true}>
```javascript !! js
// JavaScript - Set-based collections
// HashSet implementation using object keys
class HashSet {
    constructor() {
        this.items = {};
        this.size = 0;
    }
    
    add(item) {
        const key = this.getKey(item);
        if (!this.items.hasOwnProperty(key)) {
            this.items[key] = item;
            this.size++;
        }
        return this;
    }
    
    delete(item) {
        const key = this.getKey(item);
        if (this.items.hasOwnProperty(key)) {
            delete this.items[key];
            this.size--;
            return true;
        }
        return false;
    }
    
    has(item) {
        const key = this.getKey(item);
        return this.items.hasOwnProperty(key);
    }
    
    clear() {
        this.items = {};
        this.size = 0;
    }
    
    getSize() {
        return this.size;
    }
    
    isEmpty() {
        return this.size === 0;
    }
    
    toArray() {
        return Object.values(this.items);
    }
    
    forEach(callback) {
        Object.values(this.items).forEach(callback);
    }
    
    // Helper method to generate keys
    getKey(item) {
        if (typeof item === 'string') {
            return 'str_' + item;
        } else if (typeof item === 'number') {
            return 'num_' + item;
        } else if (typeof item === 'boolean') {
            return 'bool_' + item;
        } else if (item === null) {
            return 'null';
        } else if (item === undefined) {
            return 'undefined';
        } else {
            // For objects, use JSON stringify (simplified)
            return 'obj_' + JSON.stringify(item);
        }
    }
    
    // Set operations
    union(otherSet) {
        const unionSet = new HashSet();
        this.forEach(item => unionSet.add(item));
        otherSet.forEach(item => unionSet.add(item));
        return unionSet;
    }
    
    intersection(otherSet) {
        const intersectionSet = new HashSet();
        this.forEach(item => {
            if (otherSet.has(item)) {
                intersectionSet.add(item);
            }
        });
        return intersectionSet;
    }
    
    difference(otherSet) {
        const differenceSet = new HashSet();
        this.forEach(item => {
            if (!otherSet.has(item)) {
                differenceSet.add(item);
            }
        });
        return differenceSet;
    }
    
    isSubset(otherSet) {
        return this.toArray().every(item => otherSet.has(item));
    }
}

// TreeSet implementation (sorted set)
class TreeSet {
    constructor(compareFunction = null) {
        this.items = [];
        this.compareFunction = compareFunction || ((a, b) => a < b ? -1 : a > b ? 1 : 0);
    }
    
    add(item) {
        if (!this.has(item)) {
            this.items.push(item);
            this.items.sort(this.compareFunction);
        }
        return this;
    }
    
    delete(item) {
        const index = this.items.findIndex(x => this.compareFunction(x, item) === 0);
        if (index !== -1) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }
    
    has(item) {
        return this.items.some(x => this.compareFunction(x, item) === 0);
    }
    
    clear() {
        this.items = [];
    }
    
    getSize() {
        return this.items.length;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    toArray() {
        return [...this.items];
    }
    
    forEach(callback) {
        this.items.forEach(callback);
    }
    
    // TreeSet-specific methods
    first() {
        return this.items.length > 0 ? this.items[0] : null;
    }
    
    last() {
        return this.items.length > 0 ? this.items[this.items.length - 1] : null;
    }
    
    lower(item) {
        const index = this.items.findIndex(x => this.compareFunction(x, item) >= 0);
        return index > 0 ? this.items[index - 1] : null;
    }
    
    higher(item) {
        const index = this.items.findIndex(x => this.compareFunction(x, item) > 0);
        return index !== -1 ? this.items[index] : null;
    }
    
    floor(item) {
        const index = this.items.findIndex(x => this.compareFunction(x, item) > 0);
        return index > 0 ? this.items[index - 1] : null;
    }
    
    ceiling(item) {
        const index = this.items.findIndex(x => this.compareFunction(x, item) >= 0);
        return index !== -1 ? this.items[index] : null;
    }
}

// LinkedHashSet implementation (maintains insertion order)
class LinkedHashSet {
    constructor() {
        this.items = new Map();
    }
    
    add(item) {
        if (!this.items.has(item)) {
            this.items.set(item, true);
        }
        return this;
    }
    
    delete(item) {
        return this.items.delete(item);
    }
    
    has(item) {
        return this.items.has(item);
    }
    
    clear() {
        this.items.clear();
    }
    
    getSize() {
        return this.items.size;
    }
    
    isEmpty() {
        return this.items.size === 0;
    }
    
    toArray() {
        return Array.from(this.items.keys());
    }
    
    forEach(callback) {
        this.items.forEach((value, key) => callback(key));
    }
    
    // LinkedHashSet-specific methods
    toArrayInOrder() {
        return this.toArray(); // Already maintains order
    }
}

// Usage examples
console.log("=== HashSet Demo ===");
const hashSet = new HashSet();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Apple"); // Duplicate, won't be added
hashSet.add("Cherry");

console.log("HashSet size:", hashSet.getSize()); // 3
console.log("Contains 'Banana':", hashSet.has("Banana")); // true
console.log("HashSet:", hashSet.toArray());

hashSet.delete("Banana");
console.log("After delete:", hashSet.toArray());

// Set operations
const set1 = new HashSet();
set1.add(1).add(2).add(3);

const set2 = new HashSet();
set2.add(2).add(3).add(4);

console.log("Set1:", set1.toArray());
console.log("Set2:", set2.toArray());
console.log("Union:", set1.union(set2).toArray());
console.log("Intersection:", set1.intersection(set2).toArray());
console.log("Difference:", set1.difference(set2).toArray());

console.log("=== TreeSet Demo ===");
const treeSet = new TreeSet();
treeSet.add(3).add(1).add(4).add(1).add(5).add(9).add(2).add(6);

console.log("TreeSet:", treeSet.toArray()); // [1, 2, 3, 4, 5, 6, 9]
console.log("First:", treeSet.first()); // 1
console.log("Last:", treeSet.last()); // 9
console.log("Lower than 4:", treeSet.lower(4)); // 3
console.log("Higher than 4:", treeSet.higher(4)); // 5

console.log("=== LinkedHashSet Demo ===");
const linkedHashSet = new LinkedHashSet();
linkedHashSet.add("First").add("Second").add("Third").add("First");

console.log("LinkedHashSet:", linkedHashSet.toArray()); // ["First", "Second", "Third"]

// Native JavaScript Set comparison
console.log("=== Native Set Demo ===");
const nativeSet = new Set();
nativeSet.add("Apple");
nativeSet.add("Banana");
nativeSet.add("Apple"); // Duplicate, won't be added

console.log("Native Set size:", nativeSet.size);
console.log("Native Set:", Array.from(nativeSet));

// Set operations with native Set
const nativeSet1 = new Set([1, 2, 3]);
const nativeSet2 = new Set([2, 3, 4]);

console.log("Native Set1:", Array.from(nativeSet1));
console.log("Native Set2:", Array.from(nativeSet2));

// Union
const union = new Set([...nativeSet1, ...nativeSet2]);
console.log("Native Union:", Array.from(union));

// Intersection
const intersection = new Set(
    Array.from(nativeSet1).filter(x => nativeSet2.has(x))
);
console.log("Native Intersection:", Array.from(intersection));

// Difference
const difference = new Set(
    Array.from(nativeSet1).filter(x => !nativeSet2.has(x))
);
console.log("Native Difference:", Array.from(difference));
```

```java !! java
// Java - Collections Framework Set implementations
import java.util.*;

// HashSet demonstration
public class HashSetDemo {
    public static void main(String[] args) {
        // Creating HashSet
        Set<String> hashSet = new HashSet<>();
        
        // Adding elements
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Apple"); // Duplicate, won't be added
        hashSet.add("Cherry");
        
        System.out.println("HashSet: " + hashSet);
        System.out.println("Size: " + hashSet.size());
        System.out.println("Contains 'Banana': " + hashSet.contains("Banana"));
        
        // Removing elements
        hashSet.remove("Banana");
        System.out.println("After remove: " + hashSet);
        
        // Adding collection
        List<String> fruits = Arrays.asList("Date", "Elderberry", "Fig");
        hashSet.addAll(fruits);
        System.out.println("After addAll: " + hashSet);
        
        // Iterating
        System.out.println("Iterating with for-each:");
        for (String fruit : hashSet) {
            System.out.println(fruit);
        }
        
        System.out.println("Iterating with forEach:");
        hashSet.forEach(System.out::println);
        
        // Set operations
        Set<String> set1 = new HashSet<>(Arrays.asList("A", "B", "C"));
        Set<String> set2 = new HashSet<>(Arrays.asList("B", "C", "D"));
        
        System.out.println("Set1: " + set1);
        System.out.println("Set2: " + set2);
        
        // Union
        Set<String> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("Union: " + union);
        
        // Intersection
        Set<String> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("Intersection: " + intersection);
        
        // Difference
        Set<String> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("Difference: " + difference);
        
        // Subset check
        boolean isSubset = set1.containsAll(intersection);
        System.out.println("Intersection is subset of Set1: " + isSubset);
    }
}

// TreeSet demonstration
public class TreeSetDemo {
    public static void main(String[] args) {
        // Creating TreeSet
        Set<String> treeSet = new TreeSet<>();
        
        // Adding elements
        treeSet.add("Cherry");
        treeSet.add("Apple");
        treeSet.add("Banana");
        treeSet.add("Date");
        
        System.out.println("TreeSet: " + treeSet); // Natural ordering
        System.out.println("Size: " + treeSet.size());
        
        // TreeSet-specific operations
        TreeSet<String> ts = (TreeSet<String>) treeSet;
        
        System.out.println("First: " + ts.first());
        System.out.println("Last: " + ts.last());
        System.out.println("Lower than 'C': " + ts.lower("C"));
        System.out.println("Higher than 'C': " + ts.higher("C"));
        System.out.println("Floor of 'C': " + ts.floor("C"));
        System.out.println("Ceiling of 'C': " + ts.ceiling("C"));
        
        // Head and tail sets
        Set<String> headSet = ts.headSet("C");
        Set<String> tailSet = ts.tailSet("C");
        Set<String> subSet = ts.subSet("A", "D");
        
        System.out.println("HeadSet (before 'C'): " + headSet);
        System.out.println("TailSet (from 'C'): " + tailSet);
        System.out.println("SubSet (A to D): " + subSet);
        
        // Polling
        System.out.println("Poll first: " + ts.pollFirst());
        System.out.println("Poll last: " + ts.pollLast());
        System.out.println("After polling: " + ts);
        
        // Custom comparator
        TreeSet<String> reverseSet = new TreeSet<>(Collections.reverseOrder());
        reverseSet.addAll(Arrays.asList("Apple", "Banana", "Cherry"));
        System.out.println("Reverse TreeSet: " + reverseSet);
    }
}

// LinkedHashSet demonstration
public class LinkedHashSetDemo {
    public static void main(String[] args) {
        // Creating LinkedHashSet
        Set<String> linkedHashSet = new LinkedHashSet<>();
        
        // Adding elements
        linkedHashSet.add("First");
        linkedHashSet.add("Second");
        linkedHashSet.add("Third");
        linkedHashSet.add("First"); // Duplicate, won't be added
        
        System.out.println("LinkedHashSet: " + linkedHashSet);
        System.out.println("Size: " + linkedHashSet.size());
        
        // Order is maintained
        System.out.println("Iterating (order maintained):");
        for (String item : linkedHashSet) {
            System.out.println(item);
        }
        
        // Converting to array
        String[] array = linkedHashSet.toArray(new String[0]);
        System.out.println("Array: " + Arrays.toString(array));
        
        // Performance comparison
        int size = 100000;
        
        // HashSet performance
        Set<Integer> hashSet = new HashSet<>();
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < size; i++) {
            hashSet.add(i);
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("HashSet add time: " + (endTime - startTime) + "ms");
        
        // TreeSet performance
        Set<Integer> treeSet = new TreeSet<>();
        startTime = System.currentTimeMillis();
        
        for (int i = 0; i < size; i++) {
            treeSet.add(i);
        }
        
        endTime = System.currentTimeMillis();
        System.out.println("TreeSet add time: " + (endTime - startTime) + "ms");
        
        // LinkedHashSet performance
        Set<Integer> linkedSet = new LinkedHashSet<>();
        startTime = System.currentTimeMillis();
        
        for (int i = 0; i < size; i++) {
            linkedSet.add(i);
        }
        
        endTime = System.currentTimeMillis();
        System.out.println("LinkedHashSet add time: " + (endTime - startTime) + "ms");
    }
}

// EnumSet demonstration
public class EnumSetDemo {
    enum DayOfWeek {
        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
    }
    
    public static void main(String[] args) {
        // Creating EnumSet
        EnumSet<DayOfWeek> weekdays = EnumSet.range(DayOfWeek.MONDAY, DayOfWeek.FRIDAY);
        System.out.println("Weekdays: " + weekdays);
        
        EnumSet<DayOfWeek> weekend = EnumSet.of(DayOfWeek.SATURDAY, DayOfWeek.SUNDAY);
        System.out.println("Weekend: " + weekend);
        
        // All days
        EnumSet<DayOfWeek> allDays = EnumSet.allOf(DayOfWeek.class);
        System.out.println("All days: " + allDays);
        
        // Complement
        EnumSet<DayOfWeek> notWeekdays = EnumSet.complementOf(weekdays);
        System.out.println("Not weekdays: " + notWeekdays);
        
        // Adding and removing
        weekdays.add(DayOfWeek.SATURDAY);
        System.out.println("After adding Saturday: " + weekdays);
        
        weekdays.remove(DayOfWeek.MONDAY);
        System.out.println("After removing Monday: " + weekdays);
    }
}
```
</UniversalEditor>

## Exercises

### Exercise 1: List Operations

<UniversalEditor title="Exercise 1: List Operations">
```java !! java
// TODO: Implement list operations
public class ListOperations {
    // TODO: Add method to reverse a list
    
    // TODO: Add method to find duplicates in a list
    
    // TODO: Add method to remove duplicates from a list
    
    // TODO: Add method to find the most frequent element
    
    // TODO: Add method to check if a list is palindrome
    
    // TODO: Add method to rotate a list by n positions
}

public class ListExercise {
    public static void main(String[] args) {
        ListOperations ops = new ListOperations();
        
        // Test your implementations
        List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry", "Apple", "Date");
        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 1);
        
        System.out.println("Original list: " + fruits);
        System.out.println("Reversed: " + ops.reverse(fruits));
        System.out.println("Duplicates: " + ops.findDuplicates(fruits));
        System.out.println("Without duplicates: " + ops.removeDuplicates(fruits));
        System.out.println("Most frequent: " + ops.findMostFrequent(fruits));
        
        System.out.println("Numbers: " + numbers);
        System.out.println("Is palindrome: " + ops.isPalindrome(numbers));
        System.out.println("Rotated by 2: " + ops.rotate(numbers, 2));
    }
}
```
</UniversalEditor>

### Exercise 2: Set Operations

<UniversalEditor title="Exercise 2: Set Operations">
```java !! java
// TODO: Implement set operations
public class SetOperations {
    // TODO: Add method to find symmetric difference of two sets
    
    // TODO: Add method to check if two sets are disjoint
    
    // TODO: Add method to find power set of a set
    
    // TODO: Add method to find cartesian product of two sets
    
    // TODO: Add method to partition a set into subsets of given size
}

public class SetExercise {
    public static void main(String[] args) {
        SetOperations ops = new SetOperations();
        
        // Test your implementations
        Set<String> set1 = new HashSet<>(Arrays.asList("A", "B", "C"));
        Set<String> set2 = new HashSet<>(Arrays.asList("B", "C", "D"));
        
        System.out.println("Set1: " + set1);
        System.out.println("Set2: " + set2);
        System.out.println("Symmetric difference: " + ops.symmetricDifference(set1, set2));
        System.out.println("Are disjoint: " + ops.areDisjoint(set1, set2));
        
        Set<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3));
        System.out.println("Power set: " + ops.powerSet(numbers));
        System.out.println("Cartesian product: " + ops.cartesianProduct(set1, set2));
        System.out.println("Partitions of size 2: " + ops.partition(numbers, 2));
    }
}
```
</UniversalEditor>

## Summary

In this module, we explored Java's Collections Framework and compared it with JavaScript's collection approaches:

### Key Points:
1. **List Interface**: Ordered collections with ArrayList, LinkedList, Vector, Stack
2. **Set Interface**: Unique collections with HashSet, TreeSet, LinkedHashSet
3. **Performance**: Different implementations have different performance characteristics
4. **Type Safety**: Java collections provide compile-time type safety
5. **Rich API**: Extensive methods for manipulation and iteration

### Next Steps:
- Practice using different collection implementations
- Master collection operations and algorithms
- Explore Map interface and implementations
- Prepare for the next module on concurrency

## Additional Resources

- [Java Collections Framework](https://docs.oracle.com/javase/tutorial/collections/)
- [Java List Interface](https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html)
- [Java Set Interface](https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html)

---

**Exercise Tips**: Focus on understanding when to use different collection implementations. Practice set operations and list manipulations. Consider performance implications when choosing collections. 