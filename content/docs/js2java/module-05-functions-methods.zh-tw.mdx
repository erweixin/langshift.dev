---
title: "模組 05: 函數和方法"
description: "學習 Java 方法、函數重載、遞歸和函數式編程概念，與 JavaScript 函數進行對比。"
---

# 模組 05: 函數和方法

在本模組中，我們將探索 Java 方法以及它們與 JavaScript 函數的對比。雖然 JavaScript 具有靈活的函數聲明和表達式，但 Java 提供了具有強類型化和重載能力的結構化方法定義。

## 學習目標

完成本模組後，您將能夠：
- 理解 Java 方法語法和結構
- 比較 Java 方法與 JavaScript 函數
- 在 Java 中實現方法重載
- 有效使用遞歸
- 應用函數式編程概念
- 理解方法作用域和可見性

## 方法基礎

### 1. 方法聲明和定義

Java 方法在類中定義，具有嚴格的類型化，與 JavaScript 的靈活函數聲明不同。

<UniversalEditor title="方法聲明和定義" compare={true}>
```javascript !! js
// JavaScript - 函數聲明和表達式
// 函數聲明
function greet(name) {
    return "Hello, " + name + "!";
}

// 函數表達式
const greetArrow = (name) => {
    return "Hello, " + name + "!";
};

// 隱式返回的函數表達式
const greetShort = name => "Hello, " + name + "!";

// 帶默認參數的函數
function greetWithDefault(name = "World") {
    return "Hello, " + name + "!";
}

// 帶剩餘參數的函數
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

// 函數作為一等公民
const operations = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => a / b
};

// 返回函數的函數（閉包）
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

// 使用
console.log(greet("Alice"));
console.log(greetArrow("Bob"));
console.log(greetShort("Charlie"));
console.log(greetWithDefault());
console.log(sum(1, 2, 3, 4, 5));
console.log(operations.add(5, 3));
console.log(operations.multiply(4, 6));

const double = createMultiplier(2);
const triple = createMultiplier(3);
console.log(double(5));  // 10
console.log(triple(5));  // 15
```

```java !! java
// Java - 類內的方法聲明
public class MethodBasics {
    // 帶返回類型的方法聲明
    public String greet(String name) {
        return "Hello, " + name + "!";
    }
    
    // 帶 void 返回類型的方法（無返回值）
    public void printGreeting(String name) {
        System.out.println("Hello, " + name + "!");
    }
    
    // 帶多個參數的方法
    public int add(int a, int b) {
        return a + b;
    }
    
    // 帶不同參數類型的方法
    public double add(double a, double b) {
        return a + b;
    }
    
    // 帶數組參數的方法
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }
    
    // 靜態方法（屬於類，不屬於實例）
    public static String staticGreet(String name) {
        return "Static hello, " + name + "!";
    }
    
    // 私有方法（只能在類內訪問）
    private String privateGreet(String name) {
        return "Private hello, " + name + "!";
    }
    
    // 調用另一個方法的方法
    public void demonstrateMethods() {
        System.out.println(greet("Alice"));
        printGreeting("Bob");
        System.out.println("Sum: " + add(5, 3));
        System.out.println("Double sum: " + add(5.5, 3.3));
        System.out.println("Varargs sum: " + sum(1, 2, 3, 4, 5));
        System.out.println(staticGreet("Charlie"));
        System.out.println(privateGreet("David"));
    }
    
    public static void main(String[] args) {
        MethodBasics example = new MethodBasics();
        example.demonstrateMethods();
    }
}
```
</UniversalEditor>

### 2. 方法重載

Java 支持方法重載（多個同名但參數不同的方法），這是 JavaScript 原生不具備的功能。

<UniversalEditor title="方法重載" compare={true}>
```javascript !! js
// JavaScript - 無原生重載，但可以用不同方法模擬
// 方法 1: 使用不同的函數名
function addNumbers(a, b) {
    return a + b;
}

function addThreeNumbers(a, b, c) {
    return a + b + c;
}

function addArray(numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

// 方法 2: 使用參數檢查
function add(...args) {
    if (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {
        return args[0] + args[1];
    } else if (args.length === 3 && typeof args[0] === 'number' && typeof args[1] === 'number' && typeof args[2] === 'number') {
        return args[0] + args[1] + args[2];
    } else if (args.length === 1 && Array.isArray(args[0])) {
        return args[0].reduce((acc, num) => acc + num, 0);
    } else {
        throw new Error("Invalid parameters");
    }
}

// 方法 3: 使用對象參數
function calculate(operation, params) {
    switch (operation) {
        case 'add':
            return params.a + params.b;
        case 'multiply':
            return params.a * params.b;
        case 'divide':
            return params.a / params.b;
        default:
            throw new Error("Unknown operation");
    }
}

// 使用
console.log(addNumbers(5, 3));
console.log(addThreeNumbers(1, 2, 3));
console.log(addArray([1, 2, 3, 4, 5]));

console.log(add(5, 3));
console.log(add(1, 2, 3));
console.log(add([1, 2, 3, 4, 5]));

console.log(calculate('add', {a: 5, b: 3}));
console.log(calculate('multiply', {a: 4, b: 6}));
```

```java !! java
// Java - 方法重載（同名，不同參數）
public class MethodOverloading {
    // 不同參數數量的重載方法
    public int add(int a, int b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    public int add(int... numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
    
    // 不同參數類型的重載方法
    public double add(double a, double b) {
        return a + b;
    }
    
    public String add(String a, String b) {
        return a + b;
    }
    
    // 不同參數順序的重載方法
    public void printInfo(String name, int age) {
        System.out.println("Name: " + name + ", Age: " + age);
    }
    
    public void printInfo(int age, String name) {
        System.out.println("Age: " + age + ", Name: " + name);
    }
    
    // 構造函數重載
    public MethodOverloading() {
        System.out.println("Default constructor");
    }
    
    public MethodOverloading(String message) {
        System.out.println("Constructor with message: " + message);
    }
    
    public MethodOverloading(int number) {
        System.out.println("Constructor with number: " + number);
    }
    
    public void demonstrateOverloading() {
        System.out.println("add(5, 3): " + add(5, 3));
        System.out.println("add(1, 2, 3): " + add(1, 2, 3));
        System.out.println("add(1, 2, 3, 4, 5): " + add(1, 2, 3, 4, 5));
        System.out.println("add(5.5, 3.3): " + add(5.5, 3.3));
        System.out.println("add(\"Hello, \", \"World!\"): " + add("Hello, ", "World!"));
        
        printInfo("Alice", 25);
        printInfo(30, "Bob");
    }
    
    public static void main(String[] args) {
        MethodOverloading example = new MethodOverloading();
        example.demonstrateOverloading();
        
        // 構造函數重載演示
        new MethodOverloading();
        new MethodOverloading("Hello from constructor");
        new MethodOverloading(42);
    }
}
```
</UniversalEditor>

### 3. 遞歸方法

遞歸是函數調用自身的技術，在兩種語言中都有重要應用。

<UniversalEditor title="遞歸方法" compare={true}>
```javascript !! js
// JavaScript - 遞歸函數
// 階乘計算
function factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// 斐波那契數列
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 尾遞歸優化（JavaScript 引擎可能優化）
function factorialTail(n, acc = 1) {
    if (n <= 1) {
        return acc;
    }
    return factorialTail(n - 1, n * acc);
}

// 深度優先搜索
function dfs(node, visited = new Set()) {
    if (!node || visited.has(node)) {
        return;
    }
    
    visited.add(node);
    console.log("Visiting:", node.value);
    
    if (node.left) dfs(node.left, visited);
    if (node.right) dfs(node.right, visited);
}

// 使用
console.log("Factorial of 5:", factorial(5));
console.log("Fibonacci(7):", fibonacci(7));
console.log("Factorial tail of 5:", factorialTail(5));

// 簡單的樹結構
const tree = {
    value: 1,
    left: { value: 2, left: { value: 4 }, right: { value: 5 } },
    right: { value: 3, left: { value: 6 }, right: { value: 7 } }
};

console.log("DFS traversal:");
dfs(tree);
```

```java !! java
// Java - 遞歸方法
public class RecursionExamples {
    // 階乘計算
    public static int factorial(int n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    // 斐波那契數列
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    // 尾遞歸（Java 不自動優化，但可以手動優化）
    public static int factorialTail(int n, int acc) {
        if (n <= 1) {
            return acc;
        }
        return factorialTail(n - 1, n * acc);
    }
    
    // 重載方法提供默認參數
    public static int factorialTail(int n) {
        return factorialTail(n, 1);
    }
    
    // 深度優先搜索
    public static void dfs(TreeNode node, java.util.Set<TreeNode> visited) {
        if (node == null || visited.contains(node)) {
            return;
        }
        
        visited.add(node);
        System.out.println("Visiting: " + node.value);
        
        dfs(node.left, visited);
        dfs(node.right, visited);
    }
    
    // 重載方法提供默認參數
    public static void dfs(TreeNode node) {
        dfs(node, new java.util.HashSet<>());
    }
    
    // 二分查找（遞歸版本）
    public static int binarySearch(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1; // 未找到
        }
        
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return binarySearch(arr, target, left, mid - 1);
        } else {
            return binarySearch(arr, target, mid + 1, right);
        }
    }
    
    // 重載方法提供默認參數
    public static int binarySearch(int[] arr, int target) {
        return binarySearch(arr, target, 0, arr.length - 1);
    }
    
    public static void main(String[] args) {
        System.out.println("Factorial of 5: " + factorial(5));
        System.out.println("Fibonacci(7): " + fibonacci(7));
        System.out.println("Factorial tail of 5: " + factorialTail(5));
        
        // 創建簡單的樹結構
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);
        root.right.right = new TreeNode(7);
        
        System.out.println("DFS traversal:");
        dfs(root);
        
        // 二分查找測試
        int[] arr = {1, 3, 5, 7, 9, 11, 13, 15};
        int target = 7;
        int result = binarySearch(arr, target);
        System.out.println("Binary search for " + target + ": index " + result);
    }
}

// 簡單的樹節點類
class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
    
    TreeNode(int value) {
        this.value = value;
    }
}
```
</UniversalEditor>

### 4. 函數式編程概念

Java 8+ 引入了函數式編程特性，與 JavaScript 的函數式特性進行對比。

<UniversalEditor title="函數式編程概念" compare={true}>
```javascript !! js
// JavaScript - 函數式編程特性
// 高階函數
function map(array, transform) {
    return array.map(transform);
}

function filter(array, predicate) {
    return array.filter(predicate);
}

function reduce(array, reducer, initialValue) {
    return array.reduce(reducer, initialValue);
}

// 函數組合
function compose(...functions) {
    return function(x) {
        return functions.reduceRight((acc, fn) => fn(acc), x);
    };
}

function pipe(...functions) {
    return function(x) {
        return functions.reduce((acc, fn) => fn(acc), x);
    };
}

// 柯里化
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function(...moreArgs) {
            return curried.apply(this, args.concat(moreArgs));
        };
    };
}

// 偏函數應用
function partial(fn, ...presetArgs) {
    return function(...laterArgs) {
        return fn.apply(this, presetArgs.concat(laterArgs));
    };
}

// 使用示例
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// 高階函數使用
const doubled = map(numbers, x => x * 2);
const evens = filter(numbers, x => x % 2 === 0);
const sum = reduce(numbers, (acc, x) => acc + x, 0);

console.log("Doubled:", doubled);
console.log("Evens:", evens);
console.log("Sum:", sum);

// 函數組合
const addOne = x => x + 1;
const multiplyByTwo = x => x * 2;
const square = x => x * x;

const composed = compose(square, multiplyByTwo, addOne);
const piped = pipe(addOne, multiplyByTwo, square);

console.log("Composed(3):", composed(3)); // ((3 + 1) * 2)^2 = 64
console.log("Piped(3):", piped(3)); // ((3 + 1) * 2)^2 = 64

// 柯里化
const add = curry((a, b, c) => a + b + c);
const addFive = add(5);
const addFiveAndThree = addFive(3);

console.log("Curried add(5, 3, 2):", add(5, 3, 2));
console.log("Curried add(5)(3)(2):", add(5)(3)(2));
console.log("Partial add(5, 3)(2):", addFiveAndThree(2));

// 偏函數應用
const addToTen = partial((a, b) => a + b, 10);
console.log("Partial add(10, 5):", addToTen(5));
```

```java !! java
// Java - 函數式編程特性（Java 8+）
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class FunctionalProgramming {
    // 高階函數（使用 Stream API）
    public static <T, R> List<R> map(List<T> list, Function<T, R> transform) {
        return list.stream()
                   .map(transform)
                   .collect(Collectors.toList());
    }
    
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        return list.stream()
                   .filter(predicate)
                   .collect(Collectors.toList());
    }
    
    public static <T> T reduce(List<T> list, BinaryOperator<T> reducer, T initialValue) {
        return list.stream()
                   .reduce(initialValue, reducer);
    }
    
    // 函數組合
    public static <T> Function<T, T> compose(Function<T, T>... functions) {
        return Arrays.stream(functions)
                     .reduce(Function.identity(), Function::compose);
    }
    
    public static <T> Function<T, T> pipe(Function<T, T>... functions) {
        return Arrays.stream(functions)
                     .reduce(Function.identity(), (f, g) -> f.andThen(g));
    }
    
    // 柯里化（手動實現）
    public static Function<Integer, Function<Integer, Function<Integer, Integer>>> 
    curryAdd() {
        return a -> b -> c -> a + b + c;
    }
    
    // 偏函數應用
    public static Function<Integer, Integer> partialAdd(int a) {
        return b -> a + b;
    }
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // 高階函數使用
        List<Integer> doubled = map(numbers, x -> x * 2);
        List<Integer> evens = filter(numbers, x -> x % 2 == 0);
        Integer sum = reduce(numbers, Integer::sum, 0);
        
        System.out.println("Doubled: " + doubled);
        System.out.println("Evens: " + evens);
        System.out.println("Sum: " + sum);
        
        // Stream API 直接使用
        List<Integer> squared = numbers.stream()
                                      .map(x -> x * x)
                                      .collect(Collectors.toList());
        System.out.println("Squared: " + squared);
        
        // 函數組合
        Function<Integer, Integer> addOne = x -> x + 1;
        Function<Integer, Integer> multiplyByTwo = x -> x * 2;
        Function<Integer, Integer> square = x -> x * x;
        
        Function<Integer, Integer> composed = compose(square, multiplyByTwo, addOne);
        Function<Integer, Integer> piped = pipe(addOne, multiplyByTwo, square);
        
        System.out.println("Composed(3): " + composed.apply(3)); // ((3 + 1) * 2)^2 = 64
        System.out.println("Piped(3): " + piped.apply(3)); // ((3 + 1) * 2)^2 = 64
        
        // 柯里化
        Function<Integer, Function<Integer, Function<Integer, Integer>>> curriedAdd = curryAdd();
        System.out.println("Curried add(5, 3, 2): " + curriedAdd.apply(5).apply(3).apply(2));
        
        // 偏函數應用
        Function<Integer, Integer> addToTen = partialAdd(10);
        System.out.println("Partial add(10, 5): " + addToTen.apply(5));
        
        // Optional 使用（函數式錯誤處理）
        Optional<Integer> maybeNumber = Optional.of(42);
        Optional<String> result = maybeNumber
            .map(x -> x * 2)
            .filter(x -> x > 80)
            .map(x -> "Result: " + x);
        
        System.out.println("Optional result: " + result.orElse("No result"));
        
        // 方法引用
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        names.forEach(System.out::println);
        
        // 比較器函數式寫法
        List<String> sortedNames = names.stream()
                                       .sorted(String::compareTo)
                                       .collect(Collectors.toList());
        System.out.println("Sorted names: " + sortedNames);
    }
}
```
</UniversalEditor>

## 方法作用域和可見性

### 1. 訪問修飾符

Java 提供了詳細的訪問控制，而 JavaScript 的訪問控制相對簡單。

<UniversalEditor title="訪問修飾符" compare={true}>
```javascript !! js
// JavaScript - 訪問控制相對簡單
class Example {
    constructor() {
        // 公共屬性（默認）
        this.publicProperty = "I'm public";
        
        // 私有屬性（使用 # 前綴，ES2022+）
        this.#privateProperty = "I'm private";
        
        // 受保護屬性（約定，非強制）
        this._protectedProperty = "I'm protected (by convention)";
    }
    
    // 公共方法
    publicMethod() {
        return "I'm a public method";
    }
    
    // 私有方法（ES2022+）
    #privateMethod() {
        return "I'm a private method";
    }
    
    // 受保護方法（約定）
    _protectedMethod() {
        return "I'm a protected method (by convention)";
    }
    
    // 訪問私有成員的方法
    accessPrivate() {
        console.log(this.#privateProperty);
        console.log(this.#privateMethod());
    }
}

// 模塊級私有（使用閉包）
const privateModule = (function() {
    let privateVariable = "I'm module private";
    
    function privateFunction() {
        return "I'm a private function";
    }
    
    return {
        publicFunction: function() {
            console.log(privateVariable);
            console.log(privateFunction());
        }
    };
})();

// 使用
const example = new Example();
console.log(example.publicProperty);
console.log(example.publicMethod());
example.accessPrivate();

// 注意：以下會拋出錯誤
// console.log(example.#privateProperty); // SyntaxError
// example.#privateMethod(); // SyntaxError

privateModule.publicFunction();
```

```java !! java
// Java - 詳細的訪問控制
public class AccessModifiers {
    // 公共成員 - 任何地方都可訪問
    public String publicField = "I'm public";
    public void publicMethod() {
        System.out.println("I'm a public method");
    }
    
    // 受保護成員 - 同包和子類可訪問
    protected String protectedField = "I'm protected";
    protected void protectedMethod() {
        System.out.println("I'm a protected method");
    }
    
    // 包私有成員（默認） - 同包內可訪問
    String packagePrivateField = "I'm package private";
    void packagePrivateMethod() {
        System.out.println("I'm a package private method");
    }
    
    // 私有成員 - 只有類內可訪問
    private String privateField = "I'm private";
    private void privateMethod() {
        System.out.println("I'm a private method");
    }
    
    // 公共方法訪問私有成員
    public void accessPrivateMembers() {
        System.out.println(privateField);
        privateMethod();
    }
    
    // 靜態成員
    public static String staticField = "I'm static";
    public static void staticMethod() {
        System.out.println("I'm a static method");
    }
    
    // 常量
    public static final String CONSTANT = "I'm a constant";
}

// 同包中的另一個類
class SamePackageClass {
    public void accessExample() {
        AccessModifiers example = new AccessModifiers();
        
        // 可以訪問公共、受保護和包私有成員
        System.out.println(example.publicField);
        System.out.println(example.protectedField);
        System.out.println(example.packagePrivateField);
        
        example.publicMethod();
        example.protectedMethod();
        example.packagePrivateMethod();
        
        // 不能訪問私有成員
        // System.out.println(example.privateField); // 編譯錯誤
        // example.privateMethod(); // 編譯錯誤
    }
}

// 不同包中的類
package otherpackage;

public class DifferentPackageClass extends AccessModifiers {
    public void accessExample() {
        // 可以訪問公共和受保護成員
        System.out.println(publicField);
        System.out.println(protectedField);
        
        publicMethod();
        protectedMethod();
        
        // 不能訪問包私有和私有成員
        // System.out.println(packagePrivateField); // 編譯錯誤
        // System.out.println(privateField); // 編譯錯誤
    }
}

// 主類演示
public class AccessModifiersDemo {
    public static void main(String[] args) {
        AccessModifiers example = new AccessModifiers();
        
        // 公共成員
        System.out.println(example.publicField);
        example.publicMethod();
        
        // 靜態成員
        System.out.println(AccessModifiers.staticField);
        AccessModifiers.staticMethod();
        
        // 常量
        System.out.println(AccessModifiers.CONSTANT);
        
        // 訪問私有成員的方法
        example.accessPrivateMembers();
    }
}
```
</UniversalEditor>

### 2. 方法重寫和隱藏

Java 中的方法重寫與 JavaScript 的原型鏈方法覆蓋進行對比。

<UniversalEditor title="方法重寫和隱藏" compare={true}>
```javascript !! js
// JavaScript - 原型鏈和方法覆蓋
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    speak() {
        return `${this.name} makes a sound`;
    }
    
    move() {
        return `${this.name} moves`;
    }
    
    // 靜態方法
    static create(name) {
        return new Animal(name);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name);
        this.breed = breed;
    }
    
    // 方法重寫
    speak() {
        return `${this.name} barks`;
    }
    
    // 新增方法
    fetch() {
        return `${this.name} fetches the ball`;
    }
    
    // 調用父類方法
    speakAndMove() {
        return this.speak() + " and " + this.move();
    }
}

class Cat extends Animal {
    constructor(name, color) {
        super(name);
        this.color = color;
    }
    
    speak() {
        return `${this.name} meows`;
    }
    
    climb() {
        return `${this.name} climbs the tree`;
    }
}

// 使用
const dog = new Dog("Buddy", "Golden Retriever");
const cat = new Cat("Whiskers", "Orange");

console.log(dog.speak()); // "Buddy barks"
console.log(cat.speak()); // "Whiskers meows"
console.log(dog.fetch()); // "Buddy fetches the ball"
console.log(cat.climb()); // "Whiskers climbs the tree"
console.log(dog.speakAndMove()); // "Buddy barks and Buddy moves"

// 原型鏈檢查
console.log(dog instanceof Animal); // true
console.log(dog instanceof Dog); // true
console.log(Object.getPrototypeOf(dog) === Dog.prototype); // true

// 方法調用和綁定
const speakMethod = dog.speak;
console.log(speakMethod()); // "undefined barks" (this 丟失)

// 正確的方法調用
const boundSpeak = speakMethod.bind(dog);
console.log(boundSpeak()); // "Buddy barks"

// 使用箭頭函數保持 this 綁定
class ArrowExample {
    constructor() {
        this.value = 42;
    }
    
    regularMethod() {
        setTimeout(function() {
            console.log(this.value); // undefined
        }, 100);
    }
    
    arrowMethod() {
        setTimeout(() => {
            console.log(this.value); // 42
        }, 100);
    }
}
```

```java !! java
// Java - 方法重寫和隱藏
class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    // 可重寫的方法
    public String speak() {
        return name + " makes a sound";
    }
    
    public String move() {
        return name + " moves";
    }
    
    // 靜態方法（不能被重寫，只能被隱藏）
    public static String getType() {
        return "Animal";
    }
    
    // final 方法（不能被重寫）
    public final String getInfo() {
        return "This is an animal named " + name;
    }
    
    // 私有方法（不能被重寫）
    private String privateMethod() {
        return "Private method";
    }
}

class Dog extends Animal {
    private String breed;
    
    public Dog(String name, String breed) {
        super(name); // 調用父類構造函數
        this.breed = breed;
    }
    
    // 方法重寫
    @Override
    public String speak() {
        return name + " barks";
    }
    
    // 新增方法
    public String fetch() {
        return name + " fetches the ball";
    }
    
    // 調用父類方法
    public String speakAndMove() {
        return speak() + " and " + super.move();
    }
    
    // 隱藏靜態方法（不是重寫）
    public static String getType() {
        return "Dog";
    }
    
    // 重載方法
    public String speak(String message) {
        return name + " barks: " + message;
    }
}

class Cat extends Animal {
    private String color;
    
    public Cat(String name, String color) {
        super(name);
        this.color = color;
    }
    
    @Override
    public String speak() {
        return name + " meows";
    }
    
    public String climb() {
        return name + " climbs the tree";
    }
}

// 接口定義
interface Speakable {
    String speak();
    default String getDescription() {
        return "I can speak";
    }
}

// 實現接口
class Bird extends Animal implements Speakable {
    public Bird(String name) {
        super(name);
    }
    
    @Override
    public String speak() {
        return name + " chirps";
    }
    
    @Override
    public String getDescription() {
        return "I am a bird that can chirp";
    }
}

// 主類演示
public class MethodOverridingDemo {
    public static void main(String[] args) {
        // 多態性演示
        Animal[] animals = {
            new Dog("Buddy", "Golden Retriever"),
            new Cat("Whiskers", "Orange"),
            new Bird("Tweety")
        };
        
        for (Animal animal : animals) {
            System.out.println(animal.speak()); // 多態調用
        }
        
        // 具體類型使用
        Dog dog = new Dog("Buddy", "Golden Retriever");
        Cat cat = new Cat("Whiskers", "Orange");
        
        System.out.println(dog.speak()); // "Buddy barks"
        System.out.println(cat.speak()); // "Whiskers meows"
        System.out.println(dog.fetch()); // "Buddy fetches the ball"
        System.out.println(cat.climb()); // "Whiskers climbs the tree"
        System.out.println(dog.speakAndMove()); // "Buddy barks and Buddy moves"
        
        // 靜態方法隱藏
        System.out.println(Animal.getType()); // "Animal"
        System.out.println(Dog.getType()); // "Dog"
        
        // 方法重載
        System.out.println(dog.speak("Hello!")); // "Buddy barks: Hello!"
        
        // 接口實現
        Bird bird = new Bird("Tweety");
        System.out.println(bird.speak()); // "Tweety chirps"
        System.out.println(bird.getDescription()); // "I am a bird that can chirp"
        
        // instanceof 檢查
        System.out.println(dog instanceof Animal); // true
        System.out.println(dog instanceof Dog); // true
        System.out.println(bird instanceof Speakable); // true
    }
}
```
</UniversalEditor>

## 練習題

### 練習 1: 方法重載實現
創建一個 `Calculator` 類，實現以下重載方法：
- `add(int a, int b)` - 兩個整數相加
- `add(double a, double b)` - 兩個浮點數相加
- `add(int... numbers)` - 多個整數相加
- `add(String a, String b)` - 字符串連接

### 練習 2: 遞歸實現
實現以下遞歸方法：
- 計算數組中所有元素的和
- 檢查字符串是否為回文
- 計算最大公約數（GCD）

### 練習 3: 函數式編程
使用 Java 8+ 的 Stream API 實現：
- 過濾偶數並計算平方
- 計算字符串列表中長度大於 5 的字符串數量
- 將數字列表轉換為字符串並連接

## 總結

在本模組中，我們深入學習了 Java 方法的核心概念：

### 關鍵要點
1. **方法結構**: Java 方法必須在類中定義，具有嚴格的類型化
2. **方法重載**: Java 支持同名不同參數的方法重載
3. **遞歸**: 遞歸是解決複雜問題的強大工具
4. **函數式編程**: Java 8+ 提供了豐富的函數式編程特性
5. **訪問控制**: Java 提供了詳細的訪問修飾符系統
6. **方法重寫**: 支持面向對象的多態性

### 與 JavaScript 的對比
- **類型化**: Java 方法有嚴格的類型，JavaScript 函數類型靈活
- **重載**: Java 原生支持方法重載，JavaScript 需要手動模擬
- **作用域**: Java 有詳細的訪問控制，JavaScript 相對簡單
- **函數式**: 兩種語言都支持函數式編程，但實現方式不同

### 下一步學習
在接下來的模組中，我們將學習：
- 類和對象的深入概念
- 繼承和多態
- 接口和抽象類
- 異常處理機制

這些概念將幫助您更好地理解 Java 的面向對象編程範式。 