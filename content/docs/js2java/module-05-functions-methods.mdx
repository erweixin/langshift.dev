---
title: "Module 05: Functions and Methods"
description: "Learn Java methods, function overloading, recursion, and functional programming concepts compared to JavaScript functions."
---

# Module 05: Functions and Methods

In this module, we'll explore Java methods and how they compare to JavaScript functions. While JavaScript has flexible function declarations and expressions, Java provides structured method definitions with strong typing and overloading capabilities.

## Learning Objectives

By the end of this module, you will be able to:
- Understand Java method syntax and structure
- Compare Java methods with JavaScript functions
- Implement method overloading in Java
- Use recursion effectively
- Apply functional programming concepts
- Understand method scope and visibility

## Method Basics

### 1. Method Declaration and Definition

Java methods are defined within classes and have strict typing, unlike JavaScript's flexible function declarations.

<UniversalEditor title="Method Declaration and Definition" compare={true}>
```javascript !! js
// JavaScript - Function declarations and expressions
// Function declaration
function greet(name) {
    return "Hello, " + name + "!";
}

// Function expression
const greetArrow = (name) => {
    return "Hello, " + name + "!";
};

// Function expression with implicit return
const greetShort = name => "Hello, " + name + "!";

// Function with default parameters
function greetWithDefault(name = "World") {
    return "Hello, " + name + "!";
}

// Function with rest parameters
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

// Function as first-class citizen
const operations = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => a / b
};

// Function returning function (closure)
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

// Usage
console.log(greet("Alice"));
console.log(greetArrow("Bob"));
console.log(greetShort("Charlie"));
console.log(greetWithDefault());
console.log(sum(1, 2, 3, 4, 5));
console.log(operations.add(5, 3));
console.log(operations.multiply(4, 6));

const double = createMultiplier(2);
const triple = createMultiplier(3);
console.log(double(5));  // 10
console.log(triple(5));  // 15
```

```java !! java
// Java - Method declarations within classes
public class MethodBasics {
    // Method declaration with return type
    public String greet(String name) {
        return "Hello, " + name + "!";
    }
    
    // Method with void return type (no return value)
    public void printGreeting(String name) {
        System.out.println("Hello, " + name + "!");
    }
    
    // Method with multiple parameters
    public int add(int a, int b) {
        return a + b;
    }
    
    // Method with different parameter types
    public double add(double a, double b) {
        return a + b;
    }
    
    // Method with array parameter
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }
    
    // Static method (belongs to class, not instance)
    public static String staticGreet(String name) {
        return "Static hello, " + name + "!";
    }
    
    // Private method (only accessible within class)
    private String privateGreet(String name) {
        return "Private hello, " + name + "!";
    }
    
    // Method calling another method
    public void demonstrateMethods() {
        System.out.println(greet("Alice"));
        printGreeting("Bob");
        System.out.println("Sum: " + add(5, 3));
        System.out.println("Double sum: " + add(5.5, 3.3));
        System.out.println("Varargs sum: " + sum(1, 2, 3, 4, 5));
        System.out.println(staticGreet("Charlie"));
        System.out.println(privateGreet("David"));
    }
    
    public static void main(String[] args) {
        MethodBasics example = new MethodBasics();
        example.demonstrateMethods();
    }
}
```
</UniversalEditor>

### 2. Method Overloading

Java supports method overloading (multiple methods with same name but different parameters), which JavaScript doesn't have natively.

<UniversalEditor title="Method Overloading" compare={true}>
```javascript !! js
// JavaScript - No native overloading, but can simulate with different approaches
// Approach 1: Using different function names
function addNumbers(a, b) {
    return a + b;
}

function addThreeNumbers(a, b, c) {
    return a + b + c;
}

function addArray(numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

// Approach 2: Using parameter checking
function add(...args) {
    if (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {
        return args[0] + args[1];
    } else if (args.length === 3 && typeof args[0] === 'number' && typeof args[1] === 'number' && typeof args[2] === 'number') {
        return args[0] + args[1] + args[2];
    } else if (args.length === 1 && Array.isArray(args[0])) {
        return args[0].reduce((acc, num) => acc + num, 0);
    } else {
        throw new Error("Invalid parameters");
    }
}

// Approach 3: Using object parameters
function calculate(operation, params) {
    switch (operation) {
        case 'add':
            return params.a + params.b;
        case 'multiply':
            return params.a * params.b;
        case 'divide':
            return params.a / params.b;
        default:
            throw new Error("Unknown operation");
    }
}

// Usage
console.log(addNumbers(5, 3));
console.log(addThreeNumbers(1, 2, 3));
console.log(addArray([1, 2, 3, 4, 5]));

console.log(add(5, 3));
console.log(add(1, 2, 3));
console.log(add([1, 2, 3, 4, 5]));

console.log(calculate('add', {a: 5, b: 3}));
console.log(calculate('multiply', {a: 4, b: 6}));
```

```java !! java
// Java - Method overloading (same name, different parameters)
public class MethodOverloading {
    // Overloaded methods with different parameter counts
    public int add(int a, int b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    public int add(int... numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
    
    // Overloaded methods with different parameter types
    public double add(double a, double b) {
        return a + b;
    }
    
    public String add(String a, String b) {
        return a + b;
    }
    
    // Overloaded methods with different parameter order
    public void printInfo(String name, int age) {
        System.out.println("Name: " + name + ", Age: " + age);
    }
    
    public void printInfo(int age, String name) {
        System.out.println("Age: " + age + ", Name: " + name);
    }
    
    // Constructor overloading
    public MethodOverloading() {
        System.out.println("Default constructor");
    }
    
    public MethodOverloading(String message) {
        System.out.println("Constructor with message: " + message);
    }
    
    public MethodOverloading(int number) {
        System.out.println("Constructor with number: " + number);
    }
    
    // Method to demonstrate overloading
    public void demonstrateOverloading() {
        System.out.println("add(5, 3): " + add(5, 3));
        System.out.println("add(1, 2, 3): " + add(1, 2, 3));
        System.out.println("add(1, 2, 3, 4, 5): " + add(1, 2, 3, 4, 5));
        System.out.println("add(5.5, 3.3): " + add(5.5, 3.3));
        System.out.println("add(\"Hello, \", \"World!\"): " + add("Hello, ", "World!"));
        
        printInfo("Alice", 25);
        printInfo(30, "Bob");
    }
    
    public static void main(String[] args) {
        MethodOverloading example = new MethodOverloading();
        example.demonstrateOverloading();
        
        // Constructor overloading demonstration
        new MethodOverloading("Hello");
        new MethodOverloading(42);
    }
}
```
</UniversalEditor>

## Recursion

### 1. Recursive Methods

Both Java and JavaScript support recursion, but Java's strong typing provides additional safety.

<UniversalEditor title="Recursive Methods" compare={true}>
```javascript !! js
// JavaScript - Recursive functions
// Factorial calculation
function factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// Fibonacci sequence
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Binary search (recursive)
function binarySearch(arr, target, left = 0, right = arr.length - 1) {
    if (left > right) {
        return -1;  // Not found
    }
    
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearch(arr, target, mid + 1, right);
    } else {
        return binarySearch(arr, target, left, mid - 1);
    }
}

// Tree traversal (recursive)
function traverseTree(node) {
    if (!node) {
        return;
    }
    
    console.log(node.value);  // Pre-order traversal
    traverseTree(node.left);
    traverseTree(node.right);
}

// Tower of Hanoi
function towerOfHanoi(n, source, auxiliary, destination) {
    if (n === 1) {
        console.log(`Move disk 1 from ${source} to ${destination}`);
        return;
    }
    
    towerOfHanoi(n - 1, source, destination, auxiliary);
    console.log(`Move disk ${n} from ${source} to ${destination}`);
    towerOfHanoi(n - 1, auxiliary, source, destination);
}

// Usage
console.log("Factorial of 5:", factorial(5));
console.log("Fibonacci(7):", fibonacci(7));

const sortedArray = [1, 3, 5, 7, 9, 11, 13, 15];
console.log("Binary search for 7:", binarySearch(sortedArray, 7));
console.log("Binary search for 10:", binarySearch(sortedArray, 10));

console.log("Tower of Hanoi (3 disks):");
towerOfHanoi(3, 'A', 'B', 'C');
```

```java !! java
// Java - Recursive methods
public class RecursionExamples {
    // Factorial calculation
    public static int factorial(int n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    // Fibonacci sequence
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    // Binary search (recursive)
    public static int binarySearch(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;  // Not found
        }
        
        int mid = (left + right) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            return binarySearch(arr, target, mid + 1, right);
        } else {
            return binarySearch(arr, target, left, mid - 1);
        }
    }
    
    // Overloaded binary search for easier use
    public static int binarySearch(int[] arr, int target) {
        return binarySearch(arr, target, 0, arr.length - 1);
    }
    
    // Tower of Hanoi
    public static void towerOfHanoi(int n, String source, String auxiliary, String destination) {
        if (n == 1) {
            System.out.println("Move disk 1 from " + source + " to " + destination);
            return;
        }
        
        towerOfHanoi(n - 1, source, destination, auxiliary);
        System.out.println("Move disk " + n + " from " + source + " to " + destination);
        towerOfHanoi(n - 1, auxiliary, source, destination);
    }
    
    // GCD (Greatest Common Divisor) using Euclidean algorithm
    public static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
    
    // Power calculation (recursive)
    public static double power(double base, int exponent) {
        if (exponent == 0) {
            return 1;
        } else if (exponent < 0) {
            return 1 / power(base, -exponent);
        } else if (exponent % 2 == 0) {
            double half = power(base, exponent / 2);
            return half * half;
        } else {
            return base * power(base, exponent - 1);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("Factorial of 5: " + factorial(5));
        System.out.println("Fibonacci(7): " + fibonacci(7));
        
        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15};
        System.out.println("Binary search for 7: " + binarySearch(sortedArray, 7));
        System.out.println("Binary search for 10: " + binarySearch(sortedArray, 10));
        
        System.out.println("GCD of 48 and 18: " + gcd(48, 18));
        System.out.println("2^10: " + power(2, 10));
        System.out.println("2^-3: " + power(2, -3));
        
        System.out.println("Tower of Hanoi (3 disks):");
        towerOfHanoi(3, "A", "B", "C");
    }
}
```
</UniversalEditor>

## Functional Programming Concepts

### 1. Lambda Expressions and Functional Interfaces

Java 8+ introduced lambda expressions and functional programming concepts similar to JavaScript arrow functions.

<UniversalEditor title="Lambda Expressions and Functional Programming" compare={true}>
```javascript !! js
// JavaScript - Arrow functions and functional programming
// Arrow functions
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
const square = x => x * x;

// Higher-order functions
const map = (arr, fn) => arr.map(fn);
const filter = (arr, predicate) => arr.filter(predicate);
const reduce = (arr, fn, initial) => arr.reduce(fn, initial);

// Function composition
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// Currying
const curry = (fn) => {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function(...moreArgs) {
            return curried.apply(this, args.concat(moreArgs));
        };
    };
};

// Partial application
const partial = (fn, ...args) => {
    return function(...moreArgs) {
        return fn.apply(this, args.concat(moreArgs));
    };
};

// Usage examples
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Map, filter, reduce
const doubled = map(numbers, x => x * 2);
const evens = filter(numbers, x => x % 2 === 0);
const sum = reduce(numbers, (acc, x) => acc + x, 0);

// Function composition
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const composed = compose(square, double, addOne);
const piped = pipe(addOne, double, square);

console.log("Original:", numbers);
console.log("Doubled:", doubled);
console.log("Evens:", evens);
console.log("Sum:", sum);
console.log("Composed(3):", composed(3));  // ((3+1)*2)^2 = 64
console.log("Piped(3):", piped(3));        // ((3+1)*2)^2 = 64

// Currying example
const curriedAdd = curry((a, b, c) => a + b + c);
console.log("Curried add:", curriedAdd(1)(2)(3));

// Partial application
const addFive = partial(add, 5);
console.log("Add five to 3:", addFive(3));
```

```java !! java
// Java - Lambda expressions and functional programming (Java 8+)
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class FunctionalProgramming {
    public static void main(String[] args) {
        // Lambda expressions
        BinaryOperator<Integer> add = (a, b) -> a + b;
        BinaryOperator<Integer> multiply = (a, b) -> a * b;
        Function<Integer, Integer> square = x -> x * x;
        
        // Predicate examples
        Predicate<Integer> isEven = x -> x % 2 == 0;
        Predicate<Integer> isPositive = x -> x > 0;
        Predicate<String> isEmpty = String::isEmpty;
        
        // Function examples
        Function<String, Integer> length = String::length;
        Function<Integer, String> toString = Object::toString;
        
        // Consumer examples
        Consumer<String> printer = System.out::println;
        Consumer<Integer> squarePrinter = x -> System.out.println(x * x);
        
        // Supplier examples
        Supplier<Double> randomSupplier = Math::random;
        Supplier<String> helloSupplier = () -> "Hello, World!";
        
        // Stream operations (functional programming)
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Map, filter, reduce
        List<Integer> doubled = numbers.stream()
            .map(x -> x * 2)
            .collect(Collectors.toList());
        
        List<Integer> evens = numbers.stream()
            .filter(x -> x % 2 == 0)
            .collect(Collectors.toList());
        
        int sum = numbers.stream()
            .reduce(0, Integer::sum);
        
        // Method references
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        names.forEach(System.out::println);
        
        List<Integer> lengths = names.stream()
            .map(String::length)
            .collect(Collectors.toList());
        
        // Function composition
        Function<Integer, Integer> addOne = x -> x + 1;
        Function<Integer, Integer> double = x -> x * 2;
        Function<Integer, Integer> square = x -> x * x;
        
        Function<Integer, Integer> composed = addOne.andThen(double).andThen(square);
        Function<Integer, Integer> piped = square.compose(double).compose(addOne);
        
        // Optional for functional programming
        Optional<Integer> optional = Optional.of(42);
        optional.map(x -> x * 2)
               .filter(x -> x > 80)
               .ifPresent(System.out::println);
        
        // Custom functional interfaces
        TriFunction<Integer, Integer, Integer, Integer> addThree = (a, b, c) -> a + b + c;
        
        // Usage
        System.out.println("Original: " + numbers);
        System.out.println("Doubled: " + doubled);
        System.out.println("Evens: " + evens);
        System.out.println("Sum: " + sum);
        System.out.println("Composed(3): " + composed.apply(3));
        System.out.println("Piped(3): " + piped.apply(3));
        System.out.println("Add three: " + addThree.apply(1, 2, 3));
        
        // Stream operations with collectors
        Map<Boolean, List<Integer>> partitioned = numbers.stream()
            .collect(Collectors.partitioningBy(x -> x % 2 == 0));
        
        System.out.println("Partitioned: " + partitioned);
        
        // Parallel streams
        long count = numbers.parallelStream()
            .filter(x -> x > 5)
            .count();
        
        System.out.println("Count > 5: " + count);
    }
    
    // Custom functional interface
    @FunctionalInterface
    interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }
}
```
</UniversalEditor>

## Method Scope and Visibility

### 1. Access Modifiers and Scope

Java has strict access control, while JavaScript uses closures and module patterns for encapsulation.

<UniversalEditor title="Method Scope and Visibility" compare={true}>
```javascript !! js
// JavaScript - Scope and encapsulation patterns
// Module pattern for encapsulation
const Calculator = (function() {
    // Private variables
    let history = [];
    let operationCount = 0;
    
    // Private methods
    function logOperation(operation, result) {
        history.push({
            operation: operation,
            result: result,
            timestamp: new Date()
        });
        operationCount++;
    }
    
    function validateNumber(num) {
        return typeof num === 'number' && !isNaN(num);
    }
    
    // Public methods
    return {
        add: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            const result = a + b;
            logOperation(`add(${a}, ${b})`, result);
            return result;
        },
        
        subtract: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            const result = a - b;
            logOperation(`subtract(${a}, ${b})`, result);
            return result;
        },
        
        multiply: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            const result = a * b;
            logOperation(`multiply(${a}, ${b})`, result);
            return result;
        },
        
        divide: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            if (b === 0) {
                throw new Error('Division by zero');
            }
            const result = a / b;
            logOperation(`divide(${a}, ${b})`, result);
            return result;
        },
        
        // Public getter methods
        getHistory: function() {
            return [...history]; // Return copy to prevent modification
        },
        
        getOperationCount: function() {
            return operationCount;
        },
        
        clearHistory: function() {
            history = [];
            operationCount = 0;
        }
    };
})();

// ES6 Class with private fields (newer browsers)
class ModernCalculator {
    #history = [];
    #operationCount = 0;
    
    #logOperation(operation, result) {
        this.#history.push({
            operation: operation,
            result: result,
            timestamp: new Date()
        });
        this.#operationCount++;
    }
    
    #validateNumber(num) {
        return typeof num === 'number' && !isNaN(num);
    }
    
    add(a, b) {
        if (!this.#validateNumber(a) || !this.#validateNumber(b)) {
            throw new Error('Invalid numbers');
        }
        const result = a + b;
        this.#logOperation(`add(${a}, ${b})`, result);
        return result;
    }
    
    getHistory() {
        return [...this.#history];
    }
    
    getOperationCount() {
        return this.#operationCount;
    }
}

// Usage
try {
    console.log(Calculator.add(5, 3));
    console.log(Calculator.multiply(4, 6));
    console.log(Calculator.getHistory());
    console.log(Calculator.getOperationCount());
    
    // This would throw an error
    // Calculator.logOperation("test", 42); // Error: logOperation is not a function
} catch (error) {
    console.error("Error:", error.message);
}
```

```java !! java
// Java - Access modifiers and scope
public class Calculator {
    // Private fields (only accessible within this class)
    private List<Operation> history;
    private int operationCount;
    
    // Package-private constructor (accessible within same package)
    Calculator() {
        this.history = new ArrayList<>();
        this.operationCount = 0;
    }
    
    // Public constructor
    public Calculator(String name) {
        this();
        System.out.println("Calculator initialized: " + name);
    }
    
    // Private method (only accessible within this class)
    private void logOperation(String operation, double result) {
        history.add(new Operation(operation, result, new Date()));
        operationCount++;
    }
    
    // Private method for validation
    private boolean isValidNumber(double num) {
        return !Double.isNaN(num) && !Double.isInfinite(num);
    }
    
    // Public methods (accessible from anywhere)
    public double add(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        double result = a + b;
        logOperation("add(" + a + ", " + b + ")", result);
        return result;
    }
    
    public double subtract(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        double result = a - b;
        logOperation("subtract(" + a + ", " + b + ")", result);
        return result;
    }
    
    public double multiply(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        double result = a * b;
        logOperation("multiply(" + a + ", " + b + ")", result);
        return result;
    }
    
    public double divide(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        if (b == 0) {
            throw new ArithmeticException("Division by zero");
        }
        double result = a / b;
        logOperation("divide(" + a + ", " + b + ")", result);
        return result;
    }
    
    // Protected method (accessible within package and subclasses)
    protected List<Operation> getHistoryInternal() {
        return new ArrayList<>(history); // Return copy to prevent modification
    }
    
    // Public getter methods
    public List<Operation> getHistory() {
        return getHistoryInternal();
    }
    
    public int getOperationCount() {
        return operationCount;
    }
    
    public void clearHistory() {
        history.clear();
        operationCount = 0;
    }
    
    // Static method (belongs to class, not instance)
    public static double power(double base, double exponent) {
        return Math.pow(base, exponent);
    }
    
    // Inner class for operation history
    public static class Operation {
        private String operation;
        private double result;
        private Date timestamp;
        
        public Operation(String operation, double result, Date timestamp) {
            this.operation = operation;
            this.result = result;
            this.timestamp = timestamp;
        }
        
        // Getters
        public String getOperation() { return operation; }
        public double getResult() { return result; }
        public Date getTimestamp() { return timestamp; }
        
        @Override
        public String toString() {
            return operation + " = " + result + " (" + timestamp + ")";
        }
    }
}

// Subclass demonstrating protected access
class ScientificCalculator extends Calculator {
    public double squareRoot(double a) {
        if (a < 0) {
            throw new IllegalArgumentException("Cannot calculate square root of negative number");
        }
        double result = Math.sqrt(a);
        // Can access protected method from parent
        getHistoryInternal().add(new Calculator.Operation("sqrt(" + a + ")", result, new Date()));
        return result;
    }
}

// Main class to demonstrate usage
class MethodScopeDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator("MyCalculator");
        
        try {
            System.out.println("5 + 3 = " + calc.add(5, 3));
            System.out.println("4 * 6 = " + calc.multiply(4, 6));
            System.out.println("10 / 2 = " + calc.divide(10, 2));
            
            System.out.println("History: " + calc.getHistory());
            System.out.println("Operation count: " + calc.getOperationCount());
            
            // Static method call
            System.out.println("2^10 = " + Calculator.power(2, 10));
            
            // Scientific calculator
            ScientificCalculator sciCalc = new ScientificCalculator();
            System.out.println("sqrt(16) = " + sciCalc.squareRoot(16));
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Method Implementation

<UniversalEditor title="Exercise 1: Method Implementation">
```java !! java
// TODO: Implement these methods
public class MethodExercises {
    public static void main(String[] args) {
        // Test your implementations
        System.out.println("Factorial of 5: " + factorial(5));
        System.out.println("GCD of 48 and 18: " + gcd(48, 18));
        System.out.println("Is palindrome: " + isPalindrome("racecar"));
        System.out.println("Reverse string: " + reverseString("hello"));
        
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6};
        System.out.println("Array before sort: " + Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println("Array after sort: " + Arrays.toString(arr));
    }
    
    // 1. Implement factorial using recursion
    public static int factorial(int n) {
        // TODO: Implement this method
        return 0;
    }
    
    // 2. Implement GCD using Euclidean algorithm
    public static int gcd(int a, int b) {
        // TODO: Implement this method
        return 0;
    }
    
    // 3. Check if a string is palindrome
    public static boolean isPalindrome(String str) {
        // TODO: Implement this method
        return false;
    }
    
    // 4. Reverse a string using recursion
    public static String reverseString(String str) {
        // TODO: Implement this method
        return "";
    }
    
    // 5. Implement bubble sort
    public static void bubbleSort(int[] arr) {
        // TODO: Implement this method
    }
}
```
</UniversalEditor>

### Exercise 2: Functional Programming

<UniversalEditor title="Exercise 2: Functional Programming">
```java !! java
// TODO: Implement functional programming solutions
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class FunctionalExercises {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<String> words = Arrays.asList("hello", "world", "java", "programming", "functional");
        
        // Test your implementations
        System.out.println("Sum of squares: " + sumOfSquares(numbers));
        System.out.println("Longest word: " + findLongestWord(words));
        System.out.println("Words with length > 4: " + filterByLength(words, 4));
        System.out.println("All even: " + allEven(numbers));
        System.out.println("Any odd: " + anyOdd(numbers));
        
        // Custom functional operations
        List<Integer> result = customMap(numbers, x -> x * x + 1);
        System.out.println("Custom map result: " + result);
        
        List<Integer> filtered = customFilter(numbers, x -> x % 2 == 0);
        System.out.println("Custom filter result: " + filtered);
    }
    
    // 1. Calculate sum of squares using streams
    public static int sumOfSquares(List<Integer> numbers) {
        // TODO: Implement using streams
        return 0;
    }
    
    // 2. Find longest word using streams
    public static String findLongestWord(List<String> words) {
        // TODO: Implement using streams
        return "";
    }
    
    // 3. Filter words by length
    public static List<String> filterByLength(List<String> words, int minLength) {
        // TODO: Implement using streams
        return new ArrayList<>();
    }
    
    // 4. Check if all numbers are even
    public static boolean allEven(List<Integer> numbers) {
        // TODO: Implement using streams
        return false;
    }
    
    // 5. Check if any number is odd
    public static boolean anyOdd(List<Integer> numbers) {
        // TODO: Implement using streams
        return false;
    }
    
    // 6. Custom map function using recursion
    public static List<Integer> customMap(List<Integer> numbers, Function<Integer, Integer> mapper) {
        // TODO: Implement using recursion
        return new ArrayList<>();
    }
    
    // 7. Custom filter function using recursion
    public static List<Integer> customFilter(List<Integer> numbers, Predicate<Integer> predicate) {
        // TODO: Implement using recursion
        return new ArrayList<>();
    }
}
```
</UniversalEditor>

## Summary

In this module, we explored Java methods and compared them with JavaScript functions:

### Key Points:
1. **Method Structure**: Java methods are defined within classes with strict typing
2. **Method Overloading**: Java supports multiple methods with the same name but different parameters
3. **Recursion**: Both languages support recursive functions with different safety mechanisms
4. **Functional Programming**: Java 8+ introduced lambda expressions and streams
5. **Access Control**: Java has strict access modifiers for encapsulation

### Next Steps:
- Practice implementing recursive algorithms
- Master method overloading patterns
- Explore functional programming with streams
- Prepare for the next module on object-oriented programming

## Additional Resources

- [Java Methods](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)
- [Java Lambda Expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
- [Java Streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

---

**Exercise Tips**: Create small programs demonstrating each method type. Focus on understanding when to use recursion vs iteration, and practice functional programming concepts with streams. 