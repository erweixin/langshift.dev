---
title: "模块 04: 数组和集合"
description: "学习 Java 数组、集合框架和数据结构，与 JavaScript 模式进行对比。"
---

# 模块 04: 数组和集合

在本模块中，我们将探索 Java 的数组系统和全面的集合框架。虽然 JavaScript 有单一数组类型可以存储混合数据，但 Java 提供强类型数组和丰富的集合类来满足不同的用例。

## 学习目标

通过本模块的学习，你将能够：
- 理解 Java 数组及其类型安全
- 掌握集合框架（List、Set、Map）
- 比较 Java 集合与 JavaScript 数组和对象
- 使用泛型实现类型安全的集合
- 应用数据结构选择的最佳实践

## 数组

### 1. 数组声明和初始化

Java 数组是固定大小和强类型的，与 JavaScript 的动态数组不同。

<UniversalEditor title="数组声明和初始化" compare={true}>
```javascript !! js
// JavaScript - 数组声明和初始化
// 动态数组，可存储混合类型
let numbers = [1, 2, 3, 4, 5];
let mixed = [1, "hello", true, {name: "John"}];
let empty = [];

// 数组构造函数
let array1 = new Array(5);  // 创建长度为 5 的数组
let array2 = new Array(1, 2, 3, 4, 5);

// Array.from() 和展开运算符
let arrayFrom = Array.from("hello");  // ['h', 'e', 'l', 'l', 'o']
let spreadArray = [...numbers, 6, 7, 8];

// 数组方法
numbers.push(6);  // 添加到末尾
numbers.unshift(0);  // 添加到开头
let popped = numbers.pop();  // 从末尾移除
let shifted = numbers.shift();  // 从开头移除

console.log("Numbers:", numbers);
console.log("Mixed:", mixed);
console.log("Array from string:", arrayFrom);
console.log("Spread array:", spreadArray);
```

```java !! java
// Java - 数组声明和初始化
public class ArrayBasics {
    public static void main(String[] args) {
        // 数组声明和初始化
        int[] numbers = {1, 2, 3, 4, 5};
        String[] names = {"Alice", "Bob", "Charlie"};
        
        // 带大小的数组声明
        int[] array1 = new int[5];  // 创建包含 5 个元素的数组（全部为 0）
        String[] array2 = new String[3];  // 创建包含 3 个元素的数组（全部为 null）
        
        // 多维数组
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        int[][] matrix2 = new int[3][4];  // 3x4 矩阵
        
        // 数组长度属性
        System.out.println("Numbers length: " + numbers.length);
        System.out.println("Matrix rows: " + matrix.length);
        System.out.println("Matrix columns: " + matrix[0].length);
        
        // 数组访问和修改
        numbers[0] = 10;
        System.out.println("First element: " + numbers[0]);
        
        // 数组迭代
        System.out.println("Numbers array:");
        for (int i = 0; i < numbers.length; i++) {
            System.out.print(numbers[i] + " ");
        }
        System.out.println();
        
        // 增强 for 循环（for-each）
        System.out.println("Names array:");
        for (String name : names) {
            System.out.print(name + " ");
        }
        System.out.println();
        
        // Arrays 工具类
        int[] copy = java.util.Arrays.copyOf(numbers, numbers.length);
        java.util.Arrays.sort(copy);
        System.out.println("Sorted copy: " + java.util.Arrays.toString(copy));
    }
}
```
</UniversalEditor>

### 2. 数组操作和方法

<UniversalEditor title="数组操作和方法" compare={true}>
```javascript !! js
// JavaScript - 数组操作和方法
let fruits = ["apple", "banana", "orange", "grape"];

// 添加元素
fruits.push("mango");  // 添加到末尾
fruits.unshift("kiwi");  // 添加到开头
fruits.splice(2, 0, "pear");  // 在索引 2 处插入

// 移除元素
fruits.pop();  // 从末尾移除
fruits.shift();  // 从开头移除
fruits.splice(1, 1);  // 移除索引 1 处的 1 个元素

// 查找元素
let index = fruits.indexOf("banana");
let lastIndex = fruits.lastIndexOf("apple");
let includes = fruits.includes("orange");

// 数组转换
let upperFruits = fruits.map(fruit => fruit.toUpperCase());
let longFruits = fruits.filter(fruit => fruit.length > 5);
let allLong = fruits.every(fruit => fruit.length > 3);
let someLong = fruits.some(fruit => fruit.length > 6);

// 数组归约
let concatenated = fruits.reduce((acc, fruit) => acc + ", " + fruit, "");
let totalLength = fruits.reduce((sum, fruit) => sum + fruit.length, 0);

// 排序
fruits.sort();  // 字母顺序
fruits.reverse();  // 反转顺序

console.log("Fruits:", fruits);
console.log("Index of banana:", index);
console.log("Upper fruits:", upperFruits);
console.log("Long fruits:", longFruits);
console.log("Concatenated:", concatenated);
```

```java !! java
// Java - 数组操作和方法
import java.util.Arrays;

public class ArrayOperations {
    public static void main(String[] args) {
        String[] fruits = {"apple", "banana", "orange", "grape"};
        
        // 数组是固定大小的，所以需要创建新数组来修改
        // 添加元素（创建新数组）
        String[] newFruits = new String[fruits.length + 1];
        System.arraycopy(fruits, 0, newFruits, 0, fruits.length);
        newFruits[fruits.length] = "mango";
        fruits = newFruits;
        
        // Arrays 工具类方法
        System.out.println("Original: " + Arrays.toString(fruits));
        
        // 排序
        Arrays.sort(fruits);
        System.out.println("Sorted: " + Arrays.toString(fruits));
        
        // 搜索
        int index = Arrays.binarySearch(fruits, "banana");
        System.out.println("Index of banana: " + index);
        
        // 复制数组
        String[] copy = Arrays.copyOf(fruits, fruits.length);
        String[] partialCopy = Arrays.copyOfRange(fruits, 1, 3);
        
        // 填充数组
        int[] numbers = new int[5];
        Arrays.fill(numbers, 42);
        System.out.println("Filled array: " + Arrays.toString(numbers));
        
        // 比较数组
        boolean equals = Arrays.equals(fruits, copy);
        System.out.println("Arrays equal: " + equals);
        
        // 带索引的数组迭代
        System.out.println("Fruits with index:");
        for (int i = 0; i < fruits.length; i++) {
            System.out.println(i + ": " + fruits[i]);
        }
        
        // 增强 for 循环
        System.out.println("All fruits:");
        for (String fruit : fruits) {
            System.out.print(fruit + " ");
        }
        System.out.println();
        
        // 查找最大值/最小值（数值数组）
        int[] numbers2 = {3, 7, 2, 9, 1, 8, 5};
        int max = Arrays.stream(numbers2).max().orElse(0);
        int min = Arrays.stream(numbers2).min().orElse(0);
        System.out.println("Max: " + max + ", Min: " + min);
    }
}
```
</UniversalEditor>

## 集合框架

### 1. List 接口

List 是有序集合，允许重复元素。

<UniversalEditor title="List 接口" compare={true}>
```javascript !! js
// JavaScript - 数组作为 List
let list = ["apple", "banana", "orange"];

// 添加元素
list.push("grape");  // 添加到末尾
list.unshift("kiwi");  // 添加到开头
list.splice(2, 0, "pear");  // 在索引 2 处插入

// 移除元素
list.pop();  // 从末尾移除
list.shift();  // 从开头移除
list.splice(1, 1);  // 移除索引 1 处的元素

// 访问元素
let first = list[0];
let last = list[list.length - 1];
let element = list[2];

// 查找元素
let index = list.indexOf("banana");
let lastIndex = list.lastIndexOf("apple");
let includes = list.includes("orange");

// List 转换
let upperList = list.map(item => item.toUpperCase());
let filteredList = list.filter(item => item.length > 5);

// List 迭代
list.forEach((item, index) => {
    console.log(`${index}: ${item}`);
});

console.log("List:", list);
console.log("First:", first);
console.log("Index of banana:", index);
console.log("Upper list:", upperList);
```

```java !! java
// Java - List 接口
import java.util.*;

public class ListExamples {
    public static void main(String[] args) {
        // ArrayList - 动态数组实现
        List<String> arrayList = new ArrayList<>();
        arrayList.add("apple");
        arrayList.add("banana");
        arrayList.add("orange");
        
        // LinkedList - 双向链表实现
        List<String> linkedList = new LinkedList<>();
        linkedList.add("grape");
        linkedList.add("kiwi");
        linkedList.add("pear");
        
        // 添加元素
        arrayList.add("grape");  // 添加到末尾
        arrayList.add(0, "kiwi");  // 在索引 0 处添加
        arrayList.addAll(linkedList);  // 添加另一个列表的所有元素
        
        // 移除元素
        arrayList.remove("banana");  // 按值移除
        arrayList.remove(0);  // 按索引移除
        arrayList.removeIf(item -> item.length() > 5);  // 按条件移除
        
        // 访问元素
        String first = arrayList.get(0);
        String last = arrayList.get(arrayList.size() - 1);
        
        // 查找元素
        int index = arrayList.indexOf("orange");
        int lastIndex = arrayList.lastIndexOf("apple");
        boolean contains = arrayList.contains("grape");
        
        // List 转换
        List<String> upperList = new ArrayList<>();
        for (String item : arrayList) {
            upperList.add(item.toUpperCase());
        }
        
        // List 迭代
        System.out.println("ArrayList elements:");
        for (int i = 0; i < arrayList.size(); i++) {
            System.out.println(i + ": " + arrayList.get(i));
        }
        
        // 增强 for 循环
        System.out.println("All elements:");
        for (String item : arrayList) {
            System.out.print(item + " ");
        }
        System.out.println();
        
        // Lambda forEach（Java 8+）
        arrayList.forEach(item -> System.out.print(item + " "));
        System.out.println();
        
        // List 方法
        System.out.println("Size: " + arrayList.size());
        System.out.println("Is empty: " + arrayList.isEmpty());
        System.out.println("Contains orange: " + contains);
        System.out.println("Index of orange: " + index);
        
        // 排序
        Collections.sort(arrayList);
        System.out.println("Sorted: " + arrayList);
        
        // 反转
        Collections.reverse(arrayList);
        System.out.println("Reversed: " + arrayList);
    }
}
```
</UniversalEditor>

### 2. Set 接口

Set 是不允许重复元素的集合。

<UniversalEditor title="Set 接口" compare={true}>
```javascript !! js
// JavaScript - Set 对象
let set = new Set(["apple", "banana", "orange"]);

// 添加元素
set.add("grape");
set.add("banana");  // 不会添加重复项

// 移除元素
set.delete("banana");
set.clear();  // 移除所有元素

// 检查元素
let hasApple = set.has("apple");
let size = set.size;

// Set 操作
let set1 = new Set([1, 2, 3, 4]);
let set2 = new Set([3, 4, 5, 6]);

// 并集
let union = new Set([...set1, ...set2]);

// 交集
let intersection = new Set([...set1].filter(x => set2.has(x)));

// 差集
let difference = new Set([...set1].filter(x => !set2.has(x)));

// Set 迭代
set1.forEach(value => {
    console.log("Value:", value);
});

// 转换为数组
let array = [...set1];

console.log("Set:", set);
console.log("Has apple:", hasApple);
console.log("Size:", size);
console.log("Union:", union);
console.log("Intersection:", intersection);
console.log("Difference:", difference);
```

```java !! java
// Java - Set 接口
import java.util.*;

public class SetExamples {
    public static void main(String[] args) {
        // HashSet - 无序，无重复
        Set<String> hashSet = new HashSet<>();
        hashSet.add("apple");
        hashSet.add("banana");
        hashSet.add("orange");
        hashSet.add("banana");  // 不会添加重复项
        
        // LinkedHashSet - 维护插入顺序
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("grape");
        linkedHashSet.add("kiwi");
        linkedHashSet.add("pear");
        
        // TreeSet - 排序顺序
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("zebra");
        treeSet.add("apple");
        treeSet.add("banana");
        
        // 添加元素
        hashSet.add("grape");
        hashSet.addAll(linkedHashSet);
        
        // 移除元素
        hashSet.remove("banana");
        hashSet.removeIf(item -> item.length() > 5);
        
        // 检查元素
        boolean contains = hashSet.contains("apple");
        boolean isEmpty = hashSet.isEmpty();
        int size = hashSet.size();
        
        // Set 操作
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        
        // 并集
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        
        // 交集
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        
        // 差集
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        
        // Set 迭代
        System.out.println("HashSet elements:");
        for (String item : hashSet) {
            System.out.print(item + " ");
        }
        System.out.println();
        
        // Lambda forEach
        treeSet.forEach(item -> System.out.print(item + " "));
        System.out.println();
        
        // Set 方法
        System.out.println("HashSet: " + hashSet);
        System.out.println("LinkedHashSet: " + linkedHashSet);
        System.out.println("TreeSet: " + treeSet);
        System.out.println("Contains apple: " + contains);
        System.out.println("Size: " + size);
        System.out.println("Union: " + union);
        System.out.println("Intersection: " + intersection);
        System.out.println("Difference: " + difference);
        
        // 转换为数组
        String[] array = hashSet.toArray(new String[0]);
        System.out.println("Array: " + Arrays.toString(array));
    }
}
```
</UniversalEditor>

### 3. Map 接口

Map 存储键值对，类似于 JavaScript 对象。

<UniversalEditor title="Map 接口" compare={true}>
```javascript !! js
// JavaScript - 对象作为 Map
let map = {
    "name": "John",
    "age": 30,
    "city": "NYC"
};

// 添加/更新元素
map.email = "john@example.com";
map["phone"] = "123-456-7890";

// 移除元素
delete map.age;
let removed = map.city;
delete map.city;

// 检查元素
let hasName = "name" in map;
let hasAge = map.hasOwnProperty("age");
let value = map.name;
let undefinedValue = map.nonexistent;

// 对象方法
let keys = Object.keys(map);
let values = Object.values(map);
let entries = Object.entries(map);

// 对象迭代
for (let key in map) {
    if (map.hasOwnProperty(key)) {
        console.log(`${key}: ${map[key]}`);
    }
}

Object.entries(map).forEach(([key, value]) => {
    console.log(`${key}: ${value}`);
});

// Map 对象（ES6）
let mapObject = new Map();
mapObject.set("name", "John");
mapObject.set("age", 30);
mapObject.set("city", "NYC");

mapObject.set("email", "john@example.com");
mapObject.delete("age");
let hasKey = mapObject.has("name");
let mapValue = mapObject.get("name");
let mapSize = mapObject.size;

console.log("Object map:", map);
console.log("Has name:", hasName);
console.log("Keys:", keys);
console.log("Values:", values);
console.log("Map object:", mapObject);
console.log("Map size:", mapSize);
```

```java !! java
// Java - Map 接口
import java.util.*;

public class MapExamples {
    public static void main(String[] args) {
        // HashMap - 无序键值对
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("name", "John");
        hashMap.put("age", "30");
        hashMap.put("city", "NYC");
        
        // LinkedHashMap - 维护插入顺序
        Map<String, String> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("email", "john@example.com");
        linkedHashMap.put("phone", "123-456-7890");
        
        // TreeMap - 按键排序
        Map<String, String> treeMap = new TreeMap<>();
        treeMap.put("zebra", "animal");
        treeMap.put("apple", "fruit");
        treeMap.put("banana", "fruit");
        
        // 添加/更新元素
        hashMap.put("email", "john@example.com");
        hashMap.putAll(linkedHashMap);
        
        // 移除元素
        hashMap.remove("age");
        hashMap.remove("nonexistent", "default");  // 仅当值匹配时移除
        
        // 检查元素
        boolean containsKey = hashMap.containsKey("name");
        boolean containsValue = hashMap.containsValue("John");
        String value = hashMap.get("name");
        String defaultValue = hashMap.getOrDefault("nonexistent", "default");
        
        // Map 操作
        Set<String> keys = hashMap.keySet();
        Collection<String> values = hashMap.values();
        Set<Map.Entry<String, String>> entries = hashMap.entrySet();
        
        // Map 迭代
        System.out.println("HashMap entries:");
        for (Map.Entry<String, String> entry : hashMap.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // Lambda forEach
        hashMap.forEach((key, val) -> System.out.println(key + " -> " + val));
        
        // Map 方法
        System.out.println("HashMap: " + hashMap);
        System.out.println("LinkedHashMap: " + linkedHashMap);
        System.out.println("TreeMap: " + treeMap);
        System.out.println("Contains key 'name': " + containsKey);
        System.out.println("Value for 'name': " + value);
        System.out.println("Size: " + hashMap.size());
        System.out.println("Is empty: " + hashMap.isEmpty());
        
        // 转换为集合
        System.out.println("Keys: " + keys);
        System.out.println("Values: " + values);
        
        // 不同值类型的 Map
        Map<String, Object> mixedMap = new HashMap<>();
        mixedMap.put("name", "John");
        mixedMap.put("age", 30);
        mixedMap.put("active", true);
        mixedMap.put("scores", Arrays.asList(85, 92, 78));
        
        System.out.println("Mixed map: " + mixedMap);
        
        // 嵌套 Map
        Map<String, Map<String, String>> nestedMap = new HashMap<>();
        Map<String, String> innerMap = new HashMap<>();
        innerMap.put("street", "123 Main St");
        innerMap.put("city", "NYC");
        nestedMap.put("address", innerMap);
        
        System.out.println("Nested map: " + nestedMap);
    }
}
```
</UniversalEditor>

## 泛型

### 1. 泛型集合

泛型为集合提供类型安全。

<UniversalEditor title="泛型集合" compare={true}>
```javascript !! js
// JavaScript - 没有泛型，但可以用 JSDoc 强制类型
/**
 * @template T
 * @param {T[]} array
 * @returns {T}
 */
function getFirst(array) {
    return array[0];
}

/**
 * @template T
 * @param {T[]} array
 * @param {function(T): boolean} predicate
 * @returns {T[]}
 */
function filter(array, predicate) {
    return array.filter(predicate);
}

// 使用
let numbers = [1, 2, 3, 4, 5];
let strings = ["hello", "world", "test"];

let firstNumber = getFirst(numbers);
let firstString = getFirst(strings);

let evenNumbers = filter(numbers, n => n % 2 === 0);
let longStrings = filter(strings, s => s.length > 4);

console.log("First number:", firstNumber);
console.log("First string:", firstString);
console.log("Even numbers:", evenNumbers);
console.log("Long strings:", longStrings);
```

```java !! java
// Java - 泛型提供编译时类型安全
import java.util.*;

public class GenericCollections {
    public static void main(String[] args) {
        // 泛型 List
        List<String> stringList = new ArrayList<>();
        stringList.add("hello");
        stringList.add("world");
        // stringList.add(123);  // 编译时错误！
        
        List<Integer> intList = new ArrayList<>();
        intList.add(1);
        intList.add(2);
        intList.add(3);
        
        // 泛型 Set
        Set<String> stringSet = new HashSet<>();
        stringSet.add("apple");
        stringSet.add("banana");
        
        // 泛型 Map
        Map<String, Integer> stringIntMap = new HashMap<>();
        stringIntMap.put("one", 1);
        stringIntMap.put("two", 2);
        
        // 泛型方法
        String firstString = getFirst(stringList);
        Integer firstInt = getFirst(intList);
        
        List<String> filteredStrings = filter(stringList, s -> s.length() > 4);
        List<Integer> evenNumbers = filter(intList, n -> n % 2 == 0);
        
        // 泛型类
        Box<String> stringBox = new Box<>("Hello");
        Box<Integer> intBox = new Box<>(42);
        
        System.out.println("First string: " + firstString);
        System.out.println("First int: " + firstInt);
        System.out.println("Filtered strings: " + filteredStrings);
        System.out.println("Even numbers: " + evenNumbers);
        System.out.println("String box: " + stringBox.getContent());
        System.out.println("Int box: " + intBox.getContent());
        
        // 通配符
        List<Number> numbers = new ArrayList<>();
        numbers.add(1);
        numbers.add(2.5);
        numbers.add(3L);
        
        printList(numbers);
        printList(stringList);
    }
    
    // 泛型方法
    public static <T> T getFirst(List<T> list) {
        if (list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }
    
    // 带谓词的泛型方法
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                result.add(item);
            }
        }
        return result;
    }
    
    // 通配符方法
    public static void printList(List<?> list) {
        for (Object item : list) {
            System.out.print(item + " ");
        }
        System.out.println();
    }
    
    // 泛型类
    static class Box<T> {
        private T content;
        
        public Box(T content) {
            this.content = content;
        }
        
        public T getContent() {
            return content;
        }
        
        public void setContent(T content) {
            this.content = content;
        }
    }
}
```
</UniversalEditor>

## 最佳实践

### 1. 集合选择

<UniversalEditor title="集合选择最佳实践" compare={true}>
```javascript !! js
// JavaScript - 集合选择模式
// 使用数组进行有序集合
let orderedList = [1, 2, 3, 4, 5];

// 使用 Set 进行唯一值
let uniqueValues = new Set([1, 2, 2, 3, 3, 4]);

// 使用 Map 进行键值对
let keyValueMap = new Map([
    ["name", "John"],
    ["age", 30],
    ["city", "NYC"]
]);

// 使用对象进行简单键值存储
let simpleObject = {
    name: "John",
    age: 30,
    city: "NYC"
};

// 性能考虑
// 数组操作
let array = [1, 2, 3, 4, 5];
array.push(6);  // O(1) - 摊销
array.unshift(0);  // O(n) - 移动所有元素
array.splice(2, 1);  // O(n) - 移动元素

// Set 操作
let set = new Set([1, 2, 3]);
set.add(4);  // O(1) - 平均情况
set.has(2);  // O(1) - 平均情况
set.delete(2);  // O(1) - 平均情况

// Map 操作
let map = new Map();
map.set("key", "value");  // O(1) - 平均情况
map.get("key");  // O(1) - 平均情况
map.delete("key");  // O(1) - 平均情况

console.log("Ordered list:", orderedList);
console.log("Unique values:", uniqueValues);
console.log("Key-value map:", keyValueMap);
console.log("Simple object:", simpleObject);
```

```java !! java
// Java - 集合选择最佳实践
import java.util.*;

public class CollectionBestPractices {
    public static void main(String[] args) {
        // 使用 ArrayList 进行随机访问和迭代
        List<String> arrayList = new ArrayList<>();
        arrayList.add("apple");
        arrayList.add("banana");
        arrayList.add("orange");
        
        // 使用 LinkedList 进行频繁插入/删除
        List<String> linkedList = new LinkedList<>();
        linkedList.add("grape");
        linkedList.add("kiwi");
        linkedList.add("pear");
        
        // 使用 HashSet 进行唯一元素，不需要顺序
        Set<String> hashSet = new HashSet<>();
        hashSet.add("red");
        hashSet.add("green");
        hashSet.add("blue");
        
        // 使用 LinkedHashSet 进行唯一元素，维护插入顺序
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("first");
        linkedHashSet.add("second");
        linkedHashSet.add("third");
        
        // 使用 TreeSet 进行排序唯一元素
        Set<String> treeSet = new TreeSet<>();
        treeSet.add("zebra");
        treeSet.add("apple");
        treeSet.add("banana");
        
        // 使用 HashMap 进行键值对，不需要顺序
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("one", 1);
        hashMap.put("two", 2);
        hashMap.put("three", 3);
        
        // 使用 LinkedHashMap 进行键值对，维护插入顺序
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("first", 1);
        linkedHashMap.put("second", 2);
        linkedHashMap.put("third", 3);
        
        // 使用 TreeMap 进行排序键值对
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("zebra", 26);
        treeMap.put("apple", 1);
        treeMap.put("banana", 2);
        
        // 性能考虑
        System.out.println("ArrayList (随机访问): " + arrayList);
        System.out.println("LinkedList (频繁修改): " + linkedList);
        System.out.println("HashSet (唯一，无顺序): " + hashSet);
        System.out.println("LinkedHashSet (唯一，插入顺序): " + linkedHashSet);
        System.out.println("TreeSet (唯一，排序): " + treeSet);
        System.out.println("HashMap (键值对，无顺序): " + hashMap);
        System.out.println("LinkedHashMap (键值对，插入顺序): " + linkedHashMap);
        System.out.println("TreeMap (键值对，排序): " + treeMap);
        
        // 集合性能总结
        System.out.println("\n性能总结:");
        System.out.println("ArrayList: O(1) get/set, O(n) insert/delete");
        System.out.println("LinkedList: O(n) get/set, O(1) insert/delete");
        System.out.println("HashSet: O(1) add/remove/contains");
        System.out.println("TreeSet: O(log n) add/remove/contains");
        System.out.println("HashMap: O(1) put/get/remove");
        System.out.println("TreeMap: O(log n) put/get/remove");
    }
}
```
</UniversalEditor>

## 练习题目

### 练习 1: 数组和 List 操作

<UniversalEditor title="练习 1: 数组和 List 操作">
```java !! java
// TODO: 完成这些数组和 List 操作
public class ArrayListExercise {
    public static void main(String[] args) {
        // 1. 创建一个方法，查找数组中的第二大元素
        
        // 2. 创建一个方法，原地反转数组
        
        // 3. 创建一个方法，查找两个数组之间的公共元素
        
        // 4. 创建一个方法，从列表中移除重复项
        
        // 5. 创建一个方法，查找列表中最长的字符串
        
        // 测试你的实现
        int[] numbers = {3, 7, 2, 9, 1, 8, 5, 4, 6};
        String[] words = {"apple", "banana", "orange", "grape", "kiwi"};
        
        System.out.println("Second largest: " + findSecondLargest(numbers));
        reverseArray(numbers);
        System.out.println("Reversed array: " + Arrays.toString(numbers));
        
        int[] array1 = {1, 2, 3, 4, 5};
        int[] array2 = {4, 5, 6, 7, 8};
        System.out.println("Common elements: " + findCommonElements(array1, array2));
        
        List<String> list = Arrays.asList("apple", "banana", "apple", "orange", "banana");
        System.out.println("Without duplicates: " + removeDuplicates(list));
        System.out.println("Longest string: " + findLongestString(list));
    }
    
    // 在这里实现你的方法
}
```
</UniversalEditor>

### 练习 2: 集合框架

<UniversalEditor title="练习 2: 集合框架">
```java !! java
// TODO: 实现这些集合操作
public class CollectionExercise {
    public static void main(String[] args) {
        // 1. 创建一个方法，计算列表中单词的频率
        
        // 2. 创建一个方法，查找最频繁的元素
        
        // 3. 创建一个方法，检查两个列表是否为变位词
        
        // 4. 创建一个方法，按长度分组字符串
        
        // 5. 创建一个方法，查找多个集合的交集
        
        // 测试你的实现
        List<String> words = Arrays.asList("hello", "world", "hello", "java", "world", "hello");
        System.out.println("Word frequencies: " + countWordFrequencies(words));
        System.out.println("Most frequent: " + findMostFrequent(words));
        
        List<String> list1 = Arrays.asList("listen", "silent");
        List<String> list2 = Arrays.asList("triangle", "integral");
        System.out.println("Are anagrams: " + areAnagrams(list1.get(0), list1.get(1)));
        System.out.println("Are anagrams: " + areAnagrams(list2.get(0), list2.get(1)));
        
        List<String> strings = Arrays.asList("a", "bb", "ccc", "dd", "eee");
        System.out.println("Grouped by length: " + groupByLength(strings));
        
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        Set<Integer> set3 = new HashSet<>(Arrays.asList(4, 5, 6, 7));
        System.out.println("Intersection: " + findIntersection(set1, set2, set3));
    }
    
    // 在这里实现你的方法
}
```
</UniversalEditor>

## 总结

在本模块中，我们探索了 Java 的数组系统和集合框架，并将其与 JavaScript 模式进行了比较：

### 关键要点：
1. **数组**: Java 数组是固定大小和强类型的，与 JavaScript 的动态数组不同
2. **集合框架**: 为不同用例提供专门的数据结构（List、Set、Map）
3. **泛型**: 在编译时确保类型安全
4. **性能**: 不同集合具有不同的性能特征
5. **最佳实践**: 为特定需求选择正确的集合

### 下一步：
- 练习使用不同的集合类型
- 理解何时使用每种集合
- 掌握泛型语法和通配符
- 为下一个关于面向对象编程的模块做准备

## 额外资源

- [Java 集合框架](https://docs.oracle.com/javase/tutorial/collections/)
- [Java 泛型](https://docs.oracle.com/javase/tutorial/java/generics/)
- [Java 数组](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html)

---

**练习提示**: 创建演示每种集合类型使用的小程序。专注于理解何时使用每种集合及其性能特征。 