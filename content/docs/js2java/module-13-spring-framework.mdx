---
title: "Spring Framework Basics"
description: "Learn Spring framework core concepts, dependency injection, Spring Boot introduction and enterprise development practices"
---

# Spring Framework Basics

The Spring Framework is the core of Java enterprise development, providing a complete solution to simplify enterprise application development. As a JavaScript developer, you'll find that Spring offers functionality similar to Express.js and dependency injection in the Node.js ecosystem, but more comprehensive and powerful.

## Spring Framework Overview

### Core Features of Spring
- **Dependency Injection (DI)**: Automatic management of object dependencies
- **Aspect-Oriented Programming (AOP)**: Modularization of cross-cutting concerns
- **Transaction Management**: Declarative transaction support
- **MVC Framework**: Web application development
- **Data Access**: Unified data access abstraction

<UniversalEditor title="Spring vs Express.js Comparison">
```javascript !! js
// Express.js - Simple Web Service
const express = require('express');
const app = express();

// Manual dependency management
const userService = require('./services/userService');
const userController = require('./controllers/userController');

app.get('/api/users', (req, res) => {
    const users = userService.getAllUsers();
    res.json(users);
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```

```java !! java
// Spring Boot - Enterprise Web Application
@SpringBootApplication
@RestController
public class UserController {
    
    // Automatic dependency injection
    @Autowired
    private UserService userService;
    
    @GetMapping("/api/users")
    public ResponseEntity<List<User>> getUsers() {
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
    
    public static void main(String[] args) {
        SpringApplication.run(UserController.class, args);
    }
}
```
</UniversalEditor>

## Dependency Injection (DI)

### What is Dependency Injection
Dependency injection is a design pattern that allows objects to automatically receive their dependencies when created, without manually creating these dependencies.

<UniversalEditor title="Dependency Injection Comparison">
```javascript !! js
// JavaScript - Manual dependency management
class UserService {
    constructor() {
        this.userRepository = new UserRepository();
        this.emailService = new EmailService();
    }
    
    createUser(userData) {
        const user = this.userRepository.save(userData);
        this.emailService.sendWelcomeEmail(user.email);
        return user;
    }
}

// Manual dependency creation
const userService = new UserService();
```

```java !! java
// Java - Spring dependency injection
@Service
public class UserService {
    
    // Spring automatically injects dependencies
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public User createUser(UserData userData) {
        User user = userRepository.save(userData);
        emailService.sendWelcomeEmail(user.getEmail());
        return user;
    }
}

// Spring container automatically manages dependencies
@Autowired
private UserService userService;
```
</UniversalEditor>

### Dependency Injection Methods

#### 1. Constructor Injection
<UniversalEditor title="Constructor Injection">
```java !! java
@Service
public class UserService {
    
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    // Constructor injection - recommended approach
    public UserService(UserRepository userRepository, 
                      EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    public User createUser(UserData userData) {
        User user = userRepository.save(userData);
        emailService.sendWelcomeEmail(user.getEmail());
        return user;
    }
}
```

```javascript !! js
// Similar pattern in JavaScript
class UserService {
    constructor(userRepository, emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
    
    createUser(userData) {
        const user = this.userRepository.save(userData);
        this.emailService.sendWelcomeEmail(user.email);
        return user;
    }
}
```
</UniversalEditor>

#### 2. Setter Injection
<UniversalEditor title="Setter Injection">
```java !! java
@Service
public class UserService {
    
    private UserRepository userRepository;
    private EmailService emailService;
    
    // Setter injection
    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    @Autowired
    public void setEmailService(EmailService emailService) {
        this.emailService = emailService;
    }
    
    public User createUser(UserData userData) {
        User user = userRepository.save(userData);
        emailService.sendWelcomeEmail(user.getEmail());
        return user;
    }
}
```

```javascript !! js
// Similar pattern in JavaScript
class UserService {
    setUserRepository(userRepository) {
        this.userRepository = userRepository;
    }
    
    setEmailService(emailService) {
        this.emailService = emailService;
    }
    
    createUser(userData) {
        const user = this.userRepository.save(userData);
        this.emailService.sendWelcomeEmail(user.email);
        return user;
    }
}
```
</UniversalEditor>

#### 3. Field Injection
<UniversalEditor title="Field Injection">
```java !! java
@Service
public class UserService {
    
    // Field injection - less recommended
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private EmailService emailService;
    
    public User createUser(UserData userData) {
        User user = userRepository.save(userData);
        emailService.sendWelcomeEmail(user.getEmail());
        return user;
    }
}
```

```javascript !! js
// JavaScript doesn't have direct field injection
// but can use property assignment
class UserService {
    createUser(userData) {
        const user = this.userRepository.save(userData);
        this.emailService.sendWelcomeEmail(user.email);
        return user;
    }
}

// Manual property assignment
const userService = new UserService();
userService.userRepository = new UserRepository();
userService.emailService = new EmailService();
```
</UniversalEditor>

## Spring Boot Introduction

### What is Spring Boot
Spring Boot is an extension of the Spring Framework that simplifies the configuration and deployment of Spring applications.

<UniversalEditor title="Spring Boot vs Manual Configuration">
```java !! java
// Traditional Spring configuration
@Configuration
@EnableWebMvc
@ComponentScan("com.example")
public class WebConfig implements WebMvcConfigurer {
    
    @Bean
    public DataSource dataSource() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/mydb");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }
    
    @Bean
    public JdbcTemplate jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }
}
```

```java !! java
// Spring Boot - Auto-configuration
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}

// application.properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```
</UniversalEditor>

### Spring Boot Auto-configuration
<UniversalEditor title="Auto-configuration Example">
```java !! java
// Spring Boot automatically configures based on classpath
@SpringBootApplication
public class UserApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}

// If H2 database is in classpath, Spring Boot auto-configures it
// If JPA is in classpath, Spring Boot auto-configures EntityManager
// If Web starter is in classpath, Spring Boot auto-configures Tomcat
```

```javascript !! js
// JavaScript - Manual configuration
const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const helmet = require('helmet');

const app = express();

// Manual middleware configuration
app.use(cors());
app.use(helmet());
app.use(express.json());

// Manual database configuration
const connection = mysql.createConnection({
    host: 'localhost',
    user: 'root',
    password: 'password',
    database: 'mydb'
});

// Manual server startup
app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```
</UniversalEditor>

## Spring Annotations

### Core Annotations
<UniversalEditor title="Spring Annotations">
```java !! java
// Component annotations
@Component
public class UserService {
    // Generic Spring component
}

@Service
public class UserService {
    // Service layer component
}

@Repository
public class UserRepository {
    // Data access layer component
}

@Controller
public class UserController {
    // Web controller component
}

@RestController
public class UserController {
    // REST controller (combines @Controller + @ResponseBody)
}

// Dependency injection annotations
@Autowired
private UserService userService;

@Qualifier("userService")
private UserService userService;

@Value("${app.name}")
private String appName;

// Bean definition
@Bean
public UserService userService() {
    return new UserService();
}
```

```javascript !! js
// JavaScript - No built-in annotations
// But can use decorators (experimental)
class UserService {
    // Service implementation
}

// Manual dependency injection
class UserController {
    constructor() {
        this.userService = new UserService();
    }
}

// Configuration using environment variables
const appName = process.env.APP_NAME || 'Default App';
```
</UniversalEditor>

## Spring Configuration

### Properties Configuration
<UniversalEditor title="Configuration Management">
```java !! java
// application.properties
server.port=8080
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password
app.name=User Management System
app.version=1.0.0

// Using @Value annotation
@Component
public class AppConfig {
    
    @Value("${app.name}")
    private String appName;
    
    @Value("${app.version}")
    private String appVersion;
    
    @Value("${server.port:8080}")
    private int serverPort;
    
    public String getAppInfo() {
        return appName + " v" + appVersion + " on port " + serverPort;
    }
}
```

```javascript !! js
// JavaScript - Environment variables
// .env file
PORT=3000
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=password
APP_NAME=User Management System
APP_VERSION=1.0.0

// Using environment variables
const config = {
    port: process.env.PORT || 3000,
    dbHost: process.env.DB_HOST || 'localhost',
    dbUser: process.env.DB_USER || 'root',
    dbPassword: process.env.DB_PASSWORD || 'password',
    appName: process.env.APP_NAME || 'Default App',
    appVersion: process.env.APP_VERSION || '1.0.0'
};

console.log(`${config.appName} v${config.appVersion} on port ${config.port}`);
```
</UniversalEditor>

### Profile-based Configuration
<UniversalEditor title="Profile Configuration">
```java !! java
// application-dev.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.jpa.hibernate.ddl-auto=create-drop

// application-prod.properties
spring.datasource.url=jdbc:mysql://prod-server:3306/proddb
spring.datasource.username=${DB_USERNAME}
spring.datasource.password=${DB_PASSWORD}
spring.jpa.hibernate.ddl-auto=validate

// Using profiles
@Profile("dev")
@Component
public class DevConfig {
    // Development-specific configuration
}

@Profile("prod")
@Component
public class ProdConfig {
    // Production-specific configuration
}
```

```javascript !! js
// JavaScript - Environment-based configuration
// config/development.js
module.exports = {
    database: {
        host: 'localhost',
        database: 'testdb',
        dialect: 'sqlite'
    }
};

// config/production.js
module.exports = {
    database: {
        host: process.env.DB_HOST,
        database: process.env.DB_NAME,
        dialect: 'mysql'
    }
};

// Using NODE_ENV
const config = require(`./config/${process.env.NODE_ENV || 'development'}`);
```
</UniversalEditor>

## Spring Boot Starters

### Common Starters
<UniversalEditor title="Spring Boot Starters">
```xml !! xml
<!-- Maven dependencies -->
<dependencies>
    <!-- Web starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- Data JPA starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    
    <!-- Security starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    
    <!-- Test starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

```javascript !! js
// JavaScript - Manual package management
// package.json
{
  "dependencies": {
    "express": "^4.18.0",
    "mysql2": "^3.0.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0",
    "cors": "^2.8.5",
    "helmet": "^7.0.0"
  },
  "devDependencies": {
    "jest": "^29.0.0",
    "supertest": "^6.0.0"
  }
}
```
</UniversalEditor>

## Practical Example: User Management System

### Complete Spring Boot Application
<UniversalEditor title="Complete User Management System">
```java !! java
// User entity
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(unique = true)
    private String email;
    
    private String name;
    private String password;
    
    // Constructors, getters, setters
    public User() {}
    
    public User(String email, String name, String password) {
        this.email = email;
        this.name = name;
        this.password = password;
    }
    
    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}

// Repository
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    boolean existsByEmail(String email);
}

// Service
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    public User createUser(User user) {
        if (userRepository.existsByEmail(user.getEmail())) {
            throw new RuntimeException("User already exists");
        }
        
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        return userRepository.save(user);
    }
    
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
    
    public User getUserById(Long id) {
        return userRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("User not found"));
    }
    
    public User updateUser(Long id, User userDetails) {
        User user = getUserById(id);
        user.setName(userDetails.getName());
        user.setEmail(userDetails.getEmail());
        return userRepository.save(user);
    }
    
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}

// Controller
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PostMapping
    public ResponseEntity<User> createUser(@RequestBody User user) {
        User createdUser = userService.createUser(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);
    }
    
    @GetMapping
    public ResponseEntity<List<User>> getAllUsers() {
        List<User> users = userService.getAllUsers();
        return ResponseEntity.ok(users);
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable Long id) {
        User user = userService.getUserById(id);
        return ResponseEntity.ok(user);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<User> updateUser(@PathVariable Long id, 
                                         @RequestBody User userDetails) {
        User updatedUser = userService.updateUser(id, userDetails);
        return ResponseEntity.ok(updatedUser);
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}

// Main application
@SpringBootApplication
public class UserManagementApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserManagementApplication.class, args);
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

```javascript !! js
// JavaScript equivalent with Express.js
const express = require('express');
const bcrypt = require('bcryptjs');
const { Pool } = require('pg');

const app = express();
app.use(express.json());

// Database connection
const pool = new Pool({
    host: 'localhost',
    database: 'userdb',
    user: 'postgres',
    password: 'password'
});

// User service
class UserService {
    async createUser(userData) {
        const { email, name, password } = userData;
        
        // Check if user exists
        const existingUser = await pool.query(
            'SELECT * FROM users WHERE email = $1', [email]
        );
        
        if (existingUser.rows.length > 0) {
            throw new Error('User already exists');
        }
        
        // Hash password
        const hashedPassword = await bcrypt.hash(password, 10);
        
        // Create user
        const result = await pool.query(
            'INSERT INTO users (email, name, password) VALUES ($1, $2, $3) RETURNING *',
            [email, name, hashedPassword]
        );
        
        return result.rows[0];
    }
    
    async getAllUsers() {
        const result = await pool.query('SELECT id, email, name FROM users');
        return result.rows;
    }
    
    async getUserById(id) {
        const result = await pool.query(
            'SELECT id, email, name FROM users WHERE id = $1', [id]
        );
        
        if (result.rows.length === 0) {
            throw new Error('User not found');
        }
        
        return result.rows[0];
    }
    
    async updateUser(id, userData) {
        const { name, email } = userData;
        
        const result = await pool.query(
            'UPDATE users SET name = $1, email = $2 WHERE id = $3 RETURNING *',
            [name, email, id]
        );
        
        if (result.rows.length === 0) {
            throw new Error('User not found');
        }
        
        return result.rows[0];
    }
    
    async deleteUser(id) {
        const result = await pool.query(
            'DELETE FROM users WHERE id = $1', [id]
        );
        
        if (result.rowCount === 0) {
            throw new Error('User not found');
        }
    }
}

const userService = new UserService();

// Routes
app.post('/api/users', async (req, res) => {
    try {
        const user = await userService.createUser(req.body);
        res.status(201).json(user);
    } catch (error) {
        res.status(400).json({ error: error.message });
    }
});

app.get('/api/users', async (req, res) => {
    try {
        const users = await userService.getAllUsers();
        res.json(users);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

app.get('/api/users/:id', async (req, res) => {
    try {
        const user = await userService.getUserById(req.params.id);
        res.json(user);
    } catch (error) {
        res.status(404).json({ error: error.message });
    }
});

app.put('/api/users/:id', async (req, res) => {
    try {
        const user = await userService.updateUser(req.params.id, req.body);
        res.json(user);
    } catch (error) {
        res.status(404).json({ error: error.message });
    }
});

app.delete('/api/users/:id', async (req, res) => {
    try {
        await userService.deleteUser(req.params.id);
        res.status(204).send();
    } catch (error) {
        res.status(404).json({ error: error.message });
    }
});

app.listen(3000, () => {
    console.log('Server running on port 3000');
});
```
</UniversalEditor>

## Best Practices

### 1. Use Constructor Injection
```java
@Service
public class UserService {
    private final UserRepository userRepository;
    private final EmailService emailService;
    
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}
```

### 2. Use @Configuration for Complex Beans
```java
@Configuration
public class AppConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.registerModule(new JavaTimeModule());
        return mapper;
    }
}
```

### 3. Use Profiles for Environment-specific Configuration
```java
@Profile("dev")
@Configuration
public class DevConfig {
    // Development-specific beans
}

@Profile("prod")
@Configuration
public class ProdConfig {
    // Production-specific beans
}
```

### 4. Use @Valid for Input Validation
```java
@PostMapping("/users")
public ResponseEntity<User> createUser(@Valid @RequestBody User user) {
    // Spring automatically validates the user object
    return ResponseEntity.ok(userService.createUser(user));
}
```

## Summary

Spring Framework provides a comprehensive solution for Java enterprise development:

1. **Dependency Injection**: Automatic management of object dependencies
2. **Spring Boot**: Simplified configuration and deployment
3. **Auto-configuration**: Automatic setup based on classpath
4. **Profiles**: Environment-specific configuration
5. **Annotations**: Declarative programming style
6. **Starters**: Pre-configured dependencies

As a JavaScript developer, you'll find that Spring offers similar functionality to Node.js frameworks but with stronger typing, better dependency management, and more comprehensive enterprise features.

## Exercises

1. Create a Spring Boot application with a simple REST API
2. Implement dependency injection using constructor injection
3. Configure different profiles for development and production
4. Create a service layer with proper separation of concerns
5. Implement input validation using @Valid annotation

## Next Steps

In the next module, we'll explore Spring MVC for web development, including controllers, request mapping, and view resolution. 