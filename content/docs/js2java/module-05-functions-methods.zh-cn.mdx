---
title: "模块 05: 函数和方法"
description: "学习 Java 方法、函数重载、递归和函数式编程概念，与 JavaScript 函数进行对比。"
---

# 模块 05: 函数和方法

在本模块中，我们将探索 Java 方法以及它们与 JavaScript 函数的对比。虽然 JavaScript 具有灵活的函数声明和表达式，但 Java 提供了具有强类型和重载功能的结构化方法定义。

## 学习目标

通过本模块的学习，你将能够：
- 理解 Java 方法语法和结构
- 对比 Java 方法与 JavaScript 函数
- 在 Java 中实现方法重载
- 有效使用递归
- 应用函数式编程概念
- 理解方法作用域和可见性

## 方法基础

### 1. 方法声明和定义

Java 方法在类中定义并具有严格的类型检查，这与 JavaScript 的灵活函数声明不同。

<UniversalEditor title="方法声明和定义" compare={true}>
```javascript !! js
// JavaScript - 函数声明和表达式
// 函数声明
function greet(name) {
    return "Hello, " + name + "!";
}

// 函数表达式
const greetArrow = (name) => {
    return "Hello, " + name + "!";
};

// 函数表达式（隐式返回）
const greetShort = name => "Hello, " + name + "!";

// 带默认参数的函数
function greetWithDefault(name = "World") {
    return "Hello, " + name + "!";
}

// 带剩余参数的函数
function sum(...numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

// 函数作为一等公民
const operations = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b,
    multiply: (a, b) => a * b,
    divide: (a, b) => a / b
};

// 返回函数的函数（闭包）
function createMultiplier(factor) {
    return function(number) {
        return number * factor;
    };
}

// 使用示例
console.log(greet("Alice"));
console.log(greetArrow("Bob"));
console.log(greetShort("Charlie"));
console.log(greetWithDefault());
console.log(sum(1, 2, 3, 4, 5));
console.log(operations.add(5, 3));
console.log(operations.multiply(4, 6));

const double = createMultiplier(2);
const triple = createMultiplier(3);
console.log(double(5));  // 10
console.log(triple(5));  // 15
```

```java !! java
// Java - 类中的方法声明
public class MethodBasics {
    // 带返回类型的方法声明
    public String greet(String name) {
        return "Hello, " + name + "!";
    }
    
    // 带 void 返回类型的方法（无返回值）
    public void printGreeting(String name) {
        System.out.println("Hello, " + name + "!");
    }
    
    // 带多个参数的方法
    public int add(int a, int b) {
        return a + b;
    }
    
    // 带不同参数类型的方法
    public double add(double a, double b) {
        return a + b;
    }
    
    // 带数组参数的方法
    public int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }
    
    // 静态方法（属于类，不属于实例）
    public static String staticGreet(String name) {
        return "Static hello, " + name + "!";
    }
    
    // 私有方法（仅在类内可访问）
    private String privateGreet(String name) {
        return "Private hello, " + name + "!";
    }
    
    // 调用其他方法的方法
    public void demonstrateMethods() {
        System.out.println(greet("Alice"));
        printGreeting("Bob");
        System.out.println("Sum: " + add(5, 3));
        System.out.println("Double sum: " + add(5.5, 3.3));
        System.out.println("Varargs sum: " + sum(1, 2, 3, 4, 5));
        System.out.println(staticGreet("Charlie"));
        System.out.println(privateGreet("David"));
    }
    
    public static void main(String[] args) {
        MethodBasics example = new MethodBasics();
        example.demonstrateMethods();
    }
}
```
</UniversalEditor>

### 2. 方法重载

Java 支持方法重载（多个同名但参数不同的方法），这是 JavaScript 原生不支持的。

<UniversalEditor title="方法重载" compare={true}>
```javascript !! js
// JavaScript - 没有原生重载，但可以用不同方法模拟
// 方法1：使用不同的函数名
function addNumbers(a, b) {
    return a + b;
}

function addThreeNumbers(a, b, c) {
    return a + b + c;
}

function addArray(numbers) {
    return numbers.reduce((acc, num) => acc + num, 0);
}

// 方法2：使用参数检查
function add(...args) {
    if (args.length === 2 && typeof args[0] === 'number' && typeof args[1] === 'number') {
        return args[0] + args[1];
    } else if (args.length === 3 && typeof args[0] === 'number' && typeof args[1] === 'number' && typeof args[2] === 'number') {
        return args[0] + args[1] + args[2];
    } else if (args.length === 1 && Array.isArray(args[0])) {
        return args[0].reduce((acc, num) => acc + num, 0);
    } else {
        throw new Error("Invalid parameters");
    }
}

// 方法3：使用对象参数
function calculate(operation, params) {
    switch (operation) {
        case 'add':
            return params.a + params.b;
        case 'multiply':
            return params.a * params.b;
        case 'divide':
            return params.a / params.b;
        default:
            throw new Error("Unknown operation");
    }
}

// 使用示例
console.log(addNumbers(5, 3));
console.log(addThreeNumbers(1, 2, 3));
console.log(addArray([1, 2, 3, 4, 5]));

console.log(add(5, 3));
console.log(add(1, 2, 3));
console.log(add([1, 2, 3, 4, 5]));

console.log(calculate('add', {a: 5, b: 3}));
console.log(calculate('multiply', {a: 4, b: 6}));
```

```java !! java
// Java - 方法重载（同名，不同参数）
public class MethodOverloading {
    // 带不同参数数量的重载方法
    public int add(int a, int b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    public int add(int... numbers) {
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
    
    // 带不同参数类型的重载方法
    public double add(double a, double b) {
        return a + b;
    }
    
    public String add(String a, String b) {
        return a + b;
    }
    
    // 带不同参数顺序的重载方法
    public void printInfo(String name, int age) {
        System.out.println("Name: " + name + ", Age: " + age);
    }
    
    public void printInfo(int age, String name) {
        System.out.println("Age: " + age + ", Name: " + name);
    }
    
    // 构造函数重载
    public MethodOverloading() {
        System.out.println("Default constructor");
    }
    
    public MethodOverloading(String message) {
        System.out.println("Constructor with message: " + message);
    }
    
    public MethodOverloading(int number) {
        System.out.println("Constructor with number: " + number);
    }
    
    // 演示重载的方法
    public void demonstrateOverloading() {
        System.out.println("add(5, 3): " + add(5, 3));
        System.out.println("add(1, 2, 3): " + add(1, 2, 3));
        System.out.println("add(1, 2, 3, 4, 5): " + add(1, 2, 3, 4, 5));
        System.out.println("add(5.5, 3.3): " + add(5.5, 3.3));
        System.out.println("add(\"Hello, \", \"World!\"): " + add("Hello, ", "World!"));
        
        printInfo("Alice", 25);
        printInfo(30, "Bob");
    }
    
    public static void main(String[] args) {
        MethodOverloading example = new MethodOverloading();
        example.demonstrateOverloading();
        
        // 构造函数重载演示
        new MethodOverloading("Hello");
        new MethodOverloading(42);
    }
}
```
</UniversalEditor>

## 递归

### 1. 递归方法

Java 和 JavaScript 都支持递归，但 Java 的强类型提供了额外的安全性。

<UniversalEditor title="递归方法" compare={true}>
```javascript !! js
// JavaScript - 递归函数
// 阶乘计算
function factorial(n) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}

// 斐波那契数列
function fibonacci(n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// 二分查找（递归）
function binarySearch(arr, target, left = 0, right = arr.length - 1) {
    if (left > right) {
        return -1;  // 未找到
    }
    
    const mid = Math.floor((left + right) / 2);
    
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearch(arr, target, mid + 1, right);
    } else {
        return binarySearch(arr, target, left, mid - 1);
    }
}

// 树遍历（递归）
function traverseTree(node) {
    if (!node) {
        return;
    }
    
    console.log(node.value);  // 前序遍历
    traverseTree(node.left);
    traverseTree(node.right);
}

// 汉诺塔
function towerOfHanoi(n, source, auxiliary, destination) {
    if (n === 1) {
        console.log(`Move disk 1 from ${source} to ${destination}`);
        return;
    }
    
    towerOfHanoi(n - 1, source, destination, auxiliary);
    console.log(`Move disk ${n} from ${source} to ${destination}`);
    towerOfHanoi(n - 1, auxiliary, source, destination);
}

// 使用示例
console.log("Factorial of 5:", factorial(5));
console.log("Fibonacci(7):", fibonacci(7));

const sortedArray = [1, 3, 5, 7, 9, 11, 13, 15];
console.log("Binary search for 7:", binarySearch(sortedArray, 7));
console.log("Binary search for 10:", binarySearch(sortedArray, 10));

console.log("Tower of Hanoi (3 disks):");
towerOfHanoi(3, 'A', 'B', 'C');
```

```java !! java
// Java - 递归方法
public class RecursionExamples {
    // 阶乘计算
    public static int factorial(int n) {
        if (n <= 1) {
            return 1;
        }
        return n * factorial(n - 1);
    }
    
    // 斐波那契数列
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        }
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    // 二分查找（递归）
    public static int binarySearch(int[] arr, int target, int left, int right) {
        if (left > right) {
            return -1;  // 未找到
        }
        
        int mid = (left + right) / 2;
        
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            return binarySearch(arr, target, mid + 1, right);
        } else {
            return binarySearch(arr, target, left, mid - 1);
        }
    }
    
    // 重载的二分查找，便于使用
    public static int binarySearch(int[] arr, int target) {
        return binarySearch(arr, target, 0, arr.length - 1);
    }
    
    // 汉诺塔
    public static void towerOfHanoi(int n, String source, String auxiliary, String destination) {
        if (n == 1) {
            System.out.println("Move disk 1 from " + source + " to " + destination);
            return;
        }
        
        towerOfHanoi(n - 1, source, destination, auxiliary);
        System.out.println("Move disk " + n + " from " + source + " to " + destination);
        towerOfHanoi(n - 1, auxiliary, source, destination);
    }
    
    // GCD（最大公约数）使用欧几里得算法
    public static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
    
    // 幂计算（递归）
    public static double power(double base, int exponent) {
        if (exponent == 0) {
            return 1;
        } else if (exponent < 0) {
            return 1 / power(base, -exponent);
        } else if (exponent % 2 == 0) {
            double half = power(base, exponent / 2);
            return half * half;
        } else {
            return base * power(base, exponent - 1);
        }
    }
    
    public static void main(String[] args) {
        System.out.println("Factorial of 5: " + factorial(5));
        System.out.println("Fibonacci(7): " + fibonacci(7));
        
        int[] sortedArray = {1, 3, 5, 7, 9, 11, 13, 15};
        System.out.println("Binary search for 7: " + binarySearch(sortedArray, 7));
        System.out.println("Binary search for 10: " + binarySearch(sortedArray, 10));
        
        System.out.println("GCD of 48 and 18: " + gcd(48, 18));
        System.out.println("2^10: " + power(2, 10));
        System.out.println("2^-3: " + power(2, -3));
        
        System.out.println("Tower of Hanoi (3 disks):");
        towerOfHanoi(3, "A", "B", "C");
    }
}
```
</UniversalEditor>

## 函数式编程概念

### 1. Lambda 表达式和函数式接口

Java 8+ 引入了 lambda 表达式和函数式编程概念，类似于 JavaScript 的箭头函数。

<UniversalEditor title="Lambda 表达式和函数式编程" compare={true}>
```javascript !! js
// JavaScript - 箭头函数和函数式编程
// 箭头函数
const add = (a, b) => a + b;
const multiply = (a, b) => a * b;
const square = x => x * x;

// 高阶函数
const map = (arr, fn) => arr.map(fn);
const filter = (arr, predicate) => arr.filter(predicate);
const reduce = (arr, fn, initial) => arr.reduce(fn, initial);

// 函数组合
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);

// 柯里化
const curry = (fn) => {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function(...moreArgs) {
            return curried.apply(this, args.concat(moreArgs));
        };
    };
};

// 偏应用
const partial = (fn, ...args) => {
    return function(...moreArgs) {
        return fn.apply(this, args.concat(moreArgs));
    };
};

// 使用示例
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Map, filter, reduce
const doubled = map(numbers, x => x * 2);
const evens = filter(numbers, x => x % 2 === 0);
const sum = reduce(numbers, (acc, x) => acc + x, 0);

// 函数组合
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const composed = compose(square, double, addOne);
const piped = pipe(addOne, double, square);

console.log("Original:", numbers);
console.log("Doubled:", doubled);
console.log("Evens:", evens);
console.log("Sum:", sum);
console.log("Composed(3):", composed(3));  // ((3+1)*2)^2 = 64
console.log("Piped(3):", piped(3));        // ((3+1)*2)^2 = 64

// 柯里化示例
const curriedAdd = curry((a, b, c) => a + b + c);
console.log("Curried add:", curriedAdd(1)(2)(3));

// 偏应用
const addFive = partial(add, 5);
console.log("Add five to 3:", addFive(3));
```

```java !! java
// Java - Lambda 表达式和函数式编程（Java 8+）
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class FunctionalProgramming {
    public static void main(String[] args) {
        // Lambda 表达式
        BinaryOperator<Integer> add = (a, b) -> a + b;
        BinaryOperator<Integer> multiply = (a, b) -> a * b;
        Function<Integer, Integer> square = x -> x * x;
        
        // Predicate 示例
        Predicate<Integer> isEven = x -> x % 2 == 0;
        Predicate<Integer> isPositive = x -> x > 0;
        Predicate<String> isEmpty = String::isEmpty;
        
        // Function 示例
        Function<String, Integer> length = String::length;
        Function<Integer, String> toString = Object::toString;
        
        // Consumer 示例
        Consumer<String> printer = System.out::println;
        Consumer<Integer> squarePrinter = x -> System.out.println(x * x);
        
        // Supplier 示例
        Supplier<Double> randomSupplier = Math::random;
        Supplier<String> helloSupplier = () -> "Hello, World!";
        
        // Stream 操作（函数式编程）
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Map, filter, reduce
        List<Integer> doubled = numbers.stream()
            .map(x -> x * 2)
            .collect(Collectors.toList());
        
        List<Integer> evens = numbers.stream()
            .filter(x -> x % 2 == 0)
            .collect(Collectors.toList());
        
        int sum = numbers.stream()
            .reduce(0, Integer::sum);
        
        // 方法引用
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        names.forEach(System.out::println);
        
        List<Integer> lengths = names.stream()
            .map(String::length)
            .collect(Collectors.toList());
        
        // 函数组合
        Function<Integer, Integer> addOne = x -> x + 1;
        Function<Integer, Integer> double = x -> x * 2;
        Function<Integer, Integer> square = x -> x * x;
        
        Function<Integer, Integer> composed = addOne.andThen(double).andThen(square);
        Function<Integer, Integer> piped = square.compose(double).compose(addOne);
        
        // Optional 用于函数式编程
        Optional<Integer> optional = Optional.of(42);
        optional.map(x -> x * 2)
               .filter(x -> x > 80)
               .ifPresent(System.out::println);
        
        // 自定义函数式接口
        TriFunction<Integer, Integer, Integer, Integer> addThree = (a, b, c) -> a + b + c;
        
        // 使用示例
        System.out.println("Original: " + numbers);
        System.out.println("Doubled: " + doubled);
        System.out.println("Evens: " + evens);
        System.out.println("Sum: " + sum);
        System.out.println("Composed(3): " + composed.apply(3));
        System.out.println("Piped(3): " + piped.apply(3));
        System.out.println("Add three: " + addThree.apply(1, 2, 3));
        
        // Stream 操作与收集器
        Map<Boolean, List<Integer>> partitioned = numbers.stream()
            .collect(Collectors.partitioningBy(x -> x % 2 == 0));
        
        System.out.println("Partitioned: " + partitioned);
        
        // 并行流
        long count = numbers.parallelStream()
            .filter(x -> x > 5)
            .count();
        
        System.out.println("Count > 5: " + count);
    }
    
    // 自定义函数式接口
    @FunctionalInterface
    interface TriFunction<T, U, V, R> {
        R apply(T t, U u, V v);
    }
}
```
</UniversalEditor>

## 方法作用域和可见性

### 1. 访问修饰符和作用域

Java 有严格的访问控制，而 JavaScript 使用闭包和模块模式进行封装。

<UniversalEditor title="方法作用域和可见性" compare={true}>
```javascript !! js
// JavaScript - 作用域和封装模式
// 模块模式用于封装
const Calculator = (function() {
    // 私有变量
    let history = [];
    let operationCount = 0;
    
    // 私有方法
    function logOperation(operation, result) {
        history.push({
            operation: operation,
            result: result,
            timestamp: new Date()
        });
        operationCount++;
    }
    
    function validateNumber(num) {
        return typeof num === 'number' && !isNaN(num);
    }
    
    // 公共方法
    return {
        add: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            const result = a + b;
            logOperation(`add(${a}, ${b})`, result);
            return result;
        },
        
        subtract: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            const result = a - b;
            logOperation(`subtract(${a}, ${b})`, result);
            return result;
        },
        
        multiply: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            const result = a * b;
            logOperation(`multiply(${a}, ${b})`, result);
            return result;
        },
        
        divide: function(a, b) {
            if (!validateNumber(a) || !validateNumber(b)) {
                throw new Error('Invalid numbers');
            }
            if (b === 0) {
                throw new Error('Division by zero');
            }
            const result = a / b;
            logOperation(`divide(${a}, ${b})`, result);
            return result;
        },
        
        // 公共 getter 方法
        getHistory: function() {
            return [...history]; // 返回副本以防止修改
        },
        
        getOperationCount: function() {
            return operationCount;
        },
        
        clearHistory: function() {
            history = [];
            operationCount = 0;
        }
    };
})();

// ES6 类与私有字段（较新的浏览器）
class ModernCalculator {
    #history = [];
    #operationCount = 0;
    
    #logOperation(operation, result) {
        this.#history.push({
            operation: operation,
            result: result,
            timestamp: new Date()
        });
        this.#operationCount++;
    }
    
    #validateNumber(num) {
        return typeof num === 'number' && !isNaN(num);
    }
    
    add(a, b) {
        if (!this.#validateNumber(a) || !this.#validateNumber(b)) {
            throw new Error('Invalid numbers');
        }
        const result = a + b;
        this.#logOperation(`add(${a}, ${b})`, result);
        return result;
    }
    
    getHistory() {
        return [...this.#history];
    }
    
    getOperationCount() {
        return this.#operationCount;
    }
}

// 使用示例
try {
    console.log(Calculator.add(5, 3));
    console.log(Calculator.multiply(4, 6));
    console.log(Calculator.getHistory());
    console.log(Calculator.getOperationCount());
    
    // 这会抛出错误
    // Calculator.logOperation("test", 42); // Error: logOperation is not a function
} catch (error) {
    console.error("Error:", error.message);
}
```

```java !! java
// Java - 访问修饰符和作用域
public class Calculator {
    // 私有字段（仅在此类内可访问）
    private List<Operation> history;
    private int operationCount;
    
    // 包私有构造函数（在同一包内可访问）
    Calculator() {
        this.history = new ArrayList<>();
        this.operationCount = 0;
    }
    
    // 公共构造函数
    public Calculator(String name) {
        this();
        System.out.println("Calculator initialized: " + name);
    }
    
    // 私有方法（仅在此类内可访问）
    private void logOperation(String operation, double result) {
        history.add(new Operation(operation, result, new Date()));
        operationCount++;
    }
    
    // 私有验证方法
    private boolean isValidNumber(double num) {
        return !Double.isNaN(num) && !Double.isInfinite(num);
    }
    
    // 公共方法（可从任何地方访问）
    public double add(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        double result = a + b;
        logOperation("add(" + a + ", " + b + ")", result);
        return result;
    }
    
    public double subtract(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        double result = a - b;
        logOperation("subtract(" + a + ", " + b + ")", result);
        return result;
    }
    
    public double multiply(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        double result = a * b;
        logOperation("multiply(" + a + ", " + b + ")", result);
        return result;
    }
    
    public double divide(double a, double b) {
        if (!isValidNumber(a) || !isValidNumber(b)) {
            throw new IllegalArgumentException("Invalid numbers");
        }
        if (b == 0) {
            throw new ArithmeticException("Division by zero");
        }
        double result = a / b;
        logOperation("divide(" + a + ", " + b + ")", result);
        return result;
    }
    
    // 受保护方法（在包内和子类中可访问）
    protected List<Operation> getHistoryInternal() {
        return new ArrayList<>(history); // 返回副本以防止修改
    }
    
    // 公共 getter 方法
    public List<Operation> getHistory() {
        return getHistoryInternal();
    }
    
    public int getOperationCount() {
        return operationCount;
    }
    
    public void clearHistory() {
        history.clear();
        operationCount = 0;
    }
    
    // 静态方法（属于类，不属于实例）
    public static double power(double base, double exponent) {
        return Math.pow(base, exponent);
    }
    
    // 内部类用于操作历史
    public static class Operation {
        private String operation;
        private double result;
        private Date timestamp;
        
        public Operation(String operation, double result, Date timestamp) {
            this.operation = operation;
            this.result = result;
            this.timestamp = timestamp;
        }
        
        // Getters
        public String getOperation() { return operation; }
        public double getResult() { return result; }
        public Date getTimestamp() { return timestamp; }
        
        @Override
        public String toString() {
            return operation + " = " + result + " (" + timestamp + ")";
        }
    }
}

// 子类演示受保护访问
class ScientificCalculator extends Calculator {
    public double squareRoot(double a) {
        if (a < 0) {
            throw new IllegalArgumentException("Cannot calculate square root of negative number");
        }
        double result = Math.sqrt(a);
        // 可以访问父类的受保护方法
        getHistoryInternal().add(new Calculator.Operation("sqrt(" + a + ")", result, new Date()));
        return result;
    }
}

// 主类演示用法
class MethodScopeDemo {
    public static void main(String[] args) {
        Calculator calc = new Calculator("MyCalculator");
        
        try {
            System.out.println("5 + 3 = " + calc.add(5, 3));
            System.out.println("4 * 6 = " + calc.multiply(4, 6));
            System.out.println("10 / 2 = " + calc.divide(10, 2));
            
            System.out.println("History: " + calc.getHistory());
            System.out.println("Operation count: " + calc.getOperationCount());
            
            // 静态方法调用
            System.out.println("2^10 = " + Calculator.power(2, 10));
            
            // 科学计算器
            ScientificCalculator sciCalc = new ScientificCalculator();
            System.out.println("sqrt(16) = " + sciCalc.squareRoot(16));
            
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
        }
    }
}
```
</UniversalEditor>

## 练习题

### 练习 1: 方法实现

<UniversalEditor title="练习 1: 方法实现">
```java !! java
// TODO: 实现这些方法
public class MethodExercises {
    public static void main(String[] args) {
        // 测试你的实现
        System.out.println("Factorial of 5: " + factorial(5));
        System.out.println("GCD of 48 and 18: " + gcd(48, 18));
        System.out.println("Is palindrome: " + isPalindrome("racecar"));
        System.out.println("Reverse string: " + reverseString("hello"));
        
        int[] arr = {3, 1, 4, 1, 5, 9, 2, 6};
        System.out.println("Array before sort: " + Arrays.toString(arr));
        bubbleSort(arr);
        System.out.println("Array after sort: " + Arrays.toString(arr));
    }
    
    // 1. 使用递归实现阶乘
    public static int factorial(int n) {
        // TODO: 实现此方法
        return 0;
    }
    
    // 2. 使用欧几里得算法实现 GCD
    public static int gcd(int a, int b) {
        // TODO: 实现此方法
        return 0;
    }
    
    // 3. 检查字符串是否为回文
    public static boolean isPalindrome(String str) {
        // TODO: 实现此方法
        return false;
    }
    
    // 4. 使用递归反转字符串
    public static String reverseString(String str) {
        // TODO: 实现此方法
        return "";
    }
    
    // 5. 实现冒泡排序
    public static void bubbleSort(int[] arr) {
        // TODO: 实现此方法
    }
}
```
</UniversalEditor>

### 练习 2: 函数式编程

<UniversalEditor title="练习 2: 函数式编程">
```java !! java
// TODO: 实现函数式编程解决方案
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class FunctionalExercises {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<String> words = Arrays.asList("hello", "world", "java", "programming", "functional");
        
        // 测试你的实现
        System.out.println("Sum of squares: " + sumOfSquares(numbers));
        System.out.println("Longest word: " + findLongestWord(words));
        System.out.println("Words with length > 4: " + filterByLength(words, 4));
        System.out.println("All even: " + allEven(numbers));
        System.out.println("Any odd: " + anyOdd(numbers));
        
        // 自定义函数式操作
        List<Integer> result = customMap(numbers, x -> x * x + 1);
        System.out.println("Custom map result: " + result);
        
        List<Integer> filtered = customFilter(numbers, x -> x % 2 == 0);
        System.out.println("Custom filter result: " + filtered);
    }
    
    // 1. 使用流计算平方和
    public static int sumOfSquares(List<Integer> numbers) {
        // TODO: 使用流实现
        return 0;
    }
    
    // 2. 使用流查找最长单词
    public static String findLongestWord(List<String> words) {
        // TODO: 使用流实现
        return "";
    }
    
    // 3. 按长度过滤单词
    public static List<String> filterByLength(List<String> words, int minLength) {
        // TODO: 使用流实现
        return new ArrayList<>();
    }
    
    // 4. 检查所有数字是否都是偶数
    public static boolean allEven(List<Integer> numbers) {
        // TODO: 使用流实现
        return false;
    }
    
    // 5. 检查是否有奇数
    public static boolean anyOdd(List<Integer> numbers) {
        // TODO: 使用流实现
        return false;
    }
    
    // 6. 使用递归的自定义 map 函数
    public static List<Integer> customMap(List<Integer> numbers, Function<Integer, Integer> mapper) {
        // TODO: 使用递归实现
        return new ArrayList<>();
    }
    
    // 7. 使用递归的自定义 filter 函数
    public static List<Integer> customFilter(List<Integer> numbers, Predicate<Integer> predicate) {
        // TODO: 使用递归实现
        return new ArrayList<>();
    }
}
```
</UniversalEditor>

## 总结

在本模块中，我们探索了 Java 方法并将其与 JavaScript 函数进行了对比：

### 关键要点：
1. **方法结构**: Java 方法在类中定义，具有严格的类型检查
2. **方法重载**: Java 支持同名但参数不同的多个方法
3. **递归**: 两种语言都支持递归函数，但有不同的安全机制
4. **函数式编程**: Java 8+ 引入了 lambda 表达式和流
5. **访问控制**: Java 有严格的访问修饰符用于封装

### 下一步：
- 练习实现递归算法
- 掌握方法重载模式
- 探索使用流的函数式编程
- 为下一个关于面向对象编程的模块做准备

## 额外资源

- [Java 方法](https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html)
- [Java Lambda 表达式](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)
- [Java 流](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

---

**练习提示**: 创建演示每种方法类型的小程序。专注于理解何时使用递归 vs 迭代，并练习使用流的函数式编程概念。 