---
title: "Module 10: Generics"
description: "Learn Java generics, type parameters, bounded types, and generic collections compared to JavaScript type handling and generic patterns."
---

# Module 10: Generics

In this module, we'll explore Java's generic system and compare it with JavaScript's type handling approaches. We'll learn about type parameters, bounded types, generic methods, and how generics provide type safety while maintaining code reusability.

## Learning Objectives

By the end of this module, you will be able to:
- Understand Java generics and type parameters
- Compare Java generics with JavaScript type handling
- Implement generic classes and methods
- Use bounded types and wildcards
- Apply generics in collections and data structures
- Understand type erasure and its implications

## Generic Basics

### 1. Generic Classes and Type Parameters

Java generics provide compile-time type safety, while JavaScript uses runtime type checking and TypeScript for static typing.

<UniversalEditor title="Generic Classes and Type Parameters" compare={true}>
```javascript !! js
// JavaScript - Generic patterns and type handling
// Generic-like function with type checking
function createContainer(value) {
    return {
        value: value,
        getValue: function() {
            return this.value;
        },
        setValue: function(newValue) {
            this.value = newValue;
        },
        getType: function() {
            return typeof this.value;
        }
    };
}

// Type-safe container with validation
function createTypedContainer(value, type) {
    const container = {
        value: value,
        type: type,
        getValue: function() {
            return this.value;
        },
        setValue: function(newValue) {
            if (typeof newValue !== this.type) {
                throw new Error(`Expected ${this.type}, got ${typeof newValue}`);
            }
            this.value = newValue;
        },
        getType: function() {
            return this.type;
        }
    };
    
    // Validate initial value
    container.setValue(value);
    return container;
}

// Generic-like class with TypeScript-style comments
class Container {
    constructor(value) {
        this.value = value;
    }
    
    getValue() {
        return this.value;
    }
    
    setValue(newValue) {
        this.value = newValue;
    }
    
    getType() {
        return typeof this.value;
    }
}

// Generic-like pair class
class Pair {
    constructor(first, second) {
        this.first = first;
        this.second = second;
    }
    
    getFirst() {
        return this.first;
    }
    
    getSecond() {
        return this.second;
    }
    
    setFirst(first) {
        this.first = first;
    }
    
    setSecond(second) {
        this.second = second;
    }
    
    swap() {
        [this.first, this.second] = [this.second, this.first];
    }
    
    toString() {
        return `(${this.first}, ${this.second})`;
    }
}

// Generic-like stack implementation
class Stack {
    constructor() {
        this.items = [];
    }
    
    push(item) {
        this.items.push(item);
    }
    
    pop() {
        if (this.isEmpty()) {
            throw new Error('Stack is empty');
        }
        return this.items.pop();
    }
    
    peek() {
        if (this.isEmpty()) {
            throw new Error('Stack is empty');
        }
        return this.items[this.items.length - 1];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
    
    clear() {
        this.items = [];
    }
}

// Generic-like queue implementation
class Queue {
    constructor() {
        this.items = [];
    }
    
    enqueue(item) {
        this.items.push(item);
    }
    
    dequeue() {
        if (this.isEmpty()) {
            throw new Error('Queue is empty');
        }
        return this.items.shift();
    }
    
    front() {
        if (this.isEmpty()) {
            throw new Error('Queue is empty');
        }
        return this.items[0];
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    size() {
        return this.items.length;
    }
    
    clear() {
        this.items = [];
    }
}

// Generic-like linked list node
class ListNode {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// Generic-like linked list
class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }
    
    add(data) {
        const newNode = new ListNode(data);
        
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }
    
    remove(data) {
        if (!this.head) {
            return false;
        }
        
        if (this.head.data === data) {
            this.head = this.head.next;
            this.size--;
            return true;
        }
        
        let current = this.head;
        while (current.next) {
            if (current.next.data === data) {
                current.next = current.next.next;
                this.size--;
                return true;
            }
            current = current.next;
        }
        return false;
    }
    
    find(data) {
        let current = this.head;
        while (current) {
            if (current.data === data) {
                return current;
            }
            current = current.next;
        }
        return null;
    }
    
    toArray() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        return result;
    }
    
    getSize() {
        return this.size;
    }
    
    isEmpty() {
        return this.size === 0;
    }
}

// Usage examples
const stringContainer = createContainer("Hello");
const numberContainer = createContainer(42);
const booleanContainer = createContainer(true);

console.log(stringContainer.getValue()); // "Hello"
console.log(numberContainer.getValue()); // 42
console.log(booleanContainer.getType()); // "boolean"

// Typed containers
const typedStringContainer = createTypedContainer("Hello", "string");
const typedNumberContainer = createTypedContainer(42, "number");

try {
    typedStringContainer.setValue(123); // Error: Expected string, got number
} catch (error) {
    console.error(error.message);
}

// Pairs
const stringPair = new Pair("Hello", "World");
const numberPair = new Pair(1, 2);
const mixedPair = new Pair("Hello", 42);

console.log(stringPair.toString()); // "(Hello, World)"
console.log(numberPair.toString()); // "(1, 2)"
mixedPair.swap();
console.log(mixedPair.toString()); // "(42, Hello)"

// Stack usage
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);

console.log(stack.pop()); // 3
console.log(stack.peek()); // 2
console.log(stack.size()); // 2

// Queue usage
const queue = new Queue();
queue.enqueue("First");
queue.enqueue("Second");
queue.enqueue("Third");

console.log(queue.dequeue()); // "First"
console.log(queue.front()); // "Second"
console.log(queue.size()); // 2

// Linked list usage
const list = new LinkedList();
list.add("Apple");
list.add("Banana");
list.add("Cherry");

console.log(list.toArray()); // ["Apple", "Banana", "Cherry"]
console.log(list.find("Banana")); // ListNode { data: "Banana", next: ... }
list.remove("Banana");
console.log(list.toArray()); // ["Apple", "Cherry"]
```

```java !! java
// Java - Generic classes and type parameters
import java.util.*;

// Generic container class
public class Container<T> {
    private T value;
    
    public Container(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public void setValue(T newValue) {
        this.value = newValue;
    }
    
    public String getType() {
        return value != null ? value.getClass().getSimpleName() : "null";
    }
    
    @Override
    public String toString() {
        return "Container{" + value + "}";
    }
}

// Generic pair class
public class Pair<T, U> {
    private T first;
    private U second;
    
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
    
    public T getFirst() {
        return first;
    }
    
    public U getSecond() {
        return second;
    }
    
    public void setFirst(T first) {
        this.first = first;
    }
    
    public void setSecond(U second) {
        this.second = second;
    }
    
    public void swap() {
        // Note: This requires both types to be the same
        if (first.getClass() == second.getClass()) {
            @SuppressWarnings("unchecked")
            T temp = (T) second;
            second = (U) first;
            first = temp;
        }
    }
    
    @Override
    public String toString() {
        return "(" + first + ", " + second + ")";
    }
}

// Generic stack implementation
public class Stack<T> {
    private List<T> items;
    
    public Stack() {
        this.items = new ArrayList<>();
    }
    
    public void push(T item) {
        items.add(item);
    }
    
    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return items.remove(items.size() - 1);
    }
    
    public T peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return items.get(items.size() - 1);
    }
    
    public boolean isEmpty() {
        return items.isEmpty();
    }
    
    public int size() {
        return items.size();
    }
    
    public void clear() {
        items.clear();
    }
    
    @Override
    public String toString() {
        return items.toString();
    }
}

// Generic queue implementation
public class Queue<T> {
    private List<T> items;
    
    public Queue() {
        this.items = new ArrayList<>();
    }
    
    public void enqueue(T item) {
        items.add(item);
    }
    
    public T dequeue() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return items.remove(0);
    }
    
    public T front() {
        if (isEmpty()) {
            throw new NoSuchElementException("Queue is empty");
        }
        return items.get(0);
    }
    
    public boolean isEmpty() {
        return items.isEmpty();
    }
    
    public int size() {
        return items.size();
    }
    
    public void clear() {
        items.clear();
    }
    
    @Override
    public String toString() {
        return items.toString();
    }
}

// Generic linked list node
public class ListNode<T> {
    private T data;
    private ListNode<T> next;
    
    public ListNode(T data) {
        this.data = data;
        this.next = null;
    }
    
    public T getData() {
        return data;
    }
    
    public void setData(T data) {
        this.data = data;
    }
    
    public ListNode<T> getNext() {
        return next;
    }
    
    public void setNext(ListNode<T> next) {
        this.next = next;
    }
}

// Generic linked list
public class LinkedList<T> {
    private ListNode<T> head;
    private int size;
    
    public LinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    public void add(T data) {
        ListNode<T> newNode = new ListNode<>(data);
        
        if (head == null) {
            head = newNode;
        } else {
            ListNode<T> current = head;
            while (current.getNext() != null) {
                current = current.getNext();
            }
            current.setNext(newNode);
        }
        size++;
    }
    
    public boolean remove(T data) {
        if (head == null) {
            return false;
        }
        
        if (head.getData().equals(data)) {
            head = head.getNext();
            size--;
            return true;
        }
        
        ListNode<T> current = head;
        while (current.getNext() != null) {
            if (current.getNext().getData().equals(data)) {
                current.setNext(current.getNext().getNext());
                size--;
                return true;
            }
            current = current.getNext();
        }
        return false;
    }
    
    public ListNode<T> find(T data) {
        ListNode<T> current = head;
        while (current != null) {
            if (current.getData().equals(data)) {
                return current;
            }
            current = current.getNext();
        }
        return null;
    }
    
    public List<T> toList() {
        List<T> result = new ArrayList<>();
        ListNode<T> current = head;
        while (current != null) {
            result.add(current.getData());
            current = current.getNext();
        }
        return result;
    }
    
    public int getSize() {
        return size;
    }
    
    public boolean isEmpty() {
        return size == 0;
    }
    
    @Override
    public String toString() {
        return toList().toString();
    }
}

// Main class to demonstrate generics
public class GenericDemo {
    public static void main(String[] args) {
        // Container usage
        Container<String> stringContainer = new Container<>("Hello");
        Container<Integer> numberContainer = new Container<>(42);
        Container<Boolean> booleanContainer = new Container<>(true);
        
        System.out.println(stringContainer.getValue()); // "Hello"
        System.out.println(numberContainer.getValue()); // 42
        System.out.println(booleanContainer.getType()); // "Boolean"
        
        // Pair usage
        Pair<String, String> stringPair = new Pair<>("Hello", "World");
        Pair<Integer, Integer> numberPair = new Pair<>(1, 2);
        Pair<String, Integer> mixedPair = new Pair<>("Hello", 42);
        
        System.out.println(stringPair); // "(Hello, World)"
        System.out.println(numberPair); // "(1, 2)"
        System.out.println(mixedPair); // "(Hello, 42)"
        
        // Stack usage
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        
        System.out.println(stack.pop()); // 3
        System.out.println(stack.peek()); // 2
        System.out.println(stack.size()); // 2
        
        // Queue usage
        Queue<String> queue = new Queue<>();
        queue.enqueue("First");
        queue.enqueue("Second");
        queue.enqueue("Third");
        
        System.out.println(queue.dequeue()); // "First"
        System.out.println(queue.front()); // "Second"
        System.out.println(queue.size()); // 2
        
        // Linked list usage
        LinkedList<String> list = new LinkedList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        
        System.out.println(list.toList()); // [Apple, Banana, Cherry]
        System.out.println(list.find("Banana")); // ListNode@...
        list.remove("Banana");
        System.out.println(list.toList()); // [Apple, Cherry]
        
        // Type safety demonstration
        Container<String> container = new Container<>("Hello");
        // container.setValue(42); // Compilation error!
        container.setValue("World"); // OK
    }
}
```
</UniversalEditor>

### 2. Generic Methods and Bounded Types

Java supports generic methods and bounded types for more flexible type constraints.

<UniversalEditor title="Generic Methods and Bounded Types" compare={true}>
```javascript !! js
// JavaScript - Generic methods and type constraints
// Generic-like utility functions
function findMax(array) {
    if (array.length === 0) {
        throw new Error('Array is empty');
    }
    
    let max = array[0];
    for (let i = 1; i < array.length; i++) {
        if (array[i] > max) {
            max = array[i];
        }
    }
    return max;
}

function findMin(array) {
    if (array.length === 0) {
        throw new Error('Array is empty');
    }
    
    let min = array[0];
    for (let i = 1; i < array.length; i++) {
        if (array[i] < min) {
            min = array[i];
        }
    }
    return min;
}

// Generic-like sorting function
function sort(array, compareFunction = null) {
    const result = [...array];
    if (compareFunction) {
        result.sort(compareFunction);
    } else {
        result.sort();
    }
    return result;
}

// Generic-like filter function
function filter(array, predicate) {
    return array.filter(predicate);
}

// Generic-like map function
function map(array, transform) {
    return array.map(transform);
}

// Generic-like reduce function
function reduce(array, reducer, initialValue) {
    return array.reduce(reducer, initialValue);
}

// Type-constrained functions (runtime checking)
function findMaxComparable(array) {
    if (array.length === 0) {
        throw new Error('Array is empty');
    }
    
    // Check if all elements are comparable
    for (let item of array) {
        if (typeof item !== 'number' && typeof item !== 'string') {
            throw new Error('All elements must be comparable (numbers or strings)');
        }
    }
    
    let max = array[0];
    for (let i = 1; i < array.length; i++) {
        if (array[i] > max) {
            max = array[i];
        }
    }
    return max;
}

// Generic-like class with type constraints
class ComparableContainer {
    constructor(value) {
        if (typeof value !== 'number' && typeof value !== 'string') {
            throw new Error('Value must be comparable (number or string)');
        }
        this.value = value;
    }
    
    getValue() {
        return this.value;
    }
    
    setValue(newValue) {
        if (typeof newValue !== 'number' && typeof newValue !== 'string') {
            throw new Error('Value must be comparable (number or string)');
        }
        this.value = newValue;
    }
    
    compareTo(other) {
        if (other instanceof ComparableContainer) {
            if (this.value < other.value) return -1;
            if (this.value > other.value) return 1;
            return 0;
        }
        throw new Error('Cannot compare with non-ComparableContainer');
    }
}

// Generic-like utility class
class ArrayUtils {
    static findMax(array) {
        return findMax(array);
    }
    
    static findMin(array) {
        return findMin(array);
    }
    
    static sort(array, compareFunction = null) {
        return sort(array, compareFunction);
    }
    
    static filter(array, predicate) {
        return filter(array, predicate);
    }
    
    static map(array, transform) {
        return map(array, transform);
    }
    
    static reduce(array, reducer, initialValue) {
        return reduce(array, reducer, initialValue);
    }
    
    static reverse(array) {
        return [...array].reverse();
    }
    
    static unique(array) {
        return [...new Set(array)];
    }
    
    static shuffle(array) {
        const result = [...array];
        for (let i = result.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
    }
}

// Usage examples
const numbers = [3, 1, 4, 1, 5, 9, 2, 6];
const strings = ['banana', 'apple', 'cherry', 'date'];

console.log('Max number:', findMax(numbers)); // 9
console.log('Min number:', findMin(numbers)); // 1
console.log('Max string:', findMax(strings)); // 'date'
console.log('Min string:', findMin(strings)); // 'apple'

// Sorting
console.log('Sorted numbers:', sort(numbers)); // [1, 1, 2, 3, 4, 5, 6, 9]
console.log('Sorted strings:', sort(strings)); // ['apple', 'banana', 'cherry', 'date']

// Filtering
const evenNumbers = filter(numbers, x => x % 2 === 0);
const longStrings = filter(strings, s => s.length > 5);
console.log('Even numbers:', evenNumbers); // [4, 2, 6]
console.log('Long strings:', longStrings); // ['banana', 'cherry']

// Mapping
const doubledNumbers = map(numbers, x => x * 2);
const upperStrings = map(strings, s => s.toUpperCase());
console.log('Doubled numbers:', doubledNumbers); // [6, 2, 8, 2, 10, 18, 4, 12]
console.log('Upper strings:', upperStrings); // ['BANANA', 'APPLE', 'CHERRY', 'DATE']

// Reducing
const sum = reduce(numbers, (acc, x) => acc + x, 0);
const concatenated = reduce(strings, (acc, s) => acc + s, '');
console.log('Sum:', sum); // 31
console.log('Concatenated:', concatenated); // 'bananacherrydate'

// Comparable containers
const numContainer1 = new ComparableContainer(5);
const numContainer2 = new ComparableContainer(10);
const strContainer1 = new ComparableContainer('apple');
const strContainer2 = new ComparableContainer('banana');

console.log('5 compareTo 10:', numContainer1.compareTo(numContainer2)); // -1
console.log('apple compareTo banana:', strContainer1.compareTo(strContainer2)); // -1

// Array utilities
console.log('Reversed numbers:', ArrayUtils.reverse(numbers));
console.log('Unique numbers:', ArrayUtils.unique([1, 2, 2, 3, 3, 4]));
console.log('Shuffled numbers:', ArrayUtils.shuffle(numbers));
```

```java !! java
// Java - Generic methods and bounded types
import java.util.*;

// Generic utility class with bounded types
public class ArrayUtils {
    
    // Generic method with bounded type parameter
    public static <T extends Comparable<T>> T findMax(T[] array) {
        if (array.length == 0) {
            throw new IllegalArgumentException("Array is empty");
        }
        
        T max = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i].compareTo(max) > 0) {
                max = array[i];
            }
        }
        return max;
    }
    
    public static <T extends Comparable<T>> T findMin(T[] array) {
        if (array.length == 0) {
            throw new IllegalArgumentException("Array is empty");
        }
        
        T min = array[0];
        for (int i = 1; i < array.length; i++) {
            if (array[i].compareTo(min) < 0) {
                min = array[i];
            }
        }
        return min;
    }
    
    // Generic method with multiple bounds
    public static <T extends Comparable<T> & Cloneable> T[] sort(T[] array) {
        T[] result = array.clone();
        Arrays.sort(result);
        return result;
    }
    
    // Generic method with wildcard
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                result.add(item);
            }
        }
        return result;
    }
    
    public static <T, R> List<R> map(List<T> list, Function<T, R> function) {
        List<R> result = new ArrayList<>();
        for (T item : list) {
            result.add(function.apply(item));
        }
        return result;
    }
    
    public static <T> T reduce(List<T> list, BinaryOperator<T> operator, T initial) {
        T result = initial;
        for (T item : list) {
            result = operator.apply(result, item);
        }
        return result;
    }
    
    // Generic method with type bounds
    public static <T extends Number> double average(List<T> numbers) {
        if (numbers.isEmpty()) {
            throw new IllegalArgumentException("List is empty");
        }
        
        double sum = 0.0;
        for (T number : numbers) {
            sum += number.doubleValue();
        }
        return sum / numbers.size();
    }
    
    // Generic method with multiple type parameters
    public static <T, U> List<Pair<T, U>> zip(List<T> list1, List<U> list2) {
        List<Pair<T, U>> result = new ArrayList<>();
        int minSize = Math.min(list1.size(), list2.size());
        
        for (int i = 0; i < minSize; i++) {
            result.add(new Pair<>(list1.get(i), list2.get(i)));
        }
        return result;
    }
    
    // Generic method with wildcards
    public static void printList(List<?> list) {
        for (Object item : list) {
            System.out.print(item + " ");
        }
        System.out.println();
    }
    
    // Upper bounded wildcard
    public static double sumOfNumbers(List<? extends Number> numbers) {
        double sum = 0.0;
        for (Number number : numbers) {
            sum += number.doubleValue();
        }
        return sum;
    }
    
    // Lower bounded wildcard
    public static void addNumbers(List<? super Integer> numbers) {
        numbers.add(1);
        numbers.add(2);
        numbers.add(3);
    }
}

// Generic class with bounded type parameter
public class ComparableContainer<T extends Comparable<T>> {
    private T value;
    
    public ComparableContainer(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public void setValue(T newValue) {
        this.value = newValue;
    }
    
    public int compareTo(ComparableContainer<T> other) {
        return this.value.compareTo(other.value);
    }
    
    public boolean isGreaterThan(ComparableContainer<T> other) {
        return this.value.compareTo(other.value) > 0;
    }
    
    public boolean isLessThan(ComparableContainer<T> other) {
        return this.value.compareTo(other.value) < 0;
    }
    
    public boolean equals(ComparableContainer<T> other) {
        return this.value.compareTo(other.value) == 0;
    }
    
    @Override
    public String toString() {
        return "ComparableContainer{" + value + "}";
    }
}

// Generic class with multiple bounds
public class NumberContainer<T extends Number & Comparable<T>> {
    private T value;
    
    public NumberContainer(T value) {
        this.value = value;
    }
    
    public T getValue() {
        return value;
    }
    
    public void setValue(T newValue) {
        this.value = newValue;
    }
    
    public double getDoubleValue() {
        return value.doubleValue();
    }
    
    public int getIntValue() {
        return value.intValue();
    }
    
    public boolean isGreaterThan(NumberContainer<T> other) {
        return this.value.compareTo(other.value) > 0;
    }
    
    @Override
    public String toString() {
        return "NumberContainer{" + value + "}";
    }
}

// Generic method examples
public class GenericMethodDemo {
    
    // Simple generic method
    public static <T> void swap(T[] array, int i, int j) {
        T temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    
    // Generic method with bounds
    public static <T extends Comparable<T>> void sort(T[] array) {
        Arrays.sort(array);
    }
    
    // Generic method returning generic type
    public static <T> List<T> createList(T... elements) {
        List<T> list = new ArrayList<>();
        for (T element : elements) {
            list.add(element);
        }
        return list;
    }
    
    // Generic method with wildcards
    public static void processList(List<?> list) {
        for (Object item : list) {
            System.out.println(item);
        }
    }
    
    // Generic method with upper bounded wildcard
    public static double sum(List<? extends Number> numbers) {
        double sum = 0.0;
        for (Number number : numbers) {
            sum += number.doubleValue();
        }
        return sum;
    }
    
    // Generic method with lower bounded wildcard
    public static void addIntegers(List<? super Integer> list) {
        list.add(1);
        list.add(2);
        list.add(3);
    }
}

// Main class to demonstrate generic methods and bounded types
public class GenericMethodsDemo {
    public static void main(String[] args) {
        // Test generic methods with arrays
        Integer[] numbers = {3, 1, 4, 1, 5, 9, 2, 6};
        String[] strings = {"banana", "apple", "cherry", "date"};
        
        System.out.println("Max number: " + ArrayUtils.findMax(numbers)); // 9
        System.out.println("Min number: " + ArrayUtils.findMin(numbers)); // 1
        System.out.println("Max string: " + ArrayUtils.findMax(strings)); // "date"
        System.out.println("Min string: " + ArrayUtils.findMin(strings)); // "apple"
        
        // Test sorting
        Integer[] sortedNumbers = ArrayUtils.sort(numbers);
        System.out.println("Sorted numbers: " + Arrays.toString(sortedNumbers));
        
        // Test with lists
        List<Integer> numberList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<String> stringList = Arrays.asList("apple", "banana", "cherry", "date");
        
        // Filtering
        List<Integer> evenNumbers = ArrayUtils.filter(numberList, x -> x % 2 == 0);
        List<String> longStrings = ArrayUtils.filter(stringList, s -> s.length() > 5);
        System.out.println("Even numbers: " + evenNumbers);
        System.out.println("Long strings: " + longStrings);
        
        // Mapping
        List<Integer> doubledNumbers = ArrayUtils.map(numberList, x -> x * 2);
        List<String> upperStrings = ArrayUtils.map(stringList, String::toUpperCase);
        System.out.println("Doubled numbers: " + doubledNumbers);
        System.out.println("Upper strings: " + upperStrings);
        
        // Reducing
        Integer sum = ArrayUtils.reduce(numberList, Integer::sum, 0);
        System.out.println("Sum: " + sum);
        
        // Average
        double average = ArrayUtils.average(numberList);
        System.out.println("Average: " + average);
        
        // Zipping
        List<Pair<String, Integer>> zipped = ArrayUtils.zip(stringList, numberList.subList(0, 4));
        System.out.println("Zipped: " + zipped);
        
        // Comparable containers
        ComparableContainer<Integer> numContainer1 = new ComparableContainer<>(5);
        ComparableContainer<Integer> numContainer2 = new ComparableContainer<>(10);
        ComparableContainer<String> strContainer1 = new ComparableContainer<>("apple");
        ComparableContainer<String> strContainer2 = new ComparableContainer<>("banana");
        
        System.out.println("5 > 10: " + numContainer1.isGreaterThan(numContainer2)); // false
        System.out.println("apple < banana: " + strContainer1.isLessThan(strContainer2)); // true
        
        // Number containers
        NumberContainer<Integer> intContainer = new NumberContainer<>(42);
        NumberContainer<Double> doubleContainer = new NumberContainer<>(3.14);
        
        System.out.println("Int value: " + intContainer.getDoubleValue()); // 42.0
        System.out.println("Double value: " + doubleContainer.getIntValue()); // 3
        
        // Wildcard examples
        List<Integer> intList = new ArrayList<>();
        List<Number> numberList2 = new ArrayList<>();
        List<Object> objectList = new ArrayList<>();
        
        ArrayUtils.addNumbers(intList);
        ArrayUtils.addNumbers(numberList2);
        ArrayUtils.addNumbers(objectList);
        
        System.out.println("Int list: " + intList);
        System.out.println("Number list: " + numberList2);
        System.out.println("Object list: " + objectList);
        
        double sumOfNumbers = ArrayUtils.sumOfNumbers(Arrays.asList(1, 2, 3, 4, 5));
        System.out.println("Sum of numbers: " + sumOfNumbers);
    }
}
```
</UniversalEditor>

## Exercises

### Exercise 1: Generic Classes

<UniversalEditor title="Exercise 1: Generic Classes">
```java !! java
// TODO: Implement generic classes
public class Box<T> {
    // TODO: Add private field for storing value
    
    // TODO: Implement constructor
    
    // TODO: Add getter and setter methods
    
    // TODO: Add method to check if box is empty
    
    // TODO: Override toString method
}

public class Triple<T, U, V> {
    // TODO: Add private fields for three values
    
    // TODO: Implement constructor
    
    // TODO: Add getter and setter methods
    
    // TODO: Add method to rotate values (T->U->V->T)
    
    // TODO: Override toString method
}

public class GenericStack<T> {
    // TODO: Add private field for storing elements
    
    // TODO: Implement constructor
    
    // TODO: Add push, pop, peek methods
    
    // TODO: Add isEmpty, size, clear methods
    
    // TODO: Add method to search for element
}

public class GenericExercise1 {
    public static void main(String[] args) {
        // Test your implementations
        Box<String> stringBox = new Box<>("Hello");
        Box<Integer> intBox = new Box<>(42);
        
        System.out.println("String box: " + stringBox);
        System.out.println("Int box: " + intBox);
        System.out.println("String box empty: " + stringBox.isEmpty());
        
        Triple<String, Integer, Boolean> triple = new Triple<>("Hello", 42, true);
        System.out.println("Triple: " + triple);
        triple.rotate();
        System.out.println("After rotation: " + triple);
        
        GenericStack<String> stack = new GenericStack<>();
        stack.push("First");
        stack.push("Second");
        stack.push("Third");
        
        System.out.println("Stack size: " + stack.size());
        System.out.println("Top element: " + stack.peek());
        System.out.println("Popped: " + stack.pop());
        System.out.println("Search 'Second': " + stack.search("Second"));
    }
}
```
</UniversalEditor>

### Exercise 2: Generic Methods and Bounded Types

<UniversalEditor title="Exercise 2: Generic Methods and Bounded Types">
```java !! java
// TODO: Implement generic methods and bounded types
public class GenericUtils {
    // TODO: Add generic method to find maximum element in array (bounded by Comparable)
    
    // TODO: Add generic method to count occurrences of element in list
    
    // TODO: Add generic method to reverse array
    
    // TODO: Add generic method to check if array is sorted (bounded by Comparable)
    
    // TODO: Add generic method to find common elements between two lists
    
    // TODO: Add generic method to convert list to array
}

public class NumberUtils {
    // TODO: Add generic method to calculate sum of numbers (bounded by Number)
    
    // TODO: Add generic method to find average of numbers (bounded by Number)
    
    // TODO: Add generic method to find minimum and maximum (bounded by Comparable & Number)
    
    // TODO: Add generic method to sort numbers (bounded by Comparable & Number)
}

public class GenericExercise2 {
    public static void main(String[] args) {
        // Test your implementations
        Integer[] numbers = {3, 1, 4, 1, 5, 9, 2, 6};
        String[] strings = {"banana", "apple", "cherry", "date"};
        
        System.out.println("Max number: " + GenericUtils.findMax(numbers));
        System.out.println("Max string: " + GenericUtils.findMax(strings));
        
        List<Integer> numberList = Arrays.asList(1, 2, 2, 3, 3, 4);
        System.out.println("Count of 2: " + GenericUtils.countOccurrences(numberList, 2));
        
        GenericUtils.reverse(numbers);
        System.out.println("Reversed numbers: " + Arrays.toString(numbers));
        
        System.out.println("Is sorted: " + GenericUtils.isSorted(strings));
        
        List<String> list1 = Arrays.asList("apple", "banana", "cherry");
        List<String> list2 = Arrays.asList("banana", "date", "apple");
        System.out.println("Common elements: " + GenericUtils.findCommonElements(list1, list2));
        
        // Number utilities
        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);
        List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3, 4.4, 5.5);
        
        System.out.println("Sum of integers: " + NumberUtils.sum(intList));
        System.out.println("Average of doubles: " + NumberUtils.average(doubleList));
        
        Pair<Double, Double> minMax = NumberUtils.findMinMax(doubleList);
        System.out.println("Min: " + minMax.getFirst() + ", Max: " + minMax.getSecond());
        
        List<Double> sortedDoubles = NumberUtils.sort(doubleList);
        System.out.println("Sorted doubles: " + sortedDoubles);
    }
}
```
</UniversalEditor>

## Summary

In this module, we explored Java's generic system and compared it with JavaScript's type handling approaches:

### Key Points:
1. **Type Safety**: Java generics provide compile-time type safety
2. **Type Parameters**: Generic classes and methods use type parameters
3. **Bounded Types**: Type constraints ensure specific capabilities
4. **Wildcards**: Upper and lower bounded wildcards for flexibility
5. **Type Erasure**: Generics are erased at runtime

### Next Steps:
- Practice implementing generic classes and methods
- Master bounded types and wildcards
- Explore generic collections and data structures
- Prepare for the next module on collections framework

## Additional Resources

- [Java Generics](https://docs.oracle.com/javase/tutorial/java/generics/)
- [Java Generic Methods](https://docs.oracle.com/javase/tutorial/java/generics/methods.html)
- [Java Wildcards](https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html)

---

**Exercise Tips**: Focus on understanding type safety and how generics prevent runtime errors. Practice using bounded types to ensure objects have required capabilities. Use wildcards when you need flexibility in type parameters. 