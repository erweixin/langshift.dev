---
title: "模組 02: 類型和變數"
description: "學習 Java 的類型系統、基本類型、參考類型、類型轉換和變數作用域，與 JavaScript 進行對比。"
---

# 模組 02: 類型和變數

在本模組中，我們將深入探討 Java 的類型系統和變數管理。理解 Java 的強類型系統對於 JavaScript 開發者來說至關重要，因為它代表了兩種語言之間最顯著的差異之一。

## 學習目標

通過本模組的學習，你將能夠：
- 理解 Java 的基本類型和參考類型
- 比較 Java 的類型系統與 JavaScript 的動態類型
- 掌握 Java 中的類型轉換和強制轉換
- 理解 Java 中變數的作用域和生命週期
- 應用變數宣告和使用的最佳實踐

## Java 類型系統概述

### 1. 基本類型 vs 參考類型

Java 有兩種類型類別：基本類型和參考類型。這與 JavaScript 的統一類型系統根本不同。

<UniversalEditor title="類型系統對比" compare={true}>
```javascript !! js
// JavaScript - 統一類型系統
let number = 42;           // Number 類型
let text = "Hello";        // String 類型
let boolean = true;        // Boolean 類型
let array = [1, 2, 3];     // Object 類型（陣列）
let object = {name: "John"}; // Object 類型
let nothing = null;        // Object 類型（null）
let undefined = undefined; // Undefined 類型

// 所有類型都可以用 typeof 檢查
console.log(typeof number);    // "number"
console.log(typeof text);      // "string"
console.log(typeof boolean);   // "boolean"
console.log(typeof array);     // "object"
console.log(typeof object);    // "object"
console.log(typeof nothing);   // "object"
console.log(typeof undefined); // "undefined"
```

```java !! java
// Java - 兩種類型系統
public class TypeSystem {
    public static void main(String[] args) {
        // 基本類型
        byte byteNum = 127;           // 8位整數
        short shortNum = 32767;       // 16位整數
        int intNum = 2147483647;      // 32位整數
        long longNum = 9223372036854775807L; // 64位整數
        
        float floatNum = 3.14f;       // 32位浮點數
        double doubleNum = 3.14159;   // 64位浮點數
        
        char charVal = 'A';           // 16位 Unicode 字元
        boolean boolVal = true;       // true 或 false
        
        // 參考類型
        String text = "Hello";        // String 類
        int[] array = {1, 2, 3};      // 陣列
        Object object = new Object(); // Object 類
        
        // 類型檢查
        System.out.println("intNum 是基本類型: " + int.class.isPrimitive());
        System.out.println("text 是基本類型: " + String.class.isPrimitive());
    }
}
```
</UniversalEditor>

### 2. 基本類型詳解

Java 有 8 種基本類型，每種都有特定的記憶體要求和值範圍。

<UniversalEditor title="基本類型詳情" compare={true}>
```javascript !! js
// JavaScript - Number 類型處理所有數值
let smallInt = 42;
let bigInt = 9007199254740991; // Number.MAX_SAFE_INTEGER
let decimal = 3.14159;
let negative = -42;
let zero = 0;

// JavaScript 數字總是 64 位浮點數
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991
console.log(Number.MAX_VALUE);        // 1.7976931348623157e+308
console.log(Number.MIN_VALUE);        // 5e-324

// 類型檢查
console.log(typeof smallInt);  // "number"
console.log(typeof bigInt);    // "number"
console.log(typeof decimal);   // "number"
```

```java !! java
// Java - 8 種基本類型，每種都有特定範圍
public class PrimitiveTypes {
    public static void main(String[] args) {
        // 整數類型
        byte byteVal = 127;                    // -128 到 127
        short shortVal = 32767;                // -32,768 到 32,767
        int intVal = 2147483647;               // -2^31 到 2^31-1
        long longVal = 9223372036854775807L;   // -2^63 到 2^63-1
        
        // 浮點類型
        float floatVal = 3.14f;                // 32位 IEEE 754
        double doubleVal = 3.14159265359;      // 64位 IEEE 754
        
        // 字元類型
        char charVal = 'A';                    // 16位 Unicode
        
        // 布林類型
        boolean boolVal = true;                // true 或 false
        
        // 顯示範圍
        System.out.println("Byte 範圍: " + Byte.MIN_VALUE + " 到 " + Byte.MAX_VALUE);
        System.out.println("Short 範圍: " + Short.MIN_VALUE + " 到 " + Short.MAX_VALUE);
        System.out.println("Int 範圍: " + Integer.MIN_VALUE + " 到 " + Integer.MAX_VALUE);
        System.out.println("Long 範圍: " + Long.MIN_VALUE + " 到 " + Long.MAX_VALUE);
        System.out.println("Float 範圍: " + Float.MIN_VALUE + " 到 " + Float.MAX_VALUE);
        System.out.println("Double 範圍: " + Double.MIN_VALUE + " 到 " + Double.MAX_VALUE);
    }
}
```
</UniversalEditor>

### 3. 參考類型

Java 中的參考類型包括類、介面、陣列和列舉。它們總是通過參考存取。

<UniversalEditor title="參考類型" compare={true}>
```javascript !! js
// JavaScript - 物件和陣列是參考類型
let person = {
    name: "John",
    age: 30
};

let numbers = [1, 2, 3, 4, 5];
let greeting = "Hello World";

// 函數也是物件
function greet(name) {
    return "Hello, " + name;
}

// 參考行為
let personCopy = person;  // 兩者參考同一個物件
personCopy.age = 31;     // 改變原始物件
console.log(person.age); // 31

let numbersCopy = [...numbers]; // 建立新陣列
numbersCopy.push(6);     // 不影響原始陣列
console.log(numbers.length); // 5
```

```java !! java
// Java - 參考類型包括類、介面、陣列
public class ReferenceTypes {
    public static void main(String[] args) {
        // String（不可變參考類型）
        String greeting = "Hello World";
        
        // 陣列
        int[] numbers = {1, 2, 3, 4, 5};
        
        // 自訂類
        Person person = new Person("John", 30);
        
        // 參考行為
        Person personCopy = person;  // 兩者參考同一個物件
        personCopy.setAge(31);       // 改變原始物件
        System.out.println(person.getAge()); // 31
        
        // 陣列複製（淺複製）
        int[] numbersCopy = numbers.clone(); // 建立新陣列
        numbersCopy[0] = 10;         // 不影響原始陣列
        System.out.println(numbers[0]); // 1
    }
}

class Person {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    public int getAge() {
        return age;
    }
}
```
</UniversalEditor>

## 類型轉換和強制轉換

### 1. 隱式轉換（擴展）

Java 允許從小類型到大類型的自動轉換。

<UniversalEditor title="隱式類型轉換" compare={true}>
```javascript !! js
// JavaScript - 自動類型強制轉換
let smallNumber = 42;
let bigNumber = 3.14159;

// 操作中的自動轉換
let result1 = smallNumber + bigNumber;  // 45.14159
let result2 = "5" + 3;                  // "53"（字串連接）
let result3 = "5" - 3;                  // 2（數值減法）
let result4 = true + 1;                 // 2（true 變為 1）

console.log(result1, typeof result1);   // 45.14159 "number"
console.log(result2, typeof result2);   // "53" "string"
console.log(result3, typeof result3);   // 2 "number"
console.log(result4, typeof result4);   // 2 "number"
```

```java !! java
// Java - 隱式擴展轉換
public class TypeConversion {
    public static void main(String[] args) {
        // 隱式擴展（自動）
        byte byteVal = 100;
        short shortVal = byteVal;      // byte -> short
        int intVal = shortVal;         // short -> int
        long longVal = intVal;         // int -> long
        float floatVal = longVal;      // long -> float
        double doubleVal = floatVal;   // float -> double
        
        // char 可以轉換為 int
        char charVal = 'A';
        int charAsInt = charVal;       // char -> int (65)
        
        System.out.println("byte -> short: " + shortVal);
        System.out.println("short -> int: " + intVal);
        System.out.println("int -> long: " + longVal);
        System.out.println("long -> float: " + floatVal);
        System.out.println("float -> double: " + doubleVal);
        System.out.println("char -> int: " + charAsInt);
        
        // 沒有從大類型到小類型的隱式轉換
        // int intValue = 1000;
        // byte byteValue = intValue;  // 編譯錯誤！
    }
}
```
</UniversalEditor>

### 2. 顯式強制轉換（收縮）

Java 在從大類型轉換到小類型時需要顯式強制轉換。

<UniversalEditor title="顯式類型強制轉換" compare={true}>
```javascript !! js
// JavaScript - 各種類型轉換方式
let number = 3.14159;
let string = "42";

// 轉換為整數
let intValue1 = parseInt(string);      // 42
let intValue2 = Math.floor(number);    // 3
let intValue3 = ~~number;              // 3（按位非）

// 轉換為浮點數
let floatValue = parseFloat(string);   // 42.0

// 轉換為字串
let stringValue = number.toString();   // "3.14159"
let stringValue2 = String(number);     // "3.14159"

// 轉換為布林值
let boolValue = Boolean(number);       // true
let boolValue2 = !!number;             // true

console.log(intValue1, typeof intValue1);   // 42 "number"
console.log(floatValue, typeof floatValue); // 42 "number"
console.log(stringValue, typeof stringValue); // "3.14159" "string"
console.log(boolValue, typeof boolValue);   // true "boolean"
```

```java !! java
// Java - 收縮需要顯式強制轉換
public class TypeCasting {
    public static void main(String[] args) {
        // 顯式強制轉換（收縮）
        double doubleVal = 3.14159;
        float floatVal = (float) doubleVal;   // double -> float
        long longVal = (long) floatVal;       // float -> long
        int intVal = (int) longVal;           // long -> int
        short shortVal = (short) intVal;      // int -> short
        byte byteVal = (byte) shortVal;       // short -> byte
        char charVal = (char) intVal;         // int -> char
        
        System.out.println("原始 double: " + doubleVal);
        System.out.println("強制轉換為 float: " + floatVal);
        System.out.println("強制轉換為 long: " + longVal);
        System.out.println("強制轉換為 int: " + intVal);
        System.out.println("強制轉換為 short: " + shortVal);
        System.out.println("強制轉換為 byte: " + byteVal);
        System.out.println("強制轉換為 char: " + charVal);
        
        // 潛在的資料遺失
        int largeInt = 1000000;
        byte smallByte = (byte) largeInt;  // 資料遺失！
        System.out.println("大整數: " + largeInt);
        System.out.println("強制轉換為 byte: " + smallByte);
        
        // 字串到數字轉換
        String numberString = "42";
        int parsedInt = Integer.parseInt(numberString);
        double parsedDouble = Double.parseDouble("3.14");
        
        System.out.println("解析的 int: " + parsedInt);
        System.out.println("解析的 double: " + parsedDouble);
    }
}
```
</UniversalEditor>

## 變數宣告和初始化

### 1. 變數宣告風格

<UniversalEditor title="變數宣告風格" compare={true}>
```javascript !! js
// JavaScript - 多種宣告風格
// var（函數作用域，提升）
var oldStyle = "deprecated";

// let（塊作用域，不提升）
let modernStyle = "recommended";
let uninitialized;  // undefined

// const（塊作用域，不可變參考）
const constant = "cannot be reassigned";
const object = {name: "John"};  // 物件可以被修改
object.name = "Jane";  // 這樣可以

// 多重宣告
let a = 1, b = 2, c = 3;
const [x, y, z] = [1, 2, 3];  // 解構

// 類型推斷
let number = 42;        // number
let string = "hello";   // string
let boolean = true;     // boolean
let array = [1, 2, 3];  // object
let func = () => {};    // function
```

```java !! java
// Java - 需要顯式類型宣告
public class VariableDeclaration {
    public static void main(String[] args) {
        // 帶初始化的單個宣告
        int number = 42;
        String text = "Hello";
        boolean flag = true;
        
        // 不帶初始化的宣告
        int uninitialized;  // 使用前必須初始化
        // System.out.println(uninitialized);  // 編譯錯誤！
        
        // 多重宣告
        int a = 1, b = 2, c = 3;
        
        // Final（不可變）變數
        final int constant = 100;
        final String immutable = "cannot change";
        // constant = 200;  // 編譯錯誤！
        
        // 區域變數類型推斷（Java 10+）
        var inferredInt = 42;           // int
        var inferredString = "Hello";   // String
        var inferredArray = new int[]{1, 2, 3}; // int[]
        
        // 類型必須從上下文明顯
        // var ambiguous;  // 編譯錯誤！
        
        System.out.println("推斷的 int: " + inferredInt);
        System.out.println("推斷的 string: " + inferredString);
    }
}
```
</UniversalEditor>

### 2. 變數作用域和生命週期

<UniversalEditor title="變數作用域和生命週期" compare={true}>
```javascript !! js
// JavaScript - 函數作用域和塊作用域
let globalVar = "I'm global";

function outerFunction() {
    let outerVar = "I'm in outer function";
    
    function innerFunction() {
        let innerVar = "I'm in inner function";
        console.log(globalVar);    // 可存取
        console.log(outerVar);     // 可存取
        console.log(innerVar);     // 可存取
    }
    
    innerFunction();
    // console.log(innerVar);  // 錯誤 - 不可存取
}

// 塊作用域與 let/const
if (true) {
    let blockVar = "I'm in block";
    console.log(blockVar);  // 可存取
}
// console.log(blockVar);  // 錯誤 - 不可存取

// var 的提升
console.log(hoistedVar);  // undefined（不是錯誤）
var hoistedVar = "I'm hoisted";

// let 的暫時性死區
// console.log(tdzVar);  // 錯誤 - 宣告前無法存取
let tdzVar = "I'm in TDZ";
```

```java !! java
// Java - 塊作用域和生命週期
public class VariableScope {
    // 類級變數（欄位）
    private static String classVariable = "I'm a class variable";
    private String instanceVariable = "I'm an instance variable";
    
    public void method1() {
        // 方法級變數
        String methodVar = "I'm in method1";
        
        if (true) {
            // 塊級變數
            String blockVar = "I'm in block";
            System.out.println(methodVar);  // 可存取
            System.out.println(blockVar);   // 可存取
        }
        
        // System.out.println(blockVar);  // 編譯錯誤！
        System.out.println(methodVar);      // 可存取
    }
    
    public void method2() {
        // System.out.println(methodVar);  // 編譯錯誤！
        System.out.println(classVariable);  // 可存取
        System.out.println(instanceVariable); // 可存取
    }
    
    public static void main(String[] args) {
        VariableScope obj = new VariableScope();
        obj.method1();
        obj.method2();
        
        // 區域變數在使用前必須初始化
        int localVar;
        // System.out.println(localVar);  // 編譯錯誤！
        localVar = 42;
        System.out.println(localVar);  // 可以
    }
}
```
</UniversalEditor>

## 最佳實踐和常見陷阱

### 1. 類型安全最佳實踐

<UniversalEditor title="類型安全最佳實踐" compare={true}>
```javascript !! js
// JavaScript - 類型檢查和驗證
function processUser(user) {
    // 執行時類型檢查
    if (typeof user !== 'object' || user === null) {
        throw new Error('User must be an object');
    }
    
    if (typeof user.name !== 'string') {
        throw new Error('User name must be a string');
    }
    
    if (typeof user.age !== 'number' || user.age < 0) {
        throw new Error('User age must be a positive number');
    }
    
    return `Hello, ${user.name}! You are ${user.age} years old.`;
}

// 使用預設值
function greet(name = 'Guest') {
    return `Hello, ${name}!`;
}

// 空值合併（ES2020）
const value = null;
const result = value ?? 'default';  // 'default'

// 可選鏈（ES2020）
const user = { profile: { name: 'John' } };
const userName = user?.profile?.name;  // 'John'
const missingName = user?.profile?.missing;  // undefined
```

```java !! java
// Java - 編譯時類型安全
public class TypeSafety {
    public static String processUser(User user) {
        // 編譯時類型檢查
        if (user == null) {
            throw new IllegalArgumentException("User cannot be null");
        }
        
        if (user.getName() == null || user.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("User name cannot be null or empty");
        }
        
        if (user.getAge() < 0) {
            throw new IllegalArgumentException("User age cannot be negative");
        }
        
        return String.format("Hello, %s! You are %d years old.", 
                           user.getName(), user.getAge());
    }
    
    // 方法重載實現類型安全
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double add(double a, double b) {
        return a + b;
    }
    
    // 使用 Optional 處理可空值（Java 8+）
    public static String getDisplayName(Optional<String> name) {
        return name.orElse("Guest");
    }
    
    public static void main(String[] args) {
        User user = new User("John", 30);
        System.out.println(processUser(user));
        
        // 類型安全的方法呼叫
        System.out.println(add(5, 3));      // 8
        System.out.println(add(5.5, 3.2));  // 8.7
        
        // Optional 使用
        Optional<String> name = Optional.of("John");
        System.out.println(getDisplayName(name));  // John
        
        Optional<String> emptyName = Optional.empty();
        System.out.println(getDisplayName(emptyName));  // Guest
    }
}

class User {
    private String name;
    private int age;
    
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
}
```
</UniversalEditor>

### 2. 常見類型相關陷阱

<UniversalEditor title="常見類型陷阱" compare={true}>
```javascript !! js
// JavaScript - 常見類型相關問題
// 1. 寬鬆相等比較
console.log(0 == false);    // true
console.log(1 == true);     // true
console.log("" == false);   // true
console.log(null == undefined); // true

// 2. 算術運算中的類型強制轉換
console.log("5" + 3);       // "53"（字串連接）
console.log("5" - 3);       // 2（數值減法）
console.log("5" * 3);       // 15（數值乘法）

// 3. NaN 比較
console.log(NaN == NaN);    // false
console.log(NaN === NaN);   // false
console.log(isNaN(NaN));    // true

// 4. 類陣列物件
let arrayLike = {0: "a", 1: "b", length: 2};
console.log(arrayLike[0]);  // "a"
// arrayLike.push("c");     // 錯誤 - 不是陣列

// 5. Undefined vs null
let undefinedVar;
console.log(undefinedVar);  // undefined
console.log(typeof undefinedVar); // "undefined"
```

```java !! java
// Java - 常見類型相關問題
public class TypePitfalls {
    public static void main(String[] args) {
        // 1. 整數除法
        int a = 5;
        int b = 2;
        double result = a / b;  // 2.0，不是 2.5！
        System.out.println("整數除法: " + result);
        
        // 正確方式
        double correctResult = (double) a / b;  // 2.5
        System.out.println("正確除法: " + correctResult);
        
        // 2. 溢位
        int maxInt = Integer.MAX_VALUE;
        System.out.println("最大 int: " + maxInt);
        maxInt++;  // 溢位！
        System.out.println("遞增後: " + maxInt);
        
        // 3. 浮點精度
        double d1 = 0.1;
        double d2 = 0.2;
        double sum = d1 + d2;
        System.out.println("浮點求和: " + sum);  // 0.30000000000000004
        
        // 使用 BigDecimal 進行精確算術
        java.math.BigDecimal bd1 = new java.math.BigDecimal("0.1");
        java.math.BigDecimal bd2 = new java.math.BigDecimal("0.2");
        java.math.BigDecimal preciseSum = bd1.add(bd2);
        System.out.println("精確求和: " + preciseSum);  // 0.3
        
        // 4. 字串比較
        String s1 = "Hello";
        String s2 = new String("Hello");
        System.out.println(s1 == s2);        // false（參考比較）
        System.out.println(s1.equals(s2));   // true（內容比較）
        
        // 5. 空指標異常
        String nullString = null;
        // System.out.println(nullString.length());  // NullPointerException
        
        // 安全的空值檢查
        if (nullString != null) {
            System.out.println(nullString.length());
        }
    }
}
```
</UniversalEditor>

## 練習題目

### 練習 1: 類型轉換練習

<UniversalEditor title="練習 1: 類型轉換">
```java !! java
// TODO: 完成以下類型轉換練習
public class TypeConversionExercise {
    public static void main(String[] args) {
        // 1. 將 double 轉換為 int（截斷小數部分）
        double price = 19.99;
        // 你的程式碼在這裡
        
        // 2. 將 String 轉換為 int（處理潛在的 NumberFormatException）
        String numberString = "42";
        // 你的程式碼在這裡
        
        // 3. 將 int 轉換為 String
        int count = 100;
        // 你的程式碼在這裡
        
        // 4. 將 char 轉換為其 ASCII 值
        char letter = 'A';
        // 你的程式碼在這裡
        
        // 5. 將 ASCII 值轉換為 char
        int asciiValue = 65;
        // 你的程式碼在這裡
        
        // 列印所有結果
        System.out.println("價格作為 int: " + priceAsInt);
        System.out.println("字串作為 int: " + stringAsInt);
        System.out.println("計數作為字串: " + countAsString);
        System.out.println("字母 ASCII: " + letterAscii);
        System.out.println("ASCII 作為 char: " + asciiAsChar);
    }
}
```
</UniversalEditor>

### 練習 2: 變數作用域和生命週期

<UniversalEditor title="練習 2: 變數作用域">
```java !! java
// TODO: 修復此程式碼中的作用域問題
public class ScopeExercise {
    private static int classVariable = 10;
    
    public static void main(String[] args) {
        int localVar = 20;
        
        if (true) {
            int blockVar = 30;
            System.out.println("塊變數: " + blockVar);
            System.out.println("區域變數: " + localVar);
            System.out.println("類變數: " + classVariable);
        }
        
        // 修復這些行使其工作
        System.out.println("塊外變數: " + blockVar);  // 錯誤
        System.out.println("區域變數: " + localVar);          // 應該工作
        System.out.println("類變數: " + classVariable);     // 應該工作
    }
    
    public static void anotherMethod() {
        // 這裡可以存取哪些變數？
        System.out.println("類變數: " + classVariable);     // 應該工作
        // System.out.println("區域變數: " + localVar);       // 錯誤
    }
}
```
</UniversalEditor>

## 總結

在本模組中，我們探討了 Java 的全面類型系統和變數管理：

### 關鍵要點：
1. **雙類型系統**: Java 有基本類型（8 種）和參考類型（類、介面、陣列）
2. **靜態類型**: 所有變數必須在編譯時聲明顯式類型
3. **類型轉換**: 隱式擴展是自動的，收縮需要顯式強制轉換
4. **變數作用域**: 塊作用域變數，具有清晰的生命週期管理
5. **類型安全**: 編譯時檢查防止許多執行時錯誤

### 下一步：
- 練習不同的基本類型及其範圍
- 掌握類型轉換和強制轉換技術
- 理解不同上下文中變數的作用域和生命週期
- 為下一個關於控制流和迴圈的模組做準備

## 額外資源

- [Java 基本資料類型](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html)
- [Java 類型轉換](https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html)
- [Java 變數作用域](https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html)

---

**練習提示**: 建立演示每種基本類型的小程式，並練習類型轉換。理解每種類型的記憶體要求和值範圍將幫助你為變數選擇最合適的類型。 