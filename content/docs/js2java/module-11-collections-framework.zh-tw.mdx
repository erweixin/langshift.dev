---
title: "模組 11：集合框架"
description: "學習 Java 集合框架、List、Set、Map 介面及其實作，對比 JavaScript 陣列和物件集合。"
---

# 模組 11：集合框架

在本模組中，我們將探索 Java 的綜合集合框架，並與 JavaScript 基於陣列和物件的集合進行對比。我們將學習 List、Set 和 Map 介面、它們的實作以及如何有效使用它們。

## 學習目標

在本模組結束時，你將能夠：
- 理解 Java 集合框架層次結構
- 對比 Java 集合與 JavaScript 陣列和物件
- 有效使用 List、Set 和 Map 介面
- 選擇合適的集合實作
- 在實際場景中應用集合
- 理解集合的效能特徵

## 集合框架概述

### 1. List 介面和實作

Java 透過 List 介面提供有序集合，而 JavaScript 使用陣列實現類似功能。

<UniversalEditor title="List 介面和實作" compare={true}>
```javascript !! js
// JavaScript - 基於陣列的集合
// 陣列作為 List 等價物
class ArrayList {
    constructor() {
        this.items = [];
    }
    
    add(item) {
        this.items.push(item);
    }
    
    addAt(index, item) {
        this.items.splice(index, 0, item);
    }
    
    get(index) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('索引越界');
        }
        return this.items[index];
    }
    
    set(index, item) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('索引越界');
        }
        this.items[index] = item;
    }
    
    remove(index) {
        if (index < 0 || index >= this.items.length) {
            throw new Error('索引越界');
        }
        return this.items.splice(index, 1)[0];
    }
    
    removeItem(item) {
        const index = this.items.indexOf(item);
        if (index !== -1) {
            return this.remove(index);
        }
        return null;
    }
    
    size() {
        return this.items.length;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    contains(item) {
        return this.items.includes(item);
    }
    
    indexOf(item) {
        return this.items.indexOf(item);
    }
    
    clear() {
        this.items = [];
    }
    
    toArray() {
        return [...this.items];
    }
    
    toString() {
        return `[${this.items.join(', ')}]`;
    }
}

// 鏈結列表實作（模擬 LinkedList）
class ListNode {
    constructor(data) {
        this.data = data;
        this.next = null;
        this.prev = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
    }
    
    add(item) {
        const newNode = new ListNode(item);
        
        if (!this.head) {
            this.head = this.tail = newNode;
        } else {
            newNode.prev = this.tail;
            this.tail.next = newNode;
            this.tail = newNode;
        }
        this.length++;
    }
    
    addAt(index, item) {
        if (index < 0 || index > this.length) {
            throw new Error('索引越界');
        }
        
        if (index === this.length) {
            this.add(item);
            return;
        }
        
        const newNode = new ListNode(item);
        const current = this.getNodeAt(index);
        
        newNode.next = current;
        newNode.prev = current.prev;
        
        if (current.prev) {
            current.prev.next = newNode;
        } else {
            this.head = newNode;
        }
        
        current.prev = newNode;
        this.length++;
    }
    
    get(index) {
        const node = this.getNodeAt(index);
        return node.data;
    }
    
    getNodeAt(index) {
        if (index < 0 || index >= this.length) {
            throw new Error('索引越界');
        }
        
        let current;
        if (index < this.length / 2) {
            current = this.head;
            for (let i = 0; i < index; i++) {
                current = current.next;
            }
        } else {
            current = this.tail;
            for (let i = this.length - 1; i > index; i--) {
                current = current.prev;
            }
        }
        return current;
    }
    
    remove(index) {
        const node = this.getNodeAt(index);
        
        if (node.prev) {
            node.prev.next = node.next;
        } else {
            this.head = node.next;
        }
        
        if (node.next) {
            node.next.prev = node.prev;
        } else {
            this.tail = node.prev;
        }
        
        this.length--;
        return node.data;
    }
    
    size() {
        return this.length;
    }
    
    isEmpty() {
        return this.length === 0;
    }
    
    clear() {
        this.head = this.tail = null;
        this.length = 0;
    }
    
    toArray() {
        const result = [];
        let current = this.head;
        while (current) {
            result.push(current.data);
            current = current.next;
        }
        return result;
    }
    
    toString() {
        return `[${this.toArray().join(', ')}]`;
    }
}

// 使用範例
const arrayList = new ArrayList();
arrayList.add("Apple");
arrayList.add("Banana");
arrayList.add("Cherry");

console.log("ArrayList:", arrayList.toString());
console.log("元素索引 1:", arrayList.get(1)); // "Banana"
console.log("包含 Apple:", arrayList.contains("Apple")); // true

const linkedList = new LinkedList();
linkedList.add("First");
linkedList.add("Second");
linkedList.add("Third");

console.log("LinkedList:", linkedList.toString());
console.log("大小:", linkedList.size()); // 3

// 陣列方法對比
const numbers = [1, 2, 3, 4, 5];

// 新增元素
numbers.push(6); // 末尾新增
numbers.unshift(0); // 開頭新增
numbers.splice(3, 0, 2.5); // 在索引 3 插入

// 刪除元素
numbers.pop(); // 刪除末尾
numbers.shift(); // 刪除開頭
numbers.splice(2, 1); // 刪除索引 2

// 尋找元素
const index = numbers.indexOf(3);
const found = numbers.find(x => x > 2);
const exists = numbers.includes(4);

// 轉換操作
const doubled = numbers.map(x => x * 2);
const filtered = numbers.filter(x => x % 2 === 0);
const sum = numbers.reduce((acc, x) => acc + x, 0);

console.log("原始陣列:", numbers);
console.log("翻倍:", doubled);
console.log("偶數:", filtered);
console.log("總和:", sum);
```

```java !! java
// Java - List 介面和實作
import java.util.*;

public class ListDemo {
    public static void main(String[] args) {
        // ArrayList - 動態陣列實作
        List<String> arrayList = new ArrayList<>();
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add("Cherry");
        
        System.out.println("ArrayList: " + arrayList);
        System.out.println("元素索引 1: " + arrayList.get(1)); // "Banana"
        System.out.println("包含 Apple: " + arrayList.contains("Apple")); // true
        
        // 在指定位置插入
        arrayList.add(1, "Avocado");
        System.out.println("插入後: " + arrayList);
        
        // 刪除元素
        arrayList.remove("Banana");
        arrayList.remove(0); // 刪除索引 0
        System.out.println("刪除後: " + arrayList);
        
        // LinkedList - 雙向鏈結列表實作
        List<String> linkedList = new LinkedList<>();
        linkedList.add("First");
        linkedList.add("Second");
        linkedList.add("Third");
        
        System.out.println("LinkedList: " + linkedList);
        System.out.println("大小: " + linkedList.size()); // 3
        
        // LinkedList 特有方法
        LinkedList<String> ll = (LinkedList<String>) linkedList;
        ll.addFirst("Zero");
        ll.addLast("Fourth");
        System.out.println("新增首尾後: " + ll);
        
        String first = ll.removeFirst();
        String last = ll.removeLast();
        System.out.println("刪除首尾: " + first + ", " + last);
        System.out.println("最終: " + ll);
        
        // Vector - 同步的 ArrayList
        List<Integer> vector = new Vector<>();
        vector.add(1);
        vector.add(2);
        vector.add(3);
        
        System.out.println("Vector: " + vector);
        
        // 列表操作範例
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        
        // 新增元素
        numbers.add(6); // 末尾新增
        numbers.add(0, 0); // 開頭新增
        numbers.add(3, 2); // 在索引 3 插入
        
        // 刪除元素
        numbers.remove(numbers.size() - 1); // 刪除末尾
        numbers.remove(0); // 刪除開頭
        numbers.remove(Integer.valueOf(3)); // 刪除值為 3 的元素
        
        // 尋找元素
        int index = numbers.indexOf(4);
        boolean exists = numbers.contains(5);
        
        System.out.println("處理後的數字列表: " + numbers);
        System.out.println("4 的索引: " + index);
        System.out.println("包含 5: " + exists);
        
        // 使用 Stream API 進行函數式操作
        List<Integer> originalNumbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // 轉換操作
        List<Integer> doubled = originalNumbers.stream()
                .map(x -> x * 2)
                .collect(Collectors.toList());
        
        List<Integer> filtered = originalNumbers.stream()
                .filter(x -> x % 2 == 0)
                .collect(Collectors.toList());
        
        int sum = originalNumbers.stream()
                .mapToInt(Integer::intValue)
                .sum();
        
        System.out.println("原始列表: " + originalNumbers);
        System.out.println("翻倍: " + doubled);
        System.out.println("偶數: " + filtered);
        System.out.println("總和: " + sum);
        
        // 列表效能比較
        System.out.println("\n效能特徵:");
        System.out.println("ArrayList - 隨機存取: O(1), 插入/刪除: O(n)");
        System.out.println("LinkedList - 隨機存取: O(n), 插入/刪除: O(1)");
        System.out.println("Vector - 與 ArrayList 類似，但執行緒安全");
    }
}
```
</UniversalEditor>

### 2. Set 介面和實作

Java 的 Set 介面確保唯一性，而 JavaScript 使用 Set 物件或物件屬性實現類似功能。

<UniversalEditor title="Set 介面和實作" compare={true}>
```javascript !! js
// JavaScript - Set 和唯一性集合
// 原生 Set
const nativeSet = new Set();
nativeSet.add("Apple");
nativeSet.add("Banana");
nativeSet.add("Apple"); // 重複，不會新增

console.log("原生 Set:", nativeSet);
console.log("大小:", nativeSet.size); // 2
console.log("包含 Apple:", nativeSet.has("Apple")); // true

// 自定義 HashSet 實作
class HashSet {
    constructor() {
        this.items = {};
        this.count = 0;
    }
    
    add(item) {
        const key = this.hash(item);
        if (!this.items[key]) {
            this.items[key] = item;
            this.count++;
            return true;
        }
        return false;
    }
    
    remove(item) {
        const key = this.hash(item);
        if (this.items[key]) {
            delete this.items[key];
            this.count--;
            return true;
        }
        return false;
    }
    
    contains(item) {
        const key = this.hash(item);
        return this.items.hasOwnProperty(key);
    }
    
    size() {
        return this.count;
    }
    
    isEmpty() {
        return this.count === 0;
    }
    
    clear() {
        this.items = {};
        this.count = 0;
    }
    
    values() {
        return Object.values(this.items);
    }
    
    hash(item) {
        if (typeof item === 'string') {
            return item;
        } else if (typeof item === 'number') {
            return 'num_' + item;
        } else if (typeof item === 'object') {
            return 'obj_' + JSON.stringify(item);
        }
        return String(item);
    }
    
    toString() {
        return `{${this.values().join(', ')}}`;
    }
}

// 排序 Set 實作（模擬 TreeSet）
class TreeSet {
    constructor(compareFn = null) {
        this.items = [];
        this.compare = compareFn || ((a, b) => {
            if (a < b) return -1;
            if (a > b) return 1;
            return 0;
        });
    }
    
    add(item) {
        const index = this.findInsertionIndex(item);
        if (index < this.items.length && this.compare(this.items[index], item) === 0) {
            return false; // 已存在
        }
        this.items.splice(index, 0, item);
        return true;
    }
    
    remove(item) {
        const index = this.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }
    
    contains(item) {
        return this.indexOf(item) !== -1;
    }
    
    indexOf(item) {
        let left = 0;
        let right = this.items.length - 1;
        
        while (left <= right) {
            const mid = Math.floor((left + right) / 2);
            const cmp = this.compare(this.items[mid], item);
            
            if (cmp === 0) {
                return mid;
            } else if (cmp < 0) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }
    
    findInsertionIndex(item) {
        let left = 0;
        let right = this.items.length;
        
        while (left < right) {
            const mid = Math.floor((left + right) / 2);
            if (this.compare(this.items[mid], item) < 0) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
    
    size() {
        return this.items.length;
    }
    
    isEmpty() {
        return this.items.length === 0;
    }
    
    clear() {
        this.items = [];
    }
    
    first() {
        if (this.isEmpty()) {
            throw new Error('Set 為空');
        }
        return this.items[0];
    }
    
    last() {
        if (this.isEmpty()) {
            throw new Error('Set 為空');
        }
        return this.items[this.items.length - 1];
    }
    
    values() {
        return [...this.items];
    }
    
    toString() {
        return `{${this.items.join(', ')}}`;
    }
}

// 使用範例
console.log("\n=== HashSet 範例 ===");
const hashSet = new HashSet();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Cherry");
hashSet.add("Apple"); // 重複

console.log("HashSet:", hashSet.toString());
console.log("大小:", hashSet.size()); // 3
console.log("包含 Banana:", hashSet.contains("Banana")); // true

console.log("\n=== TreeSet 範例 ===");
const treeSet = new TreeSet();
treeSet.add(5);
treeSet.add(2);
treeSet.add(8);
treeSet.add(3);
treeSet.add(2); // 重複

console.log("TreeSet:", treeSet.toString()); // 自動排序
console.log("第一個:", treeSet.first()); // 2
console.log("最後一個:", treeSet.last()); // 8

// Set 操作
const set1 = new Set([1, 2, 3, 4]);
const set2 = new Set([3, 4, 5, 6]);

// 聯集
const union = new Set([...set1, ...set2]);
console.log("聯集:", union);

// 交集
const intersection = new Set([...set1].filter(x => set2.has(x)));
console.log("交集:", intersection);

// 差集
const difference = new Set([...set1].filter(x => !set2.has(x)));
console.log("差集:", difference);

// 對稱差集
const symmetricDifference = new Set([
    ...[...set1].filter(x => !set2.has(x)),
    ...[...set2].filter(x => !set1.has(x))
]);
console.log("對稱差集:", symmetricDifference);
```

```java !! java
// Java - Set 介面和實作
import java.util.*;

public class SetDemo {
    public static void main(String[] args) {
        // HashSet - 基於雜湊表的實作
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Apple");
        hashSet.add("Banana");
        hashSet.add("Cherry");
        hashSet.add("Apple"); // 重複，不會新增
        
        System.out.println("HashSet: " + hashSet);
        System.out.println("大小: " + hashSet.size()); // 3
        System.out.println("包含 Banana: " + hashSet.contains("Banana")); // true
        
        // TreeSet - 基於紅黑樹的排序實作
        Set<Integer> treeSet = new TreeSet<>();
        treeSet.add(5);
        treeSet.add(2);
        treeSet.add(8);
        treeSet.add(3);
        treeSet.add(2); // 重複，不會新增
        
        System.out.println("TreeSet: " + treeSet); // 自動排序
        
        // TreeSet 特有方法
        TreeSet<Integer> ts = (TreeSet<Integer>) treeSet;
        System.out.println("第一個: " + ts.first()); // 2
        System.out.println("最後一個: " + ts.last()); // 8
        System.out.println("小於 5 的元素: " + ts.headSet(5)); // [2, 3]
        System.out.println("大於等於 5 的元素: " + ts.tailSet(5)); // [5, 8]
        System.out.println("3 到 7 之間: " + ts.subSet(3, 8)); // [3, 5]
        
        // LinkedHashSet - 保持插入順序的 HashSet
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("First");
        linkedHashSet.add("Second");
        linkedHashSet.add("Third");
        linkedHashSet.add("First"); // 重複
        
        System.out.println("LinkedHashSet: " + linkedHashSet); // 保持插入順序
        
        // Set 操作範例
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5, 6));
        
        // 聯集
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("聯集: " + union);
        
        // 交集
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("交集: " + intersection);
        
        // 差集
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("差集: " + difference);
        
        // 對稱差集
        Set<Integer> symmetricDifference = new HashSet<>(set1);
        symmetricDifference.addAll(set2);
        Set<Integer> temp = new HashSet<>(set1);
        temp.retainAll(set2);
        symmetricDifference.removeAll(temp);
        System.out.println("對稱差集: " + symmetricDifference);
        
        // 使用 Stream API 進行集合操作
        Set<String> fruits = Set.of("apple", "banana", "cherry", "date");
        
        // 過濾
        Set<String> longNames = fruits.stream()
                .filter(s -> s.length() > 5)
                .collect(Collectors.toSet());
        System.out.println("長名稱水果: " + longNames);
        
        // 轉換
        Set<String> upperCaseFruits = fruits.stream()
                .map(String::toUpperCase)
                .collect(Collectors.toSet());
        System.out.println("大寫水果: " + upperCaseFruits);
        
        // 效能特徵
        System.out.println("\n效能特徵:");
        System.out.println("HashSet - 新增/刪除/尋找: 平均 O(1)");
        System.out.println("TreeSet - 新增/刪除/尋找: O(log n), 有序");
        System.out.println("LinkedHashSet - 與 HashSet 相似，但保持插入順序");
    }
}
```
</UniversalEditor>

### 3. Map 介面和實作

Java 的 Map 介面提供鍵值對儲存，而 JavaScript 使用物件或 Map 物件。

<UniversalEditor title="Map 介面和實作" compare={true}>
```javascript !! js
// JavaScript - 物件和 Map
// 原生 Map
const nativeMap = new Map();
nativeMap.set("name", "張三");
nativeMap.set("age", 30);
nativeMap.set("city", "台北");

console.log("原生 Map:", nativeMap);
console.log("姓名:", nativeMap.get("name"));
console.log("包含 age:", nativeMap.has("age"));
console.log("大小:", nativeMap.size);

// 物件作為 Map
const objMap = {
    name: "李四",
    age: 25,
    city: "台中"
};

console.log("物件 Map:", objMap);
console.log("姓名:", objMap.name);
console.log("包含 age:", "age" in objMap);

// 學生成績 Map 操作
const studentGrades = new Map([
    ["張三", 85],
    ["李四", 92],
    ["王五", 78],
    ["趙六", 96]
]);

console.log("\n=== 學生成績 ===");
for (const [name, grade] of studentGrades) {
    console.log(`${name}: ${grade}`);
}

// 尋找最高分
let maxGrade = 0;
let topStudent = "";
for (const [name, grade] of studentGrades) {
    if (grade > maxGrade) {
        maxGrade = grade;
        topStudent = name;
    }
}
console.log(`最高分: ${topStudent} (${maxGrade})`);

// 計算平均分
const totalGrades = Array.from(studentGrades.values());
const average = totalGrades.reduce((sum, grade) => sum + grade, 0) / totalGrades.length;
console.log(`平均分: ${average.toFixed(2)}`);
```

```java !! java
// Java - Map 介面和實作
import java.util.*;

public class MapDemo {
    public static void main(String[] args) {
        // HashMap - 基於雜湊表的實作
        Map<String, String> hashMap = new HashMap<>();
        hashMap.put("name", "張三");
        hashMap.put("age", "30");
        hashMap.put("city", "台北");
        
        System.out.println("HashMap: " + hashMap);
        System.out.println("姓名: " + hashMap.get("name"));
        System.out.println("包含 age: " + hashMap.containsKey("age"));
        System.out.println("包含值 '台北': " + hashMap.containsValue("台北"));
        
        // TreeMap - 基於紅黑樹的排序實作
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("c", 3);
        treeMap.put("a", 1);
        treeMap.put("b", 2);
        treeMap.put("d", 4);
        
        System.out.println("TreeMap: " + treeMap); // 自動按鍵排序
        
        // TreeMap 特有方法
        TreeMap<String, Integer> tm = (TreeMap<String, Integer>) treeMap;
        System.out.println("第一個鍵: " + tm.firstKey()); // "a"
        System.out.println("最後一個鍵: " + tm.lastKey()); // "d"
        System.out.println("小於 'c' 的條目: " + tm.headMap("c")); // {a=1, b=2}
        System.out.println("大於等於 'c' 的條目: " + tm.tailMap("c")); // {c=3, d=4}
        System.out.println("'b' 到 'd' 之間: " + tm.subMap("b", "d")); // {b=2, c=3}
        
        // LinkedHashMap - 保持插入順序的 HashMap
        Map<String, String> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("first", "第一個");
        linkedHashMap.put("second", "第二個");
        linkedHashMap.put("third", "第三個");
        
        System.out.println("LinkedHashMap: " + linkedHashMap); // 保持插入順序
        
        // Map 操作範例
        Map<String, Integer> studentGrades = new HashMap<>();
        studentGrades.put("張三", 85);
        studentGrades.put("李四", 92);
        studentGrades.put("王五", 78);
        studentGrades.put("趙六", 96);
        
        System.out.println("\n=== 學生成績 ===");
        
        // 遍歷 Map
        for (Map.Entry<String, Integer> entry : studentGrades.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 使用 forEach (Java 8+)
        System.out.println("\n使用 forEach:");
        studentGrades.forEach((name, grade) -> 
            System.out.println(name + ": " + grade));
        
        // 尋找最高分
        String topStudent = studentGrades.entrySet().stream()
                .max(Map.Entry.comparingByValue())
                .map(Map.Entry::getKey)
                .orElse("無");
        
        int maxGrade = Collections.max(studentGrades.values());
        System.out.println("最高分: " + topStudent + " (" + maxGrade + ")");
        
        // 計算平均分
        double average = studentGrades.values().stream()
                .mapToInt(Integer::intValue)
                .average()
                .orElse(0.0);
        System.out.println("平均分: " + String.format("%.2f", average));
        
        // 過濾及格學生
        Map<String, Integer> passedStudents = studentGrades.entrySet().stream()
                .filter(entry -> entry.getValue() >= 80)
                .collect(Collectors.toMap(
                    Map.Entry::getKey,
                    Map.Entry::getValue
                ));
        System.out.println("及格學生: " + passedStudents);
        
        // Map 合併操作
        Map<String, Integer> additionalGrades = Map.of(
            "孫七", 88,
            "周八", 91
        );
        
        Map<String, Integer> allGrades = new HashMap<>(studentGrades);
        allGrades.putAll(additionalGrades);
        System.out.println("所有成績: " + allGrades);
        
        // 使用 merge 方法
        Map<String, Integer> gradeUpdates = Map.of(
            "張三", 90,  // 更新
            "新學生", 85 // 新增
        );
        
        gradeUpdates.forEach((name, grade) -> 
            allGrades.merge(name, grade, Integer::max)); // 取最大值
        
        System.out.println("合併後成績: " + allGrades);
        
        // 效能特徵
        System.out.println("\n效能特徵:");
        System.out.println("HashMap - 查找/插入/刪除: 平均 O(1)");
        System.out.println("TreeMap - 查找/插入/刪除: O(log n), 有序");
        System.out.println("LinkedHashMap - 與 HashMap 相似，但保持插入順序");
    }
}
```
</UniversalEditor>

## 練習題

### 練習 1: 集合基礎操作

<UniversalEditor title="練習 1: 集合基礎操作">
```java !! java
// TODO: 實作集合基礎操作
import java.util.*;

public class CollectionExercise1 {
    
    // TODO: 建立並操作 List
    public static void listOperations() {
        // TODO: 建立 ArrayList 並新增水果名稱
        // TODO: 在指定位置插入元素
        // TODO: 刪除指定元素和指定位置的元素
        // TODO: 尋找元素索引
        // TODO: 使用 Collections.sort() 排序
        // TODO: 使用 Collections.reverse() 反轉
        System.out.println("List 操作完成");
    }
    
    // TODO: 建立並操作 Set
    public static void setOperations() {
        // TODO: 建立 HashSet 並新增重複元素
        // TODO: 建立 TreeSet 並觀察自動排序
        // TODO: 建立 LinkedHashSet 並觀察插入順序
        // TODO: 執行集合的聯集、交集、差集操作
        System.out.println("Set 操作完成");
    }
    
    // TODO: 建立並操作 Map
    public static void mapOperations() {
        // TODO: 建立 HashMap 儲存學生資訊
        // TODO: 建立 TreeMap 並觀察鍵的排序
        // TODO: 使用 putIfAbsent、merge 等方法
        // TODO: 遍歷 Map 的不同方式
        System.out.println("Map 操作完成");
    }
    
    public static void main(String[] args) {
        listOperations();
        setOperations();
        mapOperations();
    }
}
```
</UniversalEditor>

### 練習 2: 進階集合應用

<UniversalEditor title="練習 2: 進階集合應用">
```java !! java
// TODO: 實作進階集合應用
import java.util.*;
import java.util.stream.Collectors;

public class CollectionExercise2 {
    
    // TODO: 實作圖書管理系統
    static class Book {
        // TODO: 新增 title, author, year, isbn 欄位
        // TODO: 實作建構函式
        // TODO: 實作 getter 方法
        // TODO: 重寫 toString, equals, hashCode 方法
    }
    
    static class Library {
        // TODO: 使用適當的集合儲存圖書
        // TODO: 實作新增圖書方法
        // TODO: 實作按標題尋找圖書方法
        // TODO: 實作按作者尋找圖書方法
        // TODO: 實作按年份範圍尋找圖書方法
        // TODO: 實作刪除圖書方法
        // TODO: 實作取得所有作者列表方法（無重複）
        // TODO: 實作統計每個作者的圖書數量方法
    }
    
    // TODO: 實作單字頻率統計器
    static class WordCounter {
        // TODO: 使用 Map 儲存單字和頻率
        // TODO: 實作新增單字方法
        // TODO: 實作取得頻率方法
        // TODO: 實作取得最常見單字方法
        // TODO: 實作按頻率排序的單字列表方法
    }
    
    // TODO: 實作學生成績管理系統
    static class Student {
        // TODO: 新增 name, id 欄位
        // TODO: 實作建構函式和 getter 方法
        // TODO: 重寫 equals, hashCode 方法
    }
    
    static class GradeManager {
        // TODO: 使用 Map<Student, Map<String, Integer>> 儲存成績
        // TODO: 實作新增成績方法
        // TODO: 實作取得學生平均分方法
        // TODO: 實作取得科目平均分方法
        // TODO: 實作取得最高分學生方法
        // TODO: 實作取得不及格學生列表方法
    }
    
    public static void main(String[] args) {
        // TODO: 測試圖書管理系統
        System.out.println("=== 圖書管理系統測試 ===");
        Library library = new Library();
        // TODO: 新增測試資料並呼叫各種方法
        
        // TODO: 測試單字頻率統計器
        System.out.println("\n=== 單字頻率統計器測試 ===");
        WordCounter counter = new WordCounter();
        // TODO: 新增測試資料並呼叫各種方法
        
        // TODO: 測試學生成績管理系統
        System.out.println("\n=== 學生成績管理系統測試 ===");
        GradeManager gradeManager = new GradeManager();
        // TODO: 新增測試資料並呼叫各種方法
    }
}
```
</UniversalEditor>

## 總結

在本模組中，我們深入探索了 Java 集合框架，並與 JavaScript 的集合處理方法進行了對比：

### 關鍵要點：
1. **List 介面**：有序集合，允許重複元素
2. **Set 介面**：無重複元素的集合
3. **Map 介面**：鍵值對對映
4. **實作選擇**：根據效能需求選擇合適的實作
5. **Stream API**：現代函數式集合操作

### 效能對比：
- **ArrayList vs LinkedList**：隨機存取 vs 插入刪除
- **HashSet vs TreeSet**：雜湊尋找 vs 有序儲存
- **HashMap vs TreeMap**：雜湊尋找 vs 有序鍵

### 下一步：
- 掌握各種集合的使用場景
- 練習集合的組合使用
- 學習 Stream API 進階操作
- 準備下一個模組：並行程式設計

## 其他資源

- [Java Collections Framework](https://docs.oracle.com/javase/tutorial/collections/)
- [Java Collection Performance](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)
- [Java Stream API](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html)

---

**練習提示**：重點理解不同集合的效能特徵和使用場景。練習使用 Stream API 進行函數式程式設計。在實際專案中合理選擇集合類型以最佳化效能。
