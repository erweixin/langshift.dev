---
title: "模組 1:基礎語法對比"
description: "學習 Python 和 Go 語法之間的基本差異"
---

## 簡介

在本模組中,我們將對比 Python 和 Go 的基礎語法。理解這些差異對於從 Python 的動態直譯型特性轉向 Go 的靜態編譯型方法至關重要。

## 變數宣告

### Python: 動態類型

Python 使用動態類型 - 變數可以持有任何類型:

```python
# Python - 無需類型宣告
name = "Alice"
age = 25
price = 19.99
is_active = True
items = [1, 2, 3]

# 類型可以改變
x = 10
x = "now a string"  # 在 Python 中完全有效
```

### Go: 帶類型推斷的靜態類型

Go 需要類型,但可以推斷它們:

<UniversalEditor title="變數宣告">
```python !! py
# Python - 動態類型
name = "Alice"
age = 25
price = 19.99
is_active = True
items = [1, 2, 3]
```

```go !! go
// Go - 帶類型推斷的靜態類型
var name string = "Alice"      // 完整宣告
var age = 25                   // 類型推斷 (int)
price := 19.99                 // 短變數宣告 (最常用)
is_active := true              // 類型推斷 (bool)
var items []int = []int{1, 2, 3}  // slice

// 不能改變類型
// age = "now a string"  // 編譯錯誤!
```
</UniversalEditor>

### 變數宣告風格

<UniversalEditor title="變數宣告風格">
```python !! py
# Python - 一種方式
x = 10
y = "hello"
z = 3.14
```

```go !! go
// Go - 三種方式

// 1. 完整宣告
var x int = 10

// 2. 類型推斷
var y = "hello"

// 3. 短變數宣告 (最常用,僅在函式內)
z := 3.14

// 多個變數
var a, b, c int = 1, 2, 3
name, age := "Bob", 30

// 區塊宣告 (用於套件級別)
var (
    port    int    = 8080
    host    string = "localhost"
    debug   bool   = false
)
```
</UniversalEditor>

## 常數

<UniversalEditor title="常數">
```python !! py
# Python - 常數 (約定,不強制)
MAX_CONNECTIONS = 100
API_KEY = "secret"
DEBUG = True

# 實際上可以修改 (但不應該)
MAX_CONNECTIONS = 200  # 可以工作但違反約定
```

```go !! go
// Go - 真正的常數 (編譯時)
const MaxConnections = 100
const APIKey = "secret"
const Debug = false

// 不能被修改
// MaxConnections = 200  // 編譯錯誤!

// 多個常數
const (
    StatusOK       = 200
    StatusNotFound = 404
    StatusError    = 500
)
```
</UniversalEditor>

## 基本類型

<UniversalEditor title="基本類型對比">
```python !! py
# Python - 內建類型
int_num = 42              # int (無限精度)
float_num = 3.14          # float
text = "hello"            # str
is_true = True            # bool
byte_data = b"bytes"      # bytes

# 複合類型
numbers = [1, 2, 3]       # list (可變)
coords = (1, 2)           # tuple (不可變)
```

```go !! go
// Go - 基本類型
var intNum int = 42               // int (平台相關,通常 64 位)
var floatNum float64 = 3.14       // float64
var text string = "hello"         // string
var isTrue bool = true            // bool
var byteData []byte = []byte("bytes")  // byte slice

// 複合類型
var numbers []int = []int{1, 2, 3}  // slice (動態陣列)
var coords [2]int = [2]int{1, 2}    // array (固定大小)

// 特定數值類型
var i8 int8 = 127                   // 8 位元整數
var i16 int16 = 32767               // 16 位元整數
var i32 int32 = 2147483647          // 32 位元整數
var i64 int64 = 9223372036854775807 // 64 位元整數
var f32 float32 = 3.14              // 32 位元浮點
var u8 uint8 = 255                  // 8 位元無號
```
</UniversalEditor>

## 字串

<UniversalEditor title="字串操作">
```python !! py
# Python - 字串操作
text = "Hello, World!"

# 長度
print(len(text))  # 13

# 拼接
greeting = text + " How are you?"
print(greeting)  # Hello, World! How are you?

# 字串格式化
name = "Alice"
age = 25
print(f"Name: {name}, Age: {age}")
print("Name: {}, Age: {}".format(name, age))

# 子字串 (切片)
print(text[0:5])   # Hello
print(text[7:])    # World!
print(text[-6:])   # World!

# 多行字串
multiline = """
This is a
multiline string
"""
```

```go !! go
// Go - 字串操作
package main

import (
    "fmt"
    "strings"
)

func main() {
    text := "Hello, World!"

    // 長度
    fmt.Println(len(text))  // 13 (位元組數)
    fmt.Println(len([]rune(text)))  // 13 (字元/rune 數)

    // 拼接
    greeting := text + " How are you?"
    fmt.Println(greeting)  // Hello, World! How are you?

    // 字串格式化
    name := "Alice"
    age := 25
    fmt.Printf("Name: %s, Age: %d\n", name, age)
    fmt.Printf("Name: %v, Age: %v\n", name, age)

    // 子字串 (切片)
    fmt.Println(text[0:5])   // Hello
    fmt.Println(text[7:])    // World!
    // Go 中沒有負數索引

    // 多行字串
    multiline := `
This is a
multiline string
`

    // 字串方法
    fmt.Println(strings.ToUpper(text))  // HELLO, WORLD!
    fmt.Println(strings.Contains(text, "World"))  // true
    fmt.Println(strings.Replace(text, "World", "Go", 1))  // Hello, Go!
}
```
</UniversalEditor>

## 零值

在 Go 中,每個類型都有「零值」 - 未初始化時的預設值:

<UniversalEditor title="零值">
```python !! py
# Python - 變數必須初始化
x = None  # 顯式 None
y = 0     # 初始化為 0
z = ""    # 初始化為空字串

# 沒有預設值
def my_function():
    a  # 錯誤:區域變數在賦值前被引用
```

```go !! go
// Go - 零值
var x int       // 0
var y float64   // 0
var z string    // "" (空字串)
var b bool      // false
var s []int     // nil (nil slice)

// 可以工作 - 變數有預設值
func myFunction() {
    var a int
    fmt.Println(a)  // 列印 0
}
```
</UniversalEditor>

## 註解

<UniversalEditor title="註解">
```python !! py
# Python - 註解
# 單行註解

"""
多行註解
(docstring)
"""

# 函式文件
def add(a, b):
    """Add two numbers together."""
    return a + b
```

```go !! go
// Go - 註解
// 單行註解

/* 多行
   註解 */

// 套件文件 (出現在 package 子句之前)
// Package main demonstrates basic Go syntax
package main

// 函式文件
// Add adds two numbers together and returns the result.
func Add(a int, b int) int {
    return a + b
}
```
</UniversalEditor>

## 類型轉換

<UniversalEditor title="類型轉換">
```python !! py
# Python - 自動類型轉換
x = 10
y = 3.14
result = x + y  # 13.14 (float)
text = "Value: " + str(x)  # 字串需要顯式轉換
```

```go !! go
// Go - 無自動轉換 (必須顯式)
package main

import "fmt"

func main() {
    var x int = 10
    var y float64 = 3.14

    // 錯誤:不能混合類型
    // result := x + y  // 編譯錯誤!

    // 必須顯式轉換
    result := float64(x) + y
    fmt.Println(result)  // 13.14

    // 字串轉換
    text := "Value: " + fmt.Sprintf("%d", x)
    fmt.Println(text)  // Value: 10

    // 使用 strconv 套件
    import "strconv"
    numStr := strconv.Itoa(x)
    fmt.Println(numStr)  // "10"
}
```
</UniversalEditor>

## 指標 (Python 開發者的新概念)

Go 有指標 - Python 不暴露它們:

<UniversalEditor title="指標">
```python !! py
# Python - 一切都是參考
def modify_list(lst):
    lst.append(4)  # 修改原始列表

numbers = [1, 2, 3]
modify_list(numbers)
print(numbers)  # [1, 2, 3, 4]

# 但整數是不可變的
def increment(x):
    x += 1  # 建立新的區域變數

num = 10
increment(num)
print(num)  # 10 (未改變)
```

```go !! go
// Go - 顯式指標
package main

import "fmt"

func modifySlice(slice []int) {
    slice = append(slice, 4)  // 修改 slice
}

func incrementByPointer(x *int) {
    *x++  // 解參考並遞增
}

func main() {
    // Slice 已經是參考
    numbers := []int{1, 2, 3}
    modifySlice(numbers)
    fmt.Println(numbers)  // [1, 2, 3, 4]

    // 對值類型使用指標
    num := 10
    incrementByPointer(&num)  // 傳遞位址
    fmt.Println(num)  // 11 (已改變!)

    // 指標語法
    x := 42
    p := &x     // p 是 x 的指標 (類型 *int)
    fmt.Println(*p)  // 42 (解參考)
    *p = 100      // 透過指標修改 x
    fmt.Println(x)  // 100
}
```
</UniversalEditor>

## 陣列和切片

<UniversalEditor title="陣列 vs 切片">
```python !! py
# Python - 列表 (動態陣列)
numbers = [1, 2, 3, 4, 5]
numbers.append(6)           # 新增元素
numbers.extend([7, 8])      # 新增多個
mixed = [1, "hello", 3.14]  # 混合類型 (允許)
sliced = numbers[1:4]       # 切片
```

```go !! go
// Go - 陣列 (固定) 和切片 (動態)
package main

import "fmt"

func main() {
    // 陣列 - 固定大小
    var arr [5]int = [5]int{1, 2, 3, 4, 5}
    // arr[5] = 6  // 錯誤:索引越界

    // 切片 - 動態 (主要使用這個)
    numbers := []int{1, 2, 3, 4, 5}
    numbers = append(numbers, 6)      // 新增元素
    numbers = append(numbers, 7, 8)   // 新增多個

    // Go 中不能混合類型
    // mixed := []interface{}{1, "hello", 3.14}  // 需要 interface{}

    // 切片
    sliced := numbers[1:4]  // [2 3 4]

    // 建立帶容量的切片
    nums := make([]int, 0, 10)  // 長度=0, 容量=10
    nums = append(nums, 1, 2, 3)

    fmt.Println(nums)
}
```
</UniversalEditor>

## 映射 (字典)

<UniversalEditor title="映射/字典">
```python !! py
# Python - 字典
person = {
    "name": "Alice",
    "age": 30,
    "city": "NYC"
}

# 存取
print(person["name"])  # Alice
print(person.get("country", "Unknown"))  # Unknown (預設值)

# 修改
person["age"] = 31
person["country"] = "USA"

# 刪除
del person["city"]

# 迭代
for key, value in person.items():
    print(f"{key}: {value}")
```

```go !! go
// Go - 映射
package main

import "fmt"

func main() {
    // 建立映射
    person := map[string]interface{}{
        "name": "Alice",
        "age": 30,
        "city": "NYC",
    }

    // 存取
    fmt.Println(person["name"])  // Alice
    country, exists := person["country"]
    if !exists {
        country = "Unknown"
    }
    fmt.Println(country)  // Unknown

    // 修改
    person["age"] = 31
    person["country"] = "USA"

    // 刪除
    delete(person, "city")

    // 迭代
    for key, value := range person {
        fmt.Printf("%v: %v\n", key, value)
    }

    // 類型化映射 (更好)
    ages := map[string]int{
        "Alice": 30,
        "Bob":   25,
    }
}
```
</UniversalEditor>

## 運算子

<UniversalEditor title="運算子對比">
```python !! py
# Python - 運算子
a, b = 10, 3

# 算術
print(a + b)   # 13 (加法)
print(a - b)   # 7  (減法)
print(a * b)   # 30 (乘法)
print(a / b)   # 3.333... (真除法)
print(a // b)  # 3  (整除)
print(a % b)   # 1  (取模)
print(a ** b)  # 1000 (次方)

# 比較
print(a == b)  # False
print(a != b)  # True
print(a > b)   # True
print(a >= b)  # True

# 邏輯
print(a > 5 and b < 5)  # True
print(a > 5 or b > 5)   # True
print(not (a == b))     # True
```

```go !! go
// Go - 運算子
package main

import (
    "fmt"
    "math"
)

func main() {
    a, b := 10, 3

    // 算術
    fmt.Println(a + b)    // 13 (加法)
    fmt.Println(a - b)    // 7  (減法)
    fmt.Println(a * b)    // 30 (乘法)
    fmt.Println(a / b)    // 3  (整數除法)
    fmt.Println(a % b)    // 1  (取模)
    fmt.Println(math.Pow(float64(a), float64(b)))  // 1000 (次方)

    // 比較 (與 Python 相同)
    fmt.Println(a == b)  // false
    fmt.Println(a != b)  // true
    fmt.Println(a > b)   // true
    fmt.Println(a >= b)  // true

    // 邏輯 (不同語法)
    fmt.Println(a > 5 && b < 5)  // true (and)
    fmt.Println(a > 5 || b > 5)  // true (or)
    fmt.Println(!(a == b))       // true (not)

    // 遞增/遞減
    i := 0
    i++  // i = 1
    i--  // i = 0
    // Go 中沒有 ++i 或 --i
}
```
</UniversalEditor>

## 控制流基礎

### If 語句

<UniversalEditor title="If 語句">
```python !! py
# Python - If 語句
age = 20

if age >= 18:
    print("Adult")
elif age >= 13:
    print("Teenager")
else:
    print("Child")

# 使用賦值運算式 (Python 3.8+)
if (n := len(items)) > 10:
    print(f"Too many items: {n}")
```

```go !! go
// Go - If 語句
package main

import "fmt"

func main() {
    age := 20

    if age >= 18 {
        fmt.Println("Adult")
    } else if age >= 13 {  // 注意:沒有 elif
        fmt.Println("Teenager")
    } else {
        fmt.Println("Child")
    }

    // 帶初始化語句
    if n := len(items); n > 10 {
        fmt.Printf("Too many items: %d\n", n)
    }
    // n 在 if 區塊外不可存取
}
```
</UniversalEditor>

## 總結

在本模組中,你學習了:

1. **變數宣告**: Python (動態) vs Go (帶類型推斷的靜態)
2. **基本類型**: 不同的類型系統和轉換
3. **字串**: 相似的操作,不同的語法
4. **零值**: Go 中未初始化變數的預設值
5. **指標**: Python 開發者的新概念
6. **集合**: 陣列/切片 vs 列表,映射 vs 字典
7. **運算子**: 大部分相似,一些語法差異
8. **控制流簡介**: 帶初始化的 If 語句

## 關鍵要點

- **Go 需要顯式類型** 但使用 `:=` 進行類型推斷
- **無隱式類型轉換** - 必須顯式轉換
- **零值** 意味著變數總是有預設值
- **指標** 讓你對參考有顯式控制
- **切片** 是動態陣列,**陣列**是固定大小
- **映射** 類似 Python 字典
- **使用 `:=` 進行短變數宣告** 在函式內部 (最常用)

## 練習

1. 建立一個程式,宣告不同類型的變數
2. 撰寫一個函式,接收指標並修改值
3. 建立一個切片,新增元素,並對其進行切片
4. 建構一個映射並示範 CRUD 操作
5. 在不同數值類型之間轉換
6. 使用帶初始化的 if 語句

## 下一步

在下一個模組中,我們將深入學習 Go 的控制流、迴圈和函式。
