---
title: "模块 2:控制流和循环"
description: "掌握 Go 的控制流构造,与 Python 对比"
---

## 简介

本模块涵盖 Go 中的控制流,包括循环、条件语句和 switch。虽然 Python 强调"只有一种显而易见的方式",但 Go 提供了显式的构造,使代码清晰且可预测。

## 循环:唯一的循环 - For

Python 有 `for` 和 `while` 循环。**Go 只有 `for`**,但它足够通用,可以处理所有循环场景。

### 基本 For 循环

<UniversalEditor title="基本循环对比">
```python !! py
# Python - While 循环
i = 0
while i < 5:
    print(i)
    i += 1

# Python - 带 range 的 For 循环
for i in range(5):
    print(i)

# Python - 遍历可迭代对象的 For 循环
items = ["a", "b", "c"]
for item in items:
    print(item)
```

```go !! go
// Go - 都使用 for 循环
package main

import "fmt"

func main() {
    // While 风格循环
    i := 0
    for i < 5 {
        fmt.Println(i)
        i++
    }

    // 传统 for 循环
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }

    // 遍历 slice
    items := []string{"a", "b", "c"}
    for i, item := range items {
        fmt.Printf("%d: %s\n", i, item)
    }

    // 使用 _ 忽略索引
    for _, item := range items {
        fmt.Println(item)
    }
}
```
</UniversalEditor>

### 无限循环

<UniversalEditor title="无限循环">
```python !! py
# Python - 无限循环
while True:
    print("Running...")
    if should_stop():
        break
```

```go !! go
// Go - 无限循环
for {
    fmt.Println("Running...")
    if shouldStop() {
        break
    }
}
```
</UniversalEditor>

### 遍历映射

<UniversalEditor title="遍历映射">
```python !! py
# Python - 字典迭代
person = {"name": "Alice", "age": 30, "city": "NYC"}

# 键
for key in person:
    print(key)

# 键和值
for key, value in person.items():
    print(f"{key}: {value}")
```

```go !! go
// Go - 映射迭代
package main

import "fmt"

func main() {
    person := map[string]string{
        "name": "Alice",
        "age":  "30",
        "city": "NYC",
    }

    // 键和值 (Go 中唯一的方式)
    for key, value := range person {
        fmt.Printf("%s: %s\n", key, value)
    }

    // 仅键
    for key := range person {
        fmt.Println(key)
    }
}
```
</UniversalEditor>

### 遍历字符串

<UniversalEditor title="字符串迭代">
```python !! py
# Python - 字符串迭代
text = "Hello"
for char in text:
    print(char)

for i, char in enumerate(text):
    print(f"{i}: {char}")
```

```go !! go
// Go - 字符串迭代 (按 rune)
package main

import "fmt"

func main() {
    text := "Hello"

    // 按 rune (字符)
    for i, rune := range text {
        fmt.Printf("%d: %c\n", i, rune)
    }

    // 仅 rune
    for _, rune := range text {
        fmt.Printf("%c\n", rune)
    }
}
```
</UniversalEditor>

### 循环控制:Break 和 Continue

<UniversalEditor title="Break 和 Continue">
```python !! py
# Python - Break 和 continue
for i in range(10):
    if i == 3:
        continue  # 跳过 3
    if i == 7:
        break     # 在 7 处停止
    print(i)
# 输出: 0, 1, 2, 4, 5, 6
```

```go !! go
// Go - Break 和 continue (与 Python 相同)
package main

import "fmt"

func main() {
    for i := 0; i < 10; i++ {
        if i == 3 {
            continue  // 跳过 3
        }
        if i == 7 {
            break     // 在 7 处停止
        }
        fmt.Println(i)
    }
    // 输出: 0, 1, 2, 4, 5, 6
}
```
</UniversalEditor>

## If 语句

### 基本 If

<UniversalEditor title="基本 If">
```python !! py
# Python - If 语句
age = 20

if age >= 18:
    print("Adult")
elif age >= 13:
    print("Teenager")
else:
    print("Child")
```

```go !! go
// Go - If 语句
package main

import "fmt"

func main() {
    age := 20

    if age >= 18 {
        fmt.Println("Adult")
    } else if age >= 13 {
        fmt.Println("Teenager")
    } else {
        fmt.Println("Child")
    }
}
```
</UniversalEditor>

### 带初始化的 If

<UniversalEditor title="带初始化的 If">
```python !! py
# Python 3.8+ - 海象运算符
if (n := len(items)) > 10:
    print(f"Too many: {n}")
```

```go !! go
// Go - 带初始化的 If
package main

import "fmt"

func main() {
    items := []int{1, 2, 3, 4, 5}

    // 变量作用域限定在 if 块
    if n := len(items); n > 10 {
        fmt.Printf("Too many: %d\n", n)
    } else {
        fmt.Printf("Count: %d\n", n)
    }
    // n 在这里不可访问
}
```
</UniversalEditor>

### 带多个条件的 If

<UniversalEditor title="多个条件">
```python !! py
# Python - 逻辑运算符
age = 25
has_id = True

if age >= 18 and has_id:
    print("Can enter")

if age < 18 or not has_id:
    print("Cannot enter")
```

```go !! go
// Go - 逻辑运算符 (不同语法)
package main

import "fmt"

func main() {
    age := 25
    hasID := true

    if age >= 18 && hasID {
        fmt.Println("Can enter")
    }

    if age < 18 || !hasID {
        fmt.Println("Cannot enter")
    }
}
```
</UniversalEditor>

## Switch 语句

Go 的 switch 比 Python 的 if-elif 链更强大:

<UniversalEditor title="Switch 语句">
```python !! py
# Python - 无 switch 语句 (3.10 之前),使用 if-elif
grade = "B"

if grade == "A":
    print("Excellent")
elif grade == "B":
    print("Good")
elif grade == "C":
    print("Average")
else:
    print("Need improvement")

# Python 3.10+ - Match 语句
match grade:
    case "A":
        print("Excellent")
    case "B":
        print("Good")
    case "C":
        print("Average")
    case _:
        print("Need improvement")
```

```go !! go
// Go - Switch 语句 (不需要 break!)
package main

import "fmt"

func main() {
    grade := "B"

    switch grade {
    case "A":
        fmt.Println("Excellent")
    case "B":
        fmt.Println("Good")
    case "C":
        fmt.Println("Average")
    default:
        fmt.Println("Need improvement")
    }

    // 带多个值的 switch
    day := 3
    switch day {
    case 1, 2, 3, 4, 5:
        fmt.Println("Weekday")
    case 6, 7:
        fmt.Println("Weekend")
    }

    // 无条件的 switch (类似 if-else)
    switch {
    case age < 13:
        fmt.Println("Child")
    case age < 18:
        fmt.Println("Teenager")
    default:
        fmt.Println("Adult")
    }
}
```
</UniversalEditor>

### 带初始化的 Switch

<UniversalEditor title="带初始化的 Switch">
```python !! py
# Python
num = 42
if num % 2 == 0:
    print("Even")
else:
    print("Odd")
```

```go !! go
// Go - 带初始化的 Switch
package main

import "fmt"

func main() {
    switch num := 42; num % 2 {
    case 0:
        fmt.Println("Even")
    case 1:
        fmt.Println("Odd")
    }
}
```
</UniversalEditor>

## Defer (Go 独有)

`defer` 在包围函数完成后执行语句。用于清理:

<UniversalEditor title="Defer 语句">
```python !! py
# Python - try-finally
file = None
try:
    file = open("data.txt", "r")
    data = file.read()
    process(data)
finally:
    if file:
        file.close()

# Python - 上下文管理器 (首选)
with open("data.txt", "r") as file:
    data = file.read()
    process(data)
# 自动关闭
```

```go !! go
// Go - Defer
package main

import "fmt"

func processData() {
    // 延迟到函数返回时执行
    defer fmt.Println("Cleanup: Closing resources")

    fmt.Println("Step 1: Opening file")
    fmt.Println("Step 2: Reading data")
    fmt.Println("Step 3: Processing")

    // 输出顺序:
    // Step 1
    // Step 2
    // Step 3
    // Cleanup: Closing resources
}

func main() {
    // 多个 defer (LIFO 顺序)
    defer fmt.Println("Third")
    defer fmt.Println("Second")
    defer fmt.Println("First")

    processData()
}
```
</UniversalEditor>

### 用于文件操作的 Defer

<UniversalEditor title="文件操作的 Defer">
```python !! py
# Python - 上下文管理器
def read_file(filename):
    with open(filename, 'r') as f:
        return f.read()
```

```go !! go
// Go - Defer 用于清理
package main

import (
    "fmt"
    "os"
)

func readFile(filename string) ([]byte, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    // 总是关闭,即使发生错误
    defer file.Close()

    data := make([]byte, 100)
    n, err := file.Read(data)
    if err != nil {
        return nil, err
    }

    return data[:n], nil
}

func main() {
    data, err := readFile("data.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println(string(data))
}
```
</UniversalEditor>

## 常见模式

### 循环直到条件

<UniversalEditor title="循环直到条件">
```python !! py
# Python
while True:
    line = read_line()
    if not line:
        break
    process(line)
```

```go !! go
// Go
for {
    line := readLine()
    if line == "" {
        break
    }
    process(line)
}
```
</UniversalEditor>

### 提前返回

<UniversalEditor title="提前返回">
```python !! py
# Python
def validate(data):
    if not data:
        return False

    if len(data) < 10:
        return False

    if "invalid" in data:
        return False

    return True
```

```go !! go
// Go - 惯用的提前返回
func validate(data string) bool {
    if data == "" {
        return false
    }

    if len(data) < 10 {
        return false
    }

    if strings.Contains(data, "invalid") {
        return false
    }

    return true
}
```
</UniversalEditor>

## 总结

在本模块中,你学习了:

1. **Go 只有 `for` 循环** - 足够通用以应对所有场景
2. **没有 `while`** - 使用仅带条件的 `for`
3. **基于 range 的迭代** 遍历数组、切片、映射、字符串
4. **带初始化的 If** - 作用域受限的变量
5. **Switch 语句** - 不需要 `break`,比 Python 的更强大
6. **Defer** - 在函数完成后执行 (LIFO 顺序)
7. **提前返回** - Go 中的惯用模式

## 与 Python 的主要差异

| Python | Go |
|--------|-----|
| `while`, `for` 循环 | 只有 `for` 循环 |
| `for i in range()` | `for i := 0; i < n; i++` |
| `for item in items` | `for _, item := range items` |
| `elif` | `else if` |
| `and`, `or`, `not` | `&&`, `\|\|`, `!` |
| `with` 语句 | `defer` 关键字 |
| 无 `switch` (3.10 之前) | 强大的 `switch` |

## 练习

1. 编写一个使用 `defer` 测量函数执行时间的函数
2. 创建一个处理多个情况的 switch 语句
3. 使用 `range` 遍历映射并打印键值对
4. 实现验证的提前返回模式
5. 使用带初始化、条件和后置语句的 `for`

## 下一步

下一模块:**函数和方法** - 学习 Go 的函数声明、多返回值、闭包和方法。
