---
title: "模块 6: 错误处理"
description: "Go 的显式错误处理与 Python 异常的对比"
---

## 简介

Go 采用与 Python 根本不同的错误处理方法。Go 不使用异常，而是将错误作为显式返回的值。这使得错误处理可见、可预测，并强制开发者显式处理错误。

### 关键差异

**Python 异常：**
- 错误自动沿调用栈向上冒泡
- 可以在任何级别捕获
- 在函数签名中不可见
- 容易忽略（直到它们使程序崩溃）
- 通过异常进行控制流

**Go 错误：**
- 错误作为值返回
- 必须在每一级显式处理
- 在函数签名中可见
- 不能在没有故意操作的情况下忽略
- 线性控制流

## 基本错误处理

### Error 接口

在 Go 中，`error` 是一个接口：

```go
type error interface {
    Error() string
}
```

任何实现 `Error() string` 的类型都可以用作错误。

<UniversalEditor title="错误处理对比">
```python !! py
# Python - 异常
def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

try:
    result = divide(10, 0)
except ValueError as e:
    print(f"Error: {e}")
    # 可能记录、可能重试、可能中止
```

```go !! go
// Go - 错误作为返回值
package main

import (
    "errors"
    "fmt"
)

func divide(a int, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("cannot divide by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    fmt.Printf("Result: %d\n", result)
}
```
</UniversalEditor>

### Nil 错误约定

在 Go 中，`nil` 表示"没有错误"：

<UniversalEditor title="Nil 错误约定">
```python !! py
# Python - 没有异常意味着成功
def get_user(id):
    user = db.query(id)
    if user:
        return user
    return None  # 不是错误，只是没有结果
```

```go !! go
// Go - nil 错误意味着成功
func getUser(id int) (*User, error) {
    user, err := db.Query(id)
    if err != nil {
        return nil, err  // 数据库错误
    }
    if user == nil {
        return nil, nil  // 没有错误，但没有结果
    }
    return user, nil  // 成功
}

// 使用
user, err := getUser(123)
if err != nil {
    // 处理实际错误
    log.Fatal(err)
}
if user == nil {
    // 没有找到用户，但没有错误
    fmt.Println("User not found")
}
```
</UniversalEditor>

## 自定义错误类型

### 哨兵错误

哨兵错误是可以直接比较的预定义错误值：

<UniversalEditor title="哨兵错误">
```python !! py
# Python - 自定义异常
class ValidationError(Exception):
    pass

class NotFoundError(Exception):
    pass

def validate_age(age):
    if age < 0:
        raise ValidationError("Age cannot be negative")
    if age > 120:
        raise ValidationError("Age too high")

def get_user(id):
    user = db.find(id)
    if not user:
        raise NotFoundError(f"User {id} not found")
    return user

# 使用
try:
    validate_age(-5)
except ValidationError as e:
    print(f"Validation error: {e}")
except NotFoundError as e:
    print(f"Not found: {e}")
```

```go !! go
// Go - 哨兵错误
package main

import (
    "errors"
    "fmt"
)

var (
    ErrNegativeAge   = errors.New("age cannot be negative")
    ErrAgeTooHigh    = errors.New("age too high")
    ErrUserNotFound  = errors.New("user not found")
)

func validateAge(age int) error {
    if age < 0 {
        return ErrNegativeAge
    }
    if age > 120 {
        return ErrAgeTooHigh
    }
    return nil
}

func getUser(id int) (*User, error) {
    user := db.Find(id)
    if user == nil {
        return nil, ErrUserNotFound
    }
    return user, nil
}

func main() {
    err := validateAge(-5)
    if err != nil {
        // 直接比较
        if errors.Is(err, ErrNegativeAge) {
            fmt.Println("Age is negative")
        } else if errors.Is(err, ErrAgeTooHigh) {
            fmt.Println("Age is too high")
        } else {
            fmt.Println("Other error:", err)
        }
    }
}
```
</UniversalEditor>

### 自定义错误结构体

对于更复杂的错误处理，创建自定义错误类型：

<UniversalEditor title="自定义错误结构体">
```python !! py
# Python - 带数据的异常
class ValidationError(Exception):
    def __init__(self, field, message):
        self.field = field
        self.message = message
        super().__init__(f"{field}: {message}")

def validate_user(user):
    if not user.email:
        raise ValidationError("email", "is required")
    if "@" not in user.email:
        raise ValidationError("email", "is invalid")

# 使用
try:
    validate_user(user)
except ValidationError as e:
    print(f"Field {e.field}: {e.message}")
```

```go !! go
// Go - 自定义错误结构体
package main

import "fmt"

// ValidationError 是自定义错误类型
type ValidationError struct {
    Field   string
    Message string
}

// Error 实现错误接口
func (e *ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Message)
}

// User 表示用户
type User struct {
    Email string
    Age   int
}

func validateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "is required",
        }
    }
    // 更多验证...
    return nil
}

func main() {
    user := &User{}
    err := validateUser(user)
    if err != nil {
        // 类型断言以访问自定义字段
        if validationErr, ok := err.(*ValidationError); ok {
            fmt.Printf("Field %s: %s\n", validationErr.Field, validationErr.Message)
        } else {
            fmt.Println("Error:", err)
        }
    }
}
```
</UniversalEditor>

### 带方法的错误

你的自定义错误可以有额外的方法：

<UniversalEditor title="丰富错误类型">
```python !! py
# Python - 丰富异常
class PaymentError(Exception):
    def __init__(self, code, message, retryable):
        self.code = code
        self.message = message
        self.retryable = retryable

    def is_retryable(self):
        return self.retryable

# 使用
try:
    process_payment()
except PaymentError as e:
    if e.is_retryable():
        retry()
```

```go !! go
// Go - 带方法的错误
package main

import "fmt"

// PaymentError 表示支付处理错误
type PaymentError struct {
    Code      int
    Message   string
    Retryable bool
}

func (e *PaymentError) Error() string {
    return fmt.Sprintf("payment error [%d]: %s", e.Code, e.Message)
}

func (e *PaymentError) IsRetryable() bool {
    return e.Retryable
}

func processPayment(amount float64) error {
    if amount <= 0 {
        return &PaymentError{
            Code:      1001,
            Message:   "invalid amount",
            Retryable: false,
        }
    }
    if amount > 10000 {
        return &PaymentError{
            Code:      1002,
            Message:   "amount exceeds limit",
            Retryable: true,
        }
    }
    return nil
}

func main() {
    err := processPayment(15000)
    if err != nil {
        if paymentErr, ok := err.(*PaymentError); ok {
            fmt.Println("Error:", paymentErr)
            if paymentErr.IsRetryable() {
                fmt.Println("This error is retryable")
            }
        }
    }
}
```
</UniversalEditor>

## 错误包装

### 添加上下文

Go 1.13+ 引入了使用 `%w` 动词的错误包装：

<UniversalEditor title="错误包装">
```python !! py
# Python - 异常链
try:
    data = load_data()
except ValueError as e:
    raise ValueError("Failed to process data") from e

# 或 Python 3 的隐式链接
try:
    data = load_data()
except ValueError:
    raise ValueError("Failed to process data")
```

```go !! go
// Go - 错误包装
package main

import (
    "errors"
    "fmt"
)

func loadData() error {
    return errors.New("file not found")
}

func processData() error {
    err := loadData()
    if err != nil {
        // 使用 %w 包装错误并添加上下文
        return fmt.Errorf("processData failed: %w", err)
    }
    return nil
}

func main() {
    err := processData()
    if err != nil {
        fmt.Println("Error:", err)

        // 解包以获取原始错误
        unwrapped := errors.Unwrap(err)
        fmt.Println("Original:", unwrapped)

        // 检查特定错误是否在链中
        if errors.Is(err, errors.New("file not found")) {
            fmt.Println("File not found in error chain")
        }
    }
}
```
</UniversalEditor>

### 多层包装

错误可以被包装多次：

<UniversalEditor title="多层包装">
```python !! py
# Python - 异常链
def layer3():
    raise ValueError("Base error")

def layer2():
    try:
        layer3()
    except ValueError as e:
        raise RuntimeError("Layer 2 failed") from e

def layer1():
    try:
        layer2()
    except RuntimeError as e:
        raise RuntimeError("Layer 1 failed") from e

# 回溯显示完整链
```

```go !! go
// Go - 多层包装
package main

import (
    "errors"
    "fmt"
)

func layer3() error {
    return errors.New("base error")
}

func layer2() error {
    err := layer3()
    if err != nil {
        return fmt.Errorf("layer2: %w", err)
    }
    return nil
}

func layer1() error {
    err := layer2()
    if err != nil {
        return fmt.Errorf("layer1: %w", err)
    }
    return nil
}

func main() {
    err := layer1()
    if err != nil {
        fmt.Println("Full error:", err)

        // 多次解包
        err = errors.Unwrap(err) // "layer2: base error"
        err = errors.Unwrap(err) // "base error"

        // 或检查特定错误是否在链中的任何位置
        err = layer1()
        if errors.Is(err, errors.New("base error")) {
            fmt.Println("Base error found in chain")
        }
    }
}
```
</UniversalEditor>

### 错误格式化动词

<UniversalEditor title="错误格式化动词">
```go !! go
// Go - 格式化动词
package main

import (
    "errors"
    "fmt"
)

func main() {
    baseErr := errors.New("base error")

    // %v - 只是错误文本
    fmt1 := fmt.Errorf("context: %v", baseErr)
    fmt.Println(fmt1) // "context: base error"

    // %w - 包装错误（支持 errors.Is/As）
    fmt2 := fmt.Errorf("context: %w", baseErr)
    fmt.Println(errors.Is(fmt2, baseErr)) // true

    // %+v - （如果错误支持）详细输出
    // 某些错误类型实现 Formatter 接口
    // 用于堆栈跟踪和额外细节
}
```
</UniversalEditor>

## 错误比较和类型断言

### errors.Is()

检查错误是否与链中的特定值匹配：

<UniversalEditor title="错误比较">
```python !! py
# Python - 异常类型检查
try:
    process()
except ValueError:
    print("Value error")
except RuntimeError as e:
    if "timeout" in str(e):
        print("Timeout error")
```

```go !! go
// Go - errors.Is 用于比较
package main

import (
    "errors"
    "fmt"
)

var (
    ErrNotFound = errors.New("not found")
    ErrTimeout  = errors.New("timeout")
)

func process() error {
    return fmt.Errorf("process failed: %w", ErrNotFound)
}

func main() {
    err := process()

    // 检查特定错误是否在链中
    if errors.Is(err, ErrNotFound) {
        fmt.Println("Not found error occurred")
    }

    if errors.Is(err, ErrTimeout) {
        fmt.Println("Timeout error occurred")
    }

    // 也可以检查新错误
    if errors.Is(err, errors.New("not found")) {
        fmt.Println("Not found (new instance)")
    }
}
```
</UniversalEditor>

### errors.As()

错误链的类型断言：

<UniversalEditor title="类型断言">
```python !! py
# Python - 异常实例检查
try:
    process()
except ValidationError as e:
    print(f"Validation error: {e.field}")
except PaymentError as e:
    print(f"Payment error: {e.code}")
```

```go !! go
// Go - errors.As 用于类型断言
package main

import (
    "errors"
    "fmt"
)

type ValidationError struct {
    Field string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error: %s", e.Field)
}

type PaymentError struct {
    Code int
}

func (e *PaymentError) Error() string {
    return fmt.Sprintf("payment error: %d", e.Code)
}

func process() error {
    return &ValidationError{Field: "email"}
}

func main() {
    err := process()

    // 检查错误是否为特定类型
    var validationErr *ValidationError
    if errors.As(err, &validationErr) {
        fmt.Printf("Validation error on field: %s\n", validationErr.Field)
    }

    var paymentErr *PaymentError
    if errors.As(err, &paymentErr) {
        fmt.Printf("Payment error code: %d\n", paymentErr.Code)
    }

    // 也可以直接检查
    if _, ok := err.(*ValidationError); ok {
        fmt.Println("This is a ValidationError")
    }
}
```
</UniversalEditor>

## 错误处理模式

### 重试逻辑

<UniversalEditor title="重试模式">
```python !! py
# Python - 重试装饰器
import time

def retry(max_attempts=3, delay=1):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except IOError as e:
                    if attempt == max_attempts - 1:
                        raise
                    time.sleep(delay)
            return None
        return wrapper
    return decorator

@retry(max_attempts=3)
def fetch_data():
    return api_call()
```

```go !! go
// Go - 重试函数
package main

import (
    "errors"
    "fmt"
    "time"
)

var ErrTemporary = errors.New("temporary error")

func fetch() error {
    // 模拟失败
    return ErrTemporary
}

func retry(attempts int, delay time.Duration, fn func() error) error {
    var err error
    for i := 0; i < attempts; i++ {
        err = fn()
        if err == nil {
            return nil
        }

        // 检查错误是否可重试
        if !errors.Is(err, ErrTemporary) {
            return err
        }

        if i < attempts-1 {
            fmt.Printf("Attempt %d failed, retrying...\n", i+1)
            time.Sleep(delay)
        }
    }
    return fmt.Errorf("after %d attempts: %w", attempts, err)
}

func main() {
    err := retry(3, time.Second, fetch)
    if err != nil {
        fmt.Println("Final error:", err)
    }
}
```
</UniversalEditor>

### 错误聚合

<UniversalEditor title="错误聚合">
```python !! py
# Python - 收集多个错误
class MultiError(Exception):
    def __init__(self, errors):
        self.errors = errors
        super().__init__(f"{len(errors)} errors occurred")

def process_all(items):
    errors = []
    for item in items:
        try:
            process(item)
        except Exception as e:
            errors.append(e)

    if errors:
        raise MultiError(errors)
```

```go !! go
// Go - 收集多个错误
package main

import (
    "fmt"
    "strings"
)

// MultiError 收集多个错误
type MultiError struct {
    Errors []error
}

func (e *MultiError) Error() string {
    var sb strings.Builder
    sb.WriteString(fmt.Sprintf("%d errors occurred:", len(e.Errors)))
    for _, err := range e.Errors {
        sb.WriteString("\n  - ")
        sb.WriteString(err.Error())
    }
    return sb.String()
}

func processAll(items []int) error {
    var errs []error
    for _, item := range items {
        if err := process(item); err != nil {
            errs = append(errs, err)
        }
    }

    if len(errs) > 0 {
        return &MultiError{Errors: errs}
    }
    return nil
}

func process(item int) error {
    if item < 0 {
        return fmt.Errorf("invalid item: %d", item)
    }
    return nil
}

func main() {
    items := []int{1, 2, -3, 4, -5}
    err := processAll(items)
    if err != nil {
        fmt.Println(err)
    }
}
```
</UniversalEditor>

### 临时 vs 永久错误

<UniversalEditor title="临时 vs 永久">
```python !! py
# Python - 自定义异常
class TemporaryError(Exception):
    """重试此操作"""
    pass

class PermanentError(Exception):
    """不要重试，放弃"""
    pass

def handle_error(error):
    if isinstance(error, TemporaryError):
        return "retry"
    elif isinstance(error, PermanentError):
        return "give up"
```

```go !! go
// Go - 行为的错误接口
package main

import (
    "errors"
    "time"
)

// Temporary 指示错误是临时的
type Temporary interface {
    Temporary() bool
}

// TemporaryError 可重试
type TemporaryError struct {
    Msg string
}

func (e *TemporaryError) Error() string {
    return e.Msg
}

func (e *TemporaryError) Temporary() bool {
    return true
}

// PermanentError 不可重试
type PermanentError struct {
    Msg string
}

func (e *PermanentError) Error() string {
    return e.Msg
}

func shouldRetry(err error) bool {
    // 检查错误是否实现 Temporary 接口
    if te, ok := err.(Temporary); ok {
        return te.Temporary()
    }
    return false
}

func retryOperation(fn func() error) error {
    for i := 0; i < 3; i++ {
        err := fn()
        if err == nil {
            return nil
        }

        if !shouldRetry(err) {
            return err // 永久错误，不要重试
        }

        // 临时错误，重试
        time.Sleep(time.Second)
    }
    return errors.New("max retries exceeded")
}

func main() {
    tempErr := &TemporaryError{Msg: "connection timeout"}
    permErr := &PermanentError{Msg: "authentication failed"}

    fmt.Println("Temporary retryable?", shouldRetry(tempErr)) // true
    fmt.Println("Permanent retryable?", shouldRetry(permErr)) // false
}
```
</UniversalEditor>

## Context 和错误

### Context 取消

<UniversalEditor title="Context 取消">
```python !! py
# Python - 使用线程取消
import threading

def worker(stop_event):
    while not stop_event.is_set():
        # 做工作
        if stop_event.is_set():
            break
        process()

stop_event = threading.Event()
thread = threading.Thread(target=worker, args=(stop_event,))
thread.start()

# 取消
stop_event.set()
```

```go !! go
// Go - Context 用于取消
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context) error {
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            // Context 被取消
            return ctx.Err()
        case <-ticker.C:
            // 做工作
            fmt.Println("Working...")
        }
    }
}

func main() {
    // 创建可取消的 context
    ctx, cancel := context.WithCancel(context.Background())

    // 启动 worker
    go func() {
        if err := worker(ctx); err != nil {
            fmt.Println("Worker error:", err)
        }
    }()

    // 500ms 后取消
    time.Sleep(500 * time.Millisecond)
    cancel()

    // 等待一点时间以清理
    time.Sleep(100 * time.Millisecond)
}
```
</UniversalEditor>

### Context 超时

<UniversalEditor title="Context 超时">
```python !! py
# Python - 使用信号超时
import signal

class TimeoutError(Exception):
    pass

def handler(signum, frame):
    raise TimeoutError("Operation timed out")

def fetch_with_timeout(url, timeout=5):
    # 设置闹钟
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(timeout)

    try:
        result = fetch(url)
        signal.alarm(0)  # 取消闹钟
        return result
    except TimeoutError:
        return None
```

```go !! go
// Go - 带超时的 Context
package main

import (
    "context"
    "fmt"
    "time"
)

func fetchData(ctx context.Context, url string) (string, error) {
    // 模拟慢操作
    select {
    case <-time.After(3 * time.Second):
        return "data", nil
    case <-ctx.Done():
        return "", ctx.Err() // context.DeadlineExceeded
    }
}

func main() {
    // 创建带超时的 context
    ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
    defer cancel() // 始终取消以释放资源

    data, err := fetchData(ctx, "http://example.com")
    if err != nil {
        fmt.Println("Error:", err) // context.DeadlineExceeded
        return
    }

    fmt.Println("Data:", data)
}
```
</UniversalEditor>

## Defer 用于清理

### 资源清理

<UniversalEditor title="Defer 和错误">
```python !! py
# Python - try-finally
file = None
try:
    file = open("data.txt")
    process(file)
except IOError as e:
    print(f"Error: {e}")
finally:
    if file:
        file.close()
```

```go !! go
// Go - defer 始终运行
package main

import (
    "fmt"
    "os"
)

func processData() error {
    file, err := os.Open("data.txt")
    if err != nil {
        return err
    }
    defer file.Close() // 始终运行，即使出错

    // 处理文件...
    return nil
}

func main() {
    if err := processData(); err != nil {
        fmt.Println("Error:", err)
    }
}
```
</UniversalEditor>

### Defer 和错误处理

<UniversalEditor title="Defer 错误处理">
```go !! go
// Go - 带命名返回值的 defer
package main

import (
    "fmt"
    "os"
)

func processData() (err error) {
    file, err := os.Open("data.txt")
    if err != nil {
        return err
    }

    // Defer 可以修改命名返回值
    defer func() {
        closeErr := file.Close()
        if closeErr != nil {
            // 如果处理已经失败，保留该错误
            if err == nil {
                err = closeErr
            }
        }
    }()

    // 处理文件...
    return nil
}

func main() {
    if err := processData(); err != nil {
        fmt.Println("Error:", err)
    }
}
```
</UniversalEditor>

## Panic 和 Recover

### 何时使用 Panic

Panic 不像 Python 异常。仅用于：
- 真正无法恢复的错误
- 程序员错误（不应该在生产环境中发生）
- 初始化失败

<UniversalEditor title="Panic 指南">
```python !! py
# Python - 异常用于控制流
def divide(a, b):
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b

# 这在 Python 中是正常的
```

```go !! go
// Go - Panic 仅用于异常情况
package main

import "errors"

// 错误 - 不要对预期错误 panic
func divide(a, b int) int {
    if b == 0 {
        panic("division by zero") // 错误！
    }
    return a / b
}

// 正确 - 返回错误
func divideCorrect(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

// 可以 - Panic 用于程序员错误
func MustGetUser(id int) *User {
    user, err := db.GetUser(id)
    if err != nil {
        panic("database not initialized") // 程序员错误
    }
    if user == nil {
        panic("user must exist") // 程序员错误
    }
    return user
}
```
</UniversalEditor>

### 从 Panic 恢复

<UniversalEditor title="恢复模式">
```python !! py
# Python - 捕获所有
try:
    risky_operation()
except Exception as e:
    print(f"Caught: {e}")
```

```go !! go
// Go - 从 panic 恢复（很少需要）
package main

import (
    "fmt"
    "log"
)

func risky() (result string) {
    // Defer + recover 捕获 panic
    defer func() {
        if r := recover(); r != nil {
            // 将 panic 转换为错误
            result = fmt.Sprintf("Recovered from: %v", r)
            log.Printf("Panic recovered: %v", r)
        }
    }()

    panic("something went wrong")
}

func main() {
    fmt.Println(risky()) // "Recovered from: something went wrong"
}
```
</UniversalEditor>

### 服务器恢复中间件

<UniversalEditor title="HTTP 服务器恢复">
```go !! go
// Go - HTTP 服务器的恢复中间件
package main

import (
    "fmt"
    "log"
    "net/http"
)

func recoveryMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("Panic recovered: %v", err)
                http.Error(w, "Internal Server Error", 500)
            }
        }()
        next(w, r)
    }
}

func handler(w http.ResponseWriter, r *http.Request) {
    panic("oops!")
}

func main() {
    http.HandleFunc("/", recoveryMiddleware(handler))
    fmt.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```
</UniversalEditor>

## 最佳实践

### 1. 始终检查错误

<UniversalEditor title="错误检查">
```python !! py
# Python - 异常强制处理
try:
    result = dangerous_operation()
except ValueError:
    handle_error()
```

```go !! go
// Go - 显式错误检查
// 错误 - 忽略错误
file, _ := os.Open("data.txt") // 不要这样做！

// 正确 - 始终检查错误
file, err := os.Open("data.txt")
if err != nil {
    return err
}
```
</UniversalEditor>

### 2. 为错误添加上下文

<UniversalEditor title="错误上下文">
```python !! py
# Python - 带上下文的异常
try:
    user = get_user(id)
except ValueError as e:
    raise ValueError(f"Failed to get user {id}: {e}")
```

```go !! go
// Go - 包装上下文
// 错误 - 丢失原始错误
func processUser(id int) error {
    user, err := getUser(id)
    if err != nil {
        return errors.New("user not found") // 丢失上下文！
    }
    return nil
}

// 正确 - 包装上下文
func processUser(id int) error {
    user, err := getUser(id)
    if err != nil {
        return fmt.Errorf("processUser(%d): %w", id, err)
    }
    return nil
}
```
</UniversalEditor>

### 3. 立即处理错误

<UniversalEditor title="早期错误处理">
```python !! py
# Python - 早期返回
def process(data):
    if not data:
        return None

    if len(data) < 10:
        return None

    return transform(data)
```

```go !! go
// Go - 立即处理错误
func process(data string) (string, error) {
    if data == "" {
        return "", fmt.Errorf("empty data")
    }

    if len(data) < 10 {
        return "", fmt.Errorf("data too short: got %d, want >= 10", len(data))
    }

    return transform(data), nil
}
```
</UniversalEditor>

### 4. 错误变量

<UniversalEditor title="错误变量">
```go !! go
// Go - 定义错误变量
package mypackage

import "errors"

var (
    ErrNotFound    = errors.New("not found")
    ErrInvalid     = errors.New("invalid input")
    ErrPermission  = errors.New("permission denied")
)

// 导出的错误可以被调用者检查
func FindItem(id int) (*Item, error) {
    // ...
    return nil, ErrNotFound
}

// 调用者可以检查
item, err := mypackage.FindItem(123)
if errors.Is(err, mypackage.ErrNotFound) {
    // 处理未找到
}
```
</UniversalEditor>

### 5. 不要在库中 Panic

<UniversalEditor title="库错误处理">
```python !! py
# Python - 库抛出异常
def process(data):
    if not data:
        raise ValueError("Invalid data")
    return result
```

```go !! go
// Go - 库返回错误
// 错误 - 库函数 panic
func Process(data string) string {
    if data == "" {
        panic("data is empty") // 不要在库中 panic！
    }
    return data
}

// 正确 - 库函数返回错误
func Process(data string) (string, error) {
    if data == "" {
        return "", errors.New("data is empty")
    }
    return data, nil
}
```
</UniversalEditor>

## 实际示例

### 文件操作

<UniversalEditor title="文件处理">
```python !! py
# Python - 文件操作
def process_file(path):
    try:
        with open(path) as f:
            data = f.read()
        return parse(data)
    except IOError as e:
        print(f"Failed to read {path}: {e}")
        return None
```

```go !! go
// Go - 文件操作
package main

import (
    "fmt"
    "os"
)

func processFile(path string) error {
    // 打开文件
    file, err := os.Open(path)
    if err != nil {
        return fmt.Errorf("failed to open %s: %w", path, err)
    }
    defer file.Close()

    // 读取文件
    data := make([]byte, 1024)
    n, err := file.Read(data)
    if err != nil {
        return fmt.Errorf("failed to read %s: %w", path, err)
    }

    // 处理数据
    if err := parse(data[:n]); err != nil {
        return fmt.Errorf("failed to parse %s: %w", path, err)
    }

    return nil
}

func main() {
    if err := processFile("data.txt"); err != nil {
        fmt.Println("Error:", err)
    }
}
```
</UniversalEditor>

### 数据库操作

<UniversalEditor title="数据库操作">
```python !! py
# Python - 带异常的数据库
class UserNotFound(Exception):
    pass

class DatabaseError(Exception):
    pass

def get_user(db, id):
    try:
        cursor = db.cursor()
        cursor.execute("SELECT * FROM users WHERE id = ?", (id,))
        result = cursor.fetchone()
        if not result:
            raise UserNotFound(f"User {id} not found")
        return User(result)
    except sqlite3.Error as e:
        raise DatabaseError(f"Database error: {e}")
```

```go !! go
// Go - 带错误的数据库
package main

import (
    "database/sql"
    "errors"
    "fmt"
)

var (
    ErrUserNotFound = errors.New("user not found")
    ErrDatabase     = errors.New("database error")
)

func getUser(db *sql.DB, id int) (*User, error) {
    var user User

    err := db.QueryRow(
        "SELECT id, name, email FROM users WHERE id = $1",
        id,
    ).Scan(&user.ID, &user.Name, &user.Email)

    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("user %d: %w", id, ErrUserNotFound)
    }
    if err != nil {
        return nil, fmt.Errorf("query user %d: %w", id, err)
    }

    return &user, nil
}

func main() {
    db, err := sql.Open("postgres", connString)
    if err != nil {
        panic(err)
    }
    defer db.Close()

    user, err := getUser(db, 123)
    if err != nil {
        if errors.Is(err, ErrUserNotFound) {
            fmt.Println("User not found")
        } else {
            fmt.Println("Database error:", err)
        }
        return
    }

    fmt.Printf("User: %+v\n", user)
}
```
</UniversalEditor>

### HTTP 客户端

<UniversalEditor title="带重试的 HTTP 客户端">
```python !! py
# Python - 带重试的 HTTP
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def fetch_with_retry(url, max_retries=3):
    session = requests.Session()
    retry = Retry(total=max_retries, backoff_factor=1)
    adapter = HTTPAdapter(max_retries=retry)
    session.mount('http://', adapter)

    try:
        response = session.get(url, timeout=5)
        response.raise_for_status()
        return response.json()
    except requests.RequestException as e:
        print(f"Request failed: {e}")
        return None
```

```go !! go
// Go - 带重试的 HTTP 客户端
package main

import (
    "context"
    "fmt"
    "io"
    "net/http"
    "time"
)

func fetchWithRetry(ctx context.Context, url string, maxRetries int) ([]byte, error) {
    var lastErr error

    for attempt := 0; attempt < maxRetries; attempt++ {
        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil {
            return nil, err
        }

        resp, err := http.DefaultClient.Do(req)
        if err != nil {
            lastErr = err
            time.Sleep(time.Duration(attempt+1) * time.Second)
            continue
        }

        defer resp.Body.Close()

        if resp.StatusCode == http.StatusOK {
            return io.ReadAll(resp.Body)
        }

        lastErr = fmt.Errorf("unexpected status: %d", resp.StatusCode)

        if resp.StatusCode >= 400 && resp.StatusCode < 500 {
            // 客户端错误，不要重试
            return nil, lastErr
        }

        // 服务器错误，重试
        time.Sleep(time.Duration(attempt+1) * time.Second)
    }

    return nil, fmt.Errorf("after %d attempts: %w", maxRetries, lastErr)
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    data, err := fetchWithRetry(ctx, "http://example.com", 3)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    fmt.Println("Data:", string(data))
}
```
</UniversalEditor>

## 总结

### 关键概念

1. **错误是值**：显式返回，不是抛出
2. **nil 意味着成功**：非 nil 错误表示失败
3. **始终检查错误**：立即显式处理
4. **添加上下文**：使用 fmt.Errorf 和 %w 包装错误
5. **哨兵错误**：定义错误变量用于比较
6. **自定义类型**：创建错误结构体以获得丰富错误数据
7. **errors.Is/As**：从链中检查和提取错误
8. **Panic 很罕见**：仅用于无法恢复的情况

### 常见模式

- **返回模式**：`(result, error)` - 错误是最后一个返回值
- **早期返回**：先检查错误，早期返回
- **错误包装**：`fmt.Errorf("context: %w", err)`
- **错误检查**：`errors.Is(err, ErrNotFound)`
- **类型断言**：`errors.As(err, &customErr)`
- **Defer 清理**：始终运行，即使 panic

### 最佳实践

1. 立即处理错误
2. 包装时添加上下文
3. 对已知情况使用哨兵错误
4. 不要忽略错误（少用 `_`）
5. 不要在库中 panic
6. Defer 清理操作
7. 检查 defer 函数中的错误
8. 使用 context 进行取消/超时

### 与 Python 的对比

| Python | Go |
|--------|-----|
| 异常向上冒泡 | 错误显式返回 |
| try/except 块 | if err != nil 检查 |
| 异常类型 | 错误值/类型 |
| raise Exception | return error |
| 签名中不可见 | 签名中可见 |
| 通过异常进行控制流 | 线性控制流 |

## 练习

1. 创建一个包含以下内容的自定义错误类型：
   - 错误代码
   - 错误消息
   - HTTP 状态码
   - IsRetryable() 方法

2. 实现重试逻辑：
   - 最大重试次数
   - 指数退避
   - 仅在临时错误时重试

3. 编写一个函数：
   - 打开文件
   - 读取内容
   - 解析数据
   - 在每一步正确包装错误

4. 创建错误聚合系统：
   - 收集多个错误
   - 很好地格式化它们
   - 检查特定错误是否在集合中

5. 实现基于 context 的取消：
   - 创建长时间运行的操作
   - 支持通过 context 取消
   - 取消时清理资源

## 下一步

下一模块：**Goroutines 和并发** - 摆脱 GIL 并学习强大的 Go 并发原语。
