---
title: "Module 16: Real-world Projects"
description: "Build complete projects to apply your Go knowledge"
---

## Introduction

Time to put everything together! This module presents complete, practical projects that demonstrate real-world Go development.

## Project 1: URL Shortener Service

Build a production-ready URL shortener with:
- RESTful API
- Database persistence
- Caching layer
- Metrics collection
- Docker deployment

### Architecture

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│  API Gateway    │
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
┌───────┐ ┌───────┐
│  API  │ │ Cache │
└───┬───┘ └───────┘
    │
    ▼
┌───────┐
│  DB   │
└───────┘
```

### Implementation

<UniversalEditor title="URL Shortener - Models">
```python !! py
# Python - Models
from dataclasses import dataclass
from datetime import datetime
import hashlib
import random
import string

@dataclass
class URL:
    id: int
    short_code: str
    original_url: str
    created_at: datetime
    clicks: int

def generate_short_code(url: str) -> str:
    # Generate random 6-character code
    chars = string.ascii_letters + string.digits
    return ''.join(random.choices(chars, k=6))
```

```go !! go
// Go - Models
package models

import "time"

type URL struct {
    ID          int       `json:"id"`
    ShortCode   string    `json:"short_code"`
    OriginalURL string    `json:"original_url"`
    CreatedAt   time.Time `json:"created_at"`
    Clicks      int       `json:"clicks"`
}

func GenerateShortCode() string {
    // Generate random 6-character code
    const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    b := make([]byte, 6)
    for i := range b {
        b[i] = chars[rand.Intn(len(chars))]
    }
    return string(b)
}
```
</UniversalEditor>

<UniversalEditor title="URL Shortener - API">
```python !! py
# Python - Flask API
from flask import Flask, request, jsonify, redirect
from datetime import datetime

app = Flask(__name__)

@app.route('/shorten', methods=['POST'])
def shorten():
    data = request.get_json()
    url = data.get('url')

    if not url:
        return jsonify({'error': 'URL required'}), 400

    short_code = generate_short_code(url)

    # Save to database
    url_obj = URL(
        id=1,
        short_code=short_code,
        original_url=url,
        created_at=datetime.now(),
        clicks=0
    )

    return jsonify({
        'short_url': f'https://short.ly/{short_code}'
    }), 201

@app.route('/<short_code>')
def redirect_url(short_code):
    # Lookup URL
    url_obj = get_url(short_code)

    if not url_obj:
        return jsonify({'error': 'Not found'}), 404

    # Increment clicks
    url_obj.clicks += 1

    return redirect(url_obj.original_url)
```

```go !! go
// Go - HTTP API
package main

import (
    "database/sql"
    "encoding/json"
    "fmt"
    "net/http"
    "time"

    _ "github.com/lib/pq"
)

type Server struct {
    db *sql.DB
}

func (s *Server) shortenHandler(w http.ResponseWriter, r *http.Request) {
    var req struct {
        URL string `json:"url"`
    }

    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    if req.URL == "" {
        http.Error(w, "URL required", http.StatusBadRequest)
        return
    }

    shortCode := GenerateShortCode()

    // Save to database
    var id int
    err := s.db.QueryRow(
        "INSERT INTO urls (short_code, original_url, created_at, clicks) VALUES ($1, $2, $3, $4) RETURNING id",
        shortCode, req.URL, time.Now(), 0,
    ).Scan(&id)

    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(map[string]string{
        "short_url": fmt.Sprintf("https://short.ly/%s", shortCode),
    })
}

func (s *Server) redirectHandler(w http.ResponseWriter, r *http.Request) {
    shortCode := r.URL.Path[1:] // Remove leading '/'

    var originalURL string
    err := s.db.QueryRow(
        "SELECT original_url FROM urls WHERE short_code = $1",
        shortCode,
    ).Scan(&originalURL)

    if err == sql.ErrNoRows {
        http.Error(w, "Not found", http.StatusNotFound)
        return
    } else if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // Increment clicks
    s.db.Exec("UPDATE urls SET clicks = clicks + 1 WHERE short_code = $1", shortCode)

    http.Redirect(w, r, originalURL, http.StatusMovedPermanently)
}
```
</UniversalEditor>

<UniversalEditor title="URL Shortener - Database">
```sql
-- Schema (same for both)
CREATE TABLE urls (
    id SERIAL PRIMARY KEY,
    short_code VARCHAR(10) UNIQUE NOT NULL,
    original_url TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    clicks INTEGER DEFAULT 0
);

CREATE INDEX idx_short_code ON urls(short_code);
```
</UniversalEditor>

## Project 2: WebSocket Chat Server

Real-time chat with multiple rooms:

<UniversalEditor title="WebSocket Chat">
```python !! py
# Python - FastAPI WebSockets
from fastapi import FastAPI, WebSocket
from typing import Dict

app = FastAPI()

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, list[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, room: str):
        await websocket.accept()
        if room not in self.active_connections:
            self.active_connections[room] = []
        self.active_connections[room].append(websocket)

    async def broadcast(self, message: str, room: str):
        for connection in self.active_connections.get(room, []):
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/{room}")
async def websocket_endpoint(websocket: WebSocket, room: str):
    await manager.connect(websocket, room)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.broadcast(f"User: {data}", room)
    except:
        manager.disconnect(websocket, room)
```

```go !! go
// Go - Gorilla WebSocket
package main

import (
    "log"
    "net/http"
    "sync"

    "github.com/gorilla/websocket"
)

type Hub struct {
    rooms map[string]*Room
    mu    sync.RWMutex
}

type Room struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub  *Hub
    room *Room
    conn *websocket.Conn
    send chan []byte
}

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true
    },
}

func NewHub() *Hub {
    return &Hub{
        rooms: make(map[string]*Room),
    }
}

func (h *Hub) GetRoom(roomName string) *Room {
    h.mu.Lock()
    defer h.mu.Unlock()

    if room, exists := h.rooms[roomName]; exists {
        return room
    }

    room := &Room{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }

    h.rooms[roomName] = room
    go room.run()

    return room
}

func (r *Room) run() {
    for {
        select {
        case client := <-r.register:
            r.clients[client] = true

        case client := <-r.unregister:
            if _, ok := r.clients[client]; ok {
                delete(r.clients, client)
                close(client.send)
            }

        case message := <-r.broadcast:
            for client := range r.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(r.clients, client)
                }
            }
        }
    }
}

func (h *Hub) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
    roomName := r.URL.Path[len("/ws/"):]
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Println(err)
        return
    }

    room := h.GetRoom(roomName)

    client := &Client{
        hub:  h,
        room: room,
        conn: conn,
        send: make(chan []byte, 256),
    }

    room.register <- client

    go client.writePump()
    go client.readPump()
}

func (c *Client) readPump() {
    defer func() {
        c.room.unregister <- c
        c.conn.Close()
    }()

    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            break
        }

        c.room.broadcast <- message
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()

    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }

            c.conn.WriteMessage(websocket.TextMessage, message)
        }
    }
}

func main() {
    hub := NewHub()

    http.HandleFunc("/ws/", hub.HandleWebSocket)

    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```
</UniversalEditor>

## Project 3: Task Queue System

Background job processing with Redis:

<UniversalEditor title="Task Queue">
```python !! py
# Python - Celery
from celery import Celery

app = Celery('tasks', broker='redis://localhost:6379')

@app.task
def process_image(image_path):
    # Process image
    result = resize_image(image_path)
    return result

# Usage
process_image.delay('/path/to/image.jpg')
```

```go !! go
// Go - Task queue with Redis
package main

import (
    "encoding/json"
    "fmt"
    "log"

    "github.com/go-redis/redis/v8"
    "golang.org/x/net/context"
)

type Task struct {
    ID   string                 `json:"id"`
    Type string                 `json:"type"`
    Data map[string]interface{} `json:"data"`
}

type Worker struct {
    redis   *redis.Client
    queues  []string
    handler func(Task) error
}

func NewWorker(redisAddr string, queues []string, handler func(Task) error) *Worker {
    rdb := redis.NewClient(&redis.Options{
        Addr:     redisAddr,
        Password: "",
        DB:       0,
    })

    return &Worker{
        redis:   rdb,
        queues:  queues,
        handler: handler,
    }
}

func (w *Worker) Start(ctx context.Context) error {
    for _, queue := range w.queues {
        go w.processQueue(ctx, queue)
    }

    <-ctx.Done()
    return nil
}

func (w *Worker) processQueue(ctx context.Context, queue string) {
    for {
        select {
        case <-ctx.Done():
            return

        default:
            // BRPOP with timeout
            result, err := w.redis.BRPop(ctx, queue, time.Second).Result()
            if err != nil {
                continue
            }

            if len(result) < 2 {
                continue
            }

            var task Task
            if err := json.Unmarshal([]byte(result[1]), &task); err != nil {
                log.Printf("Error unmarshaling task: %v", err)
                continue
            }

            log.Printf("Processing task: %s", task.ID)

            if err := w.handler(task); err != nil {
                log.Printf("Error processing task: %v", err)
            }
        }
    }
}

func enqueueTask(rdb *redis.Client, queue string, task Task) error {
    data, err := json.Marshal(task)
    if err != nil {
        return err
    }

    return rdb.LPush(context.Background(), queue, data).Err()
}

func main() {
    worker := NewWorker("localhost:6379", []string{"images", "emails"}, func(task Task) error {
        switch task.Type {
        case "process_image":
            imagePath := task.Data["path"].(string)
            return processImage(imagePath)

        case "send_email":
            email := task.Data["email"].(string)
            return sendEmail(email)

        default:
            return fmt.Errorf("unknown task type: %s", task.Type)
        }
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    if err := worker.Start(ctx); err != nil {
        log.Fatal(err)
    }
}
```
</UniversalEditor>

## Project 4: CLI Tool

Command-line tool for developers:

<UniversalEditor title="CLI Tool">
```python !! py
# Python - Click CLI
import click

@click.group()
def cli():
    """Developer tools"""
    pass

@cli.command()
@click.argument('name')
def create(name):
    """Create new project"""
    click.echo(f"Creating project: {name}")

@cli.command()
def status():
    """Show status"""
    click.echo("Status: OK")

if __name__ == '__main__':
    cli()
```

```go !! go
// Go - Cobra CLI
package main

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "devtool",
    Short: "Developer tools",
    Long:  "A collection of developer utilities",
}

var createCmd = &cobra.Command{
    Use:   "create [name]",
    Short: "Create new project",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        name := args[0]
        fmt.Printf("Creating project: %s\n", name)
        // Create project...
    },
}

var statusCmd = &cobra.Command{
    Use:   "status",
    Short: "Show status",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("Status: OK")
    },
}

func init() {
    rootCmd.AddCommand(createCmd)
    rootCmd.AddCommand(statusCmd)
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}
```
</UniversalEditor>

## Project 5: Microservices Logger

Centralized logging service:

<UniversalEditor title="Logger Microservice">
```go
// Go - Logger service
package main

import (
    "encoding/json"
    "io"
    "log"
    "net/http"
    "os"
    "sync"

    "github.com/go-redis/redis/v8"
)

type LogEntry struct {
    Level     string                 `json:"level"`
    Message   string                 `json:"message"`
    Service   string                 `json:"service"`
    Timestamp string                 `json:"timestamp"`
    Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

type Logger struct {
    mu   sync.Mutex
    file *os.File
}

func NewLogger(filename string) (*Logger, error) {
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }

    return &Logger{file: file}, nil
}

func (l *Logger) Log(entry LogEntry) error {
    l.mu.Lock()
    defer l.mu.Unlock()

    data, err := json.Marshal(entry)
    if err != nil {
        return err
    }

    _, err = l.file.Write(append(data, '\n'))
    return err
}

func (l *Logger) logHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    var entry LogEntry
    if err := json.NewDecoder(r.Body).Decode(&entry); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    if err := l.Log(entry); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // Also send to Redis for real-time viewing
    // redis.Publish(ctx, "logs", data)

    w.WriteHeader(http.StatusCreated)
}

func (l *Logger) streamHandler(w http.ResponseWriter, r *http.Request) {
    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming not supported", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")

    // Subscribe to Redis
    // pubsub := redis.Subscribe(ctx, "logs")

    for {
        // msg, err := pubsub.ReceiveMessage(ctx)
        // if err != nil {
        //     return
        // }

        // fmt.Fprintf(w, "data: %s\n\n", msg.Payload)
        fmt.Fprintf(w, "data: {\"level\": \"info\", \"message\": \"test\"}\n\n")
        flusher.Flush()
    }
}

func main() {
    logger, err := NewLogger("app.log")
    if err != nil {
        log.Fatal(err)
    }

    http.HandleFunc("/log", logger.logHandler)
    http.HandleFunc("/stream", logger.streamHandler)

    log.Println("Logger service starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```
</UniversalEditor>

## Summary

In this module, you learned to build:

1. **URL Shortener** - REST API with database
2. **WebSocket Chat** - Real-time communication
3. **Task Queue** - Background job processing
4. **CLI Tool** - Command-line interface
5. **Logger Service** - Microservices logging

## Project Best Practices

1. **Structure** - Organize code logically
2. **Error handling** - Always check errors
3. **Testing** - Write tests for critical paths
4. **Documentation** - Document your code
5. **Docker** - Containerize applications
6. **Monitoring** - Add metrics and logging
7. **Security** - Validate inputs, use HTTPS

## Final Exercises

1. Build the URL shortener completely
2. Add authentication to the chat server
3. Create a dashboard for the task queue
4. Extend the CLI tool with more commands
5. Deploy a project to Kubernetes

## Conclusion

You've completed the Python → Go learning path! You now have:
- Solid understanding of Go fundamentals
- Experience with Go's concurrency model
- Knowledge of web development in Go
- Skills to build production-ready services
- Best practices for idiomatic Go

Continue building projects and exploring Go's ecosystem. Happy coding!
