---
title: "模块 4: 结构体和接口"
description: "Go 面向对象编程方法，无需类"
---

## 简介

Go 没有类或继承。相反，它使用**结构体（struct）**来存储数据，使用**接口（interface）**来定义行为。这是一种更简单、更灵活的 OOP 方法，鼓励组合优于继承。

## 结构体基础

### 定义结构体

<UniversalEditor title="结构体 vs 类">
```python !! py
# Python - 带有 __init__ 的类
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hi, I'm {self.name}"

person = Person("Alice", 30)
print(person.greet())
```

```go !! go
// Go - 结构体
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func (p Person) Greet() string {
    return fmt.Sprintf("Hi, I'm %s", p.Name)
}

func main() {
    person := Person{Name: "Alice", Age: 30}
    fmt.Println(person.Greet())
}
```
</UniversalEditor>

### 结构体字段可见性

<UniversalEditor title="导出 vs 未导出字段">
```python !! py
# Python - 公共 vs 私有（约定）
class Person:
    def __init__(self, name, age, ssn):
        self.name = name      # 公共
        self._age = age        # 受保护（约定）
        self.__ssn = ssn      # 私有（名称改写）

    def get_age(self):
        return self._age
```

```go !! go
// Go - 导出 vs 未导出
package main

import "fmt"

type Person struct {
    Name   string  // 导出（首字母大写）
    age    int     // 未导出（小写）
    SSN    string  // 导出
}

func (p Person) GetAge() int {
    return p.age  // 可以在包内访问
}

func NewPerson(name string, age int, ssn string) Person {
    return Person{
        Name: name,
        age:  age,   // 可以设置未导出字段
        SSN:  ssn,
    }
}

func main() {
    p := NewPerson("Alice", 30, "123-45-6789")
    fmt.Println(p.Name)  // OK - 导出
    fmt.Println(p.GetAge())  // OK - 方法
    // fmt.Println(p.age)  // 错误：未导出
}
```
</UniversalEditor>

### 创建和初始化结构体

<UniversalEditor title="结构体创建方法">
```python !! py
# Python - 类实例化
class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

p1 = Point(1, 2)
p2 = Point(x=3, y=4)
p3 = Point()  # 默认值
p4 = Point(5)  # 部分（y=0）
```

```go !! go
// Go - 结构体创建
package main

import "fmt"

type Point struct {
    X int
    Y int
}

// 构造函数（惯用方式）
func NewPoint(x, y int) Point {
    return Point{X: x, Y: y}
}

// 带默认值的构造函数
func NewDefaultPoint() Point {
    return Point{X: 0, Y: 0}
}

func main() {
    p1 := Point{1, 2}           // 位置参数（顺序很重要）
    p2 := Point{X: 3, Y: 4}     // 命名字段
    p3 := Point{}               // 零值
    p4 := Point{X: 5}           // 部分（Y=0）
    p5 := NewPoint(6, 7)        // 构造函数
    p6 := NewDefaultPoint()     // 默认构造函数

    fmt.Println(p1, p2, p3, p4, p5, p6)
}
```
</UniversalEditor>

### 结构体标签

<UniversalEditor title="结构体标签">
```python !! py
# Python - 没有内置的结构体标签
# 会使用装饰器或类属性
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    @classmethod
    def from_dict(cls, data):
        return cls(data['name'], data['email'])
```

```go !! go
// Go - 结构体标签（元数据）
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    ID       int    `json:"id"`                    // JSON 键
    Name     string `json:"name"`                  // JSON 键
    Email    string `json:"email,omitempty"`       // 如果为空则省略
    Password string `json:"-"`                     // 从不在 JSON 中
    Internal string `json:"internal,internal"`     // 多个选项
    DBName   string `db:"user_name" json:"name"`  // 多个标签
}

func main() {
    user := User{
        ID:       1,
        Name:     "Alice",
        Email:    "alice@example.com",
        Password: "secret",
        Internal: "internal_data",
        DBName:   "alice_db",
    }

    // JSON 编码会遵守标签
    jsonBytes, _ := json.Marshal(user)
    fmt.Println(string(jsonBytes))
    // 输出: {"id":1,"name":"Alice","email":"alice@example.com","internal":"internal_data"}
}
```
</UniversalEditor>

### 匿名结构体

<UniversalEditor title="匿名结构体">
```python !! py
# Python - 没有匿名类（使用 namedtuple 或 dict）
from collections import namedtuple
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)

# 或者使用 dict
p = {'x': 1, 'y': 2}
```

```go !! go
// Go - 匿名结构体
package main

import "fmt"

func main() {
    // 匿名结构体字面量
    point := struct {
        X int
        Y int
    }{
        X: 1,
        Y: 2,
    }

    fmt.Println(point)

    // 匿名结构体切片
    people := []struct {
        Name string
        Age  int
    }{
        {"Alice", 30},
        {"Bob", 25},
    }

    for _, p := range people {
        fmt.Printf("%s is %d\n", p.Name, p.Age)
    }
}
```
</UniversalEditor>

## 组合优于继承

Go 使用组合而不是继承，这更加灵活：

### 基本组合

<UniversalEditor title="组合基础">
```python !! py
# Python - 继承
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        pass

class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)
        self.breed = breed

    def speak(self):
        return f"{self.name} says Woof!"

dog = Dog("Buddy", "Golden Retriever")
print(dog.speak())
print(dog.name)  # 继承
```

```go !! go
// Go - 组合
package main

import "fmt"

type Animal struct {
    Name string
}

func (a Animal) Speak() string {
    return fmt.Sprintf("%s makes a sound", a.Name)
}

type Dog struct {
    Animal  // 嵌入结构体（组合）
    Breed   string
}

func (d Dog) Speak() string {
    return fmt.Sprintf("%s says Woof!", d.Name)
}

func main() {
    dog := Dog{
        Animal: Animal{Name: "Buddy"},
        Breed:  "Golden Retriever",
    }

    fmt.Println(dog.Speak())
    fmt.Println(dog.Name)  // 直接访问嵌入字段（提升）
    fmt.Println(dog.Breed)

    // 也可以通过嵌入类型访问
    fmt.Println(dog.Animal.Name)
}
```
</UniversalEditor>

### 多重组合

<UniversalEditor title="多重组合">
```python !! py
# Python - 多重继承
class Flyable:
    def fly(self):
        return "Flying"

class Swimmable:
    def swim(self):
        return "Swimming"

class Duck(Flyable, Swimmable):
    def __init__(self, name):
        self.name = name

duck = Duck("Donald")
print(duck.fly())
print(duck.swim())
```

```go !! go
// Go - 多重组合
package main

import "fmt"

type Flyable struct{}

func (f Flyable) Fly() string {
    return "Flying"
}

type Swimmable struct{}

func (s Swimmable) Swim() string {
    return "Swimming"
}

type Duck struct {
    Flyable
    Swimmable
    Name string
}

func main() {
    duck := Duck{
        Name: "Donald",
    }

    fmt.Println(duck.Fly())
    fmt.Println(duck.Swim())
    fmt.Println(duck.Name)
}
```
</UniversalEditor>

### 方法解析和遮蔽

<UniversalEditor title="方法遮蔽">
```python !! py
# Python - MRO（方法解析顺序）
class A:
    def show(self):
        print("A")

class B(A):
    def show(self):
        print("B")

class C(B):
    pass

obj = C()
obj.show()  # 打印 "B"（先在 B 中找到）
```

```go !! go
// Go - 方法提升和遮蔽
package main

import "fmt"

type Animal struct {
    Name string
}

func (a Animal) Speak() string {
    return "Animal sound"
}

type Dog struct {
    Animal
    Breed string
}

// Dog 的 Speak 遮蔽了 Animal 的 Speak
func (d Dog) Speak() string {
    return "Woof!"
}

func main() {
    animal := Animal{Name: "Generic"}
    dog := Dog{
        Animal: Animal{Name: "Buddy"},
        Breed:  "Golden",
    }

    fmt.Println(animal.Speak())  // "Animal sound"
    fmt.Println(dog.Speak())      // "Woof!"（Dog 的方法）

    // 仍然可以通过嵌入字段调用 Animal 的方法
    fmt.Println(dog.Animal.Speak())  // "Animal sound"
}
```
</UniversalEditor>

## 接口

接口是隐式实现的——不需要显式的 "implements" 关键字。这是 Go 最强大的特性之一。

### 基本接口

<UniversalEditor title="隐式接口满足">
```python !! py
# Python - 鸭子类型（隐式）
class Duck:
    def quack(self):
        return "Quack!"

class Person:
    def quack(self):
        return "I'm quacking like a duck!"

def make_it_quack(thing):
    if hasattr(thing, 'quack'):
        print(thing.quack())

duck = Duck()
person = Person()

make_it_quack(duck)    # 可以工作
make_it_quack(person)  # 也可以工作！
```

```go !! go
// Go - 隐式接口
package main

import "fmt"

type Quacker interface {
    Quack() string
}

type Duck struct{}

func (d Duck) Quack() string {
    return "Quack!"
}

type Person struct{}

func (p Person) Quack() string {
    return "I'm quacking like a duck!"
}

func makeItQuack(q Quacker) {
    fmt.Println(q.Quack())
}

func main() {
    duck := Duck{}
    person := Person{}

    makeItQuack(duck)    // 可以工作
    makeItQuack(person)  // 也可以工作！

    // 类型自动满足接口
    // 不需要声明 "type Duck implements Quacker"
}
```
</UniversalEditor>

### 接口组合

<UniversalEditor title="接口组合">
```python !! py
# Python - 多个基类
class Reader:
    def read(self):
        pass

class Writer:
    def write(self, data):
        pass

class ReadWriter(Reader, Writer):
    pass
```

```go !! go
// Go - 接口组合
package main

import "fmt"

type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type ReadWriter interface {
    Reader  // 嵌入接口
    Writer  // 嵌入接口
}

// File 同时实现了 Read 和 Write
type File struct {
    name string
}

func (f File) Read(p []byte) (n int, err error) {
    // 实现
    return len(p), nil
}

func (f File) Write(p []byte) (n int, err error) {
    // 实现
    return len(p), nil
}

func process(rw ReadWriter) {
    buf := make([]byte, 1024)
    rw.Read(buf)
    rw.Write(buf)
}

func main() {
    file := File{name: "test.txt"}
    process(file)  // File 满足 ReadWriter
}
```
</UniversalEditor>

### 空接口

<UniversalEditor title="空接口">
```python !! py
# Python - 任意类型
def print_anything(value):
    print(value)
    print(type(value))

print_anything(42)
print_anything("hello")
print_anything([1, 2, 3])
```

```go !! go
// Go - 空接口（interface{}）
package main

import "fmt"

func printAnything(value interface{}) {
    fmt.Println(value)
    fmt.Printf("Type: %T\n", value)
}

func main() {
    printAnything(42)
    printAnything("hello")
    printAnything([]int{1, 2, 3})

    // 空接口可以容纳任何值
    var anything interface{}
    anything = 42
    anything = "hello"
    anything = []int{1, 2, 3}
}
```
</UniversalEditor>

### 空接口 - 使用时机

<UniversalEditor title="空接口最佳实践">
```go
// 避免：空接口当类型已知时
func process(data interface{}) {
    // data 是什么类型？不清楚！
    // 到处都需要类型断言
}

// 推荐：特定接口
func process(data []byte) {
    // 类型清晰
}

// 可以：空接口用于真正的异构数据
func printAll(items ...interface{}) {
    for _, item := range items {
        fmt.Println(item)
    }
}

// 可以：JSON 反序列化
var data map[string]interface{}
json.Unmarshal(jsonBytes, &data)

// 推荐：特定结构体
type Config struct {
    Host string `json:"host"`
    Port int    `json:"port"`
}
var config Config
json.Unmarshal(jsonBytes, &config)
```
</UniversalEditor>

## 类型断言和类型选择

### 类型断言

<UniversalEditor title="类型断言">
```python !! py
# Python - 类型检查
def process(value):
    if isinstance(value, int):
        print(f"Integer: {value}")
        return value * 2
    elif isinstance(value, str):
        print(f"String: {value}")
        return value.upper()
    elif isinstance(value, list):
        print(f"List: {value}")
        return len(value)
    else:
        print(f"Unknown type: {type(value)}")
        return None
```

```go !! go
// Go - 类型断言
package main

import (
    "fmt"
    "strings"
)

func process(value interface{}) interface{} {
    // 带逗号-ok 模式的类型断言
    if i, ok := value.(int); ok {
        fmt.Printf("Integer: %d\n", i)
        return i * 2
    }

    if s, ok := value.(string); ok {
        fmt.Printf("String: %s\n", s)
        return strings.ToUpper(s)
    }

    if lst, ok := value.([]int); ok {
        fmt.Printf("Int slice: %v\n", lst)
        return len(lst)
    }

    fmt.Printf("Unknown type: %T\n", value)
    return nil
}

// 不安全的类型断言（类型错误会 panic）
func double(value interface{}) int {
    return value.(int) * 2  // 如果 value 不是 int 会 panic
}

func main() {
    process(42)
    process("hello")
    process([]int{1, 2, 3})

    // 安全使用
    if i, ok := interface{}(42).(int); ok {
        fmt.Println("Double:", i*2)
    }
}
```
</UniversalEditor>

### 类型选择

<UniversalEditor title="类型选择">
```python !! py
# Python - 多个类型检查
def handle(value):
    if isinstance(value, int):
        return "integer"
    elif isinstance(value, str):
        return "string"
    elif isinstance(value, list):
        return "list"
    elif isinstance(value, dict):
        return "dict"
    else:
        return f"unknown: {type(value)}"
```

```go !! go
// Go - 类型选择
package main

import "fmt"

func handle(value interface{}) string {
    switch v := value.(type) {
    case int:
        return fmt.Sprintf("integer: %d", v)
    case string:
        return fmt.Sprintf("string: %s", v)
    case []int:
        return fmt.Sprintf("int slice: %v", v)
    case map[string]interface{}:
        return fmt.Sprintf("map: %d keys", len(v))
    case nil:
        return "nil value"
    default:
        return fmt.Sprintf("unknown: %T", v)
    }
}

func main() {
    fmt.Println(handle(42))
    fmt.Println(handle("hello"))
    fmt.Println(handle([]int{1, 2, 3}))
    fmt.Println(handle(map[string]interface{}{"a": 1}))
    fmt.Println(handle(nil))
}
```
</UniversalEditor>

### 多种情况的类型选择

<UniversalEditor title="类型选择多情况">
```go
// 一个 case 中多种类型
func process(value interface{}) string {
    switch v := value.(type) {
    case int, int8, int16, int32, int64:
        return "integer type"
    case uint, uint8, uint16, uint32, uint64:
        return "unsigned integer type"
    case float32, float64:
        return "float type"
    case string:
        return "string"
    case bool:
        return "boolean"
    default:
        return "other type"
    }
}
```
</UniversalEditor>

## 标准库接口

Go 标准库定义了许多有用的接口：

### Stringer 接口

<UniversalEditor title="Stringer 接口">
```python !! py
# Python - __str__ 和 __repr__
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Person(name={self.name})"

    def __repr__(self):
        return f"Person(name={self.name}, age={self.age})"

p = Person("Alice", 30)
print(p)      # 使用 __str__
print(repr(p)) # 使用 __repr__
```

```go !! go
// Go - Stringer 接口
package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

// Stringer 接口（类似 __str__）
func (p Person) String() string {
    return fmt.Sprintf("Person(name=%s)", p.Name)
}

func main() {
    person := Person{Name: "Alice", Age: 30}

    // fmt.Println 自动调用 String()
    fmt.Println(person)

    // String 也使用 String()
    fmt.Sprintf("%s", person)
}
```
</UniversalEditor>

### Error 接口

<UniversalEditor title="Error 接口">
```python !! py
# Python - Exception
class ValidationError(Exception):
    def __init__(self, message, field):
        self.message = message
        self.field = field

    def __str__(self):
        return f"{self.field}: {self.message}"

raise ValidationError("Invalid email", "email")
```

```go !! go
// Go - Error 接口
package main

import "fmt"

// Error 接口是内置的：
// type error interface {
//     Error() string
// }

type ValidationError struct {
    Message string
    Field   string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Message)
}

func validateEmail(email string) error {
    if email == "" {
        return ValidationError{
            Message: "cannot be empty",
            Field:   "email",
        }
    }
    return nil
}

func main() {
    if err := validateEmail(""); err != nil {
        fmt.Println(err)  // 自动调用 Error()
    }
}
```
</UniversalEditor>

### 其他常用接口

<UniversalEditor title="常用接口">
```go
// Reader 接口（io 包）
type Reader interface {
    Read(p []byte) (n int, err error)
}

// Writer 接口（io 包）
type Writer interface {
    Write(p []byte) (n int, err error)
}

// Closer 接口（io 包）
type Closer interface {
    Close() error
}

// ReadWriter 接口（组合）
type ReadWriter interface {
    Reader
    Writer
}

// ReadWriteCloser 接口
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```
</UniversalEditor>

## 接口最佳实践

### 接受接口，返回结构体

<UniversalEditor title="接口最佳实践">
```python !! py
# Python - 返回特定类型
def get_user():
    return User("Alice", 30)

# 接受鸭子类型接口
def process(obj):
    if hasattr(obj, 'process'):
        obj.process()
```

```go !! go
// Go - 接受接口，返回结构体
package main

// 好：返回具体类型
func NewUser(name string, age int) User {
    return User{Name: name, Age: age}
}

// 好：接受接口
func processUser(u UserInterface) {
    u.Process()
}

// 避免：返回接口（除非必要）
func getUser() UserInterface {  // 不要这样做
    return User{Name: "Alice"}
}

// 推荐：返回具体类型
func getUser() User {  // 应该这样做
    return User{Name: "Alice"}
}

// 例外：返回 nil 时返回接口
func findUser(id int) (User, error) {
    if id == 0 {
        return User{}, fmt.Errorf("invalid id")
    }
    // ...
}
```
</UniversalEditor>

### 小接口

<UniversalEditor title="小接口原则">
```go
// 好：小而专注的接口
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// 避免：大型、单体接口
type FileHandler interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
    Close() error
    Sync() error
    Stat() (os.FileInfo, error)
    // ... 更多方法
}

// 推荐：组合小接口
type ReadWriteCloser interface {
    Reader
    Writer
    io.Closer
}
```
</UniversalEditor>

### 接口 Nil 陷阱

<UniversalEditor title="接口 Nil 陷阱">
```go
// 小心 nil 接口值！
package main

import "fmt"

type MyError struct {
    Message string
}

func (e *MyError) Error() string {
    return e.Message
}

func returnsError() error {
    var p *MyError = nil
    return p  // 返回 nil 指针，但非 nil 接口！
}

func returnsErrorCorrect() error {
    var p *MyError = nil
    return nil  // 返回 nil 接口
}

func main() {
    err := returnsError()
    if err != nil {
        fmt.Println("Error is not nil!")
        // 这会打印！即使 p 是 nil！
        // 接口本身不是 nil
    }

    // 正确方式
    err2 := returnsErrorCorrect()
    if err2 != nil {
        fmt.Println("Error2 is not nil!")
    }
    // 这不会打印
}
```
</UniversalEditor>

## 指针接收者 vs 值接收者

### 何时使用每种

<UniversalEditor title="选择接收者类型">
```python !! py
# Python - 方法可以修改
class Counter:
    def __init__(self):
        self.count = 0

    def increment(self):
        self.count += 1  # 修改对象

    def get_count(self):
        return self.count

    def double(self):
        self.count *= 2  # 修改对象
```

```go !! go
// Go - 仔细选择接收者类型
package main

import "fmt"

type Counter struct {
    count int
}

// 值接收者 - 不能修改
// 使用场景：
// - 方法不需要修改
// - 结构体很小（复制成本低）
// - 一致性（如果所有方法都使用值）
func (c Counter) GetCount() int {
    return c.count
}

// 指针接收者 - 可以修改
// 使用场景：
// - 方法需要修改
// - 结构体很大（避免复制）
// - 一致性（如果任何方法使用指针）
func (c *Counter) Increment() {
    c.count++
}

// 即使对于大型结构体的只读方法，
// 也使用指针来避免复制
func (c *Counter) Double() {
    c.count *= 2
}

// 对于小型不可变值，值接收者可以
type Point struct {
    X, Y int
}

func (p Point) Distance() int {
    return p.X*p.X + p.Y*p.Y
}

func main() {
    counter := Counter{count: 0}
    counter.Increment()
    counter.Double()
    fmt.Println(counter.GetCount())  // 2
}
```
</UniversalEditor>

### 接收者类型指南

<UniversalEditor title="接收者指南">
```go
// 指南 1：如果方法需要修改则使用指针接收者
func (c *Counter) Increment() {
    c.count++
}

// 指南 2：大型结构体使用指针接收者
type BigStruct struct {
    data [1024]int
}

func (b *BigStruct) Process() {
    // 避免复制 1024 个 int
}

// 指南 3：小型不可变值使用值接收者
type Point struct {
    X, Y int
}

func (p Point) String() string {
    return fmt.Sprintf("(%d, %d)", p.X, p.Y)
}

// 指南 4：保持一致 - 不要混合接收者类型
// 不好：混合接收者
type MyStruct struct {
    value int
}

func (m MyStruct) GetValue() int {
    return m.value
}

func (m *MyStruct) SetValue(v int) {
    m.value = v
}

// 好：所有指针接收者
func (m *MyStruct) GetValue() int {
    return m.value
}

func (m *MyStruct) SetValue(v int) {
    m.value = v
}
```
</UniversalEditor>

## 实际示例

### JSON 编码/解码

<UniversalEditor title="JSON 和结构体">
```python !! py
# Python - JSON 序列化
import json

class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def to_dict(self):
        return {
            'name': self.name,
            'email': self.email
        }

    @classmethod
    def from_dict(cls, data):
        return cls(data['name'], data['email'])

user = User("Alice", "alice@example.com")
json_str = json.dumps(user.to_dict())
parsed = User.from_dict(json.loads(json_str))
```

```go !! go
// Go - JSON 和结构体标签
package main

import (
    "encoding/json"
    "fmt"
)

type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age,omitempty"`  // 如果为零值则省略
}

func main() {
    // 编码
    user := User{
        Name:  "Alice",
        Email: "alice@example.com",
    }

    jsonBytes, err := json.Marshal(user)
    if err != nil {
        panic(err)
    }
    fmt.Println(string(jsonBytes))
    // {"name":"Alice","email":"alice@example.com"}

    // 解码
    var parsed User
    if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
        panic(err)
    }
    fmt.Printf("%+v\n", parsed)
}
```
</UniversalEditor>

### 数据库模型

<UniversalEditor title="数据库模型">
```python !! py
# Python - SQLAlchemy 模型
from sqlalchemy import Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    id = Column(Integer, primary_key=True)
    name = Column(String(100))
    email = Column(String(200))
```

```go !! go
// Go - 带结构体标签的数据库模型
package main

type User struct {
    ID        int       `json:"id" db:"id"`
    Name      string    `json:"name" db:"name"`
    Email     string    `json:"email" db:"email"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// 表名映射
func (User) TableName() string {
    return "users"
}

// 自定义类型的 Scanner 和 Valuer
type NullString struct {
    String string
    Valid  bool
}

func (ns *NullString) Scan(value interface{}) error {
    if value == nil {
        ns.String, ns.Valid = "", false
        return nil
    }
    ns.Valid = true
    return nil
}
```
</UniversalEditor>

## 总结

在本模块中，你学习了：

1. **结构体** - Go 的类替代品
2. **字段可见性** - 导出 vs 未导出
3. **结构体标签** - JSON、数据库等元数据
4. **匿名结构体** - 快速、一次性结构
5. **组合** - 优于继承
6. **多重组合** - 组合多个类型
7. **方法提升** - 访问嵌入方法
8. **接口** - 隐式实现，灵活
9. **空接口** - 容纳任何值（小心使用）
10. **类型断言** - 检查和转换类型
11. **类型选择** - 类型切换
12. **标准接口** - Stringer、Error、Reader、Writer
13. **接口最佳实践** - 小而专注的接口
14. **接收者类型** - 指针 vs 值
15. **Nil 接口陷阱** - 接口 vs 具体 nil

## 与 Python 的主要区别

| Python | Go |
|--------|-----|
| 类和继承 | 结构体和组合 |
| `__init__` 初始化 | 结构体字面量或构造函数 |
| 通过 `__` 前缀私有 | 未导出（小写） |
| `self` 参数 | 接收者参数 |
| 魔术方法（`__str__`、`__eq__`） | 接口（Stringer 等） |
| 鸭子类型（运行时） | 接口（编译时 + 鸭子类型） |
| 多重继承 | 组合 + 接口组合 |
| `isinstance()` 检查 | 类型断言和类型选择 |

## 最佳实践

1. **优先使用组合**而非继承
2. **保持接口小** - 1-2 个方法最理想
3. **接受接口，返回结构体** - 返回值要具体
4. **使用指针接收者**当需要修改或结构体较大时
5. **保持一致**接收者类型
6. **使用结构体标签**作为序列化元数据
7. **避免空接口**除非真正必要
8. **小心 nil 接口** - 理解陷阱
9. **嵌入用于组合** - 提升字段/方法
10. **实现标准接口** - Stringer、Error 等

## 练习

1. 创建一个带有导出和未导出字段的结构体
2. 在自定义类型上实现 Stringer 接口
3. 使用组合来组合多个结构体
4. 编写类型选择来处理不同类型
5. 创建指针接收者和值接收者并比较行为
6. 使用标签实现自定义 JSON 编组
7. 创建一个接口并让多个类型满足它
8. 使用结构体标签构建小型数据库模型

## 下一步

下一模块：**包管理** - 理解 Go 模块和导入。
