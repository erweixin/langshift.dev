---
title: "模組 2:控制流和迴圈"
description: "掌握 Go 的控制流構造,與 Python 對比"
---

## 簡介

本模組涵蓋 Go 中的控制流,包括迴圈、條件語句和 switch。雖然 Python 強調「只有一種顯而易見的方式」,但 Go 提供了顯式的構造,使程式碼清晰且可預測。

## 迴圈:唯一的迴圈 - For

Python 有 `for` 和 `while` 迴圈。**Go 只有 `for`**,但它足夠通用,可以處理所有迴圈場景。

### 基本 For 迴圈

<UniversalEditor title="基本迴圈對比">
```python !! py
# Python - While 迴圈
i = 0
while i < 5:
    print(i)
    i += 1

# Python - 帶 range 的 For 迴圈
for i in range(5):
    print(i)

# Python - 遍歷可迭代物件的 For 迴圈
items = ["a", "b", "c"]
for item in items:
    print(item)
```

```go !! go
// Go - 都使用 for 迴圈
package main

import "fmt"

func main() {
    // While 風格迴圈
    i := 0
    for i < 5 {
        fmt.Println(i)
        i++
    }

    // 傳統 for 迴圈
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }

    // 遍歷 slice
    items := []string{"a", "b", "c"}
    for i, item := range items {
        fmt.Printf("%d: %s\n", i, item)
    }

    // 使用 _ 忽略索引
    for _, item := range items {
        fmt.Println(item)
    }
}
```
</UniversalEditor>

### 無限迴圈

<UniversalEditor title="無限迴圈">
```python !! py
# Python - 無限迴圈
while True:
    print("Running...")
    if should_stop():
        break
```

```go !! go
// Go - 無限迴圈
for {
    fmt.Println("Running...")
    if shouldStop() {
        break
    }
}
```
</UniversalEditor>

### 遍歷映射

<UniversalEditor title="遍歷映射">
```python !! py
# Python - 字典迭代
person = {"name": "Alice", "age": 30, "city": "NYC"}

# 鍵
for key in person:
    print(key)

# 鍵和值
for key, value in person.items():
    print(f"{key}: {value}")
```

```go !! go
// Go - 映射迭代
package main

import "fmt"

func main() {
    person := map[string]string{
        "name": "Alice",
        "age":  "30",
        "city": "NYC",
    }

    // 鍵和值 (Go 中唯一的方式)
    for key, value := range person {
        fmt.Printf("%s: %s\n", key, value)
    }

    // 僅鍵
    for key := range person {
        fmt.Println(key)
    }
}
```
</UniversalEditor>

### 遍歷字串

<UniversalEditor title="字串迭代">
```python !! py
# Python - 字串迭代
text = "Hello"
for char in text:
    print(char)

for i, char in enumerate(text):
    print(f"{i}: {char}")
```

```go !! go
// Go - 字串迭代 (按 rune)
package main

import "fmt"

func main() {
    text := "Hello"

    // 按 rune (字元)
    for i, rune := range text {
        fmt.Printf("%d: %c\n", i, rune)
    }

    // 僅 rune
    for _, rune := range text {
        fmt.Printf("%c\n", rune)
    }
}
```
</UniversalEditor>

### 迴圈控制:Break 和 Continue

<UniversalEditor title="Break 和 Continue">
```python !! py
# Python - Break 和 continue
for i in range(10):
    if i == 3:
        continue  # 跳過 3
    if i == 7:
        break     # 在 7 處停止
    print(i)
# 輸出: 0, 1, 2, 4, 5, 6
```

```go !! go
// Go - Break 和 continue (與 Python 相同)
package main

import "fmt"

func main() {
    for i := 0; i < 10; i++ {
        if i == 3 {
            continue  // 跳過 3
        }
        if i == 7 {
            break     // 在 7 處停止
        }
        fmt.Println(i)
    }
    // 輸出: 0, 1, 2, 4, 5, 6
}
```
</UniversalEditor>

## If 語句

### 基本 If

<UniversalEditor title="基本 If">
```python !! py
# Python - If 語句
age = 20

if age >= 18:
    print("Adult")
elif age >= 13:
    print("Teenager")
else:
    print("Child")
```

```go !! go
// Go - If 語句
package main

import "fmt"

func main() {
    age := 20

    if age >= 18 {
        fmt.Println("Adult")
    } else if age >= 13 {
        fmt.Println("Teenager")
    } else {
        fmt.Println("Child")
    }
}
```
</UniversalEditor>

### 帶初始化的 If

<UniversalEditor title="帶初始化的 If">
```python !! py
# Python 3.8+ - 海象運算子
if (n := len(items)) > 10:
    print(f"Too many: {n}")
```

```go !! go
// Go - 帶初始化的 If
package main

import "fmt"

func main() {
    items := []int{1, 2, 3, 4, 5}

    // 變數作用域限定在 if 區塊
    if n := len(items); n > 10 {
        fmt.Printf("Too many: %d\n", n)
    } else {
        fmt.Printf("Count: %d\n", n)
    }
    // n 在這裡不可存取
}
```
</UniversalEditor>

### 帶多個條件的 If

<UniversalEditor title="多個條件">
```python !! py
# Python - 邏輯運算子
age = 25
has_id = True

if age >= 18 and has_id:
    print("Can enter")

if age < 18 or not has_id:
    print("Cannot enter")
```

```go !! go
// Go - 邏輯運算子 (不同語法)
package main

import "fmt"

func main() {
    age := 25
    hasID := true

    if age >= 18 && hasID {
        fmt.Println("Can enter")
    }

    if age < 18 || !hasID {
        fmt.Println("Cannot enter")
    }
}
```
</UniversalEditor>

## Switch 語句

Go 的 switch 比 Python 的 if-elif 鏈更強大:

<UniversalEditor title="Switch 語句">
```python !! py
# Python - 無 switch 語句 (3.10 之前),使用 if-elif
grade = "B"

if grade == "A":
    print("Excellent")
elif grade == "B":
    print("Good")
elif grade == "C":
    print("Average")
else:
    print("Need improvement")

# Python 3.10+ - Match 語句
match grade:
    case "A":
        print("Excellent")
    case "B":
        print("Good")
    case "C":
        print("Average")
    case _:
        print("Need improvement")
```

```go !! go
// Go - Switch 語句 (不需要 break!)
package main

import "fmt"

func main() {
    grade := "B"

    switch grade {
    case "A":
        fmt.Println("Excellent")
    case "B":
        fmt.Println("Good")
    case "C":
        fmt.Println("Average")
    default:
        fmt.Println("Need improvement")
    }

    // 帶多個值的 switch
    day := 3
    switch day {
    case 1, 2, 3, 4, 5:
        fmt.Println("Weekday")
    case 6, 7:
        fmt.Println("Weekend")
    }

    // 無條件的 switch (類似 if-else)
    switch {
    case age < 13:
        fmt.Println("Child")
    case age < 18:
        fmt.Println("Teenager")
    default:
        fmt.Println("Adult")
    }
}
```
</UniversalEditor>

### 帶初始化的 Switch

<UniversalEditor title="帶初始化的 Switch">
```python !! py
# Python
num = 42
if num % 2 == 0:
    print("Even")
else:
    print("Odd")
```

```go !! go
// Go - 帶初始化的 Switch
package main

import "fmt"

func main() {
    switch num := 42; num % 2 {
    case 0:
        fmt.Println("Even")
    case 1:
        fmt.Println("Odd")
    }
}
```
</UniversalEditor>

## Defer (Go 獨有)

`defer` 在包圍函式完成後執行語句。用於清理:

<UniversalEditor title="Defer 語句">
```python !! py
# Python - try-finally
file = None
try:
    file = open("data.txt", "r")
    data = file.read()
    process(data)
finally:
    if file:
        file.close()

# Python - 上下文管理器 (首選)
with open("data.txt", "r") as file:
    data = file.read()
    process(data)
# 自動關閉
```

```go !! go
// Go - Defer
package main

import "fmt"

func processData() {
    // 延遲到函式返回時執行
    defer fmt.Println("Cleanup: Closing resources")

    fmt.Println("Step 1: Opening file")
    fmt.Println("Step 2: Reading data")
    fmt.Println("Step 3: Processing")

    // 輸出順序:
    // Step 1
    // Step 2
    // Step 3
    // Cleanup: Closing resources
}

func main() {
    // 多個 defer (LIFO 順序)
    defer fmt.Println("Third")
    defer fmt.Println("Second")
    defer fmt.Println("First")

    processData()
}
```
</UniversalEditor>

### 用於檔案操作的 Defer

<UniversalEditor title="檔案操作的 Defer">
```python !! py
# Python - 上下文管理器
def read_file(filename):
    with open(filename, 'r') as f:
        return f.read()
```

```go !! go
// Go - Defer 用於清理
package main

import (
    "fmt"
    "os"
)

func readFile(filename string) ([]byte, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    // 總是關閉,即使發生錯誤
    defer file.Close()

    data := make([]byte, 100)
    n, err := file.Read(data)
    if err != nil {
        return nil, err
    }

    return data[:n], nil
}

func main() {
    data, err := readFile("data.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println(string(data))
}
```
</UniversalEditor>

## 常見模式

### 迴圈直到條件

<UniversalEditor title="迴圈直到條件">
```python !! py
# Python
while True:
    line = read_line()
    if not line:
        break
    process(line)
```

```go !! go
// Go
for {
    line := readLine()
    if line == "" {
        break
    }
    process(line)
}
```
</UniversalEditor>

### 提前返回

<UniversalEditor title="提前返回">
```python !! py
# Python
def validate(data):
    if not data:
        return False

    if len(data) < 10:
        return False

    if "invalid" in data:
        return False

    return True
```

```go !! go
// Go - 慣用的提前返回
func validate(data string) bool {
    if data == "" {
        return false
    }

    if len(data) < 10 {
        return false
    }

    if strings.Contains(data, "invalid") {
        return false
    }

    return true
}
```
</UniversalEditor>

## 總結

在本模組中,你學習了:

1. **Go 只有 `for` 迴圈** - 足夠通用以應對所有場景
2. **沒有 `while`** - 使用僅帶條件的 `for`
3. **基於 range 的迭代** 遍歷陣列、切片、映射、字串
4. **帶初始化的 If** - 作用域受限的變數
5. **Switch 語句** - 不需要 `break`,比 Python 的更強大
6. **Defer** - 在函式完成後執行 (LIFO 順序)
7. **提前返回** - Go 中的慣用模式

## 與 Python 的主要差異

| Python | Go |
|--------|-----|
| `while`, `for` 迴圈 | 只有 `for` 迴圈 |
| `for i in range()` | `for i := 0; i < n; i++` |
| `for item in items` | `for _, item := range items` |
| `elif` | `else if` |
| `and`, `or`, `not` | `&&`, `\|\|`, `!` |
| `with` 語句 | `defer` 關鍵字 |
| 無 `switch` (3.10 之前) | 強大的 `switch` |

## 練習

1. 撰寫一個使用 `defer` 測量函式執行時間的函式
2. 建立一個處理多個情況的 switch 語句
3. 使用 `range` 遍歷映射並列印鍵值對
4. 實作驗證的提前返回模式
5. 使用帶初始化、條件和後置語句的 `for`

## 下一步

下一模組:**函式和方法** - 學習 Go 的函式宣告、多返回值、閉包和方法。
