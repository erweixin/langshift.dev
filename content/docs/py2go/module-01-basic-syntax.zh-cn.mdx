---
title: "模块 1:基础语法对比"
description: "学习 Python 和 Go 语法之间的基本差异"
---

## 简介

在本模块中,我们将对比 Python 和 Go 的基础语法。理解这些差异对于从 Python 的动态解释型特性转向 Go 的静态编译型方法至关重要。

## 变量声明

### Python: 动态类型

Python 使用动态类型 - 变量可以持有任何类型:

```python
# Python - 无需类型声明
name = "Alice"
age = 25
price = 19.99
is_active = True
items = [1, 2, 3]

# 类型可以改变
x = 10
x = "now a string"  # 在 Python 中完全有效
```

### Go: 带类型推断的静态类型

Go 需要类型,但可以推断它们:

<UniversalEditor title="变量声明">
```python !! py
# Python - 动态类型
name = "Alice"
age = 25
price = 19.99
is_active = True
items = [1, 2, 3]
```

```go !! go
// Go - 带类型推断的静态类型
var name string = "Alice"      // 完整声明
var age = 25                   // 类型推断 (int)
price := 19.99                 // 短变量声明 (最常用)
is_active := true              // 类型推断 (bool)
var items []int = []int{1, 2, 3}  // slice

// 不能改变类型
// age = "now a string"  // 编译错误!
```
</UniversalEditor>

### 变量声明风格

<UniversalEditor title="变量声明风格">
```python !! py
# Python - 一种方式
x = 10
y = "hello"
z = 3.14
```

```go !! go
// Go - 三种方式

// 1. 完整声明
var x int = 10

// 2. 类型推断
var y = "hello"

// 3. 短变量声明 (最常用,仅在函数内)
z := 3.14

// 多个变量
var a, b, c int = 1, 2, 3
name, age := "Bob", 30

// 块声明 (用于包级别)
var (
    port    int    = 8080
    host    string = "localhost"
    debug   bool   = false
)
```
</UniversalEditor>

## 常量

<UniversalEditor title="常量">
```python !! py
# Python - 常量 (约定,不强制)
MAX_CONNECTIONS = 100
API_KEY = "secret"
DEBUG = True

# 实际上可以修改 (但不应该)
MAX_CONNECTIONS = 200  # 可以工作但违反约定
```

```go !! go
// Go - 真正的常量 (编译时)
const MaxConnections = 100
const APIKey = "secret"
const Debug = false

// 不能被修改
// MaxConnections = 200  // 编译错误!

// 多个常量
const (
    StatusOK       = 200
    StatusNotFound = 404
    StatusError    = 500
)
```
</UniversalEditor>

## 基本类型

<UniversalEditor title="基本类型对比">
```python !! py
# Python - 内置类型
int_num = 42              # int (无限精度)
float_num = 3.14          # float
text = "hello"            # str
is_true = True            # bool
byte_data = b"bytes"      # bytes

# 复合类型
numbers = [1, 2, 3]       # list (可变)
coords = (1, 2)           # tuple (不可变)
```

```go !! go
// Go - 基本类型
var intNum int = 42               // int (平台相关,通常 64 位)
var floatNum float64 = 3.14       // float64
var text string = "hello"         // string
var isTrue bool = true            // bool
var byteData []byte = []byte("bytes")  // byte slice

// 复合类型
var numbers []int = []int{1, 2, 3}  // slice (动态数组)
var coords [2]int = [2]int{1, 2}    // array (固定大小)

// 特定数值类型
var i8 int8 = 127                   // 8 位整数
var i16 int16 = 32767               // 16 位整数
var i32 int32 = 2147483647          // 32 位整数
var i64 int64 = 9223372036854775807 // 64 位整数
var f32 float32 = 3.14              // 32 位浮点
var u8 uint8 = 255                  // 8 位无符号
```
</UniversalEditor>

## 字符串

<UniversalEditor title="字符串操作">
```python !! py
# Python - 字符串操作
text = "Hello, World!"

# 长度
print(len(text))  # 13

# 拼接
greeting = text + " How are you?"
print(greeting)  # Hello, World! How are you?

# 字符串格式化
name = "Alice"
age = 25
print(f"Name: {name}, Age: {age}")
print("Name: {}, Age: {}".format(name, age))

# 子字符串 (切片)
print(text[0:5])   # Hello
print(text[7:])    # World!
print(text[-6:])   # World!

# 多行字符串
multiline = """
This is a
multiline string
"""
```

```go !! go
// Go - 字符串操作
package main

import (
    "fmt"
    "strings"
)

func main() {
    text := "Hello, World!"

    // 长度
    fmt.Println(len(text))  // 13 (字节数)
    fmt.Println(len([]rune(text)))  // 13 (字符/rune 数)

    // 拼接
    greeting := text + " How are you?"
    fmt.Println(greeting)  // Hello, World! How are you?

    // 字符串格式化
    name := "Alice"
    age := 25
    fmt.Printf("Name: %s, Age: %d\n", name, age)
    fmt.Printf("Name: %v, Age: %v\n", name, age)

    // 子字符串 (切片)
    fmt.Println(text[0:5])   // Hello
    fmt.Println(text[7:])    // World!
    // Go 中没有负数索引

    // 多行字符串
    multiline := `
This is a
multiline string
`

    // 字符串方法
    fmt.Println(strings.ToUpper(text))  // HELLO, WORLD!
    fmt.Println(strings.Contains(text, "World"))  // true
    fmt.Println(strings.Replace(text, "World", "Go", 1))  // Hello, Go!
}
```
</UniversalEditor>

## 零值

在 Go 中,每个类型都有"零值" - 未初始化时的默认值:

<UniversalEditor title="零值">
```python !! py
# Python - 变量必须初始化
x = None  # 显式 None
y = 0     # 初始化为 0
z = ""    # 初始化为空字符串

# 没有默认值
def my_function():
    a  # 错误:局部变量在赋值前被引用
```

```go !! go
// Go - 零值
var x int       // 0
var y float64   // 0
var z string    // "" (空字符串)
var b bool      // false
var s []int     // nil (nil slice)

// 可以工作 - 变量有默认值
func myFunction() {
    var a int
    fmt.Println(a)  // 打印 0
}
```
</UniversalEditor>

## 注释

<UniversalEditor title="注释">
```python !! py
# Python - 注释
# 单行注释

"""
多行注释
(docstring)
"""

# 函数文档
def add(a, b):
    """Add two numbers together."""
    return a + b
```

```go !! go
// Go - 注释
// 单行注释

/* 多行
   注释 */

// 包文档 (出现在 package 子句之前)
// Package main demonstrates basic Go syntax
package main

// 函数文档
// Add adds two numbers together and returns the result.
func Add(a int, b int) int {
    return a + b
}
```
</UniversalEditor>

## 类型转换

<UniversalEditor title="类型转换">
```python !! py
# Python - 自动类型转换
x = 10
y = 3.14
result = x + y  # 13.14 (float)
text = "Value: " + str(x)  # 字符串需要显式转换
```

```go !! go
// Go - 无自动转换 (必须显式)
package main

import "fmt"

func main() {
    var x int = 10
    var y float64 = 3.14

    // 错误:不能混合类型
    // result := x + y  // 编译错误!

    // 必须显式转换
    result := float64(x) + y
    fmt.Println(result)  // 13.14

    // 字符串转换
    text := "Value: " + fmt.Sprintf("%d", x)
    fmt.Println(text)  // Value: 10

    // 使用 strconv 包
    import "strconv"
    numStr := strconv.Itoa(x)
    fmt.Println(numStr)  // "10"
}
```
</UniversalEditor>

## 指针 (Python 开发者的新概念)

Go 有指针 - Python 不暴露它们:

<UniversalEditor title="指针">
```python !! py
# Python - 一切都是引用
def modify_list(lst):
    lst.append(4)  # 修改原始列表

numbers = [1, 2, 3]
modify_list(numbers)
print(numbers)  # [1, 2, 3, 4]

# 但整数是不可变的
def increment(x):
    x += 1  # 创建新的局部变量

num = 10
increment(num)
print(num)  # 10 (未改变)
```

```go !! go
// Go - 显式指针
package main

import "fmt"

func modifySlice(slice []int) {
    slice = append(slice, 4)  // 修改 slice
}

func incrementByPointer(x *int) {
    *x++  // 解引用并递增
}

func main() {
    // Slice 已经是引用
    numbers := []int{1, 2, 3}
    modifySlice(numbers)
    fmt.Println(numbers)  // [1, 2, 3, 4]

    // 对值类型使用指针
    num := 10
    incrementByPointer(&num)  // 传递地址
    fmt.Println(num)  // 11 (已改变!)

    // 指针语法
    x := 42
    p := &x     // p 是 x 的指针 (类型 *int)
    fmt.Println(*p)  // 42 (解引用)
    *p = 100      // 通过指针修改 x
    fmt.Println(x)  // 100
}
```
</UniversalEditor>

## 数组和切片

<UniversalEditor title="数组 vs 切片">
```python !! py
# Python - 列表 (动态数组)
numbers = [1, 2, 3, 4, 5]
numbers.append(6)           # 添加元素
numbers.extend([7, 8])      # 添加多个
mixed = [1, "hello", 3.14]  # 混合类型 (允许)
sliced = numbers[1:4]       # 切片
```

```go !! go
// Go - 数组 (固定) 和切片 (动态)
package main

import "fmt"

func main() {
    // 数组 - 固定大小
    var arr [5]int = [5]int{1, 2, 3, 4, 5}
    // arr[5] = 6  // 错误:索引越界

    // 切片 - 动态 (主要使用这个)
    numbers := []int{1, 2, 3, 4, 5}
    numbers = append(numbers, 6)      // 添加元素
    numbers = append(numbers, 7, 8)   // 添加多个

    // Go 中不能混合类型
    // mixed := []interface{}{1, "hello", 3.14}  // 需要 interface{}

    // 切片
    sliced := numbers[1:4]  // [2 3 4]

    // 创建带容量的切片
    nums := make([]int, 0, 10)  // 长度=0, 容量=10
    nums = append(nums, 1, 2, 3)

    fmt.Println(nums)
}
```
</UniversalEditor>

## 映射 (字典)

<UniversalEditor title="映射/字典">
```python !! py
# Python - 字典
person = {
    "name": "Alice",
    "age": 30,
    "city": "NYC"
}

# 访问
print(person["name"])  # Alice
print(person.get("country", "Unknown"))  # Unknown (默认值)

# 修改
person["age"] = 31
person["country"] = "USA"

# 删除
del person["city"]

# 迭代
for key, value in person.items():
    print(f"{key}: {value}")
```

```go !! go
// Go - 映射
package main

import "fmt"

func main() {
    // 创建映射
    person := map[string]interface{}{
        "name": "Alice",
        "age": 30,
        "city": "NYC",
    }

    // 访问
    fmt.Println(person["name"])  // Alice
    country, exists := person["country"]
    if !exists {
        country = "Unknown"
    }
    fmt.Println(country)  // Unknown

    // 修改
    person["age"] = 31
    person["country"] = "USA"

    // 删除
    delete(person, "city")

    // 迭代
    for key, value := range person {
        fmt.Printf("%v: %v\n", key, value)
    }

    // 类型化映射 (更好)
    ages := map[string]int{
        "Alice": 30,
        "Bob":   25,
    }
}
```
</UniversalEditor>

## 运算符

<UniversalEditor title="运算符对比">
```python !! py
# Python - 运算符
a, b = 10, 3

# 算术
print(a + b)   # 13 (加法)
print(a - b)   # 7  (减法)
print(a * b)   # 30 (乘法)
print(a / b)   # 3.333... (真除法)
print(a // b)  # 3  (整除)
print(a % b)   # 1  (取模)
print(a ** b)  # 1000 (幂)

# 比较
print(a == b)  # False
print(a != b)  # True
print(a > b)   # True
print(a >= b)  # True

# 逻辑
print(a > 5 and b < 5)  # True
print(a > 5 or b > 5)   # True
print(not (a == b))     # True
```

```go !! go
// Go - 运算符
package main

import (
    "fmt"
    "math"
)

func main() {
    a, b := 10, 3

    // 算术
    fmt.Println(a + b)    // 13 (加法)
    fmt.Println(a - b)    // 7  (减法)
    fmt.Println(a * b)    // 30 (乘法)
    fmt.Println(a / b)    // 3  (整数除法)
    fmt.Println(a % b)    // 1  (取模)
    fmt.Println(math.Pow(float64(a), float64(b)))  // 1000 (幂)

    // 比较 (与 Python 相同)
    fmt.Println(a == b)  // false
    fmt.Println(a != b)  // true
    fmt.Println(a > b)   // true
    fmt.Println(a >= b)  // true

    // 逻辑 (不同语法)
    fmt.Println(a > 5 && b < 5)  // true (and)
    fmt.Println(a > 5 || b > 5)  // true (or)
    fmt.Println(!(a == b))       // true (not)

    // 递增/递减
    i := 0
    i++  // i = 1
    i--  // i = 0
    // Go 中没有 ++i 或 --i
}
```
</UniversalEditor>

## 控制流基础

### If 语句

<UniversalEditor title="If 语句">
```python !! py
# Python - If 语句
age = 20

if age >= 18:
    print("Adult")
elif age >= 13:
    print("Teenager")
else:
    print("Child")

# 使用赋值表达式 (Python 3.8+)
if (n := len(items)) > 10:
    print(f"Too many items: {n}")
```

```go !! go
// Go - If 语句
package main

import "fmt"

func main() {
    age := 20

    if age >= 18 {
        fmt.Println("Adult")
    } else if age >= 13 {  // 注意:没有 elif
        fmt.Println("Teenager")
    } else {
        fmt.Println("Child")
    }

    // 带初始化语句
    if n := len(items); n > 10 {
        fmt.Printf("Too many items: %d\n", n)
    }
    // n 在 if 块外不可访问
}
```
</UniversalEditor>

## 总结

在本模块中,你学习了:

1. **变量声明**: Python (动态) vs Go (带类型推断的静态)
2. **基本类型**: 不同的类型系统和转换
3. **字符串**: 相似的操作,不同的语法
4. **零值**: Go 中未初始化变量的默认值
5. **指针**: Python 开发者的新概念
6. **集合**: 数组/切片 vs 列表,映射 vs 字典
7. **运算符**: 大部分相似,一些语法差异
8. **控制流简介**: 带初始化的 If 语句

## 关键要点

- **Go 需要显式类型** 但使用 `:=` 进行类型推断
- **无隐式类型转换** - 必须显式转换
- **零值** 意味着变量总是有默认值
- **指针** 让你对引用有显式控制
- **切片** 是动态数组,**数组**是固定大小
- **映射** 类似 Python 字典
- **使用 `:=` 进行短变量声明** 在函数内部 (最常用)

## 练习

1. 创建一个程序,声明不同类型的变量
2. 编写一个函数,接收指针并修改值
3. 创建一个切片,添加元素,并对其进行切片
4. 构建一个映射并演示 CRUD 操作
5. 在不同数值类型之间转换
6. 使用带初始化的 if 语句

## 下一步

在下一个模块中,我们将深入学习 Go 的控制流、循环和函数。
