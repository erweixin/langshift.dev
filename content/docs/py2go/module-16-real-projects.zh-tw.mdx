---
title: "Module 16: 真實專案"
description: "建構完整的專案以應用你的 Go 知識"
---

## 簡介

到了將所有內容整合在一起的時候了!本模組展示完整的實用專案,演示真實的 Go 開發。

## 專案 1: URL 短鏈服務

建構一個生產就緒的 URL 短鏈,包含:
- RESTful API
- 資料庫持久化
- 快取層
- 指標收集
- Docker 部署

### 架構

```
┌─────────────┐
│   Client    │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│  API Gateway    │
└────────┬────────┘
         │
    ┌────┴────┐
    ▼         ▼
┌───────┐ ┌───────┐
│  API  │ │ Cache │
└───┬───┘ └───────┘
    │
    ▼
┌───────┐
│  DB   │
└───────┘
```

### 實作

<UniversalEditor title="URL 短鏈 - 模型">
```python !! py
# Python - 模型
from dataclasses import dataclass
from datetime import datetime
import hashlib
import random
import string

@dataclass
class URL:
    id: int
    short_code: str
    original_url: str
    created_at: datetime
    clicks: int

def generate_short_code(url: str) -> str:
    # 生成隨機 6 字元代碼
    chars = string.ascii_letters + string.digits
    return ''.join(random.choices(chars, k=6))
```

```go !! go
// Go - 模型
package models

import "time"

type URL struct {
    ID          int       `json:"id"`
    ShortCode   string    `json:"short_code"`
    OriginalURL string    `json:"original_url"`
    CreatedAt   time.Time `json:"created_at"`
    Clicks      int       `json:"clicks"`
}

func GenerateShortCode() string {
    // 生成隨機 6 字元代碼
    const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    b := make([]byte, 6)
    for i := range b {
        b[i] = chars[rand.Intn(len(chars))]
    }
    return string(b)
}
```
</UniversalEditor>

<UniversalEditor title="URL 短鏈 - API">
```python !! py
# Python - Flask API
from flask import Flask, request, jsonify, redirect
from datetime import datetime

app = Flask(__name__)

@app.route('/shorten', methods=['POST'])
def shorten():
    data = request.get_json()
    url = data.get('url')

    if not url:
        return jsonify({'error': 'URL required'}), 400

    short_code = generate_short_code(url)

    # 保存到資料庫
    url_obj = URL(
        id=1,
        short_code=short_code,
        original_url=url,
        created_at=datetime.now(),
        clicks=0
    )

    return jsonify({
        'short_url': f'https://short.ly/{short_code}'
    }), 201

@app.route('/<short_code>')
def redirect_url(short_code):
    # 查找 URL
    url_obj = get_url(short_code)

    if not url_obj:
        return jsonify({'error': 'Not found'}), 404

    # 增加點擊數
    url_obj.clicks += 1

    return redirect(url_obj.original_url)
```

```go !! go
// Go - HTTP API
package main

import (
    "database/sql"
    "encoding/json"
    "fmt"
    "net/http"
    "time"

    _ "github.com/lib/pq"
)

type Server struct {
    db *sql.DB
}

func (s *Server) shortenHandler(w http.ResponseWriter, r *http.Request) {
    var req struct {
        URL string `json:"url"`
    }

    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    if req.URL == "" {
        http.Error(w, "URL required", http.StatusBadRequest)
        return
    }

    shortCode := GenerateShortCode()

    // 保存到資料庫
    var id int
    err := s.db.QueryRow(
        "INSERT INTO urls (short_code, original_url, created_at, clicks) VALUES ($1, $2, $3, $4) RETURNING id",
        shortCode, req.URL, time.Now(), 0,
    ).Scan(&id)

    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(map[string]string{
        "short_url": fmt.Sprintf("https://short.ly/%s", shortCode),
    })
}

func (s *Server) redirectHandler(w http.ResponseWriter, r *http.Request) {
    shortCode := r.URL.Path[1:] // 移除前導 '/'

    var originalURL string
    err := s.db.QueryRow(
        "SELECT original_url FROM urls WHERE short_code = $1",
        shortCode,
    ).Scan(&originalURL)

    if err == sql.ErrNoRows {
        http.Error(w, "Not found", http.StatusNotFound)
        return
    } else if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // 增加點擊數
    s.db.Exec("UPDATE urls SET clicks = clicks + 1 WHERE short_code = $1", shortCode)

    http.Redirect(w, r, originalURL, http.StatusMovedPermanently)
}
```
</UniversalEditor>

<UniversalEditor title="URL 短鏈 - 資料庫">
```sql
-- Schema (兩者相同)
CREATE TABLE urls (
    id SERIAL PRIMARY KEY,
    short_code VARCHAR(10) UNIQUE NOT NULL,
    original_url TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    clicks INTEGER DEFAULT 0
);

CREATE INDEX idx_short_code ON urls(short_code);
```
</UniversalEditor>

## 專案 2: WebSocket 聊天伺服器

支援多房間的即時聊天:

<UniversalEditor title="WebSocket 聊天">
```python !! py
# Python - FastAPI WebSockets
from fastapi import FastAPI, WebSocket
from typing import Dict

app = FastAPI()

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, list[WebSocket]] = {}

    async def connect(self, websocket: WebSocket, room: str):
        await websocket.accept()
        if room not in self.active_connections:
            self.active_connections[room] = []
        self.active_connections[room].append(websocket)

    async def broadcast(self, message: str, room: str):
        for connection in self.active_connections.get(room, []):
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/{room}")
async def websocket_endpoint(websocket: WebSocket, room: str):
    await manager.connect(websocket, room)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.broadcast(f"User: {data}", room)
    except:
        manager.disconnect(websocket, room)
```

```go !! go
// Go - Gorilla WebSocket
package main

import (
    "log"
    "net/http"
    "sync"

    "github.com/gorilla/websocket"
)

type Hub struct {
    rooms map[string]*Room
    mu    sync.RWMutex
}

type Room struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
}

type Client struct {
    hub  *Hub
    room *Room
    conn *websocket.Conn
    send chan []byte
}

var upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool {
        return true
    },
}

func NewHub() *Hub {
    return &Hub{
        rooms: make(map[string]*Room),
    }
}

func (h *Hub) GetRoom(roomName string) *Room {
    h.mu.Lock()
    defer h.mu.Unlock()

    if room, exists := h.rooms[roomName]; exists {
        return room
    }

    room := &Room{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }

    h.rooms[roomName] = room
    go room.run()

    return room
}

func (r *Room) run() {
    for {
        select {
        case client := <-r.register:
            r.clients[client] = true

        case client := <-r.unregister:
            if _, ok := r.clients[client]; ok {
                delete(r.clients, client)
                close(client.send)
            }

        case message := <-r.broadcast:
            for client := range r.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(r.clients, client)
                }
            }
        }
    }
}

func (h *Hub) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
    roomName := r.URL.Path[len("/ws/"):]
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Println(err)
        return
    }

    room := h.GetRoom(roomName)

    client := &Client{
        hub:  h,
        room: room,
        conn: conn,
        send: make(chan []byte, 256),
    }

    room.register <- client

    go client.writePump()
    go client.readPump()
}

func (c *Client) readPump() {
    defer func() {
        c.room.unregister <- c
        c.conn.Close()
    }()

    for {
        _, message, err := c.conn.ReadMessage()
        if err != nil {
            break
        }

        c.room.broadcast <- message
    }
}

func (c *Client) writePump() {
    defer c.conn.Close()

    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }

            c.conn.WriteMessage(websocket.TextMessage, message)
        }
    }
}

func main() {
    hub := NewHub()

    http.HandleFunc("/ws/", hub.HandleWebSocket)

    log.Println("Server starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```
</UniversalEditor>

## 專案 3: 任務佇列系統

使用 Redis 的背景任務處理:

<UniversalEditor title="任務佇列">
```python !! py
# Python - Celery
from celery import Celery

app = Celery('tasks', broker='redis://localhost:6379')

@app.task
def process_image(image_path):
    # 處理圖片
    result = resize_image(image_path)
    return result

# 使用
process_image.delay('/path/to/image.jpg')
```

```go !! go
// Go - 使用 Redis 的任務佇列
package main

import (
    "encoding/json"
    "fmt"
    "log"

    "github.com/go-redis/redis/v8"
    "golang.org/x/net/context"
)

type Task struct {
    ID   string                 `json:"id"`
    Type string                 `json:"type"`
    Data map[string]interface{} `json:"data"`
}

type Worker struct {
    redis   *redis.Client
    queues  []string
    handler func(Task) error
}

func NewWorker(redisAddr string, queues []string, handler func(Task) error) *Worker {
    rdb := redis.NewClient(&redis.Options{
        Addr:     redisAddr,
        Password: "",
        DB:       0,
    })

    return &Worker{
        redis:   rdb,
        queues:  queues,
        handler: handler,
    }
}

func (w *Worker) Start(ctx context.Context) error {
    for _, queue := range w.queues {
        go w.processQueue(ctx, queue)
    }

    <-ctx.Done()
    return nil
}

func (w *Worker) processQueue(ctx context.Context, queue string) {
    for {
        select {
        case <-ctx.Done():
            return

        default:
            // 帶逾時的 BRPOP
            result, err := w.redis.BRPop(ctx, queue, time.Second).Result()
            if err != nil {
                continue
            }

            if len(result) < 2 {
                continue
            }

            var task Task
            if err := json.Unmarshal([]byte(result[1]), &task); err != nil {
                log.Printf("Error unmarshaling task: %v", err)
                continue
            }

            log.Printf("Processing task: %s", task.ID)

            if err := w.handler(task); err != nil {
                log.Printf("Error processing task: %v", err)
            }
        }
    }
}

func enqueueTask(rdb *redis.Client, queue string, task Task) error {
    data, err := json.Marshal(task)
    if err != nil {
        return err
    }

    return rdb.LPush(context.Background(), queue, data).Err()
}

func main() {
    worker := NewWorker("localhost:6379", []string{"images", "emails"}, func(task Task) error {
        switch task.Type {
        case "process_image":
            imagePath := task.Data["path"].(string)
            return processImage(imagePath)

        case "send_email":
            email := task.Data["email"].(string)
            return sendEmail(email)

        default:
            return fmt.Errorf("unknown task type: %s", task.Type)
        }
    })

    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    if err := worker.Start(ctx); err != nil {
        log.Fatal(err)
    }
}
```
</UniversalEditor>

## 專案 4: CLI 工具

面向開發者的命令列工具:

<UniversalEditor title="CLI 工具">
```python !! py
# Python - Click CLI
import click

@click.group()
def cli():
    """開發者工具"""
    pass

@cli.command()
@click.argument('name')
def create(name):
    """建立新專案"""
    click.echo(f"Creating project: {name}")

@cli.command()
def status():
    """顯示狀態"""
    click.echo("Status: OK")

if __name__ == '__main__':
    cli()
```

```go !! go
// Go - Cobra CLI
package main

import (
    "fmt"
    "os"

    "github.com/spf13/cobra"
)

var rootCmd = &cobra.Command{
    Use:   "devtool",
    Short: "Developer tools",
    Long:  "A collection of developer utilities",
}

var createCmd = &cobra.Command{
    Use:   "create [name]",
    Short: "Create new project",
    Args:  cobra.ExactArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
        name := args[0]
        fmt.Printf("Creating project: %s\n", name)
        // 建立專案...
    },
}

var statusCmd = &cobra.Command{
    Use:   "status",
    Short: "Show status",
    Run: func(cmd *cobra.Command, args []string) {
        fmt.Println("Status: OK")
    },
}

func init() {
    rootCmd.AddCommand(createCmd)
    rootCmd.AddCommand(statusCmd)
}

func main() {
    if err := rootCmd.Execute(); err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}
```
</UniversalEditor>

## 專案 5: 微服務日誌記錄器

集中式日誌服務:

<UniversalEditor title="日誌記錄器微服務">
```go
// Go - 日誌服務
package main

import (
    "encoding/json"
    "io"
    "log"
    "net/http"
    "os"
    "sync"

    "github.com/go-redis/redis/v8"
)

type LogEntry struct {
    Level     string                 `json:"level"`
    Message   string                 `json:"message"`
    Service   string                 `json:"service"`
    Timestamp string                 `json:"timestamp"`
    Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

type Logger struct {
    mu   sync.Mutex
    file *os.File
}

func NewLogger(filename string) (*Logger, error) {
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }

    return &Logger{file: file}, nil
}

func (l *Logger) Log(entry LogEntry) error {
    l.mu.Lock()
    defer l.mu.Unlock()

    data, err := json.Marshal(entry)
    if err != nil {
        return err
    }

    _, err = l.file.Write(append(data, '\n'))
    return err
}

func (l *Logger) logHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }

    var entry LogEntry
    if err := json.NewDecoder(r.Body).Decode(&entry); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }

    if err := l.Log(entry); err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // 同時發送到 Redis 進行即時查看
    // redis.Publish(ctx, "logs", data)

    w.WriteHeader(http.StatusCreated)
}

func (l *Logger) streamHandler(w http.ResponseWriter, r *http.Request) {
    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming not supported", http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")

    // 訂閱 Redis
    // pubsub := redis.Subscribe(ctx, "logs")

    for {
        // msg, err := pubsub.ReceiveMessage(ctx)
        // if err != nil {
        //     return
        // }

        // fmt.Fprintf(w, "data: %s\n\n", msg.Payload)
        fmt.Fprintf(w, "data: {\"level\": \"info\", \"message\": \"test\"}\n\n")
        flusher.Flush()
    }
}

func main() {
    logger, err := NewLogger("app.log")
    if err != nil {
        log.Fatal(err)
    }

    http.HandleFunc("/log", logger.logHandler)
    http.HandleFunc("/stream", logger.streamHandler)

    log.Println("Logger service starting on :8080")
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```
</UniversalEditor>

## 總結

在本模組中,你學習了建構:

1. **URL 短鏈** - 帶資料庫的 REST API
2. **WebSocket 聊天** - 即時通訊
3. **任務佇列** - 背景任務處理
4. **CLI 工具** - 命令列介面
5. **日誌服務** - 微服務日誌

## 專案最佳實踐

1. **結構** - 邏輯組織程式碼
2. **錯誤處理** - 始終檢查錯誤
3. **測試** - 為關鍵路徑編寫測試
4. **文件** - 記錄你的程式碼
5. **Docker** - 容器化應用
6. **監控** - 新增指標和日誌
7. **安全** - 驗證輸入,使用 HTTPS

## 最終練習

1. 完整建構 URL 短鏈
2. 為聊天伺服器新增身份驗證
3. 建立任務佇列的控制面板
4. 使用更多命令擴展 CLI 工具
5. 將專案部署到 Kubernetes

## 結語

你已經完成了 Python → Go 學習路徑!你現在擁有:
- 對 Go 基礎知識的紮實理解
- Go 並發模型的經驗
- Go Web 開發的知識
- 建構生產就緒服務的技能
- 地道 Go 的最佳實踐

繼續建構專案並探索 Go 生態系統。祝你程式愉快!
