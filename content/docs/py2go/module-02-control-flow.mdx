---
title: "Module 2: Control Flow and Loops"
description: "Master Go's control flow constructs compared to Python"
---

## Introduction

This module covers control flow in Go, including loops, conditionals, and switches. While Python focuses on "one obvious way to do it," Go provides explicit constructs that make code clear and predictable.

## Loops: The Only Loop - For

Python has `for` and `while` loops. **Go only has `for`**, but it's versatile enough to handle all looping scenarios.

### Basic For Loop

<UniversalEditor title="Basic Loop Comparison">
```python !! py
# Python - While loop
i = 0
while i < 5:
    print(i)
    i += 1

# Python - For loop with range
for i in range(5):
    print(i)

# Python - For loop over iterable
items = ["a", "b", "c"]
for item in items:
    print(item)
```

```go !! go
// Go - All use for loop
package main

import "fmt"

func main() {
    // While-style loop
    i := 0
    for i < 5 {
        fmt.Println(i)
        i++
    }

    // Traditional for loop
    for i := 0; i < 5; i++ {
        fmt.Println(i)
    }

    // Range over slice
    items := []string{"a", "b", "c"}
    for i, item := range items {
        fmt.Printf("%d: %s\n", i, item)
    }

    // Ignore index with _
    for _, item := range items {
        fmt.Println(item)
    }
}
```
</UniversalEditor>

### Infinite Loops

<UniversalEditor title="Infinite Loops">
```python !! py
# Python - Infinite loop
while True:
    print("Running...")
    if should_stop():
        break
```

```go !! go
// Go - Infinite loop
for {
    fmt.Println("Running...")
    if shouldStop() {
        break
    }
}
```
</UniversalEditor>

### Iterating Over Maps

<UniversalEditor title="Iterating Maps">
```python !! py
# Python - Dict iteration
person = {"name": "Alice", "age": 30, "city": "NYC"}

# Keys
for key in person:
    print(key)

# Keys and values
for key, value in person.items():
    print(f"{key}: {value}")
```

```go !! go
// Go - Map iteration
package main

import "fmt"

func main() {
    person := map[string]string{
        "name": "Alice",
        "age":  "30",
        "city": "NYC",
    }

    // Keys and values (only option in Go)
    for key, value := range person {
        fmt.Printf("%s: %s\n", key, value)
    }

    // Only keys
    for key := range person {
        fmt.Println(key)
    }
}
```
</UniversalEditor>

### Iterating Over Strings

<UniversalEditor title="String Iteration">
```python !! py
# Python - String iteration
text = "Hello"
for char in text:
    print(char)

for i, char in enumerate(text):
    print(f"{i}: {char}")
```

```go !! go
// Go - String iteration (by runes)
package main

import "fmt"

func main() {
    text := "Hello"

    // By rune (character)
    for i, rune := range text {
        fmt.Printf("%d: %c\n", i, rune)
    }

    // Only runes
    for _, rune := range text {
        fmt.Printf("%c\n", rune)
    }
}
```
</UniversalEditor>

### Loop Control: Break and Continue

<UniversalEditor title="Break and Continue">
```python !! py
# Python - Break and continue
for i in range(10):
    if i == 3:
        continue  # Skip 3
    if i == 7:
        break     # Stop at 7
    print(i)
# Output: 0, 1, 2, 4, 5, 6
```

```go !! go
// Go - Break and continue (same as Python)
package main

import "fmt"

func main() {
    for i := 0; i < 10; i++ {
        if i == 3 {
            continue  // Skip 3
        }
        if i == 7 {
            break     // Stop at 7
        }
        fmt.Println(i)
    }
    // Output: 0, 1, 2, 4, 5, 6
}
```
</UniversalEditor>

## If Statements

### Basic If

<UniversalEditor title="Basic If">
```python !! py
# Python - If statement
age = 20

if age >= 18:
    print("Adult")
elif age >= 13:
    print("Teenager")
else:
    print("Child")
```

```go !! go
// Go - If statement
package main

import "fmt"

func main() {
    age := 20

    if age >= 18 {
        fmt.Println("Adult")
    } else if age >= 13 {
        fmt.Println("Teenager")
    } else {
        fmt.Println("Child")
    }
}
```
</UniversalEditor>

### If with Initialization

<UniversalEditor title="If with Initialization">
```python !! py
# Python 3.8+ - Walrus operator
if (n := len(items)) > 10:
    print(f"Too many: {n}")
```

```go !! go
// Go - If with initialization
package main

import "fmt"

func main() {
    items := []int{1, 2, 3, 4, 5}

    // Variable scoped to if block
    if n := len(items); n > 10 {
        fmt.Printf("Too many: %d\n", n)
    } else {
        fmt.Printf("Count: %d\n", n)
    }
    // n not accessible here
}
```
</UniversalEditor>

### If with Multiple Conditions

<UniversalEditor title="Multiple Conditions">
```python !! py
# Python - Logical operators
age = 25
has_id = True

if age >= 18 and has_id:
    print("Can enter")

if age < 18 or not has_id:
    print("Cannot enter")
```

```go !! go
// Go - Logical operators (different syntax)
package main

import "fmt"

func main() {
    age := 25
    hasID := true

    if age >= 18 && hasID {
        fmt.Println("Can enter")
    }

    if age < 18 || !hasID {
        fmt.Println("Cannot enter")
    }
}
```
</UniversalEditor>

## Switch Statements

Go's switch is more powerful than Python's if-elif chains:

<UniversalEditor title="Switch Statement">
```python !! py
# Python - No switch statement (before 3.10), use if-elif
grade = "B"

if grade == "A":
    print("Excellent")
elif grade == "B":
    print("Good")
elif grade == "C":
    print("Average")
else:
    print("Need improvement")

# Python 3.10+ - Match statement
match grade:
    case "A":
        print("Excellent")
    case "B":
        print("Good")
    case "C":
        print("Average")
    case _:
        print("Need improvement")
```

```go !! go
// Go - Switch statement (no break needed!)
package main

import "fmt"

func main() {
    grade := "B"

    switch grade {
    case "A":
        fmt.Println("Excellent")
    case "B":
        fmt.Println("Good")
    case "C":
        fmt.Println("Average")
    default:
        fmt.Println("Need improvement")
    }

    // Switch with multiple values
    day := 3
    switch day {
    case 1, 2, 3, 4, 5:
        fmt.Println("Weekday")
    case 6, 7:
        fmt.Println("Weekend")
    }

    // Switch without condition (like if-else)
    switch {
    case age < 13:
        fmt.Println("Child")
    case age < 18:
        fmt.Println("Teenager")
    default:
        fmt.Println("Adult")
    }
}
```
</UniversalEditor>

### Switch with Initialization

<UniversalEditor title="Switch with Initialization">
```python !! py
# Python
num = 42
if num % 2 == 0:
    print("Even")
else:
    print("Odd")
```

```go !! go
// Go - Switch with initialization
package main

import "fmt"

func main() {
    switch num := 42; num % 2 {
    case 0:
        fmt.Println("Even")
    case 1:
        fmt.Println("Odd")
    }
}
```
</UniversalEditor>

## Defer (Unique to Go)

`defer` executes a statement after the surrounding function completes. Useful for cleanup:

<UniversalEditor title="Defer Statement">
```python !! py
# Python - try-finally
file = None
try:
    file = open("data.txt", "r")
    data = file.read()
    process(data)
finally:
    if file:
        file.close()

# Python - Context manager (preferred)
with open("data.txt", "r") as file:
    data = file.read()
    process(data)
# Automatically closed
```

```go !! go
// Go - Defer
package main

import "fmt"

func processData() {
    // Deferred until function returns
    defer fmt.Println("Cleanup: Closing resources")

    fmt.Println("Step 1: Opening file")
    fmt.Println("Step 2: Reading data")
    fmt.Println("Step 3: Processing")

    // Output order:
    // Step 1
    // Step 2
    // Step 3
    // Cleanup: Closing resources
}

func main() {
    // Multiple defers (LIFO order)
    defer fmt.Println("Third")
    defer fmt.Println("Second")
    defer fmt.Println("First")

    processData()
}
```
</UniversalEditor>

### Defer with File Operations

<UniversalEditor title="Defer for File Operations">
```python !! py
# Python - Context manager
def read_file(filename):
    with open(filename, 'r') as f:
        return f.read()
```

```go !! go
// Go - Defer for cleanup
package main

import (
    "fmt"
    "os"
)

func readFile(filename string) ([]byte, error) {
    file, err := os.Open(filename)
    if err != nil {
        return nil, err
    }
    // Always close, even if error occurs
    defer file.Close()

    data := make([]byte, 100)
    n, err := file.Read(data)
    if err != nil {
        return nil, err
    }

    return data[:n], nil
}

func main() {
    data, err := readFile("data.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println(string(data))
}
```
</UniversalEditor>

## Common Patterns

### Loop Until Condition

<UniversalEditor title="Loop Until Condition">
```python !! py
# Python
while True:
    line = read_line()
    if not line:
        break
    process(line)
```

```go !! go
// Go
for {
    line := readLine()
    if line == "" {
        break
    }
    process(line)
}
```
</UniversalEditor>

### Early Returns

<UniversalEditor title="Early Returns">
```python !! py
# Python
def validate(data):
    if not data:
        return False

    if len(data) < 10:
        return False

    if "invalid" in data:
        return False

    return True
```

```go !! go
// Go - Idiomatic with early returns
func validate(data string) bool {
    if data == "" {
        return false
    }

    if len(data) < 10 {
        return false
    }

    if strings.Contains(data, "invalid") {
        return false
    }

    return true
}
```
</UniversalEditor>

## Summary

In this module, you learned:

1. **Go only has `for` loops** - versatile enough for all scenarios
2. **No `while`** - use `for` with condition only
3. **Range-based iteration** over arrays, slices, maps, strings
4. **If with initialization** - scope-limited variables
5. **Switch statements** - no `break` needed, more powerful than Python's
6. **Defer** - executes after function completes (LIFO order)
7. **Early returns** - idiomatic pattern in Go

## Key Differences from Python

| Python | Go |
|--------|-----|
| `while`, `for` loops | Only `for` loop |
| `for i in range()` | `for i := 0; i < n; i++` |
| `for item in items` | `for _, item := range items` |
| `elif` | `else if` |
| `and`, `or`, `not` | `&&`, `\|\|`, `!` |
| `with` statement | `defer` keyword |
| No `switch` (before 3.10) | Powerful `switch` |

## Exercises

1. Write a function that uses `defer` to measure function execution time
2. Create a switch statement that handles multiple cases
3. Use `range` to iterate over a map and print key-value pairs
4. Implement early return pattern for validation
5. Use `for` with initialization, condition, and post statement

## Next Steps

Next module: **Functions and Methods** - Learn about Go's function declarations, multiple return values, closures, and methods.
