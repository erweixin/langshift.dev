---
title: "Module 1: Basic Syntax Comparison"
description: "Learn the fundamental differences between Python and Go syntax"
---

## Introduction

In this module, we'll compare the basic syntax of Python and Go. Understanding these differences is crucial for transitioning from Python's dynamic, interpreted nature to Go's static, compiled approach.

## Variable Declaration

### Python: Dynamic Typing

Python uses dynamic typing - variables can hold any type:

```python
# Python - No type declaration needed
name = "Alice"
age = 25
price = 19.99
is_active = True
items = [1, 2, 3]

# Type can change
x = 10
x = "now a string"  # Perfectly valid in Python
```

### Go: Static Typing with Inference

Go requires types, but can infer them:

<UniversalEditor title="Variable Declaration">
```python !! py
# Python - Dynamic typing
name = "Alice"
age = 25
price = 19.99
is_active = True
items = [1, 2, 3]
```

```go !! go
// Go - Static typing with inference
var name string = "Alice"      // Full declaration
var age = 25                   // Type inferred (int)
price := 19.99                 // Short declaration (most common)
is_active := true              // Type inferred (bool)
var items []int = []int{1, 2, 3}  // Slice

// Cannot change type
// age = "now a string"  // Compilation error!
```
</UniversalEditor>

### Variable Declaration Styles

<UniversalEditor title="Variable Declaration Styles">
```python !! py
# Python - One way
x = 10
y = "hello"
z = 3.14
```

```go !! go
// Go - Three ways

// 1. Full declaration
var x int = 10

// 2. Type inference
var y = "hello"

// 3. Short declaration (most common, only inside functions)
z := 3.14

// Multiple variables
var a, b, c int = 1, 2, 3
name, age := "Bob", 30

// Block declaration (for package level)
var (
    port    int    = 8080
    host    string = "localhost"
    debug   bool   = false
)
```
</UniversalEditor>

## Constants

<UniversalEditor title="Constants">
```python !! py
# Python - Constants (convention, not enforced)
MAX_CONNECTIONS = 100
API_KEY = "secret"
DEBUG = True

# Can actually be changed (but shouldn't)
MAX_CONNECTIONS = 200  # Works but violates convention
```

```go !! go
// Go - True constants (compile-time)
const MaxConnections = 100
const APIKey = "secret"
const Debug = false

// Cannot be changed
// MaxConnections = 200  // Compilation error!

// Multiple constants
const (
    StatusOK       = 200
    StatusNotFound = 404
    StatusError    = 500
)
```
</UniversalEditor>

## Basic Types

<UniversalEditor title="Basic Types Comparison">
```python !! py
# Python - Built-in types
int_num = 42              # int (unlimited precision)
float_num = 3.14          # float
text = "hello"            # str
is_true = True            # bool
byte_data = b"bytes"      # bytes

# Complex types
numbers = [1, 2, 3]       # list (mutable)
coords = (1, 2)           # tuple (immutable)
```

```go !! go
// Go - Basic types
var intNum int = 42               // int (platform-dependent, usually 64-bit)
var floatNum float64 = 3.14       // float64
var text string = "hello"         // string
var isTrue bool = true            // bool
var byteData []byte = []byte("bytes")  // byte slice

// Complex types
var numbers []int = []int{1, 2, 3}  // slice (dynamic array)
var coords [2]int = [2]int{1, 2}    // array (fixed size)

// Specific numeric types
var i8 int8 = 127                   // 8-bit integer
var i16 int16 = 32767               // 16-bit integer
var i32 int32 = 2147483647          // 32-bit integer
var i64 int64 = 9223372036854775807 // 64-bit integer
var f32 float32 = 3.14              // 32-bit float
var u8 uint8 = 255                  // 8-bit unsigned
```
</UniversalEditor>

## Strings

<UniversalEditor title="String Operations">
```python !! py
# Python - String operations
text = "Hello, World!"

# Length
print(len(text))  # 13

# Concatenation
greeting = text + " How are you?"
print(greeting)  # Hello, World! How are you?

# String formatting
name = "Alice"
age = 25
print(f"Name: {name}, Age: {age}")
print("Name: {}, Age: {}".format(name, age))

# Substring (slicing)
print(text[0:5])   # Hello
print(text[7:])    # World!
print(text[-6:])   # World!

# Multiline string
multiline = """
This is a
multiline string
"""
```

```go !! go
// Go - String operations
package main

import (
    "fmt"
    "strings"
)

func main() {
    text := "Hello, World!"

    // Length
    fmt.Println(len(text))  // 13 (number of bytes)
    fmt.Println(len([]rune(text)))  // 13 (number of characters/runes)

    // Concatenation
    greeting := text + " How are you?"
    fmt.Println(greeting)  // Hello, World! How are you?

    // String formatting
    name := "Alice"
    age := 25
    fmt.Printf("Name: %s, Age: %d\n", name, age)
    fmt.Printf("Name: %v, Age: %v\n", name, age)

    // Substring (slicing)
    fmt.Println(text[0:5])   // Hello
    fmt.Println(text[7:])    // World!
    // No negative indices in Go

    // Multiline string
    multiline := `
This is a
multiline string
`

    // String methods
    fmt.Println(strings.ToUpper(text))  // HELLO, WORLD!
    fmt.Println(strings.Contains(text, "World"))  // true
    fmt.Println(strings.Replace(text, "World", "Go", 1))  // Hello, Go!
}
```
</UniversalEditor>

## Zero Values

In Go, every type has a "zero value" - the default value when not initialized:

<UniversalEditor title="Zero Values">
```python !! py
# Python - Variables must be initialized
x = None  # Explicit None
y = 0     # Initialize to 0
z = ""    # Initialize to empty string

# No default values
def my_function():
    a  # Error: local variable referenced before assignment
```

```go !! go
// Go - Zero values
var x int       // 0
var y float64   // 0
var z string    // "" (empty string)
var b bool      // false
var s []int     // nil (nil slice)

// Works - variables have default values
func myFunction() {
    var a int
    fmt.Println(a)  // Prints 0
}
```
</UniversalEditor>

## Comments

<UniversalEditor title="Comments">
```python !! py
# Python - Comments
# Single line comment

"""
Multi-line comment
(docstring)
"""

# Function documentation
def add(a, b):
    """Add two numbers together."""
    return a + b
```

```go !! go
// Go - Comments
// Single line comment

/* Multi-line
   comment */

// Package documentation (appears before package clause)
// Package main demonstrates basic Go syntax
package main

// Function documentation
// Add adds two numbers together and returns the result.
func Add(a int, b int) int {
    return a + b
}
```
</UniversalEditor>

## Type Conversion

<UniversalEditor title="Type Conversion">
```python !! py
# Python - Automatic type conversion
x = 10
y = 3.14
result = x + y  # 13.14 (float)
text = "Value: " + str(x)  # Explicit conversion needed for strings
```

```go !! go
// Go - No automatic conversion (must be explicit)
package main

import "fmt"

func main() {
    var x int = 10
    var y float64 = 3.14

    // Error: cannot mix types
    // result := x + y  // Compilation error!

    // Must convert explicitly
    result := float64(x) + y
    fmt.Println(result)  // 13.14

    // String conversion
    text := "Value: " + fmt.Sprintf("%d", x)
    fmt.Println(text)  // Value: 10

    // Using strconv package
    import "strconv"
    numStr := strconv.Itoa(x)
    fmt.Println(numStr)  // "10"
}
```
</UniversalEditor>

## Pointers (New Concept for Python Developers)

Go has pointers - Python doesn't expose them:

<UniversalEditor title="Pointers">
```python !! py
# Python - Everything is a reference
def modify_list(lst):
    lst.append(4)  # Modifies original list

numbers = [1, 2, 3]
modify_list(numbers)
print(numbers)  # [1, 2, 3, 4]

# But integers are immutable
def increment(x):
    x += 1  # Creates new local variable

num = 10
increment(num)
print(num)  # 10 (unchanged)
```

```go !! go
// Go - Explicit pointers
package main

import "fmt"

func modifySlice(slice []int) {
    slice = append(slice, 4)  // Modifies slice
}

func incrementByPointer(x *int) {
    *x++  // Dereference and increment
}

func main() {
    // Slice is already a reference
    numbers := []int{1, 2, 3}
    modifySlice(numbers)
    fmt.Println(numbers)  // [1, 2, 3, 4]

    // Use pointer for value types
    num := 10
    incrementByPointer(&num)  // Pass address
    fmt.Println(num)  // 11 (changed!)

    // Pointer syntax
    x := 42
    p := &x     // p is pointer to x (type *int)
    fmt.Println(*p)  // 42 (dereference)
    *p = 100      // Modify x through pointer
    fmt.Println(x)  // 100
}
```
</UniversalEditor>

## Arrays and Slices

<UniversalEditor title="Arrays vs Slices">
```python !! py
# Python - Lists (dynamic arrays)
numbers = [1, 2, 3, 4, 5]
numbers.append(6)           # Add element
numbers.extend([7, 8])      # Add multiple
mixed = [1, "hello", 3.14]  # Mixed types (allowed)
sliced = numbers[1:4]       # Slice
```

```go !! go
// Go - Arrays (fixed) and Slices (dynamic)
package main

import "fmt"

func main() {
    // Array - fixed size
    var arr [5]int = [5]int{1, 2, 3, 4, 5}
    // arr[5] = 6  // Error: index out of bounds

    // Slice - dynamic (use this mostly)
    numbers := []int{1, 2, 3, 4, 5}
    numbers = append(numbers, 6)      // Add element
    numbers = append(numbers, 7, 8)   // Add multiple

    // Cannot mix types in Go
    // mixed := []interface{}{1, "hello", 3.14}  // Need interface{}

    // Slicing
    sliced := numbers[1:4]  // [2 3 4]

    // Make slice with capacity
    nums := make([]int, 0, 10)  // length=0, capacity=10
    nums = append(nums, 1, 2, 3)

    fmt.Println(nums)
}
```
</UniversalEditor>

## Maps (Dictionaries)

<UniversalEditor title="Maps/Dictionaries">
```python !! py
# Python - Dictionary
person = {
    "name": "Alice",
    "age": 30,
    "city": "NYC"
}

# Access
print(person["name"])  # Alice
print(person.get("country", "Unknown"))  # Unknown (default)

# Modify
person["age"] = 31
person["country"] = "USA"

# Delete
del person["city"]

# Iterate
for key, value in person.items():
    print(f"{key}: {value}")
```

```go !! go
// Go - Map
package main

import "fmt"

func main() {
    // Create map
    person := map[string]interface{}{
        "name": "Alice",
        "age": 30,
        "city": "NYC",
    }

    // Access
    fmt.Println(person["name"])  // Alice
    country, exists := person["country"]
    if !exists {
        country = "Unknown"
    }
    fmt.Println(country)  // Unknown

    // Modify
    person["age"] = 31
    person["country"] = "USA"

    // Delete
    delete(person, "city")

    // Iterate
    for key, value := range person {
        fmt.Printf("%v: %v\n", key, value)
    }

    // Typed map (better)
    ages := map[string]int{
        "Alice": 30,
        "Bob":   25,
    }
}
```
</UniversalEditor>

## Operators

<UniversalEditor title="Operators Comparison">
```python !! py
# Python - Operators
a, b = 10, 3

# Arithmetic
print(a + b)   # 13 (addition)
print(a - b)   # 7  (subtraction)
print(a * b)   # 30 (multiplication)
print(a / b)   # 3.333... (true division)
print(a // b)  # 3  (floor division)
print(a % b)   # 1  (modulo)
print(a ** b)  # 1000 (power)

# Comparison
print(a == b)  # False
print(a != b)  # True
print(a > b)   # True
print(a >= b)  # True

# Logical
print(a > 5 and b < 5)  # True
print(a > 5 or b > 5)   # True
print(not (a == b))     # True
```

```go !! go
// Go - Operators
package main

import (
    "fmt"
    "math"
)

func main() {
    a, b := 10, 3

    // Arithmetic
    fmt.Println(a + b)    // 13 (addition)
    fmt.Println(a - b)    // 7  (subtraction)
    fmt.Println(a * b)    // 30 (multiplication)
    fmt.Println(a / b)    // 3  (integer division)
    fmt.Println(a % b)    // 1  (modulo)
    fmt.Println(math.Pow(float64(a), float64(b)))  // 1000 (power)

    // Comparison (same as Python)
    fmt.Println(a == b)  // false
    fmt.Println(a != b)  // true
    fmt.Println(a > b)   // true
    fmt.Println(a >= b)  // true

    // Logical (different syntax)
    fmt.Println(a > 5 && b < 5)  // true (and)
    fmt.Println(a > 5 || b > 5)  // true (or)
    fmt.Println(!(a == b))       // true (not)

    // Increment/decrement
    i := 0
    i++  // i = 1
    i--  // i = 0
    // No ++i or --i in Go
}
```
</UniversalEditor>

## Control Flow Basics

### If Statements

<UniversalEditor title="If Statements">
```python !! py
# Python - If statement
age = 20

if age >= 18:
    print("Adult")
elif age >= 13:
    print("Teenager")
else:
    print("Child")

# With assignment expression (Python 3.8+)
if (n := len(items)) > 10:
    print(f"Too many items: {n}")
```

```go !! go
// Go - If statement
package main

import "fmt"

func main() {
    age := 20

    if age >= 18 {
        fmt.Println("Adult")
    } else if age >= 13 {  // Note: no elif
        fmt.Println("Teenager")
    } else {
        fmt.Println("Child")
    }

    // With initialization statement
    if n := len(items); n > 10 {
        fmt.Printf("Too many items: %d\n", n)
    }
    // n is not accessible outside the if block
}
```
</UniversalEditor>

## Summary

In this module, you learned:

1. **Variable declarations**: Python (dynamic) vs Go (static with inference)
2. **Basic types**: Different type systems and conversions
3. **Strings**: Similar operations, different syntax
4. **Zero values**: Go's default values for uninitialized variables
5. **Pointers**: New concept for Python developers
6. **Collections**: Arrays/slices vs lists, maps vs dictionaries
7. **Operators**: Mostly similar with some syntax differences
8. **Control flow introduction**: If statements with initialization

## Key Takeaways

- **Go requires explicit types** but uses type inference with `:=`
- **No implicit type conversion** - must convert explicitly
- **Zero values** mean variables always have a default value
- **Pointers** give you explicit control over references
- **Slices** are dynamic arrays, **arrays** are fixed-size
- **Maps** are like Python dictionaries
- **Use `:=` for short declaration** inside functions (most common)

## Exercises

1. Create a program that declares variables of different types
2. Write a function that takes a pointer and modifies the value
3. Create a slice, append elements, and slice it
4. Build a map and demonstrate CRUD operations
5. Convert between different numeric types
6. Use if statements with initialization

## Next Steps

In the next module, we'll dive deeper into control flow, loops, and functions in Go.
