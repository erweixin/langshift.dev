---
title: 多维动态规划（题单顺序）
description: 热题 100 - 多维动态规划分组（按题单顺序）：62 / 64 / 5 / 1143 / 72
---

import { LeetCodeProblem } from "@/components/leetcode/LeetCodeProblem"

本页包含题单「多维动态规划」分组的全部题目，顺序与 `list.json` 保持一致。

<details>
<summary><strong>多维 DP 统一“落地步骤”</strong>（点击展开）</summary>

- **状态**：`dp[i][j]` 表示什么（一定要带上“含义 + 范围”）。
- **转移**：`dp[i][j]` 从哪些更小状态来，为什么不会漏/重。
- **初始化**：边界（第一行/第一列/空串/长度为 0）怎么设，避免越界。
- **遍历顺序**：保证用到的状态已经算好（常见是从小到大）。
- **优化**：能否滚动数组（把二维压成一维），以及滚动时更新方向是否会污染数据。

</details>

---

## 62. 不同路径

<LeetCodeProblem titleSlug="unique-paths" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j]=dp[i-1][j]+dp[i][j-1]，可滚动成一维）</summary>

<UniversalEditor title="内存模型比较" compare={true}>
```javascript !! js
function uniquePaths(m, n) {
  const dp = new Array(n).fill(1) // 第一行全是 1
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[j] = dp[j] + dp[j - 1]
    }
  }
  return dp[n - 1]
}

// 5 个测试用例
console.log(uniquePaths(3, 7)) // 28
console.log(uniquePaths(3, 2)) // 3
console.log(uniquePaths(1, 1)) // 1
console.log(uniquePaths(1, 10)) // 1
console.log(uniquePaths(10, 1)) // 1
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- 机器人从左上到右下，只能向右或向下。
- **关键推理：到达一个格子只有两种来源**：
  - 从上面下来（`dp[i-1][j]`）
  - 从左边过来（`dp[i][j-1]`）
  所以 `dp[i][j]=dp[i-1][j]+dp[i][j-1]`。
- 第一行/第一列都只有 1 种走法。
- 用一维 dp 滚动：`dp[j]` 表示当前行的 dp 值，更新时 `dp[j] = dp[j] + dp[j-1]`。

</details>

<details>
<summary><strong>类似题目</strong>（网格 DP：来自上/左）</summary>

```javascript
dp[j] = dp[j] + dp[j-1]
```

</details>

---

## 64. 最小路径和

<LeetCodeProblem titleSlug="minimum-path-sum" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]）</summary>

<UniversalEditor title="内存模型比较" compare={true}>
```javascript !! js
function minPathSum(grid) {
  const m = grid.length
  const n = grid[0].length
  const dp = new Array(n).fill(0)

  dp[0] = grid[0][0]
  for (let j = 1; j < n; j++) dp[j] = dp[j - 1] + grid[0][j]

  for (let i = 1; i < m; i++) {
    dp[0] = dp[0] + grid[i][0]
    for (let j = 1; j < n; j++) {
      dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]
    }
  }

  return dp[n - 1]
}

// 5 个测试用例
console.log(minPathSum([[1,3,1],[1,5,1],[4,2,1]])) // 7
console.log(minPathSum([[1,2,3],[4,5,6]])) // 12
console.log(minPathSum([[5]])) // 5
console.log(minPathSum([[1],[2],[3]])) // 6
console.log(minPathSum([[1,1,1],[1,1,1]])) // 4
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- 和 62 一样，只是把“路径条数”换成“路径代价最小”。
- 到 `grid[i][j]` 的最小代价只能来自上或左的最小代价，再加上当前格子权重。
- 一维滚动时：
  - `dp[j]` 表示从上方来的最小和
  - `dp[j-1]` 表示从左方来的最小和（因为已更新到当前行）
  - 所以 `dp[j] = min(dp[j], dp[j-1]) + grid[i][j]`。

</details>

<details>
<summary><strong>类似题目</strong>（网格最短路 DP：来自上/左取 min）</summary>

```javascript
dp[j] = min(dp[j], dp[j-1]) + cost[i][j]
```

</details>

---

## 5. 最长回文子串

<LeetCodeProblem titleSlug="longest-palindromic-substring" />

<details>
<summary><strong>最优解</strong>（中心扩展：每个中心向两边扩，O(n^2) 时间 O(1) 空间）</summary>

<UniversalEditor title="内存模型比较" compare={true}>
```javascript !! js
function longestPalindrome(s) {
  if (s.length <= 1) return s
  let bestL = 0, bestR = 0

  function expand(l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      l--; r++
    }
    return [l + 1, r - 1]
  }

  for (let i = 0; i < s.length; i++) {
    const [l1, r1] = expand(i, i)     // 奇数长度
    const [l2, r2] = expand(i, i + 1) // 偶数长度
    if (r1 - l1 > bestR - bestL) { bestL = l1; bestR = r1 }
    if (r2 - l2 > bestR - bestL) { bestL = l2; bestR = r2 }
  }
  return s.slice(bestL, bestR + 1)
}

// 5 个测试用例
console.log(longestPalindrome("babad").length === 3) // true ("bab" or "aba")
console.log(longestPalindrome("cbbd")) // "bb"
console.log(longestPalindrome("a")) // "a"
console.log(longestPalindrome("ac")) // "a" or "c"
console.log(longestPalindrome("racecar")) // "racecar"
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **回文的定义**：左右对称。
- **关键推理：最长回文一定有一个“中心”**：
  - 奇数长度回文中心是一个字符（比如 `aba` 的中心是 b）
  - 偶数长度回文中心在两个字符之间（比如 `abba` 的中心在 bb 之间）
- 所以我们枚举每个可能中心，然后向两边扩展，直到不再相等。
- **为什么是 \(O(n^2)\)**：中心有 \(O(n)\) 个，每次扩展最坏 \(O(n)\)。
- 这题也可以用二维 DP 表 `pal[i][j]`，同样是 \(O(n^2)\)，中心扩展更省空间、更直观。

</details>

<details>
<summary><strong>类似题目</strong>（中心扩展模板）</summary>

```javascript
for center in all:
  expand(center, center)
  expand(center, center+1)
```

</details>

---

## 1143. 最长公共子序列

<LeetCodeProblem titleSlug="longest-common-subsequence" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j] 表示前 i/前 j 的 LCS 长度）</summary>

<UniversalEditor title="内存模型比较" compare={true}>
```javascript !! js
function longestCommonSubsequence(text1, text2) {
  const m = text1.length
  const n = text2.length
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0))

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1
      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
    }
  }
  return dp[m][n]
}

// 5 个测试用例
console.log(longestCommonSubsequence("abcde", "ace")) // 3
console.log(longestCommonSubsequence("abc", "abc")) // 3
console.log(longestCommonSubsequence("abc", "def")) // 0
console.log(longestCommonSubsequence("", "a")) // 0
console.log(longestCommonSubsequence("bsbininm", "jmjkbkjkv")) // 1
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **子序列**允许跳字符，所以不能用双指针直接贪心。
- **状态定义**：`dp[i][j]` 表示 `text1` 前 i 个字符与 `text2` 前 j 个字符的 LCS 长度。
- **转移推理**：
  - 如果最后一个字符相同：这对字符肯定可以贡献 1，所以 `dp[i][j]=dp[i-1][j-1]+1`。
  - 如果不同：最后一个字符至少有一个不在最优子序列里：
    - 要么丢掉 `text1[i-1]` → `dp[i-1][j]`
    - 要么丢掉 `text2[j-1]` → `dp[i][j-1]`
    取最大即可。

</details>

<details>
<summary><strong>类似题目</strong>（字符串二维 DP：末尾相同走对角，不同取上/左 max）</summary>

```javascript
if a[i-1]==b[j-1]: dp[i][j]=dp[i-1][j-1]+1
else dp[i][j]=max(dp[i-1][j], dp[i][j-1])
```

</details>

---

## 72. 编辑距离

<LeetCodeProblem titleSlug="edit-distance" />

<details>
<summary><strong>最优解</strong>（二维 DP：插入/删除/替换 三选一）</summary>

<UniversalEditor title="内存模型比较" compare={true}>
```javascript !! js
function minDistance(word1, word2) {
  const m = word1.length
  const n = word2.length
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0))

  for (let i = 0; i <= m; i++) dp[i][0] = i
  for (let j = 0; j <= n; j++) dp[0][j] = j

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]
      else {
        dp[i][j] = 1 + Math.min(
          dp[i - 1][j],     // 删除 word1[i-1]
          dp[i][j - 1],     // 插入 word2[j-1]
          dp[i - 1][j - 1]  // 替换
        )
      }
    }
  }
  return dp[m][n]
}

// 5 个测试用例
console.log(minDistance("horse", "ros")) // 3
console.log(minDistance("intention", "execution")) // 5
console.log(minDistance("", "a")) // 1
console.log(minDistance("a", "")) // 1
console.log(minDistance("abc", "abc")) // 0
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **编辑距离定义**：把 word1 变成 word2 的最少操作数（插入、删除、替换）。
- **状态定义**：`dp[i][j]` 表示把 `word1` 前 i 个字符变成 `word2` 前 j 个字符的最小操作数。
- **初始条件**：
  - `dp[i][0]=i`：变成空串只能删 i 次
  - `dp[0][j]=j`：从空串变成长度 j 只能插 j 次
- **转移推理**：
  - 如果末尾字符相同，不需要操作：`dp[i][j]=dp[i-1][j-1]`
  - 否则末尾要对齐，有三种方式：
    1. 删除 word1 末尾：`dp[i-1][j] + 1`
    2. 插入 word2 末尾：`dp[i][j-1] + 1`
    3. 替换 word1 末尾为 word2 末尾：`dp[i-1][j-1] + 1`
    取最小。

</details>

<details>
<summary><strong>类似题目</strong>（编辑类 DP：三操作取 min）</summary>

```javascript
if same: dp[i][j]=dp[i-1][j-1]
else dp[i][j]=1+min(del, ins, rep)
```

</details>

