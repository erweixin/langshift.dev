---
title: 多维动态规划（题单顺序）
description: 热题 100 - 多维动态规划分组（按题单顺序）：62 / 64 / 5 / 1143 / 72
---

import { LeetCodeProblem } from "@/components/leetcode/LeetCodeProblem"

本页包含题单「多维动态规划」分组的全部题目，顺序与 `list.json` 保持一致。

<details>
<summary><strong>多维 DP 统一“落地步骤”</strong>（点击展开）</summary>

- **状态**：`dp[i][j]` 表示什么（一定要带上“含义 + 范围”）。
- **转移**：`dp[i][j]` 从哪些更小状态来，为什么不会漏/重。
- **初始化**：边界（第一行/第一列/空串/长度为 0）怎么设，避免越界。
- **遍历顺序**：保证用到的状态已经算好（常见是从小到大）。
- **优化**：能否滚动数组（把二维压成一维），以及滚动时更新方向是否会污染数据。

</details>

---

## 62. 不同路径

<LeetCodeProblem titleSlug="unique-paths" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j]=dp[i-1][j]+dp[i][j-1]，可滚动成一维）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function uniquePaths(m, n) {
  const dp = new Array(n).fill(1) // 第一行全是 1
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[j] = dp[j] + dp[j - 1]
    }
  }
  return dp[n - 1]
}

// 5 个测试用例
console.log(uniquePaths(3, 7)) // 28
console.log(uniquePaths(3, 2)) // 3
console.log(uniquePaths(1, 1)) // 1
console.log(uniquePaths(1, 10)) // 1
console.log(uniquePaths(10, 1)) // 1
```

```go !! go
package main

import "fmt"

func uniquePaths(m, n int) int {
	dp := make([]int, n)
	for j := 0; j < n; j++ {
		dp[j] = 1
	}
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			dp[j] = dp[j] + dp[j-1]
		}
	}
	return dp[n-1]
}

func main() {
	fmt.Println(uniquePaths(3, 7))  // 28
	fmt.Println(uniquePaths(3, 2))   // 3
	fmt.Println(uniquePaths(1, 1))  // 1
	fmt.Println(uniquePaths(1, 10)) // 1
	fmt.Println(uniquePaths(10, 1)) // 1
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **题意**：你站在左上角，每次只能往右或往下走一步，问到右下角一共有多少种不同的走法？
- **核心想法**：走到某一个格子时，你**只能从它的上面一格下来**，或者**从它的左边一格过来**，没有别的路。所以「到达这个格子的走法数」=「到达上面那格的走法数」+「到达左边那格的走法数」。写成式子就是：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
- **边界**：第一行只能一直往右走，第一列只能一直往下走，所以第一行、第一列每个格子都只有 1 种走法，初始化为 1。
- **空间优化**：算每一行时只用得到「上一行」的结果，所以可以用一维数组「滚动」：`dp[j]` 表示当前行第 j 列有多少种走法，更新时用「上一行的 dp[j]」加上「当前行左边的 dp[j-1]」，即 `dp[j] = dp[j] + dp[j-1]`。

</details>

<details>
<summary><strong>类似题目</strong>（网格 DP：来自上/左）</summary>

思路相同：当前格子的值只依赖「上面」和「左边」，转移时用一维滚动即可，例如：

```javascript
dp[j] = dp[j] + dp[j-1]
```

</details>

---

## 64. 最小路径和

<LeetCodeProblem titleSlug="minimum-path-sum" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function minPathSum(grid) {
  const m = grid.length
  const n = grid[0].length
  const dp = new Array(n).fill(0)

  dp[0] = grid[0][0]
  for (let j = 1; j < n; j++) dp[j] = dp[j - 1] + grid[0][j]

  for (let i = 1; i < m; i++) {
    dp[0] = dp[0] + grid[i][0]
    for (let j = 1; j < n; j++) {
      dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]
    }
  }

  return dp[n - 1]
}

// 5 个测试用例
console.log(minPathSum([[1,3,1],[1,5,1],[4,2,1]])) // 7
console.log(minPathSum([[1,2,3],[4,5,6]])) // 12
console.log(minPathSum([[5]])) // 5
console.log(minPathSum([[1],[2],[3]])) // 6
console.log(minPathSum([[1,1,1],[1,1,1]])) // 4
```

```go !! go
package main

import "fmt"

func minPathSum(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	dp := make([]int, n)
	dp[0] = grid[0][0]
	for j := 1; j < n; j++ {
		dp[j] = dp[j-1] + grid[0][j]
	}
	for i := 1; i < m; i++ {
		dp[0] += grid[i][0]
		for j := 1; j < n; j++ {
			if dp[j] < dp[j-1] {
				dp[j] = dp[j] + grid[i][j]
			} else {
				dp[j] = dp[j-1] + grid[i][j]
			}
		}
	}
	return dp[n-1]
}

func main() {
	fmt.Println(minPathSum([][]int{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}})) // 7
	fmt.Println(minPathSum([][]int{{1, 2, 3}, {4, 5, 6}}))             // 12
	fmt.Println(minPathSum([][]int{{5}}))                               // 5
	fmt.Println(minPathSum([][]int{{1}, {2}, {3}}))                     // 6
	fmt.Println(minPathSum([][]int{{1, 1, 1}, {1, 1, 1}}))             // 4
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- 和 62 一样，只是把“路径条数”换成“路径代价最小”。
- 到 `grid[i][j]` 的最小代价只能来自上或左的最小代价，再加上当前格子权重。
- 一维滚动时：
  - `dp[j]` 表示从上方来的最小和
  - `dp[j-1]` 表示从左方来的最小和（因为已更新到当前行）
  - 所以 `dp[j] = min(dp[j], dp[j-1]) + grid[i][j]`。

</details>

<details>
<summary><strong>类似题目</strong>（网格最短路 DP：来自上/左取 min）</summary>

```javascript
dp[j] = min(dp[j], dp[j-1]) + cost[i][j]
```

</details>

---

## 5. 最长回文子串

<LeetCodeProblem titleSlug="longest-palindromic-substring" />

<details>
<summary><strong>最优解</strong>（中心扩展：每个中心向两边扩，O(n^2) 时间 O(1) 空间）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function longestPalindrome(s) {
  if (s.length <= 1) return s
  let bestL = 0, bestR = 0

  function expand(l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      l--; r++
    }
    return [l + 1, r - 1]
  }

  for (let i = 0; i < s.length; i++) {
    const [l1, r1] = expand(i, i)     // 奇数长度
    const [l2, r2] = expand(i, i + 1) // 偶数长度
    if (r1 - l1 > bestR - bestL) { bestL = l1; bestR = r1 }
    if (r2 - l2 > bestR - bestL) { bestL = l2; bestR = r2 }
  }
  return s.slice(bestL, bestR + 1)
}

// 5 个测试用例
console.log(longestPalindrome("babad").length === 3) // true ("bab" or "aba")
console.log(longestPalindrome("cbbd")) // "bb"
console.log(longestPalindrome("a")) // "a"
console.log(longestPalindrome("ac")) // "a" or "c"
console.log(longestPalindrome("racecar")) // "racecar"
```

```go !! go
package main

import "fmt"

func longestPalindrome(s string) string {
	if len(s) <= 1 {
		return s
	}
	bestL, bestR := 0, 0
	expand := func(l, r int) (int, int) {
		for l >= 0 && r < len(s) && s[l] == s[r] {
			l--
			r++
		}
		return l + 1, r - 1
	}
	for i := 0; i < len(s); i++ {
		l1, r1 := expand(i, i)
		l2, r2 := expand(i, i+1)
		if r1-l1 > bestR-bestL {
			bestL, bestR = l1, r1
		}
		if r2-l2 > bestR-bestL {
			bestL, bestR = l2, r2
		}
	}
	return s[bestL : bestR+1]
}

func main() {
	fmt.Println(len(longestPalindrome("babad")) == 3) // true
	fmt.Println(longestPalindrome("cbbd"))            // "bb"
	fmt.Println(longestPalindrome("a"))                // "a"
	fmt.Println(longestPalindrome("ac"))              // "a" or "c"
	fmt.Println(longestPalindrome("racecar"))          // "racecar"
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **回文的定义**：左右对称。
- **关键推理：最长回文一定有一个“中心”**：
  - 奇数长度回文中心是一个字符（比如 `aba` 的中心是 b）
  - 偶数长度回文中心在两个字符之间（比如 `abba` 的中心在 bb 之间）
- 所以我们枚举每个可能中心，然后向两边扩展，直到不再相等。
- **为什么是 \(O(n^2)\)**：中心有 \(O(n)\) 个，每次扩展最坏 \(O(n)\)。
- 这题也可以用二维 DP 表 `pal[i][j]`，同样是 \(O(n^2)\)，中心扩展更省空间、更直观。

</details>

<details>
<summary><strong>类似题目</strong>（中心扩展模板）</summary>

```javascript
for center in all:
  expand(center, center)
  expand(center, center+1)
```

</details>

---

## 1143. 最长公共子序列

<LeetCodeProblem titleSlug="longest-common-subsequence" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j] 表示前 i/前 j 的 LCS 长度）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function longestCommonSubsequence(text1, text2) {
  const m = text1.length
  const n = text2.length
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0))

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1
      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
    }
  }
  return dp[m][n]
}

// 5 个测试用例
console.log(longestCommonSubsequence("abcde", "ace")) // 3
console.log(longestCommonSubsequence("abc", "abc")) // 3
console.log(longestCommonSubsequence("abc", "def")) // 0
console.log(longestCommonSubsequence("", "a")) // 0
console.log(longestCommonSubsequence("bsbininm", "jmjkbkjkv")) // 1
```

```go !! go
package main

import "fmt"

func longestCommonSubsequence(text1, text2 string) int {
	m, n := len(text1), len(text2)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if text1[i-1] == text2[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				if dp[i-1][j] > dp[i][j-1] {
					dp[i][j] = dp[i-1][j]
				} else {
					dp[i][j] = dp[i][j-1]
				}
			}
		}
	}
	return dp[m][n]
}

func main() {
	fmt.Println(longestCommonSubsequence("abcde", "ace"))   // 3
	fmt.Println(longestCommonSubsequence("abc", "abc"))     // 3
	fmt.Println(longestCommonSubsequence("abc", "def"))     // 0
	fmt.Println(longestCommonSubsequence("", "a"))          // 0
	fmt.Println(longestCommonSubsequence("bsbininm", "jmjkbkjkv")) // 1
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **题意**：从两个字符串里各挑一些字符（顺序不变、可以不连续），能凑出的**最长相同串**有多长？这就是「最长公共子序列」。
- **想法**：`dp[i][j]` 表示：只看 `text1` 的前 i 个、`text2` 的前 j 个，这段里最长公共子序列的长度。
- **怎么算**？看「最后一个字符」：
  - **一样**：这两个字符可以一起算进公共子序列，长度就是「前面那段的答案 + 1」，即 `dp[i][j] = dp[i-1][j-1] + 1`。
  - **不一样**：这两个里至少有一个不能配对。那就看两种选择谁更大：不用 text1 的最后一个（相当于 `dp[i-1][j]`），或不用 text2 的最后一个（相当于 `dp[i][j-1]`），取较大值：`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。

</details>

<details>
<summary><strong>类似题目</strong>（字符串二维 DP：末尾相同走对角，不同取上/左 max）</summary>

套路一样：看两串「末尾」是否相同，相同就对角 +1，不同就从上/左取最大：

```javascript
if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1
else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
```

</details>

---

## 72. 编辑距离

<LeetCodeProblem titleSlug="edit-distance" />

<details>
<summary><strong>最优解</strong>（二维 DP：插入/删除/替换 三选一）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function minDistance(word1, word2) {
  const m = word1.length
  const n = word2.length
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0))

  for (let i = 0; i <= m; i++) dp[i][0] = i
  for (let j = 0; j <= n; j++) dp[0][j] = j

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]
      else {
        dp[i][j] = 1 + Math.min(
          dp[i - 1][j],     // 删除 word1[i-1]
          dp[i][j - 1],     // 插入 word2[j-1]
          dp[i - 1][j - 1]  // 替换
        )
      }
    }
  }
  return dp[m][n]
}

// 5 个测试用例
console.log(minDistance("horse", "ros")) // 3
console.log(minDistance("intention", "execution")) // 5
console.log(minDistance("", "a")) // 1
console.log(minDistance("a", "")) // 1
console.log(minDistance("abc", "abc")) // 0
```

```go !! go
package main

import "fmt"

func minDistance(word1, word2 string) int {
	m, n := len(word1), len(word2)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}
	for i := 0; i <= m; i++ {
		dp[i][0] = i
	}
	for j := 0; j <= n; j++ {
		dp[0][j] = j
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if word1[i-1] == word2[j-1] {
				dp[i][j] = dp[i-1][j-1]
			} else {
				min := dp[i-1][j]
				if dp[i][j-1] < min {
					min = dp[i][j-1]
				}
				if dp[i-1][j-1] < min {
					min = dp[i-1][j-1]
				}
				dp[i][j] = 1 + min
			}
		}
	}
	return dp[m][n]
}

func main() {
	fmt.Println(minDistance("horse", "ros"))         // 3
	fmt.Println(minDistance("intention", "execution")) // 5
	fmt.Println(minDistance("", "a"))                 // 1
	fmt.Println(minDistance("a", ""))                // 1
	fmt.Println(minDistance("abc", "abc"))            // 0
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **编辑距离定义**：把 word1 变成 word2 的最少操作数（插入、删除、替换）。
- **状态定义**：`dp[i][j]` 表示把 `word1` 前 i 个字符变成 `word2` 前 j 个字符的最小操作数。
- **初始条件**：
  - `dp[i][0]=i`：变成空串只能删 i 次
  - `dp[0][j]=j`：从空串变成长度 j 只能插 j 次
- **转移推理**：
  - 如果末尾字符相同，不需要操作：`dp[i][j]=dp[i-1][j-1]`
  - 否则末尾要对齐，有三种方式：
    1. 删除 word1 末尾：`dp[i-1][j] + 1`
    2. 插入 word2 末尾：`dp[i][j-1] + 1`
    3. 替换 word1 末尾为 word2 末尾：`dp[i-1][j-1] + 1`
    取最小。

</details>

<details>
<summary><strong>类似题目</strong>（编辑类 DP：三操作取 min）</summary>

```javascript
if same: dp[i][j]=dp[i-1][j-1]
else dp[i][j]=1+min(del, ins, rep)
```

</details>

