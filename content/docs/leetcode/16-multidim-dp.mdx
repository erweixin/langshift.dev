---
title: 多维动态规划（题单顺序）
description: 热题 100 - 多维动态规划分组（按题单顺序）：62 / 64 / 5 / 1143 / 72
---

import { LeetCodeProblem } from "@/components/leetcode/LeetCodeProblem"

本页包含题单「多维动态规划」分组的全部题目，顺序与 `list.json` 保持一致。

<details>
<summary><strong>多维 DP 统一“落地步骤”</strong>（点击展开）</summary>

- **状态**：`dp[i][j]` 表示什么（一定要带上“含义 + 范围”）。
- **转移**：`dp[i][j]` 从哪些更小状态来，为什么不会漏/重。
- **初始化**：边界（第一行/第一列/空串/长度为 0）怎么设，避免越界。
- **遍历顺序**：保证用到的状态已经算好（常见是从小到大）。
- **优化**：能否滚动数组（把二维压成一维），以及滚动时更新方向是否会污染数据。

</details>

---

## 62. 不同路径

<LeetCodeProblem titleSlug="unique-paths" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j]=dp[i-1][j]+dp[i][j-1]，可滚动成一维）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function uniquePaths(m, n) {
  const dp = new Array(n).fill(1) // 第一行全是 1
  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[j] = dp[j] + dp[j - 1]
    }
  }
  return dp[n - 1]
}

// 5 个测试用例
console.log(uniquePaths(3, 7)) // 28
console.log(uniquePaths(3, 2)) // 3
console.log(uniquePaths(1, 1)) // 1
console.log(uniquePaths(1, 10)) // 1
console.log(uniquePaths(10, 1)) // 1
```

```go !! go
package main

import "fmt"

func uniquePaths(m, n int) int {
	dp := make([]int, n)
	for j := 0; j < n; j++ {
		dp[j] = 1
	}
	for i := 1; i < m; i++ {
		for j := 1; j < n; j++ {
			dp[j] = dp[j] + dp[j-1]
		}
	}
	return dp[n-1]
}

func main() {
	fmt.Println(uniquePaths(3, 7))  // 28
	fmt.Println(uniquePaths(3, 2))   // 3
	fmt.Println(uniquePaths(1, 1))  // 1
	fmt.Println(uniquePaths(1, 10)) // 1
	fmt.Println(uniquePaths(10, 1)) // 1
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **题意**：你站在左上角，每次只能往右或往下走一步，问到右下角一共有多少种不同的走法？
- **核心想法**：走到某一个格子时，你**只能从它的上面一格下来**，或者**从它的左边一格过来**，没有别的路。所以「到达这个格子的走法数」=「到达上面那格的走法数」+「到达左边那格的走法数」。写成式子就是：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`。
- **边界**：第一行只能一直往右走，第一列只能一直往下走，所以第一行、第一列每个格子都只有 1 种走法，初始化为 1。
- **空间优化**：算每一行时只用得到「上一行」的结果，所以可以用一维数组「滚动」：`dp[j]` 表示当前行第 j 列有多少种走法，更新时用「上一行的 dp[j]」加上「当前行左边的 dp[j-1]」，即 `dp[j] = dp[j] + dp[j-1]`。

</details>

<details>
<summary><strong>类似题目</strong>（网格 DP：来自上/左）</summary>

思路相同：当前格子的值只依赖「上面」和「左边」，转移时用一维滚动即可，例如：

```javascript
dp[j] = dp[j] + dp[j-1]
```

</details>

---

## 64. 最小路径和

<LeetCodeProblem titleSlug="minimum-path-sum" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j]）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function minPathSum(grid) {
  const m = grid.length
  const n = grid[0].length
  const dp = new Array(n).fill(0)

  dp[0] = grid[0][0]
  for (let j = 1; j < n; j++) dp[j] = dp[j - 1] + grid[0][j]

  for (let i = 1; i < m; i++) {
    dp[0] = dp[0] + grid[i][0]
    for (let j = 1; j < n; j++) {
      dp[j] = Math.min(dp[j], dp[j - 1]) + grid[i][j]
    }
  }

  return dp[n - 1]
}

// 5 个测试用例
console.log(minPathSum([[1,3,1],[1,5,1],[4,2,1]])) // 7
console.log(minPathSum([[1,2,3],[4,5,6]])) // 12
console.log(minPathSum([[5]])) // 5
console.log(minPathSum([[1],[2],[3]])) // 6
console.log(minPathSum([[1,1,1],[1,1,1]])) // 4
```

```go !! go
package main

import "fmt"

func minPathSum(grid [][]int) int {
	m, n := len(grid), len(grid[0])
	dp := make([]int, n)
	dp[0] = grid[0][0]
	for j := 1; j < n; j++ {
		dp[j] = dp[j-1] + grid[0][j]
	}
	for i := 1; i < m; i++ {
		dp[0] += grid[i][0]
		for j := 1; j < n; j++ {
			if dp[j] < dp[j-1] {
				dp[j] = dp[j] + grid[i][j]
			} else {
				dp[j] = dp[j-1] + grid[i][j]
			}
		}
	}
	return dp[n-1]
}

func main() {
	fmt.Println(minPathSum([][]int{{1, 3, 1}, {1, 5, 1}, {4, 2, 1}})) // 7
	fmt.Println(minPathSum([][]int{{1, 2, 3}, {4, 5, 6}}))             // 12
	fmt.Println(minPathSum([][]int{{5}}))                               // 5
	fmt.Println(minPathSum([][]int{{1}, {2}, {3}}))                     // 6
	fmt.Println(minPathSum([][]int{{1, 1, 1}, {1, 1, 1}}))             // 4
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- 和 62 一样，只是把“路径条数”换成“路径代价最小”。
- 到 `grid[i][j]` 的最小代价只能来自上或左的最小代价，再加上当前格子权重。
- 一维滚动时：
  - `dp[j]` 表示从上方来的最小和
  - `dp[j-1]` 表示从左方来的最小和（因为已更新到当前行）
  - 所以 `dp[j] = min(dp[j], dp[j-1]) + grid[i][j]`。

</details>

<details>
<summary><strong>类似题目</strong>（网格最短路 DP：来自上/左取 min）</summary>

```javascript
dp[j] = min(dp[j], dp[j-1]) + cost[i][j]
```

</details>

---

## 5. 最长回文子串

<LeetCodeProblem titleSlug="longest-palindromic-substring" />

<details>
<summary><strong>最优解</strong>（中心扩展：每个中心向两边扩，O(n^2) 时间 O(1) 空间）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function longestPalindrome(s) {
  if (s.length < 2) return s

  let start = 0, maxLen = 1

  const expand = (l, r) => {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
      if (r - l + 1 > maxLen) {
        start = l
        maxLen = r - l + 1
      }
      l--
      r++
    }
  }

  for (let i = 0; i < s.length; i++) {
    expand(i, i)     // 奇数长度
    expand(i, i + 1) // 偶数长度
  }

  return s.substring(start, start + maxLen)
}

// 5 个测试用例
console.log(longestPalindrome("babad").length === 3) // true ("bab" or "aba")
console.log(longestPalindrome("cbbd")) // "bb"
console.log(longestPalindrome("a")) // "a"
console.log(longestPalindrome("ac")) // "a" or "c"
console.log(longestPalindrome("racecar")) // "racecar"
```

```go !! go
package main

import "fmt"

func longestPalindrome(s string) string {
	if len(s) < 2 {
		return s
	}
	start, maxLen := 0, 1
	var expand func(l, r int)
	expand = func(l, r int) {
		for l >= 0 && r < len(s) && s[l] == s[r] {
			if r-l+1 > maxLen {
				start = l
				maxLen = r - l + 1
			}
			l--
			r++
		}
	}
	for i := 0; i < len(s); i++ {
		expand(i, i)     // 奇数长度
		expand(i, i+1)   // 偶数长度
	}
	return s[start : start+maxLen]
}

func main() {
	fmt.Println(len(longestPalindrome("babad")) == 3) // true
	fmt.Println(longestPalindrome("cbbd"))            // "bb"
	fmt.Println(longestPalindrome("a"))                // "a"
	fmt.Println(longestPalindrome("ac"))              // "a" or "c"
	fmt.Println(longestPalindrome("racecar"))          // "racecar"
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **回文的定义**：左右对称。
- **关键推理：最长回文一定有一个“中心”**：
  - 奇数长度回文中心是一个字符（比如 `aba` 的中心是 b）
  - 偶数长度回文中心在两个字符之间（比如 `abba` 的中心在 bb 之间）
- 所以我们枚举每个可能中心，然后向两边扩展，直到不再相等。
- **为什么是 \(O(n^2)\)**：中心有 \(O(n)\) 个，每次扩展最坏 \(O(n)\)。
- 这题也可以用二维 DP 表 `pal[i][j]`，同样是 \(O(n^2)\)，中心扩展更省空间、更直观。

</details>

<details>
<summary><strong>类似题目</strong>（中心扩展模板）</summary>

```javascript
for center in all:
  expand(center, center)
  expand(center, center+1)
```

</details>

---

## 1143. 最长公共子序列

<LeetCodeProblem titleSlug="longest-common-subsequence" />

<details>
<summary><strong>最优解</strong>（二维 DP：dp[i][j] 表示前 i/前 j 的 LCS 长度）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function longestCommonSubsequence(text1, text2) {
  const m = text1.length
  const n = text2.length
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0))

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (text1[i - 1] === text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1
      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
    }
  }
  return dp[m][n]
}

// 5 个测试用例
console.log(longestCommonSubsequence("abcde", "ace")) // 3
console.log(longestCommonSubsequence("abc", "abc")) // 3
console.log(longestCommonSubsequence("abc", "def")) // 0
console.log(longestCommonSubsequence("", "a")) // 0
console.log(longestCommonSubsequence("bsbininm", "jmjkbkjkv")) // 1
```

```go !! go
package main

import "fmt"

func longestCommonSubsequence(text1, text2 string) int {
	m, n := len(text1), len(text2)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if text1[i-1] == text2[j-1] {
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				if dp[i-1][j] > dp[i][j-1] {
					dp[i][j] = dp[i-1][j]
				} else {
					dp[i][j] = dp[i][j-1]
				}
			}
		}
	}
	return dp[m][n]
}

func main() {
	fmt.Println(longestCommonSubsequence("abcde", "ace"))   // 3
	fmt.Println(longestCommonSubsequence("abc", "abc"))     // 3
	fmt.Println(longestCommonSubsequence("abc", "def"))     // 0
	fmt.Println(longestCommonSubsequence("", "a"))          // 0
	fmt.Println(longestCommonSubsequence("bsbininm", "jmjkbkjkv")) // 1
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

**题目在问什么？**

想象有两排字母，顺序固定。你从第一排里挑几个、从第二排里也挑几个，要挑出**一模一样的一串**（顺序一致）。问：这串**最长能有多长**？

例：`"abcde"` 和 `"ace"`，能挑出 `"ace"`，长度 3。

---

**推理的起点：先解决“小一点”的问题**

如果只让你看两串的**前几格**，你也会算“这两小段里最长公共串多长”。我们就把这个答案记在一张表里：**dp[i][j] = text1 前 i 个 与 text2 前 j 个 的最长公共子序列长度**。

表从左到右、从上到下填。填到 (i, j) 时，**左边、上边、左上**的格子都早就填好了，我们只要想：**多出来的这两个字符（text1 的第 i 个 和 text2 的第 j 个）该怎么用？**

---

**情况一：这两个字符刚好相同**

那就太好了：它们可以**一起配对**，算进公共串里。  
“前面的部分”我们早就算过了，就是左上角那一格 **dp[i-1][j-1]**。所以当前格 = 左上 + 1：

- **dp[i][j] = dp[i-1][j-1] + 1**

（就像两个人最后一位对上号了，长度自然多 1。）

---

**情况二：这两个字符不一样**

公共子序列的意思是：从两串里挑出**同一串**，也就是两边的字符要能**一一配对**（相同的才能配）。现在最后这两个字符不同，**配不成一对**，所以没法把“这两个”同时都算进公共串里。

那我们只能选一种「放弃」方式：要么**放弃 text1 的最后这个**（相当于只考虑 text1 前 i-1 个 和 text2 前 j 个），答案在**上面**那格 dp[i-1][j]；要么**放弃 text2 的最后这个**（只考虑 text1 前 i 个 和 text2 前 j-1 个），答案在**左边**那格 dp[i][j-1]。我们要的是最长公共串，所以取这两种里更大的：

- **dp[i][j] = max(上面, 左边) = max(dp[i-1][j], dp[i][j-1])**

---

**小结**

- 最后一位**相同** → 左上 +1（配对成功）。
- 最后一位**不同** → 上面、左边取 max（只能丢掉其中一串的最后一位，选更优的那边）。

填完表，右下角 **dp[m][n]** 就是答案。

</details>

<details>
<summary><strong>类似题目</strong>（字符串二维 DP：末尾相同走对角，不同取上/左 max）</summary>

套路一样：看两串「末尾」是否相同，相同就对角 +1，不同就从上/左取最大：

```javascript
if (a[i - 1] === b[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1
else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
```

</details>

---

## 72. 编辑距离

<LeetCodeProblem titleSlug="edit-distance" />

<details>
<summary><strong>最优解</strong>（二维 DP：插入/删除/替换 三选一）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function minDistance(word1, word2) {
  const m = word1.length
  const n = word2.length
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0))

  for (let i = 0; i <= m; i++) dp[i][0] = i
  for (let j = 0; j <= n; j++) dp[0][j] = j

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (word1[i - 1] === word2[j - 1]) dp[i][j] = dp[i - 1][j - 1]
      else {
        dp[i][j] = 1 + Math.min(
          dp[i - 1][j],     // 删除 word1[i-1]
          dp[i][j - 1],     // 插入 word2[j-1]
          dp[i - 1][j - 1]  // 替换
        )
      }
    }
  }
  return dp[m][n]
}

// 5 个测试用例
console.log(minDistance("horse", "ros")) // 3
console.log(minDistance("intention", "execution")) // 5
console.log(minDistance("", "a")) // 1
console.log(minDistance("a", "")) // 1
console.log(minDistance("abc", "abc")) // 0
```

```go !! go
package main

import "fmt"

func minDistance(word1, word2 string) int {
	m, n := len(word1), len(word2)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}
	for i := 0; i <= m; i++ {
		dp[i][0] = i
	}
	for j := 0; j <= n; j++ {
		dp[0][j] = j
	}
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if word1[i-1] == word2[j-1] {
				dp[i][j] = dp[i-1][j-1]
			} else {
				min := dp[i-1][j]
				if dp[i][j-1] < min {
					min = dp[i][j-1]
				}
				if dp[i-1][j-1] < min {
					min = dp[i-1][j-1]
				}
				dp[i][j] = 1 + min
			}
		}
	}
	return dp[m][n]
}

func main() {
	fmt.Println(minDistance("horse", "ros"))         // 3
	fmt.Println(minDistance("intention", "execution")) // 5
	fmt.Println(minDistance("", "a"))                 // 1
	fmt.Println(minDistance("a", ""))                // 1
	fmt.Println(minDistance("abc", "abc"))            // 0
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

这题是字符串 DP 里的另一座大山，但本质和 **LCS 是亲兄弟**。掌握它，你对「字符串怎么一点点变形」会理解得非常透。

---

**题目在干嘛？**

给你两个单词：**word1 → 变成 → word2**。每次只能做 3 种操作：

1. **插入**一个字符  
2. **删除**一个字符  
3. **替换**一个字符  

问：**最少要几步？**

例如 **horse → ros** 的一种做法：

- horse → rorse（替换 h→r）
- rorse → rose（删除 r）
- rose → ros（删除 e）  
答案 = 3。

---

**核心思路（一句话）**

把大问题拆成：**前 i 个字符变成前 j 个字符要几步**。

---

**DP 定义**

**dp[i][j]** = 把 **word1 前 i 个字符** 变成 **word2 前 j 个字符** 的**最少操作数**。

注意：是“前 i 个”，不是下标 i（所以 i、j 从 1 到 m、n，0 留给空串）。

---

**初始化（边界）**

| 情况 | 含义 | 值 |
|------|------|-----|
| dp[0][j] | 空串 → word2 前 j 个 | 需要插入 j 次 → **j** |
| dp[i][0] | word1 前 i 个 → 空串 | 需要删除 i 次 → **i** |

---

**状态转移（灵魂所在）**

看**最后一个字符**：word1[i-1] 和 word2[j-1]。

**情况 1：两个字符相同**

那最后这个字符不用管，等于没变：**dp[i][j] = dp[i-1][j-1]**（前面怎么变，现在就怎么变）。

**情况 2：字符不同**

必须做一次操作（插入 / 删除 / 替换），取**步数最少**的一种：

| 操作 | 含义 | 转移 |
|------|------|------|
| 替换 | 把 word1[i-1] 换成 word2[j-1] | dp[i-1][j-1] + 1 |
| 删除 | 删掉 word1[i-1]，word1 少一个再去匹配 word2 | dp[i-1][j] + 1 |
| 插入 | 在 word1 末尾插入 word2[j-1]，相当于 word2 少一个先匹配 | dp[i][j-1] + 1 |

**为什么对应这个格子？**

- **dp[i-1][j] + 1（删除）**：当前是“word1 前 i 个”对“word2 前 j 个”。若**删掉 word1 的最后一个**，剩下的问题就是“word1 前 i-1 个 → word2 前 j 个”，答案已经算在 **dp[i-1][j]** 里，再加这一次删除就是 dp[i-1][j] + 1。
- **dp[i][j-1] + 1（插入）**：若**在 word1 末尾插入 word2[j-1]**，插入后末尾已经对齐；等价于先解决“word1 前 i 个 → word2 前 j-1 个”（**dp[i][j-1]**），再用 1 步插入补上 word2 的最后一个。
- **dp[i-1][j-1] + 1（替换）**：若**把 word1[i-1] 替换成 word2[j-1]**，两边末尾就一样了；等价于先解决“word1 前 i-1 个 → word2 前 j-1 个”（**dp[i-1][j-1]**），再加这 1 次替换。

**取最小**：**dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])**

---

**过程直观理解**

可以理解为：从左上角走到右下角，每一步都在做「最省操作的选择」。代码见上方最优解。

**复杂度**：时间 O(m×n)，空间 O(m×n)（可优化到 O(n)）。

---

**和 LCS 的关系**

| | LCS | 编辑距离 |
|--|-----|----------|
| 末尾相同 | 配对，+1 | 不操作，继承左上 |
| 末尾不同 | 取 max（丢一边） | 取 min + 1（替换/删/插） |
| 目标 | 求最长“保留” | 求最少“修改” |

LCS 是「尽量不改」，编辑距离是「最少改几步」，本质都是在比较两个字符串的**对齐方式**。

---

**最通俗总结**

- **字符一样** → 继承左上角。  
- **字符不一样** → 从「替换、删除、插入」里选最便宜的一步。

延伸：若**只允许插入和删除**（不允许替换），有结论：编辑距离 = len1 + len2 − 2×LCS，能把两道题直接打通。

</details>

<details>
<summary><strong>类似题目</strong>（编辑类 DP：三操作取 min）</summary>

```javascript
if same: dp[i][j]=dp[i-1][j-1]
else dp[i][j]=1+min(del, ins, rep)
```

</details>

