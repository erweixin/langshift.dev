---
title: 栈（题单顺序）
description: 热题 100 - 栈分组（按题单顺序）：20 / 155 / 394 / 739 / 84
---

import { LeetCodeProblem } from "@/components/leetcode/LeetCodeProblem"

本页包含题单「栈」分组的全部题目，顺序与 `list.json` 保持一致。

<details>
<summary><strong>栈题统一“思维抓手”</strong>（点击展开）</summary>

- **栈适合解决“最近的/成对的/回退”的关系**：最近的左括号、最近更大/更小元素、解析嵌套结构等。
- **单调栈的核心不变量**：栈内元素按值单调（递增或递减），被弹出的元素说明“它的答案已经确定”。
- **下标 vs 值**：多数数组类栈题（739/84）栈里存**下标**，因为需要算距离/宽度。

</details>

---

## 20. 有效的括号

<LeetCodeProblem titleSlug="valid-parentheses" />

<details>
<summary><strong>最优解</strong>（栈：遇到右括号就匹配最近的左括号）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function isValid(s) {
  const st = []
  const match = { ")": "(", "]": "[", "}": "{" }
  for (const ch of s) {
    if (ch === "(" || ch === "[" || ch === "{") st.push(ch)
    else {
      if (!st.length) return false
      const top = st.pop()
      if (top !== match[ch]) return false
    }
  }
  return st.length === 0
}

// 5 个测试用例
console.log(isValid("()")) // true
console.log(isValid("()[]{}")) // true
console.log(isValid("(]")) // false
console.log(isValid("([)]")) // false
console.log(isValid("{[]}")) // true
```

```go !! go
package main

import "fmt"

func isValid(s string) bool {
	var st []byte
	match := map[byte]byte{')': '(', ']': '[', '}': '{'}
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if ch == '(' || ch == '[' || ch == '{' {
			st = append(st, ch)
		} else {
			if len(st) == 0 {
				return false
			}
			top := st[len(st)-1]
			st = st[:len(st)-1]
			if top != match[ch] {
				return false
			}
		}
	}
	return len(st) == 0
}

func main() {
	fmt.Println(isValid("()"), isValid("()[]{}"), isValid("(]"), isValid("([)]"), isValid("{[]}"))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **括号合法的本质**：必须“后开先关”。最近打开的括号一定要最先被关闭。
- 这句“后开先关”就是典型的 **栈** 行为（LIFO）。
- **推理流程**：
  - 遇到左括号：先记下来，等后面来关它 → 入栈
  - 遇到右括号：必须和“最近的左括号”匹配 → 出栈并检查类型
- **为什么最后还要栈空？**：如果还有没关掉的左括号，字符串也不合法。

</details>

<details>
<summary><strong>类似题目</strong>（括号/消消乐：栈匹配最近元素）</summary>

```javascript
for ch in s:
  if opening: push
  else: pop and check
return stack empty
```

</details>

---

## 155. 最小栈

<LeetCodeProblem titleSlug="min-stack" />

<details>
<summary><strong>最优解</strong>（双栈：数据栈 + 最小值栈）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function MinStack() {
  this.st = []
  this.minSt = []
}

MinStack.prototype.push = function(val) {
  this.st.push(val)
  const curMin = this.minSt.length ? Math.min(this.minSt[this.minSt.length - 1], val) : val
  this.minSt.push(curMin)
}

MinStack.prototype.pop = function() {
  this.st.pop()
  this.minSt.pop()
}

MinStack.prototype.top = function() {
  return this.st[this.st.length - 1]
}

MinStack.prototype.getMin = function() {
  return this.minSt[this.minSt.length - 1]
}

// 5 个测试用例
{
  const ms = new MinStack()
  ms.push(-2); ms.push(0); ms.push(-3)
  console.log(ms.getMin()) // -3
  ms.pop()
  console.log(ms.top()) // 0
  console.log(ms.getMin()) // -2
}
{
  const ms = new MinStack()
  ms.push(2); ms.push(2); ms.push(1)
  console.log(ms.getMin()) // 1
  ms.pop()
  console.log(ms.getMin()) // 2
}
{
  const ms = new MinStack()
  ms.push(5)
  console.log(ms.getMin()) // 5
  ms.pop()
  ms.push(7)
  console.log(ms.getMin()) // 7
}
```

```go !! go
package main

import "fmt"

type MinStack struct {
	st   []int
	minSt []int
}

func Constructor() MinStack {
	return MinStack{}
}

func (m *MinStack) Push(val int) {
	m.st = append(m.st, val)
	curMin := val
	if len(m.minSt) > 0 && m.minSt[len(m.minSt)-1] < val {
		curMin = m.minSt[len(m.minSt)-1]
	}
	m.minSt = append(m.minSt, curMin)
}

func (m *MinStack) Pop() {
	m.st = m.st[:len(m.st)-1]
	m.minSt = m.minSt[:len(m.minSt)-1]
}

func (m *MinStack) Top() int {
	return m.st[len(m.st)-1]
}

func (m *MinStack) GetMin() int {
	return m.minSt[len(m.minSt)-1]
}

func main() {
	ms := Constructor()
	ms.Push(-2)
	ms.Push(0)
	ms.Push(-3)
	fmt.Println(ms.GetMin())
	ms.Pop()
	fmt.Println(ms.Top(), ms.GetMin())
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **难点**：普通栈的 `pop/top` 都是 \(O(1)\)，但 `getMin` 如果每次都扫描一遍栈，会变成 \(O(n)\)。
- **关键推理：把“历史最小值”也一起压栈**：
  - 当我们 push 一个值 `val`，我们其实想知道“push 之后栈里的最小值是多少”。
  - 这个最小值 = `min(之前的最小值, val)`。
  - 所以用另一个栈 `minSt`，让 `minSt[i]` 记录“主栈 st 在高度 i 时的最小值”。
- **为什么 pop 时两个栈都 pop？**：因为它们是一一对应的，栈高度必须同步。

</details>

<details>
<summary><strong>类似题目</strong>（栈增强：额外维护一个“前缀最值/前缀信息”栈）</summary>

```javascript
push(x): minSt.push(min(minSt.top, x))
pop(): st.pop(); minSt.pop()
getMin(): minSt.top
```

</details>

---

## 394. 字符串解码

<LeetCodeProblem titleSlug="decode-string" />

<details>
<summary><strong>最优解</strong>（双栈：numStack 存倍数，strStack 存进入 [ 前的字符串）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function decodeString(s) {
  const numStack = []
  const strStack = []
  let curNum = 0
  let curStr = ""

  for (const ch of s) {
    if (ch >= "0" && ch <= "9") {
      curNum = curNum * 10 + (ch.charCodeAt(0) - 48)
    } else if (ch === "[") {
      numStack.push(curNum)
      strStack.push(curStr)
      curNum = 0
      curStr = ""
    } else if (ch === "]") {
      const k = numStack.pop()
      const prevStr = strStack.pop()
      curStr = prevStr + curStr.repeat(k)
    } else {
      curStr += ch
    }
  }
  return curStr
}

// 5 个测试用例
console.log(decodeString("3[a]2[bc]")) // "aaabcbc"
console.log(decodeString("3[a2[c]]")) // "accaccacc"
console.log(decodeString("2[abc]3[cd]ef")) // "abcabccdcdcdef"
console.log(decodeString("10[a]")) // 10 个 a
console.log(decodeString("abc3[cd]xyz")) // "abccdcdcdxyz"
```

```go !! go
package main

import (
	"fmt"
	"strings"
)

func decodeString(s string) string {
	var numStack []int
	var strStack []string
	curNum := 0
	curStr := ""
	for i := 0; i < len(s); i++ {
		ch := s[i]
		if ch >= '0' && ch <= '9' {
			curNum = curNum*10 + int(ch-'0')
		} else if ch == '[' {
			numStack = append(numStack, curNum)
			strStack = append(strStack, curStr)
			curNum = 0
			curStr = ""
		} else if ch == ']' {
			k := numStack[len(numStack)-1]
			numStack = numStack[:len(numStack)-1]
			prevStr := strStack[len(strStack)-1]
			strStack = strStack[:len(strStack)-1]
			curStr = prevStr + strings.Repeat(curStr, k)
		} else {
			curStr += string(ch)
		}
	}
	return curStr
}

func main() {
	fmt.Println(decodeString("3[a]2[bc]"))
	fmt.Println(decodeString("3[a2[c]]"))
	fmt.Println(decodeString("2[abc]3[cd]ef"))
	fmt.Println(decodeString("10[a]"))
	fmt.Println(decodeString("abc3[cd]xyz"))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

这题其实是**「括号展开 + 倍数复制」**的小型解释器：遇到 `k[xxx]`，就把 `xxx` 展开后重复 k 次。例如：`3[a2[c]]` → `accaccacc`。难点只有一个：**嵌套**。

**思路：用「栈」一层一层拆**。从左到右扫字符串，当成在“实时翻译”。

**两个栈：**

| 栈 | 作用 |
|----|------|
| numStack | 存倍数 k |
| strStack | 存进入 `[` 之前已经拼好的字符串 |

**两个当前变量：**

- **curNum**：正在读取的数字（可能是多位数，如 `12[a]`）
- **curStr**：当前层正在构造的字符串

**逐字符规则：**

1. **遇到数字**：`curNum = curNum * 10 + 当前数字`
2. **遇到 `[`**：进入新的一层。把当前状态存起来：`numStack.push(curNum)`、`strStack.push(curStr)`，然后重置 `curNum = 0`、`curStr = ""`（像递归进入下一层括号）。
3. **遇到字母**：`curStr += 字母`
4. **遇到 `]`**：当前层结束，结算。`k = numStack.pop()`，`prevStr = strStack.pop()`，`curStr = prevStr + curStr.repeat(k)`（子问题完成，回到上一层）。

**示例：`3[a2[c]]`**

| 读到 | 操作 | curStr | numStack | strStack |
|------|------|--------|----------|----------|
| 3 | 记录数字 | "" | [3] | [""] |
| [ | 入栈 | "" | [3] | [""] |
| a | 拼接 | "a" | [3] | [""] |
| 2 | 记录数字 | "a" | [3] | [""] |
| [ | 入栈 | "" | [3,2] | ["","a"] |
| c | 拼接 | "c" | [3,2] | ["","a"] |
| ] | 出栈结算 | "acc" | [3] | [""] |
| ] | 出栈结算 | "accaccacc" | [] | [] |

**为什么是最优解？** 每字符只遍历一次 → 时间 O(n)；栈空间最多为嵌套层数 → 空间 O(n)。不用递归，不爆栈，是面试里的标准写法。

**一句话总结**：用栈模拟递归，把每一层括号当成一段子串，遇到 `]` 再回到上一层拼接。

</details>

<details>
<summary><strong>类似题目</strong>（解析嵌套结构：栈保存上层状态）</summary>

- 遇到 `[`：入栈当前状态，重置当前层
- 遇到 `]`：出栈，用栈顶状态与当前结果合并

</details>

---

## 739. 每日温度

<LeetCodeProblem titleSlug="daily-temperatures" />

<details>
<summary><strong>最优解</strong>（单调栈：栈里保持“递减温度下标”）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function dailyTemperatures(temperatures) {
  const n = temperatures.length
  const ans = new Array(n).fill(0)
  const st = [] // 存下标，温度递减

  for (let i = 0; i < n; i++) {
    while (st.length && temperatures[i] > temperatures[st[st.length - 1]]) {
      const j = st.pop()
      ans[j] = i - j
    }
    st.push(i)
  }
  return ans
}

// 5 个测试用例
console.log(JSON.stringify(dailyTemperatures([73,74,75,71,69,72,76,73]))) // [1,1,4,2,1,1,0,0]
console.log(JSON.stringify(dailyTemperatures([30,40,50,60]))) // [1,1,1,0]
console.log(JSON.stringify(dailyTemperatures([30,60,90]))) // [1,1,0]
console.log(JSON.stringify(dailyTemperatures([90,80,70]))) // [0,0,0]
console.log(JSON.stringify(dailyTemperatures([70,70,70,71]))) // [3,2,1,0]
```

```go !! go
package main

import "fmt"

func dailyTemperatures(temperatures []int) []int {
	n := len(temperatures)
	ans := make([]int, n)
	var st []int
	for i := 0; i < n; i++ {
		for len(st) > 0 && temperatures[i] > temperatures[st[len(st)-1]] {
			j := st[len(st)-1]
			st = st[:len(st)-1]
			ans[j] = i - j
		}
		st = append(st, i)
	}
	return ans
}

func main() {
	fmt.Println(dailyTemperatures([]int{73, 74, 75, 71, 69, 72, 76, 73}))
	fmt.Println(dailyTemperatures([]int{30, 40, 50, 60}))
	fmt.Println(dailyTemperatures([]int{30, 60, 90}))
	fmt.Println(dailyTemperatures([]int{90, 80, 70}))
	fmt.Println(dailyTemperatures([]int{70, 70, 70, 71}))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **题意翻译**：对每一天，找下一次更高温度出现要等几天。
- **朴素做法**：对每个 i 往后扫，最坏 \(O(n^2)\)。
- **关键推理：用栈保存“还没找到更高温度的天”**：
  - 栈里放下标，并保持对应温度 **递减**。
  - 当今天温度 `T[i]` 比栈顶那天温度更高时，说明栈顶那天终于等到了更热的一天，答案就是 `i - j`。
  - 继续弹栈，直到栈顶温度比今天更高（或栈空）。
- **为什么要递减？**：
  - 递减保证“栈顶是最容易被今天打败的那天”，一旦今天更热，就能连续解决一串天数。
  - 每个元素最多进栈一次、出栈一次，所以总复杂度 \(O(n)\)。

</details>

<details>
<summary><strong>类似题目</strong>（下一个更大元素：单调栈）</summary>

```javascript
for i:
  while stack not empty and a[i] > a[stack.top]:
    ans[stack.top] = i - stack.top
    stack.pop()
  stack.push(i)
```

</details>

---

## 84. 柱状图中最大的矩形

<LeetCodeProblem titleSlug="largest-rectangle-in-histogram" />

<details>
<summary><strong>最优解</strong>（单调栈：每根柱子当“最矮”时的最大宽度）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function largestRectangleArea(heights) {
  const h = heights.slice()
  h.unshift(0)
  h.push(0)
  const st = [] // 存下标，保持高度递增
  let best = 0

  for (let i = 0; i < h.length; i++) {
    while (st.length && h[i] < h[st[st.length - 1]]) {
      const mid = st.pop()
      const left = st[st.length - 1]
      const width = i - left - 1
      best = Math.max(best, h[mid] * width)
    }
    st.push(i)
  }
  return best
}

// 5 个测试用例
console.log(largestRectangleArea([2,1,5,6,2,3])) // 10
console.log(largestRectangleArea([2,4])) // 4
console.log(largestRectangleArea([1,1,1,1])) // 4
console.log(largestRectangleArea([6,2,5,4,5,1,6])) // 12
console.log(largestRectangleArea([0])) // 0
```

```go !! go
package main

import "fmt"

func largestRectangleArea(heights []int) int {
	h := make([]int, len(heights)+2)
	copy(h[1:], heights)
	h[0], h[len(h)-1] = 0, 0
	var st []int
	best := 0
	for i := 0; i < len(h); i++ {
		for len(st) > 0 && h[i] < h[st[len(st)-1]] {
			mid := st[len(st)-1]
			st = st[:len(st)-1]
			left := 0
			if len(st) > 0 {
				left = st[len(st)-1]
			}
			width := i - left - 1
			if h[mid]*width > best {
				best = h[mid] * width
			}
		}
		st = append(st, i)
	}
	return best
}

func main() {
	fmt.Println(largestRectangleArea([]int{2, 1, 5, 6, 2, 3}))
	fmt.Println(largestRectangleArea([]int{2, 4}))
	fmt.Println(largestRectangleArea([]int{1, 1, 1, 1}))
	fmt.Println(largestRectangleArea([]int{6, 2, 5, 4, 5, 1, 6}))
	fmt.Println(largestRectangleArea([]int{0}))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **朴素思路**：枚举每个柱子往左右扩展找能延伸多宽，最坏 \(O(n^2)\)。
- **关键推理：最大矩形一定有一个“最矮柱子”决定高度**：
  - 如果我们把某根柱子 `mid` 当作矩形的最矮高度，那么矩形能延伸的左右边界就是：
    - 左边第一个 < `h[mid]` 的位置
    - 右边第一个 < `h[mid]` 的位置
  - 宽度一旦确定，面积就是 `h[mid] * width`。
- **怎么快速找到“左右第一个更矮”？用单调递增栈**：
  - 栈里保持高度递增，这样当遇到更矮的柱子 `h[i]` 时，说明栈顶柱子的“右边界”就是 i。
  - 弹出栈顶 `mid` 后，新的栈顶 `left` 就是 `mid` 的左边界（第一个更矮）。
  - 宽度 = `i - left - 1`。
- **为什么两端加 0？**
  - 让所有柱子都能在某个时刻被弹出并计算面积，避免最后还要额外清栈的逻辑。

</details>

<details>
<summary><strong>类似题目</strong>（单调栈求左右边界）</summary>

```javascript
add sentinel 0 at both ends
maintain increasing stack
on drop: pop mid, left = stack.top, right = i
```

</details>

