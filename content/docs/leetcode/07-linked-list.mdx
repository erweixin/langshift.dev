---
title: 链表（题单顺序）
description: 热题 100 - 链表分组（按题单顺序）：160 / 206 / 234 / 141 / 142 / 21 / 2 / 19 / 24 / 25 / 138 / 148 / 23 / 146
---

import { LeetCodeProblem } from "@/components/leetcode/LeetCodeProblem"

本页包含题单「链表」分组的全部题目，顺序与 `list.json` 保持一致。

---

## 160. 相交链表

<LeetCodeProblem titleSlug="intersection-of-two-linked-lists" />

<details>
<summary><strong>最优解</strong>（双指针走两遍：路程对齐）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function getIntersectionNode(headA, headB) {
  let p = headA
  let q = headB
  while (p !== q) {
    p = p ? p.next : headB
    q = q ? q.next : headA
  }
  return p
}

// 测试辅助
function ListNode(val) { this.val = val; this.next = null }
function tail(head) { let p=head; while (p && p.next) p=p.next; return p }

// 5 个测试用例（这里用“共享尾部节点”构造相交）
{
  const common = new ListNode(8); common.next = new ListNode(4); common.next.next = new ListNode(5)
  const a = new ListNode(4); a.next = new ListNode(1); tail(a).next = common
  const b = new ListNode(5); b.next = new ListNode(6); b.next.next = new ListNode(1); tail(b).next = common
  console.log(getIntersectionNode(a,b).val) // 8
}
{
  const common = new ListNode(2); common.next = new ListNode(4)
  const a = new ListNode(1); tail(a).next = common
  const b = new ListNode(3); tail(b).next = common
  console.log(getIntersectionNode(a,b).val) // 2
}
{
  const a = new ListNode(1); a.next = new ListNode(2)
  const b = new ListNode(3); b.next = new ListNode(4)
  console.log(getIntersectionNode(a,b)) // null
}
{
  const a = new ListNode(1)
  const b = a
  console.log(getIntersectionNode(a,b).val) // 1
}
{
  console.log(getIntersectionNode(null, null)) // null
}
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func getIntersectionNode(headA, headB *ListNode) *ListNode {
	p, q := headA, headB
	for p != q {
		if p != nil {
			p = p.Next
		} else {
			p = headB
		}
		if q != nil {
			q = q.Next
		} else {
			q = headA
		}
	}
	return p
}

func main() {
	common := &ListNode{8, &ListNode{4, &ListNode{5, nil}}}
	a := &ListNode{4, &ListNode{1, common}}
	b := &ListNode{5, &ListNode{6, &ListNode{1, common}}}
	fmt.Println(getIntersectionNode(a, b).Val) // 8
	common2 := &ListNode{2, &ListNode{4, nil}}
	a2, b2 := &ListNode{1, common2}, &ListNode{3, common2}
	fmt.Println(getIntersectionNode(a2, b2).Val) // 2
	fmt.Println(getIntersectionNode(&ListNode{1, &ListNode{2, nil}}, &ListNode{3, &ListNode{4, nil}})) // nil
	one := &ListNode{1, nil}
	fmt.Println(getIntersectionNode(one, one).Val) // 1
	fmt.Println(getIntersectionNode(nil, nil))     // nil
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **题意翻译**：两个链表如果相交，后半段会共享同一串节点（内存地址相同，不是值相同）。找第一个共享节点。
- **朴素思路**：用 Set 存 A 的所有节点地址，再扫 B 看第一个命中。能做但要 \(O(n)\) 额外空间。
- **想要 \(O(1)\) 空间，需要“把长度差消掉”**。设 A 长 a，B 长 b，相交后共享尾长 c。
- **关键推理：让两个指针走同样的总路程**：
  - 指针 p 先走 A，再走 B；指针 q 先走 B，再走 A。
  - p 走过的总路程是 `a + b`，q 也是 `b + a`，所以两者最终会在同一步数上“对齐”。
  - 如果有相交点，它们会在相交点相遇；如果不相交，两者都会在 `null` 相遇。
- **直觉类比**：两个人从不同起点出发，第一圈走完后交换跑道，再跑一圈，就能把“起点距离终点的差”抵消。
- **为什么一定不会错过相交点？**
  - 假设相交前 A 独有部分长度是 `a-c`，B 独有部分是 `b-c`。
  - 当 p 走完 A 的独有部分后进入公共尾巴时，q 可能还在 B 的独有部分；但当两人都各自“换跑道”后，独有部分的长度差会被抵消，最终同时踏入公共尾巴的同一位置。
- **边界情况**：
  - 任一链表为空：直接返回 `null`（代码里自然成立）。
  - 两条链表本来就是同一个头：第一次比较就相等，直接返回头节点。
- **复杂度**：每个指针最多走 `a+b` 步，时间 \(O(a+b)\)，空间 \(O(1)\)。

</details>

<details>
<summary><strong>类似题目</strong>（双指针对齐路程：先走自己的，再走对方的）</summary>

```javascript
while (p !== q) {
  p = p ? p.next : headB
  q = q ? q.next : headA
}
return p
```

</details>

---

## 206. 反转链表

<LeetCodeProblem titleSlug="reverse-linked-list" />

<details>
<summary><strong>最优解</strong>（迭代：prev / cur / next 三指针）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function reverseList(head) {
  let prev = null
  let cur = head
  while (cur) {
    const nxt = cur.next
    cur.next = prev
    prev = cur
    cur = nxt
  }
  return prev
}

// 测试辅助
function ListNode(val) { this.val = val; this.next = null }
function fromArray(arr) {
  const dummy = new ListNode(0)
  let p = dummy
  for (const x of arr) { p.next = new ListNode(x); p = p.next }
  return dummy.next
}
function toArray(head) {
  const res = []
  let p = head
  while (p) { res.push(p.val); p = p.next }
  return res
}

// 5 个测试用例
console.log(toArray(reverseList(fromArray([1,2,3,4,5])))) // [5,4,3,2,1]
console.log(toArray(reverseList(fromArray([1,2])))) // [2,1]
console.log(toArray(reverseList(fromArray([])))) // []
console.log(toArray(reverseList(fromArray([7])))) // [7]
console.log(toArray(reverseList(fromArray([0,1,0])))) // [0,1,0]
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func reverseList(head *ListNode) *ListNode {
	var prev *ListNode
	cur := head
	for cur != nil {
		nxt := cur.Next
		cur.Next = prev
		prev = cur
		cur = nxt
	}
	return prev
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(reverseList(fromArray([]int{1, 2, 3, 4, 5}))))
	fmt.Println(toArray(reverseList(fromArray([]int{1, 2}))))
	fmt.Println(toArray(reverseList(fromArray(nil))))
	fmt.Println(toArray(reverseList(fromArray([]int{7}))))
	fmt.Println(toArray(reverseList(fromArray([]int{0, 1, 0}))))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **链表反转的难点**：链表只有 `next` 指针，一旦你把 `cur.next` 指向别处，就可能丢失后面的链。
- **所以必须先“备份后路”**：用 `nxt = cur.next` 先记住下一个节点。
- **然后做三步循环**（这就是反转的本质）：
  1. `nxt = cur.next`（留后路）
  2. `cur.next = prev`（把箭头反过来）
  3. `prev = cur; cur = nxt`（整体往前推进）
- **不变量**：`prev` 永远是“已经反转好的链表头”，`cur` 永远指向“还没处理的头”。
- **为什么必须按这个顺序？**
  - 如果你先做 `cur.next = prev` 再去取 `cur.next`，你会把原来的后继节点丢掉（因为 `cur.next` 已经被改写）。
  - 所以“先存后路，再改指针”是链表题最常见的安全写法。
- **小例子走一遍**：`1 -> 2 -> 3`
  - 初始 `prev=null, cur=1`
  - 处理 1：`nxt=2`，`1.next=null`，`prev=1, cur=2`
  - 处理 2：`nxt=3`，`2.next=1`，`prev=2, cur=3`
  - 处理 3：`nxt=null`，`3.next=2`，结束，`prev` 就是新头 3。
- **复杂度**：时间 \(O(n)\)，空间 \(O(1)\)。

</details>

<details>
<summary><strong>类似题目</strong>（链表指针操作模板）</summary>

```javascript
let prev = null, cur = head
while (cur) {
  const nxt = cur.next
  cur.next = prev
  prev = cur
  cur = nxt
}
return prev
```

</details>

---

## 234. 回文链表

<LeetCodeProblem titleSlug="palindrome-linked-list" />

<details>
<summary><strong>最优解</strong>（快慢指针找中点 + 反转后半段 + 对比）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function isPalindrome(head) {
  if (!head || !head.next) return true

  // 1) 找中点（slow 到中间）
  let slow = head, fast = head
  while (fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
  }
  // fast 非空说明长度为奇数，slow 在正中间，跳过中点
  if (fast) slow = slow.next

  // 2) 反转后半段
  let prev = null, cur = slow
  while (cur) {
    const nxt = cur.next
    cur.next = prev
    prev = cur
    cur = nxt
  }

  // 3) 前半段 head 与 反转后的后半段 prev 对比
  let p = head, q = prev
  while (q) {
    if (p.val !== q.val) return false
    p = p.next
    q = q.next
  }
  return true
}

// 测试辅助
function ListNode(val) { this.val = val; this.next = null }
function fromArray(arr) {
  const dummy = new ListNode(0)
  let p = dummy
  for (const x of arr) { p.next = new ListNode(x); p = p.next }
  return dummy.next
}

// 5 个测试用例
console.log(isPalindrome(fromArray([1,2,2,1]))) // true
console.log(isPalindrome(fromArray([1,2]))) // false
console.log(isPalindrome(fromArray([1]))) // true
console.log(isPalindrome(fromArray([1,2,3,2,1]))) // true
console.log(isPalindrome(fromArray([1,2,3,4,3,2,1]))) // true
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func isPalindrome(head *ListNode) bool {
	if head == nil || head.Next == nil {
		return true
	}
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
	}
	if fast != nil {
		slow = slow.Next
	}
	var prev *ListNode
	cur := slow
	for cur != nil {
		nxt := cur.Next
		cur.Next = prev
		prev = cur
		cur = nxt
	}
	p, q := head, prev
	for q != nil {
		if p.Val != q.Val {
			return false
		}
		p, q = p.Next, q.Next
	}
	return true
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func main() {
	fmt.Println(isPalindrome(fromArray([]int{1, 2, 2, 1})))
	fmt.Println(isPalindrome(fromArray([]int{1, 2})))
	fmt.Println(isPalindrome(fromArray([]int{1})))
	fmt.Println(isPalindrome(fromArray([]int{1, 2, 3, 2, 1})))
	fmt.Println(isPalindrome(fromArray([]int{1, 2, 3, 4, 3, 2, 1})))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **朴素思路**：把链表转成数组，再用双指针判断回文。简单但需要 \(O(n)\) 额外空间。
- **想要更“链表味”的做法**：空间 \(O(1)\) 的关键是：只比较一半，但要让它“方向一致”。
- **第一步：快慢指针找中点**：
  - `fast` 一次走两步，`slow` 一次走一步。
  - `fast` 到尾时，`slow` 正好到中点附近。
  - 若长度为奇数，中间那个数不影响回文，跳过它即可。
- **第二步：反转后半段**：
  - 回文的定义是“前半段从左到右”要等于“后半段从右到左”。
  - 把后半段反转后，它就变成“从右到左”的顺序摆在链表里，方便直接一对一比较。
- **第三步：对比两条链**：
  - `p` 从头走，`q` 从反转后的后半段头走，只要 `q` 走完仍都相等，就是回文。
- **为什么只需要比 `q` 的长度？**：后半段长度 ≤ 前半段长度（奇数时前半多一个中点），所以只要后半都匹配就够。
- **为什么奇数长度要跳过中点？**
  - 奇数回文的中间字符没有“镜像对象”，不参与比较；跳过后就能做到左右一一对应。
- **是否需要把链表再恢复？**
  - LeetCode 通常不要求恢复；如果在真实业务里需要保持输入结构，可以在比较后把后半段再反转回去（同样是 \(O(n)\)）。
- **复杂度**：找中点 \(O(n)\) + 反转 \(O(n)\) + 比较 \(O(n)\)，总时间 \(O(n)\)，空间 \(O(1)\)。

</details>

<details>
<summary><strong>类似题目</strong>（快慢指针 + 反转：对称结构比较）</summary>

```javascript
mid = findMiddle(head)
right = reverse(mid)
return compare(head, right)
```

</details>

---

## 141. 环形链表

<LeetCodeProblem titleSlug="linked-list-cycle" />

<details>
<summary><strong>最优解</strong>（Floyd 快慢指针：追及相遇）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function hasCycle(head) {
  let slow = head
  let fast = head
  while (fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
    if (slow === fast) return true
  }
  return false
}

// 测试辅助
function ListNode(val) { this.val = val; this.next = null }
function buildCycle(arr, pos) {
  if (!arr.length) return null
  const nodes = arr.map(x => new ListNode(x))
  for (let i = 0; i < nodes.length - 1; i++) nodes[i].next = nodes[i + 1]
  if (pos >= 0) nodes[nodes.length - 1].next = nodes[pos]
  return nodes[0]
}

// 5 个测试用例
console.log(hasCycle(buildCycle([3,2,0,-4], 1))) // true
console.log(hasCycle(buildCycle([1,2], 0))) // true
console.log(hasCycle(buildCycle([1], -1))) // false
console.log(hasCycle(buildCycle([], -1))) // false
console.log(hasCycle(buildCycle([1,2,3], -1))) // false
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func hasCycle(head *ListNode) bool {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
		if slow == fast {
			return true
		}
	}
	return false
}

func buildCycle(arr []int, pos int) *ListNode {
	if len(arr) == 0 {
		return nil
	}
	nodes := make([]*ListNode, len(arr))
	for i, x := range arr {
		nodes[i] = &ListNode{Val: x}
	}
	for i := 0; i < len(arr)-1; i++ {
		nodes[i].Next = nodes[i+1]
	}
	if pos >= 0 {
		nodes[len(arr)-1].Next = nodes[pos]
	}
	return nodes[0]
}

func main() {
	fmt.Println(hasCycle(buildCycle([]int{3, 2, 0, -4}, 1))) // true
	fmt.Println(hasCycle(buildCycle([]int{1, 2}, 0)))        // true
	fmt.Println(hasCycle(buildCycle([]int{1}, -1)))          // false
	fmt.Println(hasCycle(buildCycle([]int{}, -1)))           // false
	fmt.Println(hasCycle(buildCycle([]int{1, 2, 3}, -1)))   // false
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **想法一**：用 Set 记录访问过的节点地址，遇到重复就有环。简单但要额外空间。
- **Floyd 的关键直觉：跑步追人**：
  - `slow` 每次走 1 步，`fast` 每次走 2 步。
  - 如果没环，`fast` 会先走到 `null`。
  - 如果有环，`fast` 会在环里“套圈”追上 `slow`，一定会相遇（同一条环形跑道，快的人迟早追上慢的人）。
- **为什么一定相遇？**：在环内，`fast` 相对 `slow` 每次多走 1 步，相当于在环上每轮把距离缩短 1，距离有限所以必然归零。
- **为什么没环一定能退出？**
  - 因为 `fast` 走得更快，只要链表是直线，`fast` 必然先到达 `null`（或者 `fast.next` 为 `null`），循环条件就会失败。
- **复杂度**：时间 \(O(n)\)，空间 \(O(1)\)。

</details>

<details>
<summary><strong>类似题目</strong>（快慢指针检测循环/相遇）</summary>

```javascript
while (fast && fast.next) {
  slow = slow.next
  fast = fast.next.next
  if (slow === fast) return true
}
return false
```

</details>

---

## 142. 环形链表 II

<LeetCodeProblem titleSlug="linked-list-cycle-ii" />

<details>
<summary><strong>最优解</strong>（Floyd：相遇后再走一遍找入环点）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function detectCycle(head) {
  let slow = head, fast = head
  while (fast && fast.next) {
    slow = slow.next
    fast = fast.next.next
    if (slow === fast) {
      // 相遇后：一个从头走，一个从相遇点走，步速相同，最终在入环点相遇
      let p = head
      let q = slow
      while (p !== q) {
        p = p.next
        q = q.next
      }
      return p
    }
  }
  return null
}

// 测试辅助
function ListNode(val) { this.val = val; this.next = null }
function buildCycle(arr, pos) {
  if (!arr.length) return null
  const nodes = arr.map(x => new ListNode(x))
  for (let i = 0; i < nodes.length - 1; i++) nodes[i].next = nodes[i + 1]
  if (pos >= 0) nodes[nodes.length - 1].next = nodes[pos]
  return nodes[0]
}

// 5 个测试用例
{
  const h = buildCycle([3,2,0,-4], 1)
  console.log(detectCycle(h).val) // 2
}
{
  const h = buildCycle([1,2], 0)
  console.log(detectCycle(h).val) // 1
}
console.log(detectCycle(buildCycle([1], -1))) // null
console.log(detectCycle(buildCycle([], -1))) // null
{
  const h = buildCycle([1,2,3,4,5], 2)
  console.log(detectCycle(h).val) // 3
}
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func detectCycle(head *ListNode) *ListNode {
	slow, fast := head, head
	for fast != nil && fast.Next != nil {
		slow = slow.Next
		fast = fast.Next.Next
		if slow == fast {
			p, q := head, slow
			for p != q {
				p, q = p.Next, q.Next
			}
			return p
		}
	}
	return nil
}

func buildCycle(arr []int, pos int) *ListNode {
	if len(arr) == 0 {
		return nil
	}
	nodes := make([]*ListNode, len(arr))
	for i, x := range arr {
		nodes[i] = &ListNode{Val: x}
	}
	for i := 0; i < len(arr)-1; i++ {
		nodes[i].Next = nodes[i+1]
	}
	if pos >= 0 {
		nodes[len(arr)-1].Next = nodes[pos]
	}
	return nodes[0]
}

func main() {
	fmt.Println(detectCycle(buildCycle([]int{3, 2, 0, -4}, 1)).Val) // 2
	fmt.Println(detectCycle(buildCycle([]int{1, 2}, 0)).Val)          // 1
	fmt.Println(detectCycle(buildCycle([]int{1}, -1)))               // nil
	fmt.Println(detectCycle(buildCycle([]int{}, -1)))                // nil
	fmt.Println(detectCycle(buildCycle([]int{1, 2, 3, 4, 5}, 2)).Val) // 3
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **第一阶段**和 141 一样：用快慢指针判断是否有环，并在环内找到一个相遇点。
- **第二阶段的“神奇结论”**：相遇后，让一个指针从链表头出发，另一个从相遇点出发，都每次走一步，它们会在**入环点**相遇。
- **为什么会这样？（核心推理）**
  - 设：头到入环点距离为 `a`，入环点到相遇点距离为 `b`，环长度为 `c`。
  - 相遇时：`fast` 走了 `2(a+b)`，`slow` 走了 `a+b`。
  - 因为 `fast` 比 `slow` 多走了一圈或多圈环：`2(a+b) - (a+b) = a+b = k*c`。
  - 所以 `a = k*c - b`，也就是：从相遇点再走 `a` 步，等价于在环上走 `k*c - b`，最终会回到入环点。
  - 于是：一个从头走 `a` 步到入环点，另一个从相遇点走 `a` 步也到入环点 → 相遇即入环点。
- **小例子直觉**：如果入环点在“前面走 a 步”的位置，那么从相遇点再走 a 步，相当于在环上绕若干圈再补齐差距，最终回到同一个入口。
- **复杂度**：第一次相遇 \(O(n)\)，第二次找入口再 \(O(n)\)，总时间 \(O(n)\)，空间 \(O(1)\)。

</details>

<details>
<summary><strong>类似题目</strong>（相遇后找入口模板）</summary>

```javascript
meet = getMeetPoint()
if (!meet) return null
let p = head, q = meet
while (p !== q) { p = p.next; q = q.next }
return p
```

</details>

---

## 21. 合并两个有序链表

<LeetCodeProblem titleSlug="merge-two-sorted-lists" />

<details>
<summary><strong>最优解</strong>（虚拟头结点：像合并两个有序数组）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function mergeTwoLists(l1, l2) {
  const dummy = { val: 0, next: null }
  let tail = dummy

  while (l1 && l2) {
    if (l1.val <= l2.val) {
      tail.next = l1
      l1 = l1.next
    } else {
      tail.next = l2
      l2 = l2.next
    }
    tail = tail.next
  }
  tail.next = l1 || l2
  return dummy.next
}

// 测试辅助
function ListNode(val) { this.val = val; this.next = null }
function fromArray(arr) {
  const d = new ListNode(0); let p = d
  for (const x of arr) { p.next = new ListNode(x); p = p.next }
  return d.next
}
function toArray(h) { const r=[]; for(let p=h;p;p=p.next) r.push(p.val); return r }

// 5 个测试用例
console.log(toArray(mergeTwoLists(fromArray([1,2,4]), fromArray([1,3,4])))) // [1,1,2,3,4,4]
console.log(toArray(mergeTwoLists(fromArray([]), fromArray([])))) // []
console.log(toArray(mergeTwoLists(fromArray([]), fromArray([0])))) // [0]
console.log(toArray(mergeTwoLists(fromArray([1]), fromArray([2])))) // [1,2]
console.log(toArray(mergeTwoLists(fromArray([2,3]), fromArray([1,4,5])))) // [1,2,3,4,5]
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeTwoLists(l1, l2 *ListNode) *ListNode {
	dummy := &ListNode{}
	tail := dummy
	for l1 != nil && l2 != nil {
		if l1.Val <= l2.Val {
			tail.Next = l1
			l1 = l1.Next
		} else {
			tail.Next = l2
			l2 = l2.Next
		}
		tail = tail.Next
	}
	if l1 != nil {
		tail.Next = l1
	} else {
		tail.Next = l2
	}
	return dummy.Next
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(mergeTwoLists(fromArray([]int{1, 2, 4}), fromArray([]int{1, 3, 4}))))
	fmt.Println(toArray(mergeTwoLists(fromArray(nil), fromArray(nil))))
	fmt.Println(toArray(mergeTwoLists(fromArray(nil), fromArray([]int{0}))))
	fmt.Println(toArray(mergeTwoLists(fromArray([]int{1}), fromArray([]int{2}))))
	fmt.Println(toArray(mergeTwoLists(fromArray([]int{2, 3}), fromArray([]int{1, 4, 5}))))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **这题就是“两个有序序列合并”**：每次从两个头里挑更小的挂到结果尾部。
- **虚拟头结点的作用**：避免单独处理“结果链表的第一个节点”这种边界；统一用 `tail.next = ...` 来接。
- **不变量**：`dummy.next..tail` 永远是已经合并好的有序链表；`l1/l2` 指向尚未处理的部分。
- **为什么不会丢节点？**
  - 每次只改变 `tail.next` 指向，并把其中一个链表指针向后移动一步；被接上的节点仍然带着原来的 `next`，所以链路不断。
- **稳定性（相等时选谁？）**
  - 代码用 `<=` 先接 `l1`，这样当值相等时会优先保留 `l1` 的相对顺序（稳定合并）。
- **复杂度**：每个节点最多访问一次，时间 \(O(m+n)\)，空间 \(O(1)\)（不算输出链表本身）。

</details>

<details>
<summary><strong>类似题目</strong>（归并思想：双指针合并）</summary>

```javascript
while (a && b) takeSmaller()
appendRemaining()
```

</details>

---

## 2. 两数相加

<LeetCodeProblem titleSlug="add-two-numbers" />

<details>
<summary><strong>最优解</strong>（逐位相加 + 进位 carry）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function addTwoNumbers(l1, l2) {
  const dummy = { val: 0, next: null }
  let tail = dummy
  let carry = 0

  while (l1 || l2 || carry) {
    const a = l1 ? l1.val : 0
    const b = l2 ? l2.val : 0
    const sum = a + b + carry
    carry = Math.floor(sum / 10)
    tail.next = { val: sum % 10, next: null }
    tail = tail.next
    if (l1) l1 = l1.next
    if (l2) l2 = l2.next
  }
  return dummy.next
}

// 测试辅助
function ListNode(val) { this.val = val; this.next = null }
function fromArray(arr) { const d=new ListNode(0); let p=d; for(const x of arr){p.next=new ListNode(x);p=p.next} return d.next }
function toArray(h){const r=[]; for(let p=h;p;p=p.next) r.push(p.val); return r}

// 5 个测试用例
console.log(toArray(addTwoNumbers(fromArray([2,4,3]), fromArray([5,6,4])))) // [7,0,8]
console.log(toArray(addTwoNumbers(fromArray([0]), fromArray([0])))) // [0]
console.log(toArray(addTwoNumbers(fromArray([9,9,9,9,9,9,9]), fromArray([9,9,9,9])))) // [8,9,9,9,0,0,0,1]
console.log(toArray(addTwoNumbers(fromArray([1]), fromArray([9,9])))) // [0,0,1]
console.log(toArray(addTwoNumbers(fromArray([5]), fromArray([5])))) // [0,1]
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func addTwoNumbers(l1, l2 *ListNode) *ListNode {
	dummy := &ListNode{}
	tail := dummy
	carry := 0
	for l1 != nil || l2 != nil || carry != 0 {
		a, b := 0, 0
		if l1 != nil {
			a = l1.Val
			l1 = l1.Next
		}
		if l2 != nil {
			b = l2.Val
			l2 = l2.Next
		}
		sum := a + b + carry
		carry = sum / 10
		tail.Next = &ListNode{Val: sum % 10}
		tail = tail.Next
	}
	return dummy.Next
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(addTwoNumbers(fromArray([]int{2, 4, 3}), fromArray([]int{5, 6, 4}))))
	fmt.Println(toArray(addTwoNumbers(fromArray([]int{0}), fromArray([]int{0}))))
	fmt.Println(toArray(addTwoNumbers(fromArray([]int{9, 9, 9, 9, 9, 9, 9}), fromArray([]int{9, 9, 9, 9}))))
	fmt.Println(toArray(addTwoNumbers(fromArray([]int{1}), fromArray([]int{9, 9}))))
	fmt.Println(toArray(addTwoNumbers(fromArray([]int{5}), fromArray([]int{5}))))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **题意翻译**：两个数用链表的“逆序”存储（个位在头），要求把它们相加并返回同样格式的链表。
- **逆序的好处**：从头开始就是最低位，刚好符合我们做加法的顺序（从个位往高位）。
- **逐位相加的推理**：
  - 每一位都只依赖：这一位的两个数字 + 上一位的进位 `carry`。
  - `sum = a + b + carry`，当前位是 `sum % 10`，新进位是 `Math.floor(sum / 10)`。
- **循环条件为什么是 `l1 || l2 || carry`？**：即使两条链都走完了，只要还有进位，也要再生成一个新节点（比如 5+5=10）。
- **为什么需要 dummy？**
  - 和合并链表一样，避免单独处理“结果链表第一个节点”的边界，统一用 `tail.next = 新节点`。
- **小例子**：`342 + 465`（链表为 `2->4->3` 和 `5->6->4`）
  - 个位：2+5=7（carry 0）
  - 十位：4+6=10 → 写 0，carry=1
  - 百位：3+4+1=8 → 写 8
  - 得到 `7->0->8`（即 807）
- **复杂度**：时间 \(O(m+n)\)，空间 \(O(m+n)\)（需要新链表）。

</details>

<details>
<summary><strong>类似题目</strong>（按位运算：进位 carry 模板）</summary>

```javascript
while (a || b || carry) {
  sum = digit(a) + digit(b) + carry
  carry = Math.floor(sum / base)
  push(sum % base)
}
```

</details>

---

## 19. 删除链表的倒数第 N 个结点

<LeetCodeProblem titleSlug="remove-nth-node-from-end-of-list" />

<details>
<summary><strong>最优解</strong>（快慢指针间隔 n：一次遍历定位前驱）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function removeNthFromEnd(head, n) {
  const dummy = { val: 0, next: head }
  let fast = dummy
  let slow = dummy

  // fast 先走 n 步
  for (let i = 0; i < n; i++) fast = fast.next

  // 再一起走，直到 fast 到尾；此时 slow 在待删节点的前一个
  while (fast.next) {
    fast = fast.next
    slow = slow.next
  }

  slow.next = slow.next.next
  return dummy.next
}

// 测试辅助
function ListNode(val){this.val=val;this.next=null}
function fromArray(arr){const d=new ListNode(0);let p=d;for(const x of arr){p.next=new ListNode(x);p=p.next}return d.next}
function toArray(h){const r=[];for(let p=h;p;p=p.next)r.push(p.val);return r}

// 5 个测试用例
console.log(toArray(removeNthFromEnd(fromArray([1,2,3,4,5]), 2))) // [1,2,3,5]
console.log(toArray(removeNthFromEnd(fromArray([1]), 1))) // []
console.log(toArray(removeNthFromEnd(fromArray([1,2]), 1))) // [1]
console.log(toArray(removeNthFromEnd(fromArray([1,2]), 2))) // [2]
console.log(toArray(removeNthFromEnd(fromArray([1,2,3]), 3))) // [2,3]
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummy := &ListNode{Next: head}
	fast, slow := dummy, dummy
	for i := 0; i < n; i++ {
		fast = fast.Next
	}
	for fast.Next != nil {
		fast = fast.Next
		slow = slow.Next
	}
	slow.Next = slow.Next.Next
	return dummy.Next
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(removeNthFromEnd(fromArray([]int{1, 2, 3, 4, 5}), 2)))
	fmt.Println(toArray(removeNthFromEnd(fromArray([]int{1}), 1)))
	fmt.Println(toArray(removeNthFromEnd(fromArray([]int{1, 2}), 1)))
	fmt.Println(toArray(removeNthFromEnd(fromArray([]int{1, 2}), 2)))
	fmt.Println(toArray(removeNthFromEnd(fromArray([]int{1, 2, 3}), 3)))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **朴素做法**：先遍历算长度 `len`，再走到第 `len-n` 个节点删除。两趟遍历。
- **一趟遍历的关键：制造“间隔”**：
  - 让 `fast` 先走 `n` 步，这样 `fast` 和 `slow` 之间就相隔 `n` 个节点。
  - 当 `fast` 走到链表末尾时，`slow` 恰好走到“倒数第 n 个节点的前驱”。
- **为什么要 dummy？**
  - 避免删除头节点时的特殊处理；dummy 永远在 head 前面，删头也等价于普通删除。
- **为什么 fast 从 dummy 开始更稳？**
  - 当要删除的就是头节点（n 等于链表长度）时，slow 仍然能停在 dummy，`slow.next` 正好是头节点，删除逻辑完全一致。
- **复杂度**：一趟扫描，时间 \(O(n)\)，空间 \(O(1)\)。

</details>

<details>
<summary><strong>类似题目</strong>（固定间距双指针模板）</summary>

```javascript
fast 先走 k 步
while (fast) { fast=fast.next; slow=slow.next }
// slow 到达目标位置（或前驱）
```

</details>

---

## 24. 两两交换链表中的节点

<LeetCodeProblem titleSlug="swap-nodes-in-pairs" />

<details>
<summary><strong>最优解</strong>（dummy + 指针重连：每次交换一对）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function swapPairs(head) {
  const dummy = { val: 0, next: head }
  let prev = dummy

  while (prev.next && prev.next.next) {
    const a = prev.next
    const b = a.next

    // prev -> a -> b -> next
    // 变成 prev -> b -> a -> next
    a.next = b.next
    b.next = a
    prev.next = b

    prev = a
  }
  return dummy.next
}

// 测试辅助
function ListNode(val){this.val=val;this.next=null}
function fromArray(arr){const d=new ListNode(0);let p=d;for(const x of arr){p.next=new ListNode(x);p=p.next}return d.next}
function toArray(h){const r=[];for(let p=h;p;p=p.next)r.push(p.val);return r}

// 5 个测试用例
console.log(toArray(swapPairs(fromArray([1,2,3,4])))) // [2,1,4,3]
console.log(toArray(swapPairs(fromArray([1])))) // [1]
console.log(toArray(swapPairs(fromArray([])))) // []
console.log(toArray(swapPairs(fromArray([1,2,3])))) // [2,1,3]
console.log(toArray(swapPairs(fromArray([1,2])))) // [2,1]
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func swapPairs(head *ListNode) *ListNode {
	dummy := &ListNode{Next: head}
	prev := dummy
	for prev.Next != nil && prev.Next.Next != nil {
		a, b := prev.Next, prev.Next.Next
		a.Next = b.Next
		b.Next = a
		prev.Next = b
		prev = a
	}
	return dummy.Next
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(swapPairs(fromArray([]int{1, 2, 3, 4}))))
	fmt.Println(toArray(swapPairs(fromArray([]int{1}))))
	fmt.Println(toArray(swapPairs(fromArray(nil))))
	fmt.Println(toArray(swapPairs(fromArray([]int{1, 2, 3}))))
	fmt.Println(toArray(swapPairs(fromArray([]int{1, 2}))))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **交换的本质不是交换值，是改指针**。一对节点 `a`、`b`：
  - 原来：`prev -> a -> b -> next`
  - 目标：`prev -> b -> a -> next`
- **按顺序改指针**：
  1. `a.next = b.next`（a 先接到 next，防止断链）
  2. `b.next = a`（b 指向 a）
  3. `prev.next = b`（prev 指向新头 b）
- **为什么 prev 最后要变成 a？**：交换后 a 成了这一对的尾巴，下一轮的前驱就是它。
- **为什么要先做 `a.next = b.next`？**
  - 这是“先保后路”的原则：先让 a 接到后面 `next`，再把 b 接到 a，最后 prev 接到 b，过程中不会断链。
- **复杂度**：每个节点最多参与一次交换，时间 \(O(n)\)，空间 \(O(1)\)。

</details>

<details>
<summary><strong>类似题目</strong>（链表局部重连模板）</summary>

```javascript
// prev -> a -> b -> nxt
a.next = nxt
b.next = a
prev.next = b
prev = a
```

</details>

---

## 25. K 个一组翻转链表

<LeetCodeProblem titleSlug="reverse-nodes-in-k-group" />

<details>
<summary><strong>最优解</strong>（分组定位 + 原地翻转 + 接回去）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function reverseKGroup(head, k) {
  const dummy = { val: 0, next: head }
  let groupPrev = dummy

  function getKth(start, k) {
    let p = start
    for (let i = 0; i < k; i++) {
      if (!p.next) return null
      p = p.next
    }
    return p
  }

  while (true) {
    const kth = getKth(groupPrev, k)
    if (!kth) break
    const groupNext = kth.next

    // 反转 [groupPrev.next .. kth]
    let prev = groupNext
    let cur = groupPrev.next
    while (cur !== groupNext) {
      const nxt = cur.next
      cur.next = prev
      prev = cur
      cur = nxt
    }

    const newHead = kth
    const newTail = groupPrev.next
    groupPrev.next = newHead
    groupPrev = newTail
  }

  return dummy.next
}

// 测试辅助
function ListNode(val){this.val=val;this.next=null}
function fromArray(arr){const d=new ListNode(0);let p=d;for(const x of arr){p.next=new ListNode(x);p=p.next}return d.next}
function toArray(h){const r=[];for(let p=h;p;p=p.next)r.push(p.val);return r}

// 5 个测试用例
console.log(toArray(reverseKGroup(fromArray([1,2,3,4,5]), 2))) // [2,1,4,3,5]
console.log(toArray(reverseKGroup(fromArray([1,2,3,4,5]), 3))) // [3,2,1,4,5]
console.log(toArray(reverseKGroup(fromArray([1,2,3,4,5]), 1))) // [1,2,3,4,5]
console.log(toArray(reverseKGroup(fromArray([1,2]), 3))) // [1,2]
console.log(toArray(reverseKGroup(fromArray([]), 2))) // []
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func getKth(start *ListNode, k int) *ListNode {
	p := start
	for i := 0; i < k; i++ {
		if p.Next == nil {
			return nil
		}
		p = p.Next
	}
	return p
}

func reverseKGroup(head *ListNode, k int) *ListNode {
	dummy := &ListNode{Next: head}
	groupPrev := dummy
	for {
		kth := getKth(groupPrev, k)
		if kth == nil {
			break
		}
		groupNext := kth.Next
		prev, cur := groupNext, groupPrev.Next
		for cur != groupNext {
			nxt := cur.Next
			cur.Next = prev
			prev = cur
			cur = nxt
		}
		newHead, newTail := kth, groupPrev.Next
		groupPrev.Next = newHead
		groupPrev = newTail
	}
	return dummy.Next
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(reverseKGroup(fromArray([]int{1, 2, 3, 4, 5}), 2)))
	fmt.Println(toArray(reverseKGroup(fromArray([]int{1, 2, 3, 4, 5}), 3)))
	fmt.Println(toArray(reverseKGroup(fromArray([]int{1, 2, 3, 4, 5}), 1)))
	fmt.Println(toArray(reverseKGroup(fromArray([]int{1, 2}), 3)))
	fmt.Println(toArray(reverseKGroup(fromArray(nil), 2)))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **题意翻译**：每 `k` 个节点为一组翻转，剩下不足 k 个的不动。
- **为什么不能简单递归反转整个链？**：因为要“分组翻转”，组与组之间要正确拼接。
- **整体策略分三步**：
  1. **先确认这一组够不够 k 个**：如果不够，直接结束。
  2. **原地反转这一段**：反转区间 `[start, end]` 时，需要知道 end 后面的 `groupNext`，用于反转时作为初始 `prev`（这样反转完成后尾巴能自然接回去）。
  3. **把反转后的新头/新尾接回主链**：
     - `groupPrev.next = newHead`
     - 下一组的 `groupPrev` 更新为 `newTail`
- **关键不变量**：每完成一组，`groupPrev` 永远停在“已处理部分的最后一个节点”，下一组从它后面开始。
- **为什么反转时 `prev` 初始设为 `groupNext`？**
  - 这样反转完成后，原来的组头（反转后的尾）会自然指向 `groupNext`，组与组的连接自动正确。
- **边界情况**：
  - `k=1`：不需要反转，逻辑仍然成立。
  - 剩余不足 k 个：`getKth` 返回 null，直接停止，尾部保持原样。
- **复杂度**：每个节点最多被反转一次，时间 \(O(n)\)，空间 \(O(1)\)（递归栈为 0，因为是迭代）。

</details>

<details>
<summary><strong>类似题目</strong>（区间反转：先找边界，再反转，再接回）</summary>

```javascript
end = getKth(prev, k)
next = end.next
reverse(prev.next .. end) and connect to next
prev = oldHead // 反转后的尾
```

</details>

---

## 138. 随机链表的复制

<LeetCodeProblem titleSlug="copy-list-with-random-pointer" />

<details>
<summary><strong>最优解</strong>（哈希表：旧节点 -> 新节点）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function copyRandomList(head) {
  if (!head) return null
  const map = new Map()

  // 第一遍：复制节点（只复制 val/next）
  let p = head
  while (p) {
    map.set(p, { val: p.val, next: null, random: null })
    p = p.next
  }

  // 第二遍：补全 next/random 指针
  p = head
  while (p) {
    const node = map.get(p)
    node.next = p.next ? map.get(p.next) : null
    node.random = p.random ? map.get(p.random) : null
    p = p.next
  }

  return map.get(head)
}

// 测试辅助（简单构造 + 只验证结构的部分字段）
function Node(val){this.val=val;this.next=null;this.random=null}
function snapshot(head){
  const nodes=[]; const idx=new Map()
  let p=head; let i=0
  while(p){idx.set(p,i);nodes.push(p);p=p.next;i++}
  return nodes.map(n=>[n.val, n.random?idx.get(n.random):null])
}

// 5 个测试用例
{
  const a=new Node(7),b=new Node(13),c=new Node(11),d=new Node(10),e=new Node(1)
  a.next=b;b.next=c;c.next=d;d.next=e
  b.random=a;c.random=e;d.random=c;e.random=a
  const copy=copyRandomList(a)
  console.log(JSON.stringify(snapshot(copy))) // [[7,null],[13,0],[11,4],[10,2],[1,0]]
}
{
  const a=new Node(1),b=new Node(2);a.next=b;a.random=b;b.random=b
  const copy=copyRandomList(a)
  console.log(JSON.stringify(snapshot(copy))) // [[1,1],[2,1]]
}
{
  const a=new Node(3)
  const copy=copyRandomList(a)
  console.log(JSON.stringify(snapshot(copy))) // [[3,null]]
}
console.log(copyRandomList(null)) // null
{
  const a=new Node(1),b=new Node(2),c=new Node(3);a.next=b;b.next=c; a.random=c; b.random=a; c.random=b
  const copy=copyRandomList(a)
  console.log(JSON.stringify(snapshot(copy))) // [[1,2],[2,0],[3,1]]
}
```

```go !! go
package main

import "fmt"

type Node struct {
	Val    int
	Next   *Node
	Random *Node
}

func copyRandomList(head *Node) *Node {
	if head == nil {
		return nil
	}
	m := make(map[*Node]*Node)
	for p := head; p != nil; p = p.Next {
		m[p] = &Node{Val: p.Val}
	}
	for p := head; p != nil; p = p.Next {
		node := m[p]
		if p.Next != nil {
			node.Next = m[p.Next]
		}
		if p.Random != nil {
			node.Random = m[p.Random]
		}
	}
	return m[head]
}

func main() {
	a := &Node{7, nil, nil}
	b := &Node{13, nil, a}
	c := &Node{11, nil, nil}
	d := &Node{10, nil, c}
	e := &Node{1, nil, a}
	a.Next, b.Next, c.Next, d.Next = b, c, d, e
	copy := copyRandomList(a)
	for p := copy; p != nil; p = p.Next {
		fmt.Printf("[%d] ", p.Val)
	}
	fmt.Println()
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **难点**：`random` 指针可以指向任意节点甚至自己；直接复制时，你会遇到“指向的目标还没创建”的问题。
- **关键推理：先把“节点对应关系”建立起来**：
  - 第一次遍历：只创建每个新节点，并用 `Map<oldNode, newNode>` 记住映射。
  - 这一步完成后，所有新节点都已经存在了，后续再补指针就不会缺引用。
- **第二次遍历：补齐 next/random**：
  - `new.next = old.next ? map.get(old.next) : null`
  - `new.random = old.random ? map.get(old.random) : null`
- **为什么要两遍？**：一遍做不到“既创建节点又保证 random 目标已存在”；两遍则天然解决“前向引用/后向引用/自引用”。
- **为什么 Map 的 key 必须是“旧节点对象”而不是值？**
  - 因为链表节点值可能重复，能唯一标识节点的是它的“地址/对象引用”，所以必须用旧节点对象作为 key。
- **复杂度**：两趟遍历，时间 \(O(n)\)，空间 \(O(n)\)（Map 保存映射）。

</details>

<details>
<summary><strong>类似题目</strong>（图/链表复制：先建点，再连边）</summary>

```javascript
// 1) create all nodes and store mapping
// 2) traverse again to wire pointers/edges using mapping
```

</details>

---

## 148. 排序链表

<LeetCodeProblem titleSlug="sort-list" />

<details>
<summary><strong>最优解</strong>（归并排序：分治 + 合并两个有序链表）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
function sortList(head) {
  if (!head || !head.next) return head

  // 找中点并断开
  let slow = head, fast = head, prev = null
  while (fast && fast.next) {
    prev = slow
    slow = slow.next
    fast = fast.next.next
  }
  prev.next = null

  const left = sortList(head)
  const right = sortList(slow)
  return mergeTwo(left, right)
}

function mergeTwo(a, b) {
  const dummy = { val: 0, next: null }
  let tail = dummy
  while (a && b) {
    if (a.val <= b.val) { tail.next = a; a = a.next }
    else { tail.next = b; b = b.next }
    tail = tail.next
  }
  tail.next = a || b
  return dummy.next
}

// 测试辅助
function ListNode(val){this.val=val;this.next=null}
function fromArray(arr){const d=new ListNode(0);let p=d;for(const x of arr){p.next=new ListNode(x);p=p.next}return d.next}
function toArray(h){const r=[];for(let p=h;p;p=p.next)r.push(p.val);return r}

// 5 个测试用例
console.log(toArray(sortList(fromArray([4,2,1,3])))) // [1,2,3,4]
console.log(toArray(sortList(fromArray([-1,5,3,4,0])))) // [-1,0,3,4,5]
console.log(toArray(sortList(fromArray([])))) // []
console.log(toArray(sortList(fromArray([1])))) // [1]
console.log(toArray(sortList(fromArray([2,1])))) // [1,2]
```

```go !! go
package main

import "fmt"

type ListNode struct {
	Val  int
	Next *ListNode
}

func sortList(head *ListNode) *ListNode {
	if head == nil || head.Next == nil {
		return head
	}
	slow, fast, prev := head, head, (*ListNode)(nil)
	for fast != nil && fast.Next != nil {
		prev = slow
		slow = slow.Next
		fast = fast.Next.Next
	}
	prev.Next = nil
	left := sortList(head)
	right := sortList(slow)
	return mergeTwo(left, right)
}

func mergeTwo(a, b *ListNode) *ListNode {
	dummy := &ListNode{}
	tail := dummy
	for a != nil && b != nil {
		if a.Val <= b.Val {
			tail.Next = a
			a = a.Next
		} else {
			tail.Next = b
			b = b.Next
		}
		tail = tail.Next
	}
	if a != nil {
		tail.Next = a
	} else {
		tail.Next = b
	}
	return dummy.Next
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(sortList(fromArray([]int{4, 2, 1, 3}))))
	fmt.Println(toArray(sortList(fromArray([]int{-1, 5, 3, 4, 0}))))
	fmt.Println(toArray(sortList(fromArray(nil))))
	fmt.Println(toArray(sortList(fromArray([]int{1}))))
	fmt.Println(toArray(sortList(fromArray([]int{2, 1}))))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **链表排序为什么常用归并？**：链表不支持随机访问（不能像数组那样快排/堆排方便地按下标交换），但“拆成两半 + 合并”非常适合链表。
- **归并排序的三步**：
  1. **分**：用快慢指针找中点，把链表一分为二（并断开连接）。
  2. **治**：递归把左右两半分别排好序。
  3. **合**：用“合并两个有序链表”把两半合成一个有序链。
- **为什么时间是 \(O(n\log n)\)**：每一层合并总共处理 n 个节点，层数约 \(\log n\)。
- **为什么要在中点处“断开”？**
  - 如果不把 `prev.next = null` 断开，左右两半仍然连在一起，递归会陷入死循环或者反复处理同一段链。
- **空间复杂度提醒**：
  - 归并排序的合并是原地重连指针，不需要额外数组；
  - 但递归调用会占用栈深度 \(O(\log n)\)。

</details>

<details>
<summary><strong>类似题目</strong>（链表归并排序模板）</summary>

```javascript
mid = splitByFastSlow(head)
left = sort(leftHalf)
right = sort(rightHalf)
return merge(left, right)
```

</details>

---

## 23. 合并 K 个升序链表

<LeetCodeProblem titleSlug="merge-k-sorted-lists" />

<details>
<summary><strong>最优解</strong>（小根堆：每次取当前最小头结点）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
class MinHeap {
  constructor(cmp) { this.a = []; this.cmp = cmp }
  size() { return this.a.length }
  peek() { return this.a[0] }
  push(x) { this.a.push(x); this._up(this.a.length - 1) }
  pop() {
    if (!this.a.length) return null
    const top = this.a[0]
    const last = this.a.pop()
    if (this.a.length) { this.a[0] = last; this._down(0) }
    return top
  }
  _up(i) {
    while (i > 0) {
      const p = (i - 1) >> 1
      if (this.cmp(this.a[p], this.a[i]) <= 0) break
      ;[this.a[p], this.a[i]] = [this.a[i], this.a[p]]
      i = p
    }
  }
  _down(i) {
    const n = this.a.length
    while (true) {
      let best = i
      const l = i * 2 + 1
      const r = i * 2 + 2
      if (l < n && this.cmp(this.a[l], this.a[best]) < 0) best = l
      if (r < n && this.cmp(this.a[r], this.a[best]) < 0) best = r
      if (best === i) break
      ;[this.a[i], this.a[best]] = [this.a[best], this.a[i]]
      i = best
    }
  }
}

function mergeKLists(lists) {
  const heap = new MinHeap((x, y) => x.val - y.val)
  for (const node of lists) if (node) heap.push(node)

  const dummy = { val: 0, next: null }
  let tail = dummy
  while (heap.size()) {
    const node = heap.pop()
    tail.next = node
    tail = tail.next
    if (node.next) heap.push(node.next)
  }
  tail.next = null
  return dummy.next
}

// 测试辅助
function ListNode(val){this.val=val;this.next=null}
function fromArray(arr){const d=new ListNode(0);let p=d;for(const x of arr){p.next=new ListNode(x);p=p.next}return d.next}
function toArray(h){const r=[];for(let p=h;p;p=p.next)r.push(p.val);return r}

// 5 个测试用例
console.log(toArray(mergeKLists([fromArray([1,4,5]), fromArray([1,3,4]), fromArray([2,6])]))) // [1,1,2,3,4,4,5,6]
console.log(toArray(mergeKLists([]))) // []
console.log(toArray(mergeKLists([null, null]))) // []
console.log(toArray(mergeKLists([fromArray([]), fromArray([0]) ]))) // [0]
console.log(toArray(mergeKLists([fromArray([1]), fromArray([1]), fromArray([1]) ]))) // [1,1,1]
```

```go !! go
package main

import (
	"container/heap"
	"fmt"
)

type ListNode struct {
	Val  int
	Next *ListNode
}

type minHeap []*ListNode

func (h minHeap) Len() int           { return len(h) }
func (h minHeap) Less(i, j int) bool { return h[i].Val < h[j].Val }
func (h minHeap) Swap(i, j int)     { h[i], h[j] = h[j], h[i] }
func (h *minHeap) Push(x any)        { *h = append(*h, x.(*ListNode)) }
func (h *minHeap) Pop() any {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[:n-1]
	return x
}

func mergeKLists(lists []*ListNode) *ListNode {
	h := &minHeap{}
	heap.Init(h)
	for _, node := range lists {
		if node != nil {
			heap.Push(h, node)
		}
	}
	dummy := &ListNode{}
	tail := dummy
	for h.Len() > 0 {
		node := heap.Pop(h).(*ListNode)
		tail.Next = node
		tail = tail.Next
		if node.Next != nil {
			heap.Push(h, node.Next)
		}
	}
	return dummy.Next
}

func fromArray(arr []int) *ListNode {
	dummy := &ListNode{}
	p := dummy
	for _, x := range arr {
		p.Next = &ListNode{Val: x}
		p = p.Next
	}
	return dummy.Next
}

func toArray(head *ListNode) []int {
	var res []int
	for p := head; p != nil; p = p.Next {
		res = append(res, p.Val)
	}
	return res
}

func main() {
	fmt.Println(toArray(mergeKLists([]*ListNode{fromArray([]int{1, 4, 5}), fromArray([]int{1, 3, 4}), fromArray([]int{2, 6})})))
	fmt.Println(toArray(mergeKLists(nil)))
	fmt.Println(toArray(mergeKLists([]*ListNode{nil, nil})))
	fmt.Println(toArray(mergeKLists([]*ListNode{fromArray(nil), fromArray([]int{0})})))
	fmt.Println(toArray(mergeKLists([]*ListNode{fromArray([]int{1}), fromArray([]int{1}), fromArray([]int{1})})))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **朴素做法**：把所有节点都收集到数组里排序再重建，能做但会占用额外空间且丢失“链表合并”的结构优势。
- **更直接的思路：每次都从 k 个链表的当前头里选最小的那个**：
  - 如果你每次线性扫 k 个头去找最小，单步 \(O(k)\)，总节点数为 \(N\)，总体 \(O(Nk)\)。
- **关键优化：用小根堆把“找最小”变成 \(O(\log k)\)**：
  - 堆里始终放每条链表的当前头结点。
  - 弹出堆顶（最小头），把它接到答案尾部。
  - 然后把它的 `next` 再放回堆（相当于这条链表推进了一步）。
- **为什么复杂度是 \(O(N\log k)\)**：每个节点都会被 `push+pop` 一次，堆大小最多 k。
- **为什么堆里存“节点”而不是“值”？**
  - 因为我们需要把弹出的节点直接接到结果链表尾部，同时还要能拿到它的 `next` 继续推进对应链表。
- **复杂度总结**：时间 \(O(N\log k)\)，空间 \(O(k)\)（堆大小）。

</details>

<details>
<summary><strong>类似题目</strong>（多路归并：堆维护“当前最小候选”）</summary>

```javascript
init heap with k heads
while heap not empty:
  x = popMin()
  append x
  if x.next: push(x.next)
```

</details>

---

## 146. LRU 缓存

<LeetCodeProblem titleSlug="lru-cache" />

<details>
<summary><strong>最优解</strong>（Map + 双向链表：O(1) get/put）</summary>

<UniversalEditor title=" " compare={true}>
```javascript !! js
class LRUCache {
  constructor(capacity) {
    this.cap = capacity
    this.map = new Map() // key -> node
    // 双向链表：head <-> ... <-> tail
    this.head = { key: 0, val: 0, prev: null, next: null }
    this.tail = { key: 0, val: 0, prev: null, next: null }
    this.head.next = this.tail
    this.tail.prev = this.head
  }

  _remove(node) {
    node.prev.next = node.next
    node.next.prev = node.prev
  }

  _addToFront(node) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
  }

  get(key) {
    const node = this.map.get(key)
    if (!node) return -1
    // 访问即“最近使用”：移动到最前
    this._remove(node)
    this._addToFront(node)
    return node.val
  }

  put(key, value) {
    const node = this.map.get(key)
    if (node) {
      node.val = value
      this._remove(node)
      this._addToFront(node)
      return
    }
    const newNode = { key, val: value, prev: null, next: null }
    this.map.set(key, newNode)
    this._addToFront(newNode)

    if (this.map.size > this.cap) {
      // 淘汰最久未使用：tail.prev
      const lru = this.tail.prev
      this._remove(lru)
      this.map.delete(lru.key)
    }
  }
}

// 5 个测试用例
{
  const c = new LRUCache(2)
  c.put(1,1); c.put(2,2)
  console.log(c.get(1)) // 1
  c.put(3,3) // 淘汰 2
  console.log(c.get(2)) // -1
  c.put(4,4) // 淘汰 1
  console.log(c.get(1)) // -1
  console.log(c.get(3)) // 3
  console.log(c.get(4)) // 4
}
{
  const c = new LRUCache(1)
  c.put(1,1); console.log(c.get(1)) // 1
  c.put(2,2); console.log(c.get(1)) // -1
  console.log(c.get(2)) // 2
  c.put(2,3); console.log(c.get(2)) // 3
}
```

```go !! go
package main

import "fmt"

type LRUNode struct {
	key, val int
	prev     *LRUNode
	next     *LRUNode
}

type LRUCache struct {
	cap  int
	m    map[int]*LRUNode
	head *LRUNode
	tail *LRUNode
}

func Constructor(capacity int) LRUCache {
	head := &LRUNode{}
	tail := &LRUNode{}
	head.next = tail
	tail.prev = head
	return LRUCache{cap: capacity, m: make(map[int]*LRUNode), head: head, tail: tail}
}

func (c *LRUCache) _remove(node *LRUNode) {
	node.prev.next = node.next
	node.next.prev = node.prev
}

func (c *LRUCache) _addToFront(node *LRUNode) {
	node.prev = c.head
	node.next = c.head.next
	c.head.next.prev = node
	c.head.next = node
}

func (c *LRUCache) Get(key int) int {
	node, ok := c.m[key]
	if !ok {
		return -1
	}
	c._remove(node)
	c._addToFront(node)
	return node.val
}

func (c *LRUCache) Put(key, value int) {
	if node, ok := c.m[key]; ok {
		node.val = value
		c._remove(node)
		c._addToFront(node)
		return
	}
	newNode := &LRUNode{key: key, val: value}
	c.m[key] = newNode
	c._addToFront(newNode)
	if len(c.m) > c.cap {
		lru := c.tail.prev
		c._remove(lru)
		delete(c.m, lru.key)
	}
}

func main() {
	c := Constructor(2)
	c.Put(1, 1)
	c.Put(2, 2)
	fmt.Println(c.Get(1))
	c.Put(3, 3)
	fmt.Println(c.Get(2))
	c.Put(4, 4)
	fmt.Println(c.Get(1), c.Get(3), c.Get(4))
	c2 := Constructor(1)
	c2.Put(1, 1)
	fmt.Println(c2.Get(1))
	c2.Put(2, 2)
	fmt.Println(c2.Get(1), c2.Get(2))
	c2.Put(2, 3)
	fmt.Println(c2.Get(2))
}
```
</UniversalEditor>

</details>

<details>
<summary><strong>最优解讲解</strong>（通俗版 + 推理过程）</summary>

- **LRU 需要支持两件事都很快**：
  1. 按 key 快速找到 value（get/put 查找要快）→ 哈希表
  2. 快速把“最近使用”移动到最前、把“最久未使用”从末尾删除 → 双向链表
- **为什么单用 Map 不够？**：JS 的 `Map` 虽然有插入顺序，但题目语义是“访问会更新顺序”。要做到所有操作明确 \(O(1)\)，最稳的是 Map + 双向链表。
- **双向链表存什么？**：按“最近使用”从前到后排队：
  - 头部附近：最近使用
  - 尾部附近：最久未使用（需要淘汰）
- **每个操作如何推理到指针动作**：
  - `get(key)`：如果存在，说明被访问了 → 从原位置摘下来，插到链表头部。
  - `put(key,val)`：
    - key 已存在：更新值，并把它移动到头部（也算“最近使用”）。
    - key 不存在：新建节点插到头部；如果容量超了，删除尾部前一个节点（LRU）。
- **为什么双向链表必须有 dummy head/tail**：避免处理空链/头尾边界，所有插入删除都变成统一的四条指针修改。
- **核心不变量（保证你不会写崩）**
  - 链表顺序永远表示“从最近到最久”：`head.next` 是最近使用，`tail.prev` 是最久未使用。
  - `map` 里的每个 key 都能定位到链表中的一个节点，且节点也能反查自己的 key（用于淘汰时删除 map）。
- **为什么必须是双向链表而不是单向？**
  - 淘汰的是尾部节点；如果只有单向链表，删除尾部需要找到前驱，会退化成 \(O(n)\)。
  - 双向链表能在 \(O(1)\) 摘除任意节点。
- **复杂度**：`get/put` 都是均摊 \(O(1)\) 时间，空间 \(O(capacity)\)。

</details>

<details>
<summary><strong>类似题目</strong>（缓存/淘汰策略：Map + 双向链表）</summary>

```javascript
// Map 用来 O(1) 定位节点
// Doubly Linked List 用来 O(1) 调整使用顺序与淘汰尾部
```

</details>

